<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="红黑树深入剖析及Java实现"><meta name="keywords" content="算法"><meta name="author" content="Toyan"><meta name="copyright" content="Toyan"><title>红黑树深入剖析及Java实现 | ToyanのBlog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
  google_ad_client: 'ca-pub-5300746137487021',
  enable_page_level_ads: 'true'
});
</script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?c61658fe357dc669ee95b5bd4e25caad";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="ToyanのBlog" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#bst"><span class="toc-number">1.</span> <span class="toc-text"> BST</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#bst的查找操作"><span class="toc-number">1.1.</span> <span class="toc-text"> BST的查找操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bst的插入操作"><span class="toc-number">1.2.</span> <span class="toc-text"> BST的插入操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bst的删除操作"><span class="toc-number">1.3.</span> <span class="toc-text"> BST的删除操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bst存在的问题"><span class="toc-number">1.4.</span> <span class="toc-text"> BST存在的问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rbtree"><span class="toc-number">2.</span> <span class="toc-text"> RBTree</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#avl树"><span class="toc-number">2.1.</span> <span class="toc-text"> AVL树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3树"><span class="toc-number">2.2.</span> <span class="toc-text"> 2-3树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3树的操作"><span class="toc-number">2.2.1.</span> <span class="toc-text"> 2-3树的操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#插入"><span class="toc-number">2.2.1.1.</span> <span class="toc-text"> 插入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#查找"><span class="toc-number">2.2.1.2.</span> <span class="toc-text"> 查找</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#删除"><span class="toc-number">2.2.1.3.</span> <span class="toc-text"> 删除</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rbtree定义"><span class="toc-number">2.3.</span> <span class="toc-text"> RBTree定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#rbtree的旋转操作"><span class="toc-number">2.3.1.</span> <span class="toc-text"> RBTree的旋转操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rbtree的查找操作"><span class="toc-number">2.3.2.</span> <span class="toc-text"> RBTree的查找操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#btree的插入操作介绍一"><span class="toc-number">2.3.3.</span> <span class="toc-text"> BTree的插入操作介绍一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rbtree的插入操作介绍二"><span class="toc-number">2.3.4.</span> <span class="toc-text"> RBTree的插入操作介绍二</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#插入操作case1"><span class="toc-number">2.3.4.1.</span> <span class="toc-text"> 插入操作——case1</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#插入操作case2"><span class="toc-number">2.3.4.2.</span> <span class="toc-text"> 插入操作——case2</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#插入操作case3"><span class="toc-number">2.3.4.3.</span> <span class="toc-text"> 插入操作——case3</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#插入操作的总结"><span class="toc-number">2.3.4.4.</span> <span class="toc-text"> 插入操作的总结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rbtree的删除操作"><span class="toc-number">2.3.5.</span> <span class="toc-text"> RBTree的删除操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#删除操作case1"><span class="toc-number">2.3.5.1.</span> <span class="toc-text"> 删除操作——case1</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#删除操作case2"><span class="toc-number">2.3.5.2.</span> <span class="toc-text"> 删除操作——case2</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#删除操作case3"><span class="toc-number">2.3.5.3.</span> <span class="toc-text"> 删除操作——case3</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#删除操作case4"><span class="toc-number">2.3.5.4.</span> <span class="toc-text"> 删除操作——case4</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#删除操作的总结"><span class="toc-number">2.3.5.5.</span> <span class="toc-text"> 删除操作的总结</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三-rbtree的java实现"><span class="toc-number">3.</span> <span class="toc-text"> 三、RBTree的Java实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#concurrenthashmap二叉树的构造过程"><span class="toc-number">4.</span> <span class="toc-text"> ConcurrentHashMap二叉树的构造过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#红黑树的构造过程"><span class="toc-number">4.1.</span> <span class="toc-text"> 红黑树的构造过程</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/public/avatar.jpeg"></div><div class="author-info__name text-center">Toyan</div><div class="author-info__description text-center">Email: tonganhao1103@gmail.com</div><div class="follow-button"><a href="https://github.com/toyan-blog" target="_blank" rel="noopener">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">26</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">19</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">26</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="https://molunerfinn.com/hexo-theme-melody-doc/" target="_blank" rel="noopener">hexo-theme-melody</a><a class="author-info-links__name text-center" href="https://molunerfinn.com/" target="_blank" rel="noopener">Molunerfinn</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/public/blog.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">ToyanのBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">红黑树深入剖析及Java实现</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-12-13</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/algorithm/">algorithm</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/algorithm/RBTree/">RBTree</a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">9k</span><span class="post-meta__separator">|</span><span>Reading time: 30 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="bst"><a class="markdownIt-Anchor" href="#bst"></a> BST</h2>
<p>二叉查找树（Binary Search Tree，简称BST）是一颗二叉树，它的左子节点的值比父节点的值要小，右节点的值要比父节点的值大。它的高度决定了它的查找效率。</p>
<p>在理想情况下，二叉查找树增删改查的时间复杂度为o(logN)（其中N为节点数），最坏的情况下为o(N)。当它的高度为log(N) + 1时，我们就说二叉查找树是平衡的。</p>
<p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/v2-e64df5b2126506c59bad4604d298d818_hd.png" alt="" /></p>
<h3 id="bst的查找操作"><a class="markdownIt-Anchor" href="#bst的查找操作"></a> BST的查找操作</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// T key = a search key</span></span><br><span class="line"><span class="comment">// Node root = point to the root of a BST</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (root.value.equals(key)) &#123;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.compareTo(root.value) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    root = root.left;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    root = root.right;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
<p>从程序中可以看出，当BST查找的时候，先与当前节点进行比较：</p>
<ul>
<li>如果相等的话就返回当前节点</li>
<li>如果小于当前节点则继续查找当前节点的左节点</li>
<li>如果大于当前节点则继续查找当前节点的右节点</li>
</ul>
<p>直到当前节点指针为空或者查找到对应的节点，程序查找结束</p>
<h3 id="bst的插入操作"><a class="markdownIt-Anchor" href="#bst的插入操作"></a> BST的插入操作</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Node node = create a new node with specify value</span></span><br><span class="line"><span class="comment">// Node root = point the root node of a BST</span></span><br><span class="line"><span class="comment">// Node parent = null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// find the parent node to append the new node</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  parent = root;</span><br><span class="line">  <span class="keyword">if</span> (node.value.compareTo(root.value) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    root = root.left;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    root = root.right;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (node.value.compareTo(parent.value) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    parent.left = node;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    parent.right = node;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>插入操作先通过循环查找到待插入的节点的父节点，和查找父节点的逻辑一样，都是比大小，小的往左，大的往右。找到父节点后，对比父节点，小的就插入到父节点的左节点，大就插入到父节点的右节点上</p>
<h3 id="bst的删除操作"><a class="markdownIt-Anchor" href="#bst的删除操作"></a> BST的删除操作</h3>
<p>删除操作的步骤如下：</p>
<ul>
<li>查找到要删除的节点</li>
<li>如果待删除的节点是叶子节点，则直接删除</li>
<li>如果待删除的节点不是叶子节点，则先找到待删除的节点的中序遍历的后继节点，用该后继节点的值替换待删除的节点的值，然后删除后续节点</li>
</ul>
<p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/v2-caf8927ad71613b1f93393931029b5a4_hd.png" alt="" /></p>
<h3 id="bst存在的问题"><a class="markdownIt-Anchor" href="#bst存在的问题"></a> BST存在的问题</h3>
<p>BST存在的主要问题是，在插入的时候会导致树倾斜，不同的插入顺序会导致树的高度不一样，而树的高度直接地影响了树的查找效率。理想的高度是logN，最坏的情况是所有的节点都在一条斜线上，这样的树的高度是N</p>
<h2 id="rbtree"><a class="markdownIt-Anchor" href="#rbtree"></a> RBTree</h2>
<p>基于BST存在的问题，一种新的树——平衡二叉查找树(Balanced BST)产生了。平衡树在插入和删除的时候，会通过旋转操作将高度保持在logN。其中两款具有代表性的平衡树分别为AVL树和红黑树。AVL树由于实现比较复杂，而且插入和删除性能差，在实际环境下的应用不如红黑树。</p>
<p>红黑树（Red-Black Tree，以下简称RBTree）的实际应用非常广泛，比如Linux内核中的完全公平调度器、高精度计时器、ext3文件系统等等，各种语言的函数库如Java的TreeMap和TreeSet，C++ STL的map、multimap、multiset等。</p>
<p>RBTree也是函数式语言中最常用的持久数据结构之一，在计算几何中也有重要作用。值得一提的是，Java 8中HashMap的实现也因为用RBTree取代链表，性能有所提升。</p>
<h3 id="avl树"><a class="markdownIt-Anchor" href="#avl树"></a> AVL树</h3>
<ul>
<li>
<p>简介：AVL树是带有平衡条件的二叉查找树，一般使用平衡因子差值判断是否平衡，平衡因子为左右子树高度之差，绝对值不能大于1，失衡时通过旋转来实现平衡，与红黑树相比，AVL树是严格的平衡二叉树，旋转是十分耗时的，因此AVL树适合用于插入删除次数较少，但查找较多的情况（中序遍历为有序序列，时间复杂度为o(n*logn)）</p>
</li>
<li>
<p>局限性：由于维护了这种高度平衡所付出的代价比从中获得的效益收益还大，故而实际的应用不多，更多的地方是用追求局部而不是非常严格整体平衡的红黑树。当然，如果应用场景中对插入删除不频繁，只是对查找要求较高，那么AVL还是较优于红黑树</p>
</li>
<li>
<p>应用：Windows NT内核中广泛存在</p>
</li>
</ul>
<h3 id="2-3树"><a class="markdownIt-Anchor" href="#2-3树"></a> 2-3树</h3>
<p>2-3树是一种绝对平衡树。它的节点元素个数可以为1个或者2个。如图，下面就是一个2-3树：</p>
<p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/21.png" alt="" /></p>
<p>2-3树中的2代表一个节点有两个孩子，3代表一个节点有三个孩子</p>
<h4 id="2-3树的操作"><a class="markdownIt-Anchor" href="#2-3树的操作"></a> 2-3树的操作</h4>
<h5 id="插入"><a class="markdownIt-Anchor" href="#插入"></a> 插入</h5>
<p>这里结合一个例子来查看2-3树是如何实现绝对平衡的。例如，现在我们要依次增加1、2、3、4、5、6、7这7个元素，如图</p>
<p>![](<a href="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2020/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7" target="_blank" rel="noopener">https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2020/屏幕快照</a> 2019-12-10 下午4.44.58.png)</p>
<p>如果所示，下面一个步骤一个步骤分析：</p>
<ul>
<li>插入1，判断无根节点，直接将1封装为节点并设置为根节点</li>
<li>插入2，这是因为1节点没有孩子节点并且只有1节点，所有直接将2加入到节点1中</li>
<li>插入3，和2节点一样，将3节点放入到根节点中，这是根节点有3个元素了，就需要变化为步骤4的样子。可以理解为将1、2、3的中间元素提取到根节点，也就是将2提出来，1作为左孩子，3作为右孩子</li>
<li>插入4，4比2大，增加到节点3</li>
<li>插入5，5比2大，增加到节点3、4中，这是节点3、4变为节点3、4、5，节点3、4、5按照第三步中将中间元素提取为双亲节点，而4提取出来的4回去找双亲节点2，2节点只有一个元素，所以4加入到2节点中</li>
<li>插入6，6大于根节点的2和4，进入最右边，5没有孩子只有一个元素，加入6到5节点</li>
<li>插入7，这时5、6、7将6提取出放入6的双亲节点，6的双亲节点（根节点）变为2、4、6。2、4、6提取出4变成最后的样子</li>
</ul>
<p>总的来说，插入方法和二分搜索相似。但是每个节点可以有1-2个元素，当节点元素个数为3时，就会分成3个节点并向上合并，直到合并完成。</p>
<h5 id="查找"><a class="markdownIt-Anchor" href="#查找"></a> 查找</h5>
<p>2-3树的查找和二分搜索树类似，不过因为一个节点可能有2个元素，需要对这两个元素进行比较，分别前往这两个节点的左、中、右孩子继续比较</p>
<h5 id="删除"><a class="markdownIt-Anchor" href="#删除"></a> 删除</h5>
<p>2-3树的删除稍微复杂一点儿，删除可分为两大情况，就是删除叶子节点和非叶子节点</p>
<p>这里只说理论情况，不结合代码实现，实际上代码实现会变得复杂也只是因为考虑的东西更多，代码实现会变得复杂</p>
<p><strong>删除叶子节点（不太懂）</strong></p>
<ul>
<li>当前节点是3节点，直接删除</li>
<li>当前节点是2节点：删除并判断
<ul>
<li>双亲是2节点，判断兄弟节点
<ul>
<li>兄弟节点是3节点，将兄弟节点移到双亲节点，再将双亲节点的另一个元素移到当前节点</li>
<li>兄弟节点是2节点，先通过移动兄弟节点的中序遍历直接后驱到兄弟节点，以使兄弟节点变为3节点，再进行删除</li>
</ul>
</li>
<li>双亲节点是3节点，拆分双亲节点使其变成2节点，再将双亲节点中最接近的一个拆分key与中孩子合并，将合并后的节点作为当前节点</li>
</ul>
</li>
<li>若2-3树是棵满二叉树，删除节点，将2-3树层树减少，并将兄弟节点合并到双亲节点中，同时将双亲节点的所有兄弟节点合并到双亲节点的双亲节点中，如果变为4节点，就做分解操作</li>
</ul>
<p><strong>删除非叶子节点</strong></p>
<p>使用中序遍历下的直接后继节点key来覆盖当前节点key，再删除用来覆盖的后继节点key</p>
<h3 id="rbtree定义"><a class="markdownIt-Anchor" href="#rbtree定义"></a> RBTree定义</h3>
<p>在开始红黑树之前，我们要知道红黑树并非只有2-3树这一种实现方式，虽然2-3树实现红黑树比较方便。RBTree的定义如下：</p>
<ul>
<li>任何一个节点都有颜色，黑色或者红色</li>
<li>根节点是黑色的</li>
<li>父子节点之间不能出现两个连续的红色节点</li>
<li>任何一个节点向下遍历到其子孙节点的叶子节点，所经过的黑色节点个数必须相等</li>
<li>空节点被认为是黑色的，即每一个叶子节点是黑色</li>
</ul>
<p>2-3树与红黑树的关系</p>
<p>![](<a href="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2020/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7" target="_blank" rel="noopener">https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2020/屏幕快照</a> 2019-12-10 下午8.40.54.png)</p>
<p>如图，我们可以看到，可以将2-3树中的3节点中的左元素弄成一个新节点，这个节点就是红黑树中的红节点，并且将红节点统一进行左偏向，得出右图的红黑树，这样的红黑树也叫左倾红黑树。</p>
<p>数据结构表示如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 排序也是通过key进行排序</span></span><br><span class="line">  <span class="keyword">public</span> K key;</span><br><span class="line">  <span class="keyword">public</span> V value;</span><br><span class="line">  <span class="keyword">public</span> Node left, right;</span><br><span class="line">  <span class="comment">// 红为true，黑为false，默认节点为红</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">boolean</span> color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RBTree在理论上还是一颗BST树，但是它在对BST的插入和删除操作时会维持树的平衡，即保证树的高度在[logN, logN + 1]（理论上，极端情况下可以出现RBTree的高度达到2*logN，但实际上很难遇到）。这样RBTree的查找时间复杂度始终保持在o(logN)从而接近于理想的BST。RBTree的删除和插入操作的时间复杂度也是o(logN)。RBTree的查找操作就是BST的查找操作</p>
<h4 id="rbtree的旋转操作"><a class="markdownIt-Anchor" href="#rbtree的旋转操作"></a> RBTree的旋转操作</h4>
<p>旋转操作（Rotate）的目的是使节点的颜色符合定义，让RBTree的高度达到平衡。</p>
<p>Rotate分为left-rotate（左旋）和right-notate（右旋），区分左旋和右旋的方法是：<strong>待旋转的节点从左边上升到父节点就是右旋，待旋转节点从右边上升到父节点就是左旋。</strong></p>
<p><strong>左旋转</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//   node                     x</span></span><br><span class="line"><span class="comment">//  /   \     左旋转         /  \</span></span><br><span class="line"><span class="comment">// T1   x   ---------&gt;   node   T3</span></span><br><span class="line"><span class="comment">//     / \              /   \</span></span><br><span class="line"><span class="comment">//    T2 T3            T1   T2</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">leftRotate</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">  Node x = node.right;</span><br><span class="line">  <span class="comment">// 左旋转</span></span><br><span class="line">  node.right = x.left;</span><br><span class="line">  x.left = node;</span><br><span class="line">  x.color = node.color;</span><br><span class="line">  node.color = RED;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>右旋转</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//     node                   x</span></span><br><span class="line"><span class="comment">//    /   \     右旋转       /  \</span></span><br><span class="line"><span class="comment">//   x    T2   -------&gt;   y   node</span></span><br><span class="line"><span class="comment">//  / \                       /  \</span></span><br><span class="line"><span class="comment">// y  T1                     T1  T2</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">rightRotate</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">  Node x = node.left;</span><br><span class="line">  <span class="comment">// 右旋转</span></span><br><span class="line">  node.left = x.right;</span><br><span class="line">  x.right = node;</span><br><span class="line">  x.color = node.color;</span><br><span class="line">  node.color = RED;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>颜色翻转</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 颜色翻转</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flipColors</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">  node.color = RED;</span><br><span class="line">  node.left.color = BLACK;</span><br><span class="line">  node.right.color = BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>左旋和右旋总结</strong></p>
<p>树的旋转，能保持不变的只有树的二叉查找性质，而原树的红黑性质则不能保持，在红黑树的数据插入和删除后，可利用旋转和颜色翻转来恢复树的红黑性质</p>
<h4 id="rbtree的查找操作"><a class="markdownIt-Anchor" href="#rbtree的查找操作"></a> RBTree的查找操作</h4>
<p>RBTree的查找操作和BST的查找操作是一样的。请参考BST的查找操作代码。</p>
<h4 id="btree的插入操作介绍一"><a class="markdownIt-Anchor" href="#btree的插入操作介绍一"></a> BTree的插入操作介绍一</h4>
<p>向一颗含有n个节点的红黑树插入一个新的节点的操作可以在o(logn)时间完成</p>
<p>在插入操作分析之前，再复习下红黑树的性质：</p>
<blockquote>
<p>1、每个节点要么是红色，要么是黑色<br />
2、根节点是黑色<br />
3、所有叶子节点是黑色，即空节点（NIL）<br />
4、如果一个节点是红色的，则它的两个子节点必须是黑色的，也就是父子节点不能都为红色<br />
5、从一个节点到其所有叶子节点的所有路径上包含相同数目的黑节点</p>
</blockquote>
<p><strong>规则预定</strong></p>
<ol>
<li>在红黑树中插入节点，节点的初始颜色都是红色，因为这样可以在插入过程中尽量避免对树的结构进行调整（参考第5点性质）</li>
<li>初始插入按照二叉查找树的性质插入，即找到合适大小的节点，在其左边或者右边插入子节点</li>
</ol>
<p>我们在插入一个节点后，会使树的那些性质改变呢？</p>
<ol>
<li>由于是以二叉查找树的性质插入，因此节点的查找性质不会被破坏</li>
<li>如果插入空树中，成为根节点，则性质2会被破坏，需要重新涂色</li>
<li>如果插入节点的父节点是红色，则性质4会被破坏，需要以插入的当前节点为中心进行旋转或重新涂色来恢复红黑树的性质。<strong>执行旋转或重新涂色后有可能红黑树仍然不满足性质，则需要将当前节点变换回溯到其父节点或祖父节点，以父节点或祖父节点为中心继续旋转或重新涂色，如此循环到根节点直到满足红黑树的性质。</strong></li>
</ol>
<p><strong>恢复红黑树性质的策略</strong></p>
<p>根据上面说到的性质改变，对应的恢复策略其实就简单很多</p>
<ol>
<li>
<p>把出现违背红黑树性质的结点向上移（通过旋转操作或变换当前节点到父节点或祖父节点后再旋转达到向上移动的目的），如果能移到根结点，那么很容易就能通过直接修改根结点的颜色，或旋转根节点来恢复红黑树的性质</p>
</li>
<li>
<p>旋转或涂色处理可分5种情况进行处理</p>
<blockquote>
<p>情况1：空树中插入根节点<br />
情况2：插入节点的父节点是黑色<br />
情况3：当前节点的父节点是红色，且叔叔节点（祖父节点的另一个子节点）也是红色<br />
情况4：当前节点的父节点是红色，叔叔节点是黑色，当前节点是右子节点<br />
情况5：当前节点的父节点是红色，叔叔节点是黑色，当前节点是左子节点</p>
</blockquote>
</li>
</ol>
<p><strong>情况1：空树中插入根节点</strong><br />
违反：性质2<br />
恢复策略：初始插入的节点均为红色，因此简单将红色重涂为黑色即可。</p>
<p><strong>情况2：插入节点的父节点是黑色</strong><br />
违反：插入的红色节点，未违反任何性质。<br />
恢复策略：什么也不做，无需调整。</p>
<p><strong>情况3：当前节点的父节点是红色，且叔叔节点也是红色</strong><br />
违反：性质4<br />
此时祖父节点一定存在，否则插入前就已不是红黑树。<br />
与此同时，又分为父节点是祖父节点的左子还是右子，由于对称性，我们只要解开一个方向就可以了。在此，我们只考虑父节点为祖父左子的情况。<br />
同时，还可以分为当前结点是其父结点的左子还是右子，但是处理方式是一样的。我们将此归为同一类。<br />
恢复策略：将当前节点的父节点和叔叔节点涂黑，祖父结点涂红，把当前结点指向祖父节点，以祖父节点为中心重新开始新一轮的旋转或涂色。<br />
以插入节点4为例，按照恢复策略，做如下图的涂色：</p>
<p>![](<a href="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2020/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7" target="_blank" rel="noopener">https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2020/屏幕快照</a> 2019-12-10 下午10.23.41.png)</p>
<p>以插入节点4为当前节点，判断父节点和叔叔节点是否都为红色，如果为红色，则将祖父节点7的颜色改为红色，父节点5和叔叔节点8的颜色改为黑色。同时当前节点移动到祖父节点7。此时，当前节点7的父节点也为红色，出现父子节点都为红色的情况，且叔叔节点为黑色，因此适用于<strong>情况4：当前节点的父节点是红色，叔叔节点是黑色，当前节点是右子节点</strong>，那么按照<strong>情况4</strong>的恢复策略，进行新一轮的旋转或涂色，如下看<strong>情况4</strong>如何进行调整。</p>
<p><strong>情况4：当前节点的父节点是红色，叔叔节点是黑色，当前节点是右子节点</strong><br />
违反：性质4<br />
恢复策略：以当前节点的父节点作为新的当前节点，以新的当前节点为支撑，进行左旋操作。旋转操作后再按新的情况进行旋转或涂色。</p>
<p>![](<a href="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2020/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7" target="_blank" rel="noopener">https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2020/屏幕快照</a> 2019-12-10 下午10.25.21.png)</p>
<p>这里作的操作为：当前节点由原来的7变换为其父节点2，以新的当前节点2，作左旋操作，如上图。操作完成后，发现父子节点仍都是红色，继续进行旋转或涂色。这里适用于<strong>情况5：当前节点的父节点是红色，叔叔节点是黑色，当前节点是左子节点</strong>来进行再次调整，请看下面的<strong>情况5</strong>如何进行调整。</p>
<p><strong>情况5：当前节点的父节点是红色，叔叔节点是黑色，当前节点是左子节点</strong><br />
违反：性质4<br />
恢复策略：父节点改变为黑色，祖父节点改变为红色，然后再以祖父节点为新的当前节点，做右旋操作。</p>
<p>![](<a href="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2020/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7" target="_blank" rel="noopener">https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2020/屏幕快照</a> 2019-12-10 下午10.26.51.png)</p>
<p>此时，树已经满足红黑树的性质，如果仍不满足，则仍按照情况1——情况5的方式进行旋转和重新涂色。</p>
<h4 id="rbtree的插入操作介绍二"><a class="markdownIt-Anchor" href="#rbtree的插入操作介绍二"></a> RBTree的插入操作介绍二</h4>
<p>RBTree的插入与BST的插入方式是一致的，只不过是在插入过后，可能会导致树的不平衡，这是就需要对树进行旋转操作的颜色修复（这里简称插入修复），使得它符合RBTree的定义。</p>
<p>新插入的节点是红色的，插入修复操作如果遇到父节点的颜色为黑则修复结束。也就是说，只有在父节点为红色节点的时候是需要插入修复操作的。</p>
<p>插入修复操作分为以下三种情况，而且新插入的节点的父节点都是红色的：</p>
<ul>
<li>叔叔节点也是红色</li>
<li>叔叔节点为空，且祖父节点、父节点和新节点处于一条斜线上</li>
<li>叔叔节点为空，且祖父节点、父节点和新节点不处于一条斜线上</li>
</ul>
<h5 id="插入操作case1"><a class="markdownIt-Anchor" href="#插入操作case1"></a> 插入操作——case1</h5>
<p>case1的操作是将父节点和叔叔节点与祖父节点的颜色互换，这样就符合了RBTree的定义。即维持了高度的平衡，修复后颜色也符合RBTree的定义的第三条和第四条。下图中，操作完成后A节点变成了新节点，如果A节点的父节点不是黑色的话，则继续做修复操作</p>
<p><img src="https://pic1.zhimg.com/80/v2-85d7be8e54ae9f904d86bf5f5ee3b4bc_hd.png" alt="" /></p>
<h5 id="插入操作case2"><a class="markdownIt-Anchor" href="#插入操作case2"></a> 插入操作——case2</h5>
<p>case2的操作是将B节点进行右旋操作，并且和父节点A互换颜色。通过该修复操作RBTree的高度和颜色都符合红黑树的定义。如果B和C节点都是右节点的话，只要将操作变成左旋就可以</p>
<p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/v2-cd2171937e0ed68bca55214357e6669e_hd.png" alt="" /></p>
<h5 id="插入操作case3"><a class="markdownIt-Anchor" href="#插入操作case3"></a> 插入操作——case3</h5>
<p>case3的操作是将C节点进行左旋，这样就从case3转换成case2，然后针对case 2进行操作处理就行了。case 2操作做了一个右旋操作和颜色互换来达到目的。如果树的结构是下图的镜像结构，则只需要将对应的左旋变成右旋，右旋变成左旋即可。</p>
<p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/v2-8594087429e54acbbc2aa6ae9da8cc5f_hd.png" alt="" /></p>
<h5 id="插入操作的总结"><a class="markdownIt-Anchor" href="#插入操作的总结"></a> 插入操作的总结</h5>
<p>插入后的修复操作是一个从root节点回溯的操作，一旦牵扯的节点都符合了红黑树的定义，修复操作结束。之所以会向上回溯是由于case1操作会将父节点、叔叔节点和祖父节点进行颜色互换，有可能会导致祖父节点不平衡（红黑树定义3）。这个时候需要对祖父节点为起点进行调节（向上回溯）</p>
<p>祖父节点调节后如果还是遇到它的祖父节点颜色问题，操作就会继续向上回溯，直到root节点为止，根据定义root节点永远是黑色的。在向上的追溯的过程中，针对插入的情况3中情况进行调节。直到符合红黑树定义为止。知道牵扯的节点都符合了红黑树的定义，修复操作结束。</p>
<p>如果上面的3中情况如果对应的操作是在右子树上，做对应的镜像操作就是了。</p>
<h4 id="rbtree的删除操作"><a class="markdownIt-Anchor" href="#rbtree的删除操作"></a> RBTree的删除操作</h4>
<p>删除操作首先需要做的也是BST的删除操作，删除操作会删除对应的节点，如果是叶子节点就直接删除，如果是非叶子节点，会用对应的中序遍历的后继节点来顶替要删除节点的位置。删除后就需要做删除修复操作，使得树符合红黑树的定义，符合定义的红黑树高度是平衡的。</p>
<p>删除修复操作在遇到被删除的节点是红色节点或者到达root节点后，修复操作完毕。</p>
<p>删除修复操作是针对删除黑色节点才有的，当黑色节点被删除后会让整个树不符合RBTree的定义的第四条。需要做的处理是从兄弟节点上借调黑色的节点过来，如果兄弟节点没有黑节点可以借调的话，就只能往上追溯，将每一级的黑节点数减去一个，使得整棵树符合红黑树的定义。</p>
<p>删除操作的总体思想是从兄弟节点借调黑色节点使树保持局部平衡，如果局部的平衡达到了，就看整体的树是否是平衡的，如果不平衡就接着向上追溯调整。</p>
<p>删除修复操作分为四种情况（删除黑节点后）：</p>
<ul>
<li>待删除节点的兄弟节点是红色的节点</li>
<li>待删除的节点的兄弟节点是黑色的节点，且兄弟节点的子节点都是黑色的</li>
<li>待调整的节点的兄弟节点是黑色的节点，且兄弟节点的左子节点是红色的，右节点是黑色的（兄弟节点在右边），如果兄弟节点在左边的话，就是兄弟节点的右子节点是红色的，左节点是黑色的</li>
<li>待调整节点的兄弟节点是黑色的节点，且右子节点是红色的（兄弟节点在右边），如果兄弟节点在左边，则就是对应的就是左节点是红色的</li>
</ul>
<h5 id="删除操作case1"><a class="markdownIt-Anchor" href="#删除操作case1"></a> 删除操作——case1</h5>
<p>由于兄弟节点是红色节点的时候，无法借调黑色节点，所以需要将兄弟节点提升到父节点，由于兄弟节点是红色的，根据RBTree的定义，兄弟节点的子节点是黑色的，就可以从它的子节点借调了。</p>
<p>case1这样转换之后就会变成后面的case2、case3，或者case4进行处理。上升操作需要对C做一个左旋操作，如果是镜像结构的树只需要做对应的右旋操作即可。</p>
<p>之所以要做case1操作是因为兄弟节点是红色的，无法借到一个黑节点来填补删除的黑节点。</p>
<p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/v2-46e732e84148b9bca53e995689e9ba9f_hd.png" alt="" /></p>
<h5 id="删除操作case2"><a class="markdownIt-Anchor" href="#删除操作case2"></a> 删除操作——case2</h5>
<p>case2的删除操作是由于兄弟节点可以消除一个黑色节点，因为兄弟节点和兄弟节点的子节点都是黑色的，所以可以将兄弟节点变红，这样就可以保证树的局部的颜色符合定义了。这个时候需要将父节点A变成新的节点，继续向上调整，直到整棵树的颜色符合RBTree的定义为止。</p>
<p>case2这种情况下之所以要将兄弟节点变红，是因为如果把兄弟节点借调过来，会导致兄弟的结构不符合RBTree的定义，这样的情况下只能是将兄弟节点也变成红色来达到颜色的平衡。当将兄弟节点也变红之后，达到局部的平衡了，但是对于祖父节点来说不符合定义4的。这样就需要回溯到父节点，接着进行修复操作。</p>
<p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/v2-7975d1b235cd30c0bafb716b585ba45d_hd.png" alt="" /></p>
<h5 id="删除操作case3"><a class="markdownIt-Anchor" href="#删除操作case3"></a> 删除操作——case3</h5>
<p>case3的删除操作是一个中间状态，它的目的是将左边的红色节点借调过来，这样就可以转换成case4状态，在case4状态下可以将D、E节点借调过来，通过将两个节点变成黑色来保证红黑树的平衡。</p>
<p>之所以说case3是一个中间状态，是因为根据红黑树的定义来说，下图并不是平衡的，它是通过case 2操作完后向上回溯出现的状态。之所以会出现C。</p>
<p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/v2-04dbb22d25de3849d902582809198596_hd.png" alt="" /></p>
<h5 id="删除操作case4"><a class="markdownIt-Anchor" href="#删除操作case4"></a> 删除操作——case4</h5>
<p>case4操作是真正的节点借调操作，通过将兄弟节点以及兄弟节点的右节点借调过来，并将兄弟节点的右子节点变成红色来达到借调两个黑色节点的目的，这样的话，整棵树还是符合RBTree的定义。</p>
<p>case4这种情况的发生只有在待删除的节点的兄弟节点为黑，且子节点不全部为黑，才有可能借调到两个节点来做黑节点使用，从而保持整棵树都符合红黑树的定义</p>
<p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/v2-a559407bb4847a140642d16c6301d7db_hd.png" alt="" /></p>
<h5 id="删除操作的总结"><a class="markdownIt-Anchor" href="#删除操作的总结"></a> 删除操作的总结</h5>
<p>红黑树的删除操作是最复杂的操作，复制的地方在于当删除了黑色节点的时候，如何从兄弟节点去借调节点，以保证树的颜色符合定义。由于红色的兄弟节点是没法借调出黑节点的，这样只能通过选择操作让他上升到父节点，而由于它是红节点，所以它的子节点就是黑的，可以借调。</p>
<p>对于兄弟节点是黑色节点的可以分为三种情况来处理，当所有的兄弟节点的子节点都是黑色节点时，可以直接将兄弟节点变红，这样局部的红黑树颜色是符合定义的。但是整棵树不一定是符合红黑树定义的，需要往上追溯继续调整。</p>
<p>对于兄弟节点的子节点为左红右黑（全部为红，右红左黑）两种情况，可以先将前面的情况通过选择转换为后一种情况，在后一种情况下，因为兄弟节点为黑，兄弟节点的右节点为红，可以借调出两个节点出来做黑节点，这样就可以保证删除了黑节点，整棵树还是符合红黑树定义的，因为黑色节点的个数没有改变。</p>
<p>红黑树的删除操作是遇到删除的节点为红色，或者追溯调整到了root节点，这时删除的修复操作完毕。</p>
<h2 id="三-rbtree的java实现"><a class="markdownIt-Anchor" href="#三-rbtree的java实现"></a> 三、RBTree的Java实现</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RBTreeNode</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// node value</span></span><br><span class="line">  <span class="keyword">private</span> T value;</span><br><span class="line">  <span class="comment">// left child pointer </span></span><br><span class="line">  <span class="keyword">private</span> RBTreeNode&lt;T&gt; left;</span><br><span class="line">  <span class="comment">// right child pointer</span></span><br><span class="line">  <span class="keyword">private</span> RBTreeNode&lt;T&gt; right;</span><br><span class="line">  <span class="comment">// parent pointer</span></span><br><span class="line">  <span class="keyword">private</span> RBTreeNode&lt;T&gt; parent;</span><br><span class="line">  <span class="comment">// color is red or not red</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> red;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">RBTreeNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">RBTreeNode</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">RBTreeNode</span><span class="params">(T value, <span class="keyword">boolean</span> isRed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">    <span class="keyword">this</span>.red = isRed;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> RBTreeNode&lt;T&gt; <span class="title">getLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeft</span><span class="params">(RBTreeNode&lt;T&gt; left)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.left = left;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">	<span class="function"><span class="keyword">public</span> RBTreeNode&lt;T&gt; <span class="title">getRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRight</span><span class="params">(RBTreeNode&lt;T&gt; right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.right = right;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> red;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBlack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !red;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLeaf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRed</span><span class="params">(<span class="keyword">boolean</span> red)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.red = red;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeRed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    red = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeBlack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    red = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value.toString();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RBTree</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> RBTreeNode&lt;T&gt; root;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// node number</span></span><br><span class="line">  <span class="keyword">private</span> java.util.concurrent.atomic.AtomicLong size = </span><br><span class="line">    <span class="keyword">new</span> java.util.concurrent.atomic.AtomicLong(<span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// in overwrite mode, all node's value cannot has same value</span></span><br><span class="line">  <span class="comment">// in non-overwrite mode, node can have same value, suggest don't use non-overwrite mode</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> overrideMode = <span class="keyword">true</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">RBTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.root = <span class="keyword">new</span> RBTreeNode&lt;T&gt;();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="concurrenthashmap二叉树的构造过程"><a class="markdownIt-Anchor" href="#concurrenthashmap二叉树的构造过程"></a> ConcurrentHashMap二叉树的构造过程</h2>
<p>对于ConcurrentHashMap，链表的长度超过8时，会调用<code>treeifyBin()</code>方法将链表结构转换为红黑树。</p>
<p>下面是ConcurrentHashMap中节点类型和继承关系</p>
<p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2020/Snipaste_2019-12-11_17-28-46.png" alt="" /></p>
<p>**注意点：**Node是链表中的元素，而TreeBin和TreeNode也继承自Node节点，也自然继承了next属性，同样拥有了链表的性质，其实真正在存储时，红黑树仍然是以链表形式存储的，只是逻辑上TreeBin和TreeNode多了支持红黑树的root、first、parent、left、right和red属性，在附加的属性上进行了逻辑上的引用和关联，也就造就了一棵树</p>
<p>所以理解了上面的红黑树其实也是一个链表，再来看源码就不难理解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Replaces all linked nodes in bin at given index unless table is</span></span><br><span class="line"><span class="comment"> * too small, in which case resizes instead.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tab table表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 转换为红黑树的链表在table中的索引下标</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  Node&lt;K,V&gt; b; <span class="keyword">int</span> n, sc;</span><br><span class="line">  <span class="keyword">if</span> (tab != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 一开始并非直接转换为红黑树，而是通过扩容table到2倍的方式</span></span><br><span class="line">    <span class="comment">// 只有table的长度大于64之后，才会将超过8个元素的链表转换为红黑树</span></span><br><span class="line">    <span class="keyword">if</span> ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">      tryPresize(n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// b.hash &gt;= 0 即为普通的Node链表节点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((b = tabAt(tab, index)) != <span class="keyword">null</span> &amp;&amp; b.hash &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 锁住链表头</span></span><br><span class="line">      <span class="keyword">synchronized</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tabAt(tab, index) == b) &#123;</span><br><span class="line">          TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">          <span class="comment">// 将原Node链表转换成以TreeBin节点为元素的链表</span></span><br><span class="line">          <span class="keyword">for</span> (Node&lt;K,V&gt; e = b; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p =</span><br><span class="line">              <span class="keyword">new</span> TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,</span><br><span class="line">                                <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> ((p.prev = tl) == <span class="keyword">null</span>)</span><br><span class="line">              hd = p;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">              tl.next = p;</span><br><span class="line">            tl = p;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// TreeBin的构造方法构造树，根据TreeBin链表构造</span></span><br><span class="line">          setTabAt(tab, index, <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hd));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从源码可以看出，一开始并非直接转换为红黑树，而是通过扩容table到2倍的方式，只有table的长度大于64之后，才会将超过8个元素的链表转红黑树。红黑树的构造过程是在TreeBin的构造方法中完成的。</p>
<h3 id="红黑树的构造过程"><a class="markdownIt-Anchor" href="#红黑树的构造过程"></a> 红黑树的构造过程</h3>
<p>假设待构造的红黑树TreeNode链表如下，节点中的数值代表元素的hash值：</p>
<p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2020/Snipaste_2019-12-11_17-59-57.png" alt="" /></p>
<p>源码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates bin with initial set of nodes headed by b.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">TreeBin(TreeNode&lt;K,V&gt; b) &#123;</span><br><span class="line">  <span class="keyword">super</span>(TREEBIN, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">  <span class="keyword">this</span>.first = b;</span><br><span class="line">  TreeNode&lt;K,V&gt; r = <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">// 遍历TreeNode链表进行构造</span></span><br><span class="line">  <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = b, next; x != <span class="keyword">null</span>; x = next) &#123;</span><br><span class="line">    next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">    x.left = x.right = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (r == <span class="keyword">null</span>) &#123;</span><br><span class="line">      x.parent = <span class="keyword">null</span>;</span><br><span class="line">      x.red = <span class="keyword">false</span>;</span><br><span class="line">      r = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      K k = x.key;</span><br><span class="line">      <span class="keyword">int</span> h = x.hash;</span><br><span class="line">      Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = r;;) &#123;</span><br><span class="line">        <span class="comment">// 执行插入，dir为比对节点hash的大小的标识，决定插入时是左还是右</span></span><br><span class="line">        <span class="keyword">int</span> dir, ph;</span><br><span class="line">        K pk = p.key;</span><br><span class="line">        <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">          dir = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">          dir = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                  (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                 (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">          dir = tieBreakOrder(k, pk);</span><br><span class="line">        TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">        <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">          x.parent = xp;</span><br><span class="line">          <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">            xp.left = x;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            xp.right = x;</span><br><span class="line">          <span class="comment">// 插入后，执行恢复操作，重新涂色或者旋转</span></span><br><span class="line">          r = balanceInsertion(r, x);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.root = r;</span><br><span class="line">  <span class="function"><span class="keyword">assert</span> <span class="title">checkInvariants</span><span class="params">(root)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>源码中，balanceInsertion方法为恢复操作。所以根据上述源码和红黑树的恢复策略，依次遍历链表节点插入到红黑树中，我们构造如下：</p>
<ul>
<li>节点80</li>
</ul>
<p>第一个节点80，插入到空树中，设置为根节点，并为黑色：</p>
<p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2020/Snipaste_2019-12-11_18-34-51.png" alt="" /></p>
<ul>
<li>节点60</li>
</ul>
<p>节点60按二叉树插入后，未违反任何红黑树的性质，不做任何动作</p>
<p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2020/Snipaste_2019-12-11_18-35-52.png" alt="" /></p>
<ul>
<li>节点50</li>
</ul>
<p>节点50插入后，违反了性质4，按照<strong>情况5：当前节点的父节点是红色，叔叔节点是黑色，当前节点是左子节点</strong>进行恢复。</p>
<p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2020/Snipaste_2019-12-11_18-36-56.png" alt="" /></p>
<p>按照情况5的恢复策略调整如下：<br />
把当前节点的父节点变为黑色，祖父节点变为红色，将祖父节点更新为当前节点，以新的当前节点为支点进行右旋操作。</p>
<p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2020/Snipaste_2019-12-11_18-41-03.png" alt="" /></p>
<ul>
<li>节点70</li>
</ul>
<p>节点70插入后，违反红黑树性质5，按照<strong>情况3：当前节点的父节点是红色，且叔叔节点也是红色</strong>进行调整。</p>
<p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2020/Snipaste_2019-12-11_18-41-53.png" alt="" /></p>
<p>调整如下，需要经过两次涂色调整，将当前节点70的父节点和叔叔节点改为黑色，祖父节点改为红色。由于祖父节点为根节点，根节点只能为黑色，因此在此将根节点改为黑色，调整完成。</p>
<p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2020/Snipaste_2019-12-13_14-59-47.png" alt="" /></p>
<ul>
<li>节点20</li>
</ul>
<p>节点20插入后未违反任何特性，无需调整。</p>
<p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2020/Snipaste_2019-12-11_18-43-15.png" alt="" /></p>
<ul>
<li>节点65</li>
</ul>
<p>节点65插入后违反性质4，按照<strong>情况5：当前节点的父节点是红色，叔叔节点是黑色，当前节点是左子节点</strong>进行恢复。</p>
<p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2020/Snipaste_2019-12-11_18-43-58.png" alt="" /></p>
<p>恢复调整如下，需要经过两个步骤，当前节点65的父节点改为黑色，祖父节点改为红色，然后将祖父节点设为最新的当前节点。涂色后的新树违反了性质5，因此还要以最新的当前节点为支点进行右旋操作：</p>
<p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2020/Snipaste_2019-12-11_18-47-34.png" alt="" /></p>
<ul>
<li>节点40</li>
</ul>
<p>节点40插入后，违反红黑树性质4:父子节点不能都为红色，插入后的红黑树见下图：</p>
<p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2020/Snipaste_2019-12-11_18-48-19.png" alt="" /></p>
<p>根据前文的调整策略，此处当前节点为红色，叔叔节点NIL为黑色，且当前节点为右子节点，**按情况4进行调整恢复：<br />
步骤一：以当前节点40的父节点20为新的当前节点（见下图1）；<br />
步骤二：以图1中新的当前节点20为支点，左旋（见下图2）；</p>
<p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2020/Snipaste_2019-12-11_18-57-23.png" alt="" /></p>
<p>旋转完成后，发现当前节点20和父节点40都为红色，仍然违反了红黑树的性质4，需要继续回溯当前节点再次旋转或涂色。此时，当前节点是左子节点，**按情况5进行调整恢复：<br />
步骤一：将当前节点的父节点40重涂为黑色，祖父节点50重涂为红色（见下图3）；得到的红黑树发现不满足红黑树的性质5：从一个节点到其所有叶子节点的所有路径上包含相同数目的黑节点，继续执行步骤二的调整。<br />
步骤二：以当前节点20的祖父节点50为新的当前节点，进行右旋（见下图5）；</p>
<p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2020/Snipaste_2019-12-11_18-58-01.png" alt="" /></p>
<p>到此，成功将节点40插入红黑树，满足所有红黑树的性质.</p>
<ul>
<li>节点10</li>
</ul>
<p>节点10插入后违反性质4，按照<strong>情况3：当前节点的父节点是红色，且叔叔节点（祖父节点的另一个子节点）也是红色</strong>进行恢复。</p>
<p><img src="/Users/haotongan/MyDocument/summary/personal/%E5%9B%BE%E7%89%87/Snipaste_2019-12-11_18-58-56.png" alt="" /></p>
<p>恢复调整如下，当前节点10的父节点和叔叔节点改为黑色，祖父节点40重涂为红色，调整就完成了：</p>
<p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2020/Snipaste_2019-12-11_18-59-33.png" alt="" /></p>
<p>至此，红黑树的构造完成。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Toyan</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://toyan.top/RBTree/">https://toyan.top/RBTree/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/public/alipay.jpeg"><div class="post-qr-code__desc">支付宝打赏</div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/public/wechat.jpeg"><div class="post-qr-code__desc">微信打赏</div></div></div><div class="social-share pull-right"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/spring-logger/"><i class="fa fa-chevron-left">  </i><span>Java日志框架</span></a></div><div class="next-post pull-right"><a href="/service-avalanche/"><span>服务雪崩、降级与熔断</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '64bf96f3f30de518911b',
  clientSecret: '2b721d1728859b321e4f4533bd870be019c30c37',
  repo: 'toyan-blog.github.io',
  owner: 'toyan-blog',
  admin: 'toyan-blog',
  id: md5(decodeURI(location.pathname)),
  language: 'en'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/public/blog.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2020 By Toyan</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"superSample":2,"width":210,"height":420,"position":"left","hOffset":0,"vOffset":-20},"log":false,"tagMode":false});</script></body></html>