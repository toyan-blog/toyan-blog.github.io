<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Email: tonganhao1103@gmail.com"><meta name="keywords" content=""><meta name="author" content="Toyan"><meta name="copyright" content="Toyan"><title>ToyanのBlog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?c61658fe357dc669ee95b5bd4e25caad";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><link rel="dns-prefetch" href="http://ta.qq.com"><script>(function() {
   var hm = document.createElement("script");
   hm.src = "https://tajs.qq.com/stats?sId=66513922";
   var s = document.getElementsByTagName("script")[0];
   s.parentNode.insertBefore(hm, s);
 })();</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="ToyanのBlog" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/public/avatar.jpeg"></div><div class="author-info__name text-center">Toyan</div><div class="author-info__description text-center">Email: tonganhao1103@gmail.com</div><div class="follow-button"><a href="https://github.com/toyan-blog" target="_blank" rel="noopener">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">17</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">14</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">20</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="https://molunerfinn.com/hexo-theme-melody-doc/" target="_blank" rel="noopener">hexo-theme-melody</a><a class="author-info-links__name text-center" href="https://molunerfinn.com/" target="_blank" rel="noopener">Molunerfinn</a></div></div></div><nav id="nav" style="background-image: url(https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/public/blog.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">ToyanのBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="site-info"><div id="site-title">ToyanのBlog</div><div id="site-sub-title"></div><div id="site-social-icons"><a class="social-icon" href="https://github.com/toyan-blog" target="_blank" rel="noreferrer noopener nofollow"><i class="fa-github fa"></i></a><a class="social-icon" href="https://weibo.com/3889572163" target="_blank" rel="noreferrer noopener nofollow"><i class="fa-weibo fa"></i></a><a class="social-icon" href="https://toyan.top/atom.xml" target="_blank" rel="noreferrer noopener nofollow"><i class="fa-rss fa"></i></a></div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/algorithm/">刷题汇总</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-02-06</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/algorithm/">algorithm</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/algorithm/leetcode/">leetcode</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a></span><div class="content">排序算法
剑指offer
leetcode
动态规划
</div><a class="more" href="/algorithm/#more" style="margin-top: 14px">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/hello-world/">Hello World</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-02-01</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/hexo/">hexo</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/hexo/">hexo</a></span><div class="content">Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.
 Quick Start
 Create a new post
1$ hexo new "My New Post"
More info: Writing
 Run server
1$ hexo server
More info: Server
 Generate static files
1$ hexo generate
More info: Generating
 Deploy to remote sites
1$ hexo deploy
More info: Deployment
</div><a class="more" href="/hello-world/#more" style="margin-top: 14px">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/sql-summary/">SQL</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-10-14</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/">基础知识总结</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/SQL/">SQL</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/SQL/">SQL</a></span><div class="content"> 基础

DML语句：主要由insert、update和delete三个关键字组成
DDL语句：主要由create、alter、drop和truncate四个关键字组成

 DDL语句

增加列、修改列、删除列：add、modify、drop
删除表：drop table 表名;
truncate表：删除该表里的全部数据，但保留表结构；只能一次性删除整个表的全部记录；比delete删除速度要快
建立索引：create index 索引名 on 表名
索引的缺陷：

当数据表中的记录被添加、删除、修改时，数据库系统需要维护索引，因此有一定的系统开销
存储索引需要一定的磁盘空间


distinct去除重复记录

 DML语句

mysql使用concat进行字符串连接
SQL语句中的通配符：下划线代表一个任意的字符，百分号代表任意多个字符
数据库函数

ifnull(expr1, expr2)，如果expr1为null，则返回expr2，否则返回expr1
nullif(expr1, expr2)，如果expr1和expr2相等，则返回null，否则返回expr2
if(expr1, expr2, expr3)，如果expr1为true，不等于0，且不等于null，则返回expr2，否则返回expr3
isnull(expr1)，判断expr1是否为null


分组与组函数：avg、count、max、min和sum

having子句：不能在where子句中过滤组，where子句仅用于过滤行。过滤组必须使用having子句；不能在where子句中使用组函数，having子句才可以使用组函数


多表连接查询： 查询用的多个数据表显式使用xxx join连接，而不是直接依次排列在from之后，from之后只需要放一个数据表；连接条件不再放在where之后，而是提供了专门的连接条件子句

on子句连接，每个on子句只指定一个连接条件
左、右、全外连接：left join、right join、full join
SQL99与SQL92的外连接恰好相反，SQL99左外连接将会把左边表中所有不满足连接条件的记录全部列出；SQL99右外连接将会把所有右边表不满足连接条件的记录全部列出；全外连接将会把两个表中所有不满足条件的记录全部列出（Mysql并不是全外连接）


集合运算：将select返回的两个结果集做运算，intersect（交，不支持，使用多表连查来替代）、union（并）、minus（差，不支持，使用子查询来替代）
注意：

两个结果集所包含的数据列的数量必须相同
两个结果集所包含的数据列的数据类型也必须一一对应



 SQL select语句的完整执行顺序

from子句组装来自不同数据流的数据
where子句基于指定的条件对记录行进行筛选
group by子句将数据划分为多个分组
使用聚集函数进行计算
使用having子句筛选分组
计算所有的表达式
select的字段
使用order by对结果集进行排序

SQL语言不同于其他编程语言最明显特征就是处理代码的顺序。在大多数据库语言中，代码按编码顺序被处理。但在SQL语言中，第一个被处理的子句是FROM，而不是SELECT，SQL查询处理的步骤编号如下：
123456789(8)SELECT (9) DISTINCT (11) &lt;TOP_specification&gt; &lt;select_list&gt;(1) FROM &lt;left_table&gt;(3) &lt;join_type&gt; JOIN &lt;right_table&gt;(2) ON &lt;join_condition&gt;(4) WHERE &lt;where_condition&gt;(5) GROUP BY &lt;group_by_list&gt;(6) WITH &#123;CUBE | ROLLUP&#125;(7) HAVING &lt;having_condition&gt;(8) ORDER BY &lt;order_by_list&gt;
以上每个步骤都会产生一个虚拟表，该虚拟表被用作下一个步骤的输入。这些虚拟表对调用者（客户端应用程序或者外部查询）不可用。只有最后一步生成的表才会给调用者。如果没有在查询中指定某一个子句，将跳过相应的步骤。
</div><a class="more" href="/sql-summary/#more" style="margin-top: 14px">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/JVM-summary/">JVM虚拟机总结</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-10-07</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/">基础知识总结</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/JVM/">JVM</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Java/">Java</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/JVM/">JVM</a></span><div class="content"> JVM垃圾处理方法


标记-清除算法

标记阶段：先通过根节点，标记所有从根节点开始的对象，未被标记的为垃圾对象
清除阶段：将所有未标记的对象清除



标记-整理算法

标记阶段：先通过根节点，标记所有从根节点开始的可达对象，未被标记的为垃圾对象
整理阶段：将所有的存活对象压缩到一段连续的内存空间，之后清理边界的所有空间



复制算法

将所有的内存空间分成两块，每次只使用一块，在垃圾回收时，将正在使用的内存中的存活对象复制到未使用的内存块中，然后清除正在使用的内存块中的所有对象




 GC


新生代、老年代、持久代



GC用的可达性分析算法中，可作为GC Roots对象

Java虚拟机栈中的对象
方法区中的静态成员
方法区中的常量引用对象
本地方法区中的JNI(Native方法)引用对象



新生代转移到老年代的触发条件

长期存活的对象
大对象直接进入老年代
Minor GC后，survivor仍然放不下
动态年龄判断，大于等于某个年龄的对象超过了survivor空间的一半，大于等于这个年龄的对象直接进入老年代



MinGC、FullGC



各个垃圾回收器的工作方式





还有两个老年代收集器：Serial old和Parallel old收集器


 Java虚拟机内存的划分以及每个区域的功能



程序计数器（线程私有）

线程创建时创建，执行本地方法时其值为undefined



虚拟机栈（线程私有）

（栈内存）为虚拟机执行Java方法服务，方法被调用时创建栈帧–&gt;局部变量表（基本数据类型，对象引用类型）–&gt;局部变量，对象引用
如果线程请求的栈深度超过了虚拟机所允许的深度，就会出现StackOverfFow
虚拟机栈可以动态扩展，如果扩展到无法申请足够的内存时，会出现OutOfMemeory



本地方法栈（线程私有）

Java虚拟机栈是为Java方法服务，而本地方法栈视为虚拟机使用到的Native方法服务
Java虚拟机没有对本地方法的使用和数据结构做强制规定。Sun HotSpot把Java虚拟机栈和本地方法栈合二为一
同样抛出StackOverfFlowError和OutOfMemeoryError



Java堆

被所有线程所共享，在Java虚拟机启动时创建，几乎所有的对象实例都存放在这里
GC管理的主要区域
物理不连续，逻辑上连续，可以动态扩展，扩展失败抛出OutOfMemeoryError



方法区

用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码的数据
Sun HotSpot虚拟机把方法区称为永久代



运行时常量池

受到方法区的限制，可能抛出OutOfMemeoryError



 双亲委派机制

如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而且把这个请求委派给父类加载器去完成，每一个层次的加载器都如此，因此所有的类加载器都会交给顶层的启动类加载器。只有当父类加载器无法完成该加载请求时（该加载器的搜索范围内没有找到对应的类）时，子加载器才会尝试直接去加载。
 Student s = new Student()在内存中做的事情

加载Student class文件到内存
在栈内存为s开辟空间（对象引用类型）
在堆内存为学生对象开辟空间（对象实例）
对学生对象的成员变量进行默认初始化
对学生对象的成员变量进行显式初始化
通过构造方法给学生对象的成员变量进行赋值
学生对象初始化完成， 把对象地址赋值给s变量

 Java的GC为什么要分代
分代的垃圾回收策略，是基于这样一个事实：**不同的对象的生命周期是不一样的。**因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。

试想，在不进行对象存活时间区分的情况下，每次垃圾回收都是对整个堆空间进行回收，花费时间相对会长，同时，因为每次回收都需要遍历所有存活对象，但实际上，对于生命周期长的对象而言，这种遍历是没有效果的，因为可能进行了很多次遍历，但是他们依旧存在。因此，分代垃圾回收采用分治的思想，进行代的划分，把不同生命周期的对象放在不同代上，不同代上采用最适合它的垃圾回收方式进行回收。

 如何分代
虚拟机中共分为三代：年轻代、老年代和持久代。其中持久代主要存放的是Java类的类信息，与垃圾收集要收集的Java对象关系不大。年轻代和老年代是对垃圾收集影响比较大的。


年轻代
所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。年轻代分为三个区。一个Eden区，两个Survivor区（一般而言）。大部分对象在Eden区中生成。当Eden区满时，还存活的对象将被复制到Survivor区（两个中的一个），当这个Survivor区也满了的时候，从第一个Survivor区复制过来的并且此时还存活的对象，将被复制到另一个Survivor区，当这个Survivor区也满了的时候，从第一个Survivor区复制过来的并且此时还存活的对象，将被复制到“老年区”。需要注意的是，Survivor的两个区是对称的，没先后顺序，所以同一个区中可能存在从Eden复制过来的对象，和从前一个Survivor复制过来的对象，而复制到老年区的只有从第一个Survivor区过去的对象。而且，Survivor区总有一个是空的。同时，根据程序需要，Survivor区是可以配置为多个的（多于两个），这样可以增加对象在年轻代中的存在时间，减少被放到老年代的可能。


老年代
在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到老年代。因此，可以认为老年代中存放的都是一些生命周期较长的对象。


持久代
用于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如hibernate等，在这种时候需要设置一个比较大的持久代空间来存放这些运动过程中新增的类。


 Minor GC、Full GC触发条件是什么？

从年轻代空间（包括Eden、Survivor区域）回收内存被称为Minor GC
对老年代GC称为Major GC
而Full GC是对整个堆来说

在最近几个版本的JDK里默认包括了对永生代即方法区的回收（JDK8中无永生代了），出现Full GC的时候经常伴随至少一次的Minor GC,但非绝对的。
Major GC的速度一般会比Minor GC慢10倍以上。下边看看有那种情况触发JVM进行Full GC及应对策略。


Minor GC触发条件：
当Eden区满时，触发Minor GC。


Full GC触发条件：


System.gc()方法的调用

此方法的调用是建议JVM进行Full GC，虽然只是建议而非一定，但很多情况下它会触发Full GC，从而增加Full GC的频率，也即增加了间歇性停顿的次数。虽然影响系统建议不能使用这个方法，让虚拟机自己去管理它的内存。



老年代空间不足

老年代空间只有在新生代对象转入及创建大对象、大数组时才会出现不足的现象，当执行Full GC后空间仍然不足，则抛出如下错误：java.lang.OutOfMemoryError: Java heap space，为避免以上两种情况引起的Full GC，调优时应尽量做到让对象在Minor GC阶段被回收、让对象在新生代多存活一段时间及不要创建过大的对象及数组。



方法区空间不足

JVM规范中运行时数据区域中的方法区，在HotSpot虚拟机中又被习惯称为永生代或者永生区，Permanet Generation中存放的为一些class的信息、常量、静态变量等数据，当系统中要加载的类、反射的类和调用的方法较多时，Permanet Generation可能会被占满，在未配置为采用CMS GC的情况下也会执行Full GC。如果经过Full GC仍然回收不了，那么JVM会抛出如下错误信息：java.lang.OutOfMemoryError: PermGen space。为避免Perm Gen占满造成Full GC现象，可采用的方法为增大Perm Gen空间或转为使用CMS GC。



通过Minor GC后进入老年代的平均大小大于老年代的可用内存

如果发现统计数据说之前Minor GC的平均晋升大小比目前old gen剩余的空间大，则不会触发Minor GC而是转为触发full GC



由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小




 G1 GC
G1 GC是目前为止最为复杂、也是最先进的GC，在CMS算法中，GC管理的内存被划分为新生代、老年代和永久代/元空间。这些空间必须是地址连续的。在G1算法中，采用了另外一种完全不同的方式组织堆内存，堆内存被划分为多个大小相等的内存块（Region），每个Region是逻辑连续的一段内存，Region的大小可以通过-XX:G1HeapRegionSize参数指定，如果没有配置，默认堆内存按照2048份均分，最后得到一个合理的大小。在G1中，还有一个特殊的区域，叫Humongous 区域。
如果一个对象占用的空间超过了分区容量50%以上，G1收集器就认为这是一个巨型对象。这些巨型对象，默认直接会被分配在老年代，但是如果它是一个短期存在的巨型对象，就会对垃圾回收器造成负面影响。为了解决这个问题，G1划分了一个Humongous 区域，它用来专门存放巨型对象，下面的图片展示了G1的内存结构：

 G1 GC内存结构
G1 GC的运行可以分为下面几个阶段：


**初始标记：**扫描根集合，标记所有从根节点可直接到达的对象并将它们的字段压入扫描栈。在分代式G1模式中，初始标记阶段借用 Young GC 的暂停，因而没有额外的、单独的暂停阶段。


**并发标记：**这个阶段可以并发执行，GC线程不断从扫描栈取出引用，进行递归标记，直到扫描栈清空。


**最终标记：**重新标记写入屏障标记的对象，这个阶段也进行弱引用处理。


**筛选回收：**统计每个Region被标记位活的对象有多少，如果发现完全没有活对象的Region就会将其整体回收到可分配 Region 列表中。


与其他GC相比，G1 GC有如下特点：


**并行与并发：**G1 GC能充分利用CPU、多核心等硬件优势，使用多个CPU或者CPU核心来缩短STW的时间，部分其他GC需要停顿java线程执行的GC操作，在G1 GC中仍然可以通过并发的方式让java程序继续执行


**分代收集：**和其他GC一样，分代的概念在G1 GC中仍然保留


**空间整合：**与CMS的标记-清理算法不同，G1 GC从整体来看是通过”标记-整理“算法实现的GC，从局部（两个Region之间）来看是通过”复制“算法来实现的，无论如何，这两种算法在运行期间都不会产生内存碎片，GC 活动之后可以提供规整的内存空间。


**可预测的停顿：**这是G1 GC相对于CMS的另一大优势，降低停顿时间是G1 GC和CMS GC共同关注的，但是G1 GC除了追求低停顿时间外，还建立了可预测的停顿时间模型，能让使用这明确指定在一个长度为M的时间片内，消耗在垃圾收集上的事件不得超过N毫秒。


下面的图片展示了多个GC以及他们工作的分代位置，以及如何组合使用：

 JVM GC的触发条件


**Young GC：**当Young generation中的Eden区分配满的时候触发。


Full GC：



当准备要触发一次young GC时，如果发现统计数据Young GC的平均大小比目前Old Gen剩余的空间大，则不会触发Young GC而是转为触发Full GC。
如果有Perm Gen的话，要在Perm Gen分配空间但已经没有足够空间时，也要触发一次Full GC
调用System.gc()默认也是触发Full GC

 JVM性能监控与故障处理工具


jps：JVM进程状况工具
选项：
-m 输出JVM进程启动时传递给主类main方法的参数
-l 输出主类的全名，如果进程执行的是jar包，输出jar包的路径
-v 输出进程启动时的JVM参数


jstat：JVM统计信息监控工具
该工具具有丰富的JVM统计功能，具体支持的统计可以使用man jstat来输出帮助文档


jinfo：java配置信息工具
jinfo用于获取当前JVM的配置信息


jmap：java内存映射工具
jmap用于生成堆的转储快照，下面为一个使用示例，用于将当前的JVM的堆的快照输出到文件中去


jhat：等jhat执行完毕后，就可以打开浏览器查看堆的情况的


jstack：JVM堆栈追踪工具
jstack用于生成当前堆栈的线程快照，这个命令会将所有在堆上的线程都输出，包括线程的运行状态，持有资源的状态等等，对于java应用调优，jstack是非常有用的。


</div><a class="more" href="/JVM-summary/#more" style="margin-top: 14px">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/network-summary/">计算机网络总结</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-10-07</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/">基础知识总结</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></span><div class="content"> TCP报头格式
定义：TCP传输控制协议是一种面向连接的、可靠的、基于字节流的传输层协议。

图一是TCP报文格式，下面是对各参数的解释

源端口号和目的端口号：TCP报头中的源端口号和目的端口号同IP数据报中的源IP与目的IP唯一确定一条TCP连接
序号：用来标识TCP发端向TCP收端发送的数据字节流
确认序号：ACK标志位为1时确认序号才有效（即不为0）；一旦连接建立，该值将始终发送
首部长度：报文头长度(单位：bit)/32
例子：1000（转化为十进制为8，8 * 32/8 = 32，该报文报头长度为32个字节）
存在该字段是因为TCP报头中任选字段长度可变
报头不包含任何任选字段则长度是20字节；4位所能表示的最大值为1111，转换为十进制是15，15*32/8 = 60，故报头最大长度是60字节
保留：占6位，保留为今后使用，目前应置为0
控制位：6位

URG：紧急指针有效性标志
ACK：确认序号有效性标志，一旦一个连接建立起来，该标志位总被置为1，即除了请求建立连接报文（仅设置SYN标志位为1），其他所有报文的该标志位总为1
PSH（PuSH）：推送标志位，接收方应尽快将报文段提交至应用层，而不再等到整个缓存都填满了后再向上交付
RST（ReSeT）：重置连接标志位，当RST=1时，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立运输连接
SYN：同步序号标志
FIN：传输数据结束标志


窗口大小（2字节）：TCP流量控制通过连接的每一个端声明窗口大小进行控制（接受缓冲区大小）
由于2字节能够表示的最大正整数为65535，故窗口最大值为65535
检验和（2字节）：检验和覆盖整个TCP报文段；强制字段，有发送端计算存储，有接收端进行验证
紧急指针（2字节）：当URG=1时，紧急指针才有效
选项（0-40字节）：当没有使用“选项”时，TCP的首部长度是20字节

 TCP的三次握手与四次挥手



三次握手：
**第一次握手：**主机A发送位码为SYN=1，随机产生seq number=10001的数据包到服务器，主机B由SYN=1知道A要求建立联机，此时状态为SYN_SENT；
**第二次握手：**主机B收到请求后要确认联机信息，向A发送ack number=（主机A的seq+1），SYN=1，ACK=1，随机产生seq number=20001的包，此时状态有LISTEN变为SYN_RECV；
**第三次握手：**主机A收到后检查ack number是否正确，即第一次发送的seq number + 1，以及位码ack是否为1，若正确，主机A会再次发送ack number = （主机B的seq+1），ACK=1，主机B收到后确认seq值与ack=1则连接建立成功，双方状态established
完成三次握手，主机A与主机B开始传送数据。
各个状态名称与含义

CLOSED：表示初始状态
LISTEN：表示服务器端的某个socket处于监听状态，可以接受连接了
SYN_RECV：这个状态表示接受到了SYN报文，在正常情况下，这个状态是服务端的socket在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂，基本上用netstat你是很难看到这个状态的。这种状态时，当收到客户端的ACK报文后，它会进入到established
SYN_SENT：这个状态与SYN_RECV遥相呼应，当客户端socket执行connect连接时，它首先发送SYN报文，因此也随机它会进入到了SYN_SENT状态，并等到服务端的发送三次握手中的第2个报文。SYN_SENT状态表示客户端已发送SYN报文
ESTABLISHED：表示连接已经建立了。



四次挥手：

假设Client端发起中断请求，也就是发送FIN报文。Server端接到FIN报文后，意思是说“我client端要发给你了”，但是如果你还没有数据要发送完成，则不必急着关闭Socket，可以继续发送数据。所以你先发送ACK，“告诉Client端，你的请求我收到了，但是我还没准备好，请继续你等我的消息”。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。当Server端确定数据已发送完成，则向Client端发送FIN报文，“告诉Client端，好了，我这边数据发完了，准备好关闭连接了”。Client端收到FIN报文后，“就知道可以关闭连接了，但是它还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。”，Server端收到ACK后，“就知道可以断开连接了”。Client端等待2MSL（报文最大生存时间）后仍然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。这样，TCP连接就这样关闭了。
各个状态名称与含义：

FIN_WAIT_1：其实FIN_WAIT_1与FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。这两种状态的区别是：FIN_WAIT_1状态实际上是当Socket在established状态时，它想主动关闭连接，向对方发送FIN报文，此时该socket即进入FIN_WAIT_1状态。而当对方回应ACK报文后，则进入FIN_WAIT_2状态。当然在实际的正常情况下，无论对方何种情况下，都应该马上回应ACK报文，所以FIN_WAIT_1状态比较难见，而FIN_WAIT_2状态可以用netstat看到。
FIN_WAIT_2：实际上该状态下的socket，表示半连接，也即有一方要求close连接，但另外还告诉对方，我暂时还有些数据要传，稍后再关闭连接。
TIME_WAIT：表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL后即可回到CLOSED可用状态了。如果FIN_WAIT_1状态下，收到了对方同时带FIN标志和ACK标志的报文时，则可直接进入TIME_WAIT状态，而无需经过FIN_WAIT_2状态。



下面两个问题记牢
为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？
*第一种回答：*这是因为服务端的listen状态下的socket当收到SYN报文的连接请求时后，它可以把ACK和SYN（ACK起到应答作用，而SYN起同步作用）放在一个报文里来发送。但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了，但未必你所有的数据都全部发送给对方了，所以你可以未必会关闭socket连接，也即你可能还需要发送一些数据给对方之后，在发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。
*第二种回答：*因为当Server端收到Client端的SYN连接请求后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭Socket，所以只能先回复一个ACK报文，告诉client端，“你发送的FIN报文我收到了”。只有等到Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送，故需要四次挥手。
为什么TIME_WAIT状态还需要等待2MSL后才能返回到CLOSED状态？
答：因为虽然双方都同意关闭连接了，而且握手的4个报文也都发送完毕，按理可以直接回到CLOSED状态（就好比从SYN_SENT状态到ESTABLISH状态那样），但是我们必须假想网络是不可靠的，有可能最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。
 UDP报头格式

源端口号：在需要对方回信时选用。不需要是可全为0
目的端口号：这在终点交付报文时必须要使用到
UDP长度：UDP报文的字节长度（包括首部和数据）
UDP校验和：检验UDP首部和数据部分的正确性
 TCP/UDP区别
课本：
UDP在传输数据之前不需要先建立连接。远程主机的运输层在收到UDP报文后，不需要给出任何确认。虽然UDP不提供可靠交付，但在某些情况下UDP却是一种最有效的工作方式。
TCP则提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。TCP不提供广播或多播服务。由于TCP要提供可靠地、面向连接的运输服务，因此不可避免地增加了许多的开销，如确认、流量控制、计时器以及连接管理等。这不仅使协议数据单元的首部增大很大，还要占用许多的处理机资源。
博客答案：




TCP
UDP




是否连接
面向连接
面向非连接


传输可靠性
可靠的
不可靠的


应用场合
传输大量的数据
少量数据


速度
慢
块



OSI和TCP/IP模型在传输层定义两种传输协议：TCP（传输控制协议）和UDP（用户数据报协议）。
UDP
UDP和TCP的主要区别在于UDP不一定提供可靠的数据传输。事实上，该协议不能保证数据准确无误地到达目的地。UDP在很多方面非常有效。当某个程序的目标是尽快地传输尽可能多的信息时（其中任意给定的重要性相对较低），可使用UDP。许多程序将使用单独的TCP连接和单独的UDP连接。重要的状态信息随可靠的TCP连接发送，而主数据留通过UDP发送。
TCP
TCP的目的是提供可靠的数据传输，并在相互进行通信的设备或服务之间保持一个虚拟连接。TCP在数据包接收无序、丢失或在交付期间被破坏时，负责数据恢复。它通过为其发送的每个数据包提供一个序号来完成此恢复。较低的网络层会将每个数据包视为一个独立的单元，因此，数据包可以沿完全不同的路径发送，即使它们都是同一消息的组成部分。这种路由与网络层处理分段和重新组装数据包的方式非常相似，只是级别更高而已。
为确保正确地接收数据，TCP要求在目标计算机成功收到数据时发回一个确认（即ACK）。如果在某个时限内未收到相应的ACK，将重新传送数据包。如果网络阻塞，这种重新传送将导致发送的数据包重复。但是，接收计算机可使用数据包的序号来确认它是否为重复数据包，并在必要时丢弃它。
TCP与UDP的选择：
如果比较UDP包和TCP包的结构，很明显UDP包不具备TCP包复杂的可靠性和控制机制。与TCP协议相同，UDP的源端口数和目的端口数也都支持一台主机上的多个应用。一个16位的UDP包包含了一个字节长的头部和数据的长度，校验码域使其可以进行整体校验。（许多应用只支持UDP，如：多媒体数据流，不产生任何额外的数据，即使知道有破坏的包也不进行重发。）很明显，当数据传输的性能必须让位于数据传输的完整性、可控制性和可靠性时，TCP协议是首选。当强调性能而不是传输的完整性时，如：音频和多媒体应用，UDP是最好的选择。在数据传输时间很短，以至于此前的连接过程成为整个流量主体的情况下，UDP较低的开销使其有更好的机会去传送管理数据。TCP丰富的功能有时会导致不可预料的性能低下，但是我们相信在不远的将来，TCP可靠的点对点将会用于绝大多数的网络应用。
TCP协议和UDP协议特性区别总结：

TCP协议在传送数据段的时候要给段标号；UDP不需要
TCP协议可靠；UDP协议不可靠
TCP协议是面向连接的；UDP协议采用无连接
TCP协议负载较高，采用虚电路；UDP采用无连接
TCP协议的发送方要确认接收方是否收到数据段（3次握手协议）
TCP协议采用窗口技术和流控制

 HTTP状态码
当浏览器访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含HTTP状态码的信息头（server header）用以响应浏览器的请求。
HTTP状态码的英文为HTTP Status Code。下面是常见的HTTP状态码：

200 请求成功
301 资源（网页等）被永久转移到其他URL
404 请求的资源（网页等）不存在
500 内部服务器错误

状态码分类



分类
分类描述




1**
信息，服务器收到请求，需要请求者进行执行操作


2**
成功，操作被成功接收并处理


3**
重定向，需要进一步的操作以完成请求


4**
客户端错误，请求包含语法错误或无法完成请求


5**
服务器错误，服务器在处理请求的过程中发生了错误



状态码列表



状态码
状态码英文名称
中文描述




100
Continue
继续，客户端应继续其请求


101
Switching Protocols
切换协议。服务器根据客户端的请求切换协议。只能切换到HTTP的新版本协议







200
OK
请求成功。一般用于GET和POST请求


201
Created
已创建。成功请求并创建了新的资源


202
Accepted
已接受。已经接受请求，但未处理完成


203
Non-Authoritative Information
非授权信息。请求成功，但返回的meta信息不在原始的服务器，而是一个副本


204
No Content
无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档


205
Reset Content
重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清楚浏览器的表单域


206
Partial Content
部分内容。服务器成功处理了部分GET请求







300
Multiple Choices
多种选择。请求的资源可包含多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择


301
Moved Permanently
永久移动。请求的资源已被永久的移动到新URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替


302
Found
临时移动。与301类似，但资源只是临时被移动，客户端应继续使用原有URI


303
See Other
查看其它地址，与301、302类似，如果最初的请求是POST，那么新文档要用GET找到


304
Not Modified
未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源


305
Use Proxy
使用代理，所请求的资源必须通过代理访问


306
Unused
已经被废弃的HTTP状态码


307
Temporary Redirect
临时重定向。与302类似，使用GET请求重定向







400
Bad Request
客户端请求的语法错误，服务器无法理解


401
Unauthorized
请求要求用户的身份认证


402
Payment Required
保留


403
Forbidden
服务器理解请求客户端的请求，但是拒绝执行此请求


404
Not Found
服务器无法根据客户端的请求找到资源（网页），通过此代码，网站设计人员可设置“您所请求的资源无法找到”的个性页面


405
Method Not Allowed
客户端请求中的方法被禁止


406
Not Acceptable
服务器无法根据客户端请求的内容特性完成请求


407
Proxy Authentication Required
请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权


408
Request Time-out
服务器等待客户端发送的请求时间太长，超时


409
Conflict
服务器完成客户端的PUT请求是可能返回此代码，服务器处理请求时发生了冲突


410
Gone
客户端请求的资源已经不存在，410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置


411
Length Required
服务器无法处理客户端发送的不带Content-Length的请求信息


412
Precondition Failed
客户端请求信息的先决条件错误


413
Request Entity Too Large
由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连接请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息


414
Request-URI Too Large
请求的URI过长（URI通常为网址），服务器无法处理


415
Unsupported Media Type
服务器无法处理请求附带的媒体格式


416
Requested range not satisfiable
客户端请求的范围无效


417
Expectation Failed
服务器无法满足Expect的请求头信息







500
Internal Server Error
服务器内部错误，无法完成请求


501
Not Implemented
服务器不支持请求的功能，无法完成请求


502
Bad Gateway
充当网关或代理的服务器，从远端服务器接收到了一个无效的请求


503
Service Unavailable
由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中


504
Gateway Time-out
充当网关或代理的服务器，未及时从远端服务器获取请求


505
HTTP Version not supported
服务器不支持请求的HTTP协议的版本，无法完成处理



 HTTP协议
HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写，是用于从万维网（WWW：World Wide Web）服务器传输超文本到本地浏览器的传送协议。
HTTP是一个基于TCP/IP通信协议来传递数据（HTML文件、图片文件、查询结果等）。
主要特点

简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、POST。
灵活：HTTP允许传输任意类型的数据对象，正在传输的类型由Content-Type加以标记
无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。
无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传输的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。
支持B/S及C/S

 HTTP之URL
HTTP使用统一资源标识符（Uniform Resource Identifiers，URI）来传输数据和建立连接。URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息。
URL，全称是Uniform Resource Locator，中文叫统一资源定位符，是互联网上用来标识某一处资源的地址。


URI，是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。
Web上可用的每种资源如HTML文档、图像、视频片段、程序等都是一个来URI来定位的URI一般有三个部分组成：

访问资源的命名机制
存放资源的主机名
资源自身的名称，有路径标识，着重强调于资源



URL是uniform resource locator，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。
URL是Internet上用来描述资源信息的字符串，主要用在各种WWW客户程序客户程序和服务器程序上。
采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL一般由三部分组成：

协议（或称为服务方式）
存有该资源的主机IP地址（有时也包括端口号）
主机资源的具体地址。如目录和文件名等



URN，uniform resource name，统一资源命名，是通过名字来标识资源


URI是一种抽象的，高层次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。URL和URN都是一种URI。笼统地说，每个URL都是URI，但不一定每个URI都是URL。这是因为URI还包括一个子类，即统一资源名称（URN），它命名资源但不指定如何定位资源。
在Java的URI中，一个URI实例可以代表绝对的，也可以相对的，只要它符合URI的语法规则。而URL类则不仅符合语义，还包括了定位该资源的信息，因此它不能是相对的。
在Java类库中，URI类不包括任何访问资源的方法，它唯一的作用就是解析。相反的是，URL类可以打开一个到达资源的流。
 HTTP之请求信息Request
客户端发送一个HTTP请求到服务器的请求信息包括以下格式：请求行（request line）、请求头部（header）、空行和请求数据四个部分组成。
 HTTP之响应消息Response
一般情况下，服务器接收并处理客户端发过来的请求后返回一个HTTP的响应消息。HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。
1234567200 OK                        &#x2F;&#x2F;客户端请求成功400 Bad Request               &#x2F;&#x2F;客户端请求有语法错误，不能被服务器所理解401 Unauthorized              &#x2F;&#x2F;请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 403 Forbidden                 &#x2F;&#x2F;服务器收到请求，但是拒绝提供服务404 Not Found                 &#x2F;&#x2F;请求资源不存在，eg：输入了错误的URL500 Internal Server Error     &#x2F;&#x2F;服务器发生不可预期的错误503 Server Unavailable        &#x2F;&#x2F;服务器当前不能处理客户端的请求，一段时间后可能恢复正常
 HTTP工作原理
HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。
以下是HTTP请求/响应的步骤：

客户端连接到Web服务器
一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认是80）建立一个TCP套接字连接。
发送HTTP请求
通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4个部分组成。
服务器接受请求并返回HTTP响应
Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4个部分组成。
释放连接TCP连接
若connection模型为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接；若connection模型为keep alive，则该连接会保持一段时间，则该时间内可以继续接受请求。
客户端浏览器解析HTML内容
客户端浏览器首先解析状态行，查看表明请求是否成功的状态码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。
例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程：
① 浏览器向DNS服务器请求解析该URL中的域名所对应的IP地址；
② 解析出IP地址后，根据该IP地址和默认端口80，和服务器建立TCP连接；
③ 浏览器发出读取文件（URL中域名后面部分对应的文件）的HTTP请求，该请求报文作为TCP三次握手的第三个报文的数据发送给服务器；
④ 服务器对浏览器请求作出响应，并将对应的HTML文本发送给浏览器；
⑤ 释放TCP连接
⑥ 浏览器将该HTML文本显示

GET和POST请求的区别

GET提交的数据会放在URL之后，以？分割URL和传输数据，参数之间以&amp;相连；POST方法是把提交的数据放在HTTP包的body里面；
GET提交的数据大小有限制（HTTP协议没有对传输的数据大小进行限制，HTTP协议规范也没有对URL长度进行限制，只是由于浏览器对URL的长度有限制），而POST方法提交的数据没有限制；
GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值；
GET方式提交数据，会带来安全问题
GET方式通过一次HTTP请求即可获得数据；POST方式通过两次HTTP请求获得数据，第一次返回状态码100表示浏览器继续请求。

 OSI协议、TCP/IP协议以及每层对应的协议
OSI分层 （7层）：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层；
TCP/IP分层（4层）：网络接口层、 网际层、运输层、 应用层；
5层协议 （5层）：物理层、数据链路层、网络层、运输层、 应用层；
 session机制、cookie机制
由于http协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是session。这个session是保存在服务端的，有一个唯一标识。在服务端保存session的方法有很多，内存、数据库、文件都可以。
每次http请求的时候，客户端都会发送相应的cookie信息到服务端，实际上大多数的应用都是用cookie来实现session跟踪的，第一次创建session的时候，服务端会在http协议中告诉客户端，需要在cookie里面记录一个session id，以后每次请求把这个会话id发送到服务器。
如果客户端浏览器禁用了cookie，在这种情况下，会使用一种叫做URL重写的技术来进行会话跟踪，即每次http请求，URL后面都会附上一个诸如sid=xxx这样的参数，服务端据此来标识用户。
总结：Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。
 打开网页到页面显示之间的过程
 DNS解析
 解析过程
DNS解析是一个递归查询的过程

上图是查找www.google.com的IP地址流程。首先在本地域名服务器中查询IP地址，如果没有找到的情况下，本地域名服务器会向根域名服务器发送一个请求，如果根域名服务器也不存在该域名时，本地域名会向com顶级域名服务器发送一个请求，依次类推下去。直到最后本地域名服务器得到google的IP地址并把它缓存到本地，供下次查询使用。从上述过程中，可以看出网址的解析是一个从左向右的过程：com-&gt;google.com-&gt;www.google.com。事实上，真正的网址是www.google.com.，最后一个.对应的就是根域名服务器，默认情况下，通常会省略，浏览器在请求DNS的时候都会自动加上，所有网址真正的解析过程是：.-&gt;.com-&gt;google.com.-&gt;www.google.com.。
 DNS优化
DNS缓存
DNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种：浏览器缓存、系统缓存、根域名服务器缓存、顶级域名服务器缓存、主域名服务器缓存
DNS负载均衡
DNS可以返回一个合适的机器的IP给用户，例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等，这种过程就是DNS负载均衡，又叫做DNS重定向。CDN（Content Delivery Network）就是利用DNS的重定向技术，DNS服务器会返回一个跟用户最接近的点的IP返回给用户，CDN节点的服务器负责响应用户的请求，提供所需的内容。
 TCP连接
HTTP协议是使用TCP作为其传输层协议的，当TCP出现瓶颈时，HTTP也会受到影响。
 HTTPS协议
HTTP报文是包裹在TCP报文中发送的，服务器端收到TCP报文时会解包提取出HTTP报文。但是这个过程中存在一定的风险，HTTP报文是明文，如果中间被截取的话会存在一定信息泄露的风险。HTTPS协议的本质就是HTTP+SSL(or TLS)。在HTTP报文进入TCP报文之前，先使用SSL对HTTP报文进行加密。从网络的层次结构中看它位于HTTP协议与TCP协议之间。
https在传输数据之前需要客户端与服务端进行一个握手（TCL/SSL握手），在握手过程中将确立双方加密传输数据的密码信息。TCL/SSL使用了非对称加密，对称加密和hash等。具体过程见的阮一峰先生的博客图解SSL/TLS协议
 HTTP请求
发送HTTP请求的过程就是构建HTTP请求报文并通过TCP协议发送到服务器指定端口（80和443）。HTTP请求报文是由三部分组成：请求行、请求报头和请求正文。
 服务器处理请求并返回HTTP报文
后端从在固定的端口接收到TCP报文开始，这一部分对应于编程语言中的socket。它会对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装成HTTP Request对象，供上层使用。这一部分工作一般由Web服务器去进行处理，有Tomcat、Jetty和Netty等。
HTTP响应报文也是由三部分组成：状态码、响应报头和响应报文。
 浏览器解析渲染页面
浏览器是一个边解析边渲染的过程。首先浏览器解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。这个过程比较复杂，涉及到两个概念: reflow(回流)和repain(重绘)。DOM节点中的各个元素都是以盒模型的形式存在，这些都需要浏览器去计算其位置和大小等，这个过程称为relow；当盒模型的位置,大小以及其他属性，如颜色，字体，等确定下来之后，浏览器便开始绘制内容，这个过程称为repain。页面在首次加载时必然会经历reflow和repain。
JS的解析是由浏览器中的JS解析引擎完成的。JS是单线程运行，也就是说，在同一个时间内只能做一件事，所有的任务都需要排队，前一个任务结束，后一个任务才能开始。但是又存在某些任务比较耗时，如IO读写等，所以需要一种机制可以先执行排在后面的任务，这就是：同步任务(synchronous)和异步任务(asynchronous)。JS的执行机制就可以看做是一个主线程加上一个任务队列(task queue)。同步任务就是放在主线程上执行的任务，异步任务是放在任务队列中的任务。所有的同步任务在主线程上执行，形成一个执行栈;异步任务有了运行结果就会在任务队列中放置一个事件；脚本运行时先依次运行执行栈，然后会从任务队列里提取事件，运行任务队列中的任务，这个过程是不断重复的，所以又叫做事件循环(Event loop)。
浏览器在解析过程中，如果遇到请求外部资源时，如图像,iconfont,JS等。浏览器将重复1-6过程下载该资源。请求过程是异步的，并不会影响HTML文档进行加载，但是当文档加载过程中遇到JS文件，HTML文档会挂起渲染过程，不仅要等到文档中JS文件加载完毕还要等待解析执行完毕，才会继续HTML的渲染过程。原因是因为JS有可能修改DOM结构，这就意味着JS执行完成前，后续所有资源的下载是没有必要的，这就是JS阻塞后续资源下载的根本原因。CSS文件的加载不影响JS文件的加载，但是却影响JS文件的执行。JS代码执行前浏览器必须保证CSS文件已经下载并加载完毕。
 Web优化
如何尽快的加载资源？答案就是能不从网络中加载的资源就不从网络中加载，当我们合理使用缓存，将资源放在浏览器端，这是最快的方式。如果资源必须从网络中加载，则要考虑缩短连接时间，即DNS优化部分;减少响应内容大小，即对内容进行压缩。另一方面，如果加载的资源数比较少的话，也可以快速的响应用户。当资源到达浏览器之后，浏览器开始进行解析渲染，浏览器中最耗时的部分就是reflow，所以围绕这一部分就是考虑如何减少reflow的次数。
补充：


一个完整的HTTP请求，通常有以下7个步骤

建立TCP连接
web浏览器向web服务器发送请求命令
浏览器发送请求头信息
服务器应答
服务器发送应答头信息
服务器向浏览器发送数据
服务器关闭TCP连接



一个HTTP请求由四部分组成

HTTP请求方法或动作，如：GET与POST
正在请求的URL
请求头，包含一些客户端环境信息、身份验证信息
请求体，即请求正文，可包含提交的查询字符串信息、表单信息等。



一个HTTP响应一般由三个部分组成

一个数字和文字组成的状态码，用来显示请求成功还是失败
响应头，包含许多有用的信息，如：服务器类型、日期时间、内容类型和长度
响应体，即响应正文。



readyState属性（返回请求的当前状态）

0，请求未初始换，open还没有调用
1，服务器连接已建立，open已经调用
2，请求已接收，即接收到头部信息
3，请求处理中，即接收到响应体了
4，请求已完成，且响应已就绪，即响应完成了。



 http和https区别，https在请求时额外的过程，https是如何保证数据安全的
区别：
HTTP协议传输的数据都是未加密的，即明文，为了保证隐私数据能加密传输，使用SSL协议用于对HTTP协议传输的数据进行加密，这就是HTTPS。简单的说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

https协议协议到CA申请证书，需要一定的费用
http是超文本传输协议，信息是明文传输，https则是具有安全性的SSL加密传输协议
http和https使用的是完全不用的连接方式，用到的端口不同，前者是80，后者是443
http的连接简单，是无状态的；https协议是ssl+http协议构成的可进行加密传输、身份认证的网络协议，比http协议安全

额外的过程：
https在传输数据之前需要客户端与服务端进行一个握手（TCL/SSL握手），在握手过程中将确立双方加密传输数据的密码信息。TCL/SSL使用了非对称加密，对称加密和hash等。具体过程见的阮一峰先生的博客图解SSL/TLS协议
 IP地址子网划分
IP地址的划分：

A类地址：以0开头，网络号是前一个字节
B类地址：以10开头，网络号是前两个字节
C类地址：以110开头，网络号是前三个字节

IP地址由网络号和主机号组成，ip与子网掩码相与得到网络号
子网划分
传统的两级ip地址空间利用率很低，1个A类网络可连接的主机数可超过1000万台，但实际连接数并不多，所以需要对网络进行子网划分，通过子网掩码来区分网络。
三级ip地址：&lt;网络号&gt;&lt;子网号&gt;&lt;主机号&gt;
 TCP如何保证数据的可靠传输的（这个问题可以引申出很多子问题，拥塞控制慢开始、拥塞避免、快重传、滑动窗口协议、停止等待协议、超时重传机制）
总结一：

确认和重传：接收方收到报文就会确认，发送方发送一段时间后没有收到确认就会重传
数据校验：TCP报文头有校验和，用于校验报文是否损坏
数据合理分片和排序：
TCP会按最大传输单元（MTU）合理分片，接收方会缓存为按排序到达的数据，重新排序后交给应用层
UDP：IP数据包大于1500字节，大于MTU。这个时候发送方的IP层就需要分片，吧数据包分成若干片，每一片都小于MTU。而接收方IP层则需要数据包的重组。由于UDP的特性，当某一片数据丢失时，接收方无法重组数据包，导致丢弃整个UDP数据包。
流量控制：当接收方来不及处理发送方的数据时，能通过滑动窗口，提示发送方降低发送的速率，防止包丢失。
拥塞控制：当网络拥塞时，通过拥塞窗口，减少数据的发送，防止包丢失。

总结二：

可靠传输：对于收到的请求，给出确认响应
超时重传
流量控制：让发送方的发送速率不要太快，要让接收方来得及接受。利用滑动窗口实现流量控制
拥塞控制：防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不至过载
慢开始：TCP开始发送报文段时先设置拥塞窗口为1
拥塞避免：使拥塞窗口按线性规律增长
快重传：发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待为其设置的重传计时器到期
快恢复(与快重传配合使用)：当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把慢开始门限减半。这是为了预防网络发生拥塞。请注意，接下来不执行慢开始算法。
由于发送方现在认为网络很可能没有发生拥塞(如果网络发生了严重的拥塞，就不会一连有好几个报文段连续达到接收方，就不会导致接收方连续发送重复确认)，因此与慢开始不同之处是现在不执行慢开始算法(即拥塞窗口现在不设置为1)，而是把它设置为慢开始门限减半后的数值，然后开始执行拥塞避免算法(“加法增大”)，使拥塞窗口缓慢地线性增长。

 长连接与短连接
 HTTP协议和TCP协议
HTTP的长连接和短连接本质上是TCP长连接和短连接。HTTP属于应用层协议，在传输层使用TCP协议，在网络层使用IP协议。IP协议主要解决网络路由和寻址问题，TCP协议主要解决如何在IP层之上可靠的传输数据包，使在网络上的另一端收到发端发出的所有包，并且顺序与发出顺序一致。TCP有可靠，面向连接的特点。
 HTTP协议的长连接和短连接
在HTTP/1.0中，默认使用的是短连接。也就是说，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。如果客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源，如JavaScript文件、图像文件、CSS文件等；当浏览器没遇到这样一个Web资源，就会建立一个HTTP会话。
但从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入如下代码：Connection:keep-alive。在使用长连接的情况下，当一个网页打开完成之后，客户端和服务端之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器的网页，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个事件。实现长连接要客户端和服务端都支持长连接。
HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。
 TCP长连接和短连接
我们模拟一下TCP短连接的情况，client向server发起连接请求，server接到请求，然后双方建立链接。client向server发送消息，server回应client，然后一次读写就完成了，这时候双方任何一个都可以发起close操作，不过一般都是client先发起close操作。为什么呢，一般的server不会回复完client后立即关闭连接的，当然不排除有特殊的情况。从上面的描述看，短连接一般只会在 client/server间传递一次读写操作。
短连接的优点：管理起来比较方便，存在的连接都是有用的连接，不需要额外的控制手段。
我们再模拟一下长连接的情况，client向server发起连接，server接受client连接，双方建立连接。client与server完成一次读写之后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个链接。
首先说一下TCP/IP详解上讲到的TCP保活功能，保活功能主要为服务器应用提供，服务器应用希望知道客户主机是否崩溃，从而可以代表客户使用资源。如果客户已经消失，使得服务器上保留一个半开放的连接，而服务器又在等待来自客户端的数据，则服务器将应远等待客户端的数据，保活功能就是试图在服务器端检测到这种半开放的连接。
 长连接和短连接的生命周期
短连接在建立连接后，完成一次读写就会自动关闭了。
正常情况下，一条TCP长连接建立后，只要双方不提出关闭请求并且不出现异常情况，这条连接是一直存在的，操作系统不会自动去关闭它，甚至经过物理网络拓扑的改变之后仍然可以使用。所以一条连接保持几天、几个月、几年或者更长时间都有可能，只要不出现异常情况或由用户（应用层）主动关闭。
在编程中，往往需要建立一条TCP连接，并且长时间处于连接状态。所谓的TCP长连接并没有确切的时间限制，而是说这条连接需要的时间比较长。
 怎样维护长连接或者检查中断


在应用层使用heartbeat来主动监测
对于实时性要求较高的网络通信程序，往往需要更加及时的获取已经中断的连接，从而进行及时的处理。但如果对方的连接异常中断，往往是不能及时的得到对方连接已经中断的信息，操作系统检测连接是否中断的时间间隔默认是比较长的，即便它能够检测到，但却不符合我们的实时性需求，所以需要我们进行手工去不断探测。


改变socket的keepalive选项，以使socket检查连接是否中断的时间间隔更小，以满足我们的及时性需求。有关的几个选项使用和解析如下：


我们在检测对端以一种非优雅的方式断开连接的时候，可以设置SO_KEEPALIVE属性使得我们在2小时以后发现对方的TCP连接是否依然存在。用法如下:
 12keepAlive &#x3D; 1；setsockopt(listenfd, SOL_SOCKET, SO_KEEPALIVE, (void*)&amp;keepAlive, sizeof(keepAlive));


如果我们不想使用这么长的等待时间，可以修改内核关于网络方面的配置参数，也可设置SOCKET的TCP层（SOL_TCP）选项TCP_KEEPIDLE、TCP_KEEPINTVL和TCP_KEEPCNT。
 123TCP_KEEPIDLE：开始首次KeepAlive探测前的TCP空闭时间TCP_KEEPINTVL：两次KeepAlive探测间的时间间隔TCP_KEEPCNT：断开前的KeepAlive探测次数
如果心搏函数要维护客户端的存活，即服务器必须每隔一段时间必须向客户段发送一定的数据，那么使用SO_KEEPALIVE是有很大的不足的。因为SO_KEEPALIVE选项指&quot;此套接口的任一方向都没有数据交换&quot;。在Linux2.6系列上，上面话的理解是只要打开SO_KEEPALIVE选项的套接口端检测到数据发送或者数据接受就认为是数据交换。因此在这种情况下使用 SO_KEEPALIVE选项。
检测对方是否非正常连接是完全没有作用的，在每隔一段时间发包的情况， keep-alive的包是不可能被发送的。上层程序在非正常断开的情况下是可以正常发送包到缓冲区的。非正常端开的情况是指服务器没有收到&quot;FIN&quot; 或者 &quot;RST&quot;包。




</div><a class="more" href="/network-summary/#more" style="margin-top: 14px">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/java-summary/">Java总结</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-09-02</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/">基础知识总结</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/Java/">Java</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Java/">Java</a></span><div class="content"> Java的四个特性（抽象、封装、继承、多态），对多态的理解（多态的实现方式）


抽象：抽象是将一类对象的共同特征总结出来构造类的过程。包括数据抽象和行为抽象两个方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。


继承：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类），继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段。


封装：通常认为封装是将数据与操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法是对实现细节的一种封装；我们编写的一个类就是对数据和数据操作的封装。封装就是隐藏一切可隐藏的东西，只向外提供简单的编程接口。


多态

方法重载（overload）实现的是编译时的多态性（也成为前向绑定）
方法重写（overwrite）实现的是运行时的多态性（也成为后向绑定）
多态的实现方式：方法重写，子类继承父类并重写父类中已有的或抽象的方法；对象构造，用父类型引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为
举例：有两种客户：订购客户和卖方客户，两个客户都可以登录系统，他们有相同的方法login，但登录之后他们会进入不同的页面，也就是在登录后有不同的操作行为。两种客户都继承父类的Login方法，但对于不同的对象，拥有不同的操作。



 面向对象和面向过程的区别？


面向过程就像是一个细心的管家，事无具细的都要考虑到。而面向对象就像是一个家用电器，你只需要知道他的功能，不需要知道他的工作原理


面向过程是一种以时间为中心的编程思想，就是分析出解决问题所需的步骤，然后用函数把这些步骤实现，并按顺序调用。面向对象是以“对象”为中心的编程思想


举例：汽车发送、汽车到站

对于面向过程来说，这是两个事件，面向过程编程我们关心的是事件，而不是汽车本身。针对上述过程，形成两个函数，依次调用
对于面向对象来说，我们关心的是汽车这类对象，两个事件只是这类对象所具有的行为。而且对于这两个行为没有顺序要求



 重载与重写


重载：重载发生在同一个类中，同名的方法如果有不同的参数列表（参数类型、参数个数或者两者都不同）则视为重载


重写：重写发生在子类与父类之间，重写要求子类重写方法与父类被重写方法具有相同的返回参数，比父类方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则），根据不同的子类对象确定调用哪个对象


 面向对象开发的六个基本准则（单一职责、开放封闭、里氏替换、依赖倒置、合成聚合复用、接口隔离），迪米特法则


单一职责：一个类只能它该做的事情（高内聚），在面向对象中，如果只让一个类完成它该做的事，而不涉及与它无关的领域就是践行了高内聚的原则，这个类就是单一职责


开放封闭：软件实体应当对扩展开放，对修改关闭。要做到开闭有两点：抽象是关键，一个系统如果没有抽象类或者接口系统就没有扩展点；封装可变性，将系统中可变因素封装在一个继承结构中，如果多个可变因素混杂在一起，系统将复杂而混乱


里氏替换：任何时候都可以用子类替换父类，子类一定是增加了父类的能力而不是减少，因为子类比父类的能力更多，把能力多的对象当成能力少的对象来用没有问题


依赖倒置：面向接口编程（声明方法的参数类型、方法返回类型，变量的引用类型要尽量使用抽象类型而不是具体类型，因为抽象类型可以被其子类型所替代）


合成聚合复用：优先使用聚合或合成关系复用代码


接口隔离：接口不要大而全，要小而专，一个接口只应该描述一种能力，接口也应该是高内聚的


迪米特法则：又称为最少知识原则，一个对象应当对其他对象有尽可能少的了解
 static与final的区别
static：

修饰变量：静态变量随着类加载时完成初始化，内存中只有一个，且JVM只会为它分配一次内存，所有类共享静态变量
修饰方法：在类加载的时候就存在，不依赖任何实例；static方法必须实现，不能用abstract修饰
修饰代码块：在类加载完成后就会执行代码块中的内容
父类静态代码块-&gt;子类静态代码块-&gt;父类非静态代码块-&gt;父类构造方法-&gt;子类非静态代码块-&gt;子类构造方法

final：

修饰变量

编译期常量：类加载的过程完成初始化，编译后带入到任何计算式中，只能是基本类型
运行时常量：基本数据类型或引用数据类型，引用不可变，但引用的对象内容可变


修饰方法：不能被继承，不能被子类修改
修饰类：不能被继承
修饰新参：final形参不可变

 HashMap和Hashtable的区别，HashMap中的key可以是任何对象或数据类型吗？
区别：

Hashtable的方法是同步的，HashMap未经同步，所以在多线程环境下要手动同步HashMap，这个区别就相当于Vector和ArrayList
Hashtable不允许使用null（key和value都不可以），HashMap允许null值（key只能有一个null值，value没有限制）
两者的遍历方式大同小异，Hashtable仅仅比HashMap多一个elements方法
Hashtable和HashMap都能通过values()方法返回一个Collection，然后遍历
两者也都可以通过entrySet()返回一个Set，然后遍历
Hashtable使用Enumeration，HashMap使用Iterator
哈希值计算方法不同，hashtable直接使用对象的hashCode，hashMap重新计算hash值，而且用于代替求模
Hashtable的hash数组大小是11，增加方式是old*2+1，hashMap的默认大小是16，而且一定是2的指数
hashtable是基于Dictionary，hashMap是基于AbstractMap类

HashMap的key可以为null，但不可以为可变对象。如果是可变对象时，对象的属性改变，则对象的hashCode也进行了相应的改变，导致下次无法查找到已存在Map的数据。
如果可变对象被用作HashMap的键时，在改变对象的状态时，不要再改变其哈希值，我们只需要保证成员变量的改变能保证该对象的哈希值不变即可。
hashtable是线程安全的，其实是在对应的方法添加了synchronized关键字进行修饰，由于在执行此方法的时候需要获得对象锁，则执行起来比较慢。所以可以使用concurrentHashMap
 HashMap与concurrentHashMap


区别



concurrentHashMap线程安全吗，如何保证线程安全？


hashtable容器在竞争激烈的并发环境下表现出效率低下的原因是所有访问hashtable的线程都必须竞争同一把锁，当容器中有多把锁时，每一把锁用于锁住容器中的一部分数据，那么当多线程访问容器内不同数据段的数据时，线程间不会存在锁竞争，从而提高了并发访问的效率，这也是concurrentHashMap采用的锁分段技术，当一个线程访问其中一个段的数据时，其他段的数据也能被其他线程所访问


get的高效之处：get过程不需要加锁，除非读到的值是空的才需要加锁重读



put方法首先定位到segment，然后在segment里进行插入操作





 String、StringBuffer、StringBuilder


 String重写了Object的hashCode和toString，重写equals()不重写hashCode()有什么问题？


当equals方法被重写，通常需要重写hashCode方法，以保证两个相等的对象必须有相同的hashCode

object1.equals(object2)时为true，则object1.hashCode()==object2.hashCode()也为true
object1.hashCode()==object2.hashCode()为false，则 object1.equals(object2)一定为false
object1.hashCode()==object2.hashCode()为true，则object1.equals(object2)状态不确定



在存储散列集合(如Set)时，如果原对象.equals(新对象)，但如果没有对hashCode重写，即两个对象拥有不同的hashCode，则在集合中会存储两个值相同的对象，从而导致混淆。因此，重写equals方法时，必须重写hashCode方法


 Java序列化


定义：将那些实现了Serializable接口的对象转换成一个字节序列，并能够在以后将这个字节序列完全恢复到原来的对象，序列化可以弥补不同操作系统之间的差异


作用

Java远程方法调用
对JavaBeans进行序列化



序列化与反序列化



注意事项：

被static修饰的属性不会被序列化
对象的类名、属性都会被序列化，但是方法不会被序列化
要保证对象所在的类的属性可以被序列化
当通过网络、文件进行序列化时，必须按照写入的顺序读取对象
反序列化时必须有序列化对象时的class文件
最好显示的声明serializableID，因为在不同的JVM时，默认生成的serializableID不同，可能导致反序列化失败

 多线程

线程安全

定义：某个类的行为与其规范一致；不管多个线程是怎样的执行顺序和优先级，或是wait、sleep、join等，如果一个类在多线程访问下都正常，并且不需要额外的同步处理和协调，那么这就是线程安全。
如何保证线程安全：对变量使用volitate；对程序段进行加锁（synchronized、lock）
注意：非线程安全的集合可以在多线程中使用，但是不能用作多个线程共享的属性，只能作为某个线程独享的属性


 线程池
定义：实现先创建若干个可执行的线程放入一个容器（池）中，当需要的时候，不用自行创建只需要从容器中获取，使用完毕后不需要销毁而是放入到容器中，从而减少创建和销毁线程对象的开销。
设计线程池

 volatile关键字与synchronized的区别

 sleep()与wait()

sleep是Thread类的方法
wait是Object类的方法
区别：

sleep()方法（休眠）是线程类（Thread）的静态方法，调用此方法会让当前线程暂停执行指定的时间，将执行机会（CPU）让给其他线程，但是对象的锁依然保持，因此休眠时间结束后会自动恢复（线程回到就绪状态）
wait()是object类的方法，调用对象的wait()方法导致当前线程放弃对象的锁（线程暂停执行），进入对象的等待池（wait pool），只有调用对象的notify()方法（或notifyAll()方法）时才能唤醒等待池中的线程进入等锁池（lock pool），如果线程重新获得对象的锁就可以进入就绪状态



 synchronized与lock

synchronized与static synchronized的区别：

synchronized是对类的当前实例进行加锁，防止其他线程同时访问该类的该实例的所有synchronized锁，同一个类的不同实例之间没有这种约束
static synchronized是控制类的所有实例的访问，限制线程同时访问JVM中该类的所有实例同时访问对应的代码块

 异常

Throwable是Java语言中所有错误和异常的超类，它有两个子类：Error和Exception
异常种类

Error：错误，是程序无法处理的，如OutOfMemeryError、ThreadDeath等，这种情况下交由JVM处理，一般会选择终止线程
Exception：程序可以处理的异常，它又分为CheckedException（受检异常）和UnCheckedException（不受检异常）

CheckedException：发生在编译阶段，必须使用try...catch...或者throws，否则编译不通过。
UnCheckedException：发生在运行期，一般由程序的逻辑问题引起。





 Java中的NIO、BIO、AIO分别是什么？


BIO

同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情就会造成不必要的线程开销，可以通过线程池机制来改善
BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中



NIO

同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时，才启动一个线程进行处理
NIO方式适用于连接数多且连接比较短的架构，比如聊天服务器，并发局限于应用中



AIO

异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理
AIO方式适用于连接数目多且连接比较长的架构，比如相册服务器，充分调用OS参与并发操作



 Java内存模型（Java Memory model，JMM）
对于并发编程，有两个关键问题：线程之间的通信和同步
 线程之间的通信
线程的通信是指线程之间以何种机制来交换信息。在命令式编程中，线程之间的通信机制有两种共享内存和消息传递。
典型的共享内存通信方式就是通过共享对象来进行通信。典型的消息传递方式就是wait()和notify()。
 线程之间的同步
同步是指程序用于控制不同线程之间操作发生相对顺序的机制。
在共享内存并发模型里，同步是显式进行的。程序必须显式指定某个方法或某段代码需要在线程之间互斥执行。
在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。
 Java的并发采用的是共享内存模型
JMM决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来讲，JMM定义了线程和主内存之间的抽象关系：**线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，本地内存中存储了该线程以读/写共享变量的副本。**本地内存是JMM的一个抽象概念，并不真实存在。
线程之间的通信方式：首先，线程A把本地内存A中更新过的共享变量刷新到主内存中。然后，线程B到主内存中去读取线程A之前已更新过的共享变量。
从整体来看，这两个步骤实质上是线程A在向线程B发送消息，而且这个通信过程必须要经过主内存。JMM通过控制主内存与每个线程的本地内存之间的交互，来为Java程序员提供内存可见性保证。
 JVM对Java内存模型的实现
在JVM内部，Java内存模型把内存分成了两个部分：线程栈区和堆区。下图展示了Java内存模型在JVM中的逻辑视图：

JVM中运行的每个线程都拥有自己的线程栈，线程栈包括了当前线程执行的方法调用相关信息，我们也把它称作调用栈。随着代码的执行，调用栈会不断的变化。
线程栈还包含了当前方法的所有本地变量信息。一个线程只能读取自己的线程栈，也就是说，**线程中的本地变量对其他线程是不可见的。**即使两个线程执行的是同一段代码，它们也会各自在自己的线程栈创建本地变量，因此，每个线程中的本地变量都有自己的版本。
所有原始类型（boolean、byte、short、int、long、char、float、double）的本地变量都直接保存在线程栈中，对于它们的值各个线程都相互独立。对于原始类型的本地变量，一个线程可以传递一个副本给另一个线程，当它们之间是无法共享的。
堆区包含了Java应用创建的所有对象信息，不管对象是哪个线程创建的，其中的对象包括原始类型的封装类（如Byte、Integer、Long等）。不管对象是属于一个成员变量还是方法中的本地变量，它都会被存储在堆区。

一个本地变量如果是原始类型，那么它会被完全存储到栈区。
一个本地变量也有可能是一个对象的引用，这种情况下，这个本地引用会被存储到栈中，但是对象本身仍然存储在堆区。
对于一个对象的成员方法，这些方法中包含本地变量，仍需要存储在栈区，即使它们所属的对象在堆区。
对于一个对象的成员变量，不管它是原始类型还是包装类型，都会被存储到堆区。
Static类型的变量以及类本身相关信息都会随着类本身存储在堆区。

堆中的对象可以被多线程共享。如果一个线程获得一个对象的应用，它便可访问这个对象的成员变量。如果两个线程同时调用了同一个对象的同一个方法，那么这两个线程便可同时访问这个对象的成员变量，但是对于本地变量，每个线程都会拷贝一份到自己的线程栈中。
下图是上面的全部过程：

 共享对象的可见性与竞争现象
volatile关键字可以保证变量会直接从主存读取，而对变量的更新也会直接写到主存。volatile原理是基于CPU内存屏障指令实现的。
synchronized代码块可以保证同一个时刻只能有一个线程进入代码竞争区，synchronized代码块也能保证代码块中所有变量都将会从主存中读，当线程退出代码块时，对所有变量的更新将会flush到主存，不管这些变量是不是volatile类型的。
 volatile和synchronized的区别
首先理解线程安全的两个方面：执行控制和内存可见。
执行控制的目的是控制代码执行顺序及是否可以并发执行。
内存可见指的是线程执行结果在内存中对其他线程的可见性。根据Java内存模型的实现，线程在具体执行时，会先拷贝主存数据到线程本地（CPU缓存），操作完成后再把结果从线程本地刷到主存。
synchronized关键字解决的是执行控制的问题，它会阻止其他线程获得当前对象的监控锁，这样使得当前被synchronized修饰的代码块无法被其他线程访问，也就无法并发执行。更为重要的是，synchronized还会创建内存屏障，内存屏障指令保证了所有CPU操作结果都会刷新到主存中，从而保证了内存可见性，同时也使得先获得这个锁的线程都happens-before与随后获得这个锁的线程。
volatile关键字解决的是内存可见的问题，该关键字会使得被修饰的变量读写都会直接刷新到主存中，这样就保证了内存可见。该种方式可以保证内存可见性但是对读取没有要求的需求中。

使用volatile仅能实现对原始变量（如short、boolean、int等）操作的原子性，但是不能保证复合操作的原子性。例如，对于i++，实际上是由多个原子操作组成，如果使用多个线程去操作i++，则只能保证他们所操作的变量i在同一块内存区域，但是存在写入脏数据的情况。

使用volatile关键字要满足以下条件：

对变量的写入操作不依赖与变量的当前值，或者可以确保只有单个线程在操作变量
该变量没有包含在具有其他变量的不变式中

总结如下：

 Java内存模型的基础原理

指令重排序：
为了提高程序的执行性能，编译器和处理器都会对指令进行重排序，但是JMM确保在不同的编译器和处理器平台下，通过插入指定类型的内存屏障来禁止编译器重排序和处理器重排序，为上层提供一致的内存可见性保证。



数据依赖性：
如果两个操作在访问同一个变量，且这两个操作有一个是写操作，此时两个操作之间存在数据依赖性。

编译器重排序和处理器重排序不会改变数据依赖性关系的两个操作之间的执行顺序，即不会重排序。
注意：
这里所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器和线程间之间的数据依赖性不被编译器和处理器所考虑。

as-if-serial*
不过怎么重排序，单线程下的执行结果不能改变，编译器、runtime（运行时）和处理器都必须遵守as-if-serial语义

 内存屏障（Memory Barrier）

volatile内存语义的实现：

对于volatile关键字，JMM采用保守策略
 happens-before策略

注意：
两个操作之间具有happens-before关系，并不意味前一个操作必须要在后一个操作之前执行！仅仅要求前一个操作的执行结果，对于后一个操作是可见的，且前一个操作按顺序排在后一个操作之前。
 解决hash冲突的几种方法
 开放地址法


线性探测法：ThreadLocalMap
插入元素时，如果发生冲突，算法会简单的从该槽位置向后循环遍历hash表，直到找到表中的下一个空槽，并将该元素放入该槽中（会导致相同hash值的元素挨在一起和其他hash值对应的槽被占用）。 查找元素时，首先散列值所指向的槽，如果没有找到匹配，则继续从该槽遍历hash表，直到：（1）找到相应的元素；（2）找到一个空槽，指示查找的元素不存在，（所以不能随便删除元素）；（3）整个hash表遍历完毕（指示该元素不存在并且hash表是满的）
用线性探测法处理冲突，思路清晰，算法简单，但存在下列缺点：
① 处理溢出需另编程序。一般可另外设立一个溢出表，专门用来存放上述哈希表中放不下的记录。此溢出表最简单的结构是顺序表，查找方法可用顺序查找。
② 按上述算法建立起来的哈希表，删除工作非常困难。如果将此元素删除，查找的时会发现空槽，则会认为要找的元素不存在。只能标上已被删除的标记，否则，将会影响以后的查找。
③ 线性探测法很容易产生堆聚现象。所谓堆聚现象，就是存入哈希表的记录在表中连成一片。按照线性探测法处理冲突，如果生成哈希地址的连续序列愈长 ( 即不同关键字值的哈希地址相邻在一起愈长 ) ，则当新的记录加入该表时，与这个序列发生冲突的可能性愈大。因此，哈希地址的较长连续序列比较短连续序列生长得快，这就意味着，一旦出现堆聚 ( 伴随着冲突 ) ，就将引起进一步的堆聚。


线程补偿探测法
线性补偿探测法的基本思想是：将线性探测的步长从 1 改为 Q ，即将上述算法中的
hash ＝ (hash ＋ 1) % m 改为：hash ＝ (hash ＋ Q) % m = hash % m + Q % m，**而且要求 Q 与 m 是互质的，**以便能探测到哈希表中的所有单元。


伪随机探测
随机探测的基本思想是：将线性探测的步长从常数改为随机数，即令： hash ＝ (hash ＋ RN) % m ，其中 RN 是一个随机数。在实际程序中应预先用随机数发生器产生一个随机序列，将此序列作为依次探测的步长。这样就能使不同的关键字具有不同的探测次序，从而可以避 免或减少堆聚。基于与线性探测法相同的理由，在线性补偿探测法和随机探测法中，删除一个记录后也要打上删除标记。


 拉链法
HashMap
拉链法的优点
与开放定址法相比，拉链法有如下几个优点：
①拉链法处理冲突简单，且无堆积现象，即非同义词决不会发生冲突，因此平均查找长度较短；
②由于拉链法中各链表上的结点空间是动态申请的，故它更适合于造表前无法确定表长的情况；
③开放定址法为减少冲突，要求装填因子α较小，故当结点规模较大时会浪费很多空间。而拉链法中可取α≥1，且结点较大时，拉链法中增加的指针域可忽略不计，因此节省空间；
④在用拉链法构造的散列表中，删除结点的操作易于实现。只要简单地删去链表上相应的结点即可。
拉链法的缺点
　拉链法的缺点是：指针需要额外的空间，故当结点规模较小时，开放定址法较为节省空间，而若将节省的指针空间用来扩大散列表的规模，可使装填因子变小，这又减少了开放定址法中的冲突，从而提高平均查找速度。
 再散列（双重散列、多重散列）
当发生冲突时，使用第二个、第三个、哈希函数计算地址，直到无冲突时。缺点：计算时间增加。
 建立一个公共溢出区
假设哈希函数的值域为[0,m-1],则设向量HashTable[0…m-1]为基本表，另外设立存储空间向量OverTable[0…v]用以存储发生冲突的记录。
</div><a class="more" href="/java-summary/#more" style="margin-top: 14px">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/view-for-internet/">关于互联网行业的一些看法（摘抄）</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-09-01</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E9%9A%8F%E7%AC%94/">随笔</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E9%9A%8F%E7%AC%94/">随笔</a></span><div class="content"> 这是最坏的时代，也是最好的时代
 字节跳动
今日头条打造“千人千面”的客户端，撕开了四大门户的壁垒；抖音利用年轻人的内心，结合其强大的内容分发机制，占据了原本属于微信的用户使用时间，使得腾讯不得不做出调整，也让新浪微博产生了一丝恐惧，而且自有的推荐算法也让其广告业务迅速盈利，使得百度在其原有的凤巢基础上成立新部门以应对头条的威胁。
 滴滴
背靠腾讯以及阿里这两个大金主，将Uber赶出中国市场，打造了中国最大的出行平台。
 美团
作为全球绝无仅有的独特理念，打造了全球最大的餐饮外卖服务提供商，并大手笔收购摩拜，解决了当下人们的“最后一公里”问题。
 拼多多
原本以为京东和淘宝已经形成了无人撼动的地位，但是拼多多利用“社交+电商”的模式，利用腾讯提供的优势，作成了多年来腾讯一直想实现的“电商梦”，困扰京东淘宝多年的用户下沉问题也随之解决。
</div><a class="more" href="/view-for-internet/#more" style="margin-top: 14px">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/database-summary/">数据库总结</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-08-28</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/">基础知识总结</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></span><div class="content"> 事务四大特性（ACID）
数据库事务是指作为单个逻辑工作单元执行的一系列操作，这些操作要么全做要么全不做，是一个不可分割的工作单位。

原子性(Atomicity)
事务的原子性是指，事务中包含的程序作为数据库的逻辑工作单位，它所做的对数据的修改操作要么全部执行，要么完全不执行。这种特性称为原子性。
一致性(Consistency)
事务一致性指的是在一个事务执行之前和执行之后数据库都必须处于一致性状态。这种特性称为事务的一致性。假如数据库的状态满足所有的完整性约束，就说该数据库是一致的。例如完整性约束：a + b = 10，一个事物改变了a，那么b也随之改变。
分离性(也称为独立性，lsolation)
分离性指并发的事务是相互隔离的。即一个事物内部的操作及正在操作的数据必须封锁起来，不被其他企图进行修改的事务看到。假如并发交叉执行的事务没有任何限制，操纵相关的共享对象的多个并发事务的执行可能引起异常。
持久性(Durability)
持久性意味着当系统或介质发生故障时，确保已提交事务的更新不能丢失。即一旦一个事务提交，DBMS保证它对数据库中数据的改变应该是永久性的，即对已提交事务的更新能恢复。持久性通过数据库备份和恢复来保证。

 事务隔离性以及在MySQL中的实践
数据库事务是指作为单个逻辑工作单元执行的一系列操作，要么全部执行，要么全部不执行。一方面，当多个应用程序并发访问数据库时，事务可以在应用程序间提供一个隔离方法，防止互相干扰；另一方面，事务为数据库操作序列提供了一个从失败恢复正常的方法。
当多个线程都开启事务操作数据库中的数据时，数据库系统要能进行隔离操作，以保证各个线程获取数据的准确性。


如果没有隔离，会发生以下情况

脏读：对于两个事务T1、T2，T1读取了已经被T2更新但还没有提交的字段，之后，若T2回滚，T1读取到的内容就是临时无效的内容。
不可重复读：对于事务T1、T2，T1需要读取一个字段两次，在第一次和第二次读取之间，T2更新了该字段，导致T1第二次读取到的内容值不同。
幻读：事务A读取与搜索条件相匹配的若干行。事务B以插入或删除行等方式来修改事务A的结果集，然后再提交。幻读与不可重复读之间的区别是幻读强调的是新增或删除，而不可重复读强调的是修改。比如Mary两次查工资，中间有人改过工资，则两次结果不一样，这就是不可重复读。Mary要查工资一千的人数，第一次查到了10个，中间有人增加了一条工资为一千的人，下次查的时候就变成了11个，好像第一次查询的是幻觉一样。



事务的四个隔离级别
读未提交、读已提交、可重复读、串行化。四个级别增强逐渐增强，每个级别解决上个级别的一个问题。

读未提交：另一个事务修改了数据，但尚未提交，而本事务中的select会读到这些未被提交的数据（脏读）。脏读是指另一个事务修改了数据，但尚未提交，而本事务中的select会读到这些未被提交的数据
读已提交：本事务读取到的是最新的数据（其他事务提交后）。问题是，在同一事务里，前后两次相同的select会读到不同的结果（不可重复读）。不可重复读是指同一个事务执行过程中，另外一个事务提交了新数据，因此本事务先后两次读到的数据结果会不一致。
可重复读：在同一个事务里，select的结果是事务开始时间点的状态，同样的select操作读到的结果会是一致的，但是有幻读现象。可重复读保证了同一个事务里，查询的结果都是事务开始时的状态（一致性）。但是，如果另一个事务同时提交了新数据，本事务再更新时，就会发现了这些新数据，貌似之前读到的数据都是幻觉，这就是幻读。
串行化：所有事务只能一个接一个串行执行，不能并行



隔离级别的选择
MySQL支持四种隔离级别，默认的是可重复读
 MYSQL的两种存储引擎区别

MyISAM类型不支持事务处理等高级处理，而InnoDB类型支持
MyISAM表不支持外键，InnoDB支持
MyISAM锁的粒度是表级，而InnoDB支持行级锁定
MyISAM相对简单，所以在效率上要优于InnoDB，小型应用可以考虑使用MyISAM，当你的数据库有大量的写入、更新操作而查询比较少或者数据完整性要求比较高的时候就选择Innodb表。当你的数据库主要以查询为主，相比较而言更新和写入比较少，并且业务方面数据完整性要求不那么严格，就选择mysiam表。

应用场景：

MyIASM管理非事务表，提供高速存储和检索以及全文搜索能力，如果在应用中执行大量的select操作，应该选择MyIASM
InnoDB用于事务处理，具有ACID事务支持等特性，如果在应用中执行大量的insert和update操作，应该选择InnoDB

 数据库的优化（从sql语句优化和索引两个部分回答）


只返回需要的数据

不要写select * 的语句
合理写where子句，不要写没有where的SQL语句



尽量少做重复的工作

可以合并一些SQL语句



适当建立索引（不是越多越好）但以下几点会进行全表扫描

左模糊查询‘%…’
使用了不等操作符!=
or使用不当，or两边都必须有索引才行
in、not in
where子句对字段进行表达式操作
对于创建的复合索引（从最左边开始组合），查询条件用到的列必须从左边开始不能间隔。否则无效，复合索引的结构与电话簿类似
全文索引：当对于文件建立了一个以词库为目录的索引（文件大全文索引比模糊匹配效果好）



使用join代替子查询


使用union代替手动创建临时表


 乐观锁与悲观锁
当并发事务同时访问一个资源时，有可能导致数据不一致，因此需要一种机制来将数据访问顺序化，以保证数据库数据的一致性。锁就是其中一种机制。在计算机科学中，锁时在执行多线程时用于强行限制资源访问的同步机制，即用于在并发控制保证对互斥要求的满足。在数据库的锁机制中，数据库管理系统中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。
乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。
悲观锁是一种并发控制的方法。它可以阻止一个事务以影响其他用户的方式来修改数据。如果一个事务执行的操作对某行数据应用了锁，那只有当这个事务把锁释放，其他事务才能够执行与该锁冲突的操作。主要用于数据争用激烈的环境，以及发生冲突时使用锁保护数据的成本要低于该锁冲突的操作。
悲观锁的流程：在对任意记录进行修改前，先尝试为该记录加上排他锁；如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁。期间有任何对该记录做修改或加排他锁的操作，都会等待我们解锁或者直接抛出异常。
悲观锁的缺点：悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；另外，在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载；还有会降低了并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数据。
乐观锁，它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各种影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，在没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。
相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是记录数据版本。实现数据版本有两种方式，第一种是使用版本号，第二种是使用时间戳。
乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。但如果直接简单这么做，还是有可能会遇到不可预期的结果，例如两个事务都读取了数据库的某一行，经过修改以后写回数据库，这时就遇到了问题。
 关系型数据库和非关系型数据库区别
一般非关系数据库是基于CAP模型，而传统的关系型数据库是基于ACID模型的

数据存储结构
首先关系型数据库一般都有固定的表结构，并且需要通过DDL语句来修改表结构，不是很容易进行扩展，而非关系数据库的存储机制就有很多了，比如基于文档的、K-V键值对的，还有基于图的等，对于数据的格式十分灵活没有固定的表结构，方便扩展，因此如果业务的数据结构并不是固定的或者经常变动比较大的，那么非关系数据库是个好的选择。
可扩展性
传统的关系型数据库给人一种横向扩展难，不好对数据进行分片等，而一些非关系型数据库则原生就支持数据的水平扩展，并且这可能也是很多NoSQL的一大卖点，其实像MySQL这种关系型数据库的水平扩展也不是很难，即使NoSQL水平扩展容易但对于向跨分片进行joins没有好的解决办法。不管是关系型还是非关系型数据库，解决水平扩展或者跨分片Joins这种场景，在应用层和数据库层中间加一层中间件来做数据处理也许是个好的办法。
数据一致性
非关系型数据库一般强调的是数据最终一致性，而没有像ACID一样强调数据的强一致性，从非关系型数据库中读到的有可能还是处于一个中间态的数据，因此如果你的业务对于数据的一致性要求很高，那么应该选择关系型数据库。非关系型数据库可能更多的偏向于OLAP场景，而关系型数据库更多偏向于OLTP场景。

博客SQL与NoSQL（关系型与非关系型）数据库的区别
 聚集索引与非聚集索引以及SQL的查询优化技术
聚集索引：聚集索引的顺序就是数据的物理存储顺序；
非聚集索引：索引顺序与数据物理排列顺序无关。
正因为如此，所以一个表最多只能有一个聚簇索引。简单来说，聚簇索引的叶子节点就是数据节点，非聚簇索引的叶节点仍然为索引节点，只不过有一个指针指向对应的数据块。
</div><a class="more" href="/database-summary/#more" style="margin-top: 14px">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/algorithm-sort/">排序算法</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-08-16</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/algorithm/">algorithm</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/algorithm/sort/">sort</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a></span><div class="content">123456789101112131415161718192021222324252627282930package Sort;/** * @Author: hta * @Date: 2018/03/26 * @Time: 22:03 * @Description: 冒泡排序 * o(n^2) */public class bubbleSort &#123;    public static void bubbleSort(int[] nums) &#123;        for (int i = 0; i &lt; nums.length - 1; i++) &#123;            for (int j = 0; j &lt; nums.length - i - 1; j++) &#123;                if (nums[j] &gt; nums[j + 1]) &#123;                    int tmp = nums[j];                    nums[j] = nums[j + 1];                    nums[j + 1] = tmp;                &#125;            &#125;        &#125;    &#125;    public static void main(String[] args) &#123;        int[] nums = &#123;3, 6, 2, 7, 9, 5&#125;;        bubbleSort(nums);        for (int num: nums) &#123;            System.out.print(num);        &#125;    &#125;&#125;
12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package Sort;/** * @Author: hta * @Date: 2018/03/26 * @Time: 21:31 * @Description: 堆排序 * o(nlogn) */// 先建立最大堆，然后排序public class heapSort &#123;    public static void main(String[] args) &#123;        int[] nums = &#123;3, 6, 2, 7, 9, 5&#125;;        int index = nums.length;        heapify(nums);        while (index &gt; 0) &#123;            int tmp = nums[index - 1];            nums[index - 1] = nums[0];            nums[0] = tmp;            index--;            helper(nums, index, 0);        &#125;        for (int num: nums) &#123;            System.out.print(num);        &#125;    &#125;    private static void heapify(int[] nums) &#123;        for (int i = (nums.length - 1) / 2; i &gt;= 0; i--) &#123;            helper(nums, nums.length, i);        &#125;    &#125;    private static void helper(int[] nums, int len, int k) &#123;        while (k &lt; len) &#123;            int largest = k;            if (k * 2 + 1 &lt; len &amp;&amp; nums[largest] &lt; nums[k * 2 + 1]) &#123;                largest = k * 2 + 1;            &#125;            if (k * 2 + 2 &lt; len &amp;&amp; nums[largest] &lt; nums[k * 2 + 2]) &#123;                largest = k * 2 + 2;            &#125;            if (k == largest) &#123;                break;            &#125;            int tmp = nums[largest];            nums[largest] = nums[k];            nums[k] = tmp;            k = largest;        &#125;    &#125;&#125;
12345678910111213141516171819202122232425262728293031323334package Sort;/** * @Author: hta * @Date: 2018/03/26 * @Time: 20:03 * @Description: 希尔排序 * o(n^1.5) */public class insertShell &#123;    public static void insertSort(int[] nums) &#123;        int n = nums.length;        int len = n / 2;        while (len &gt;= 1) &#123;            for (int i = 0; i &lt; n - len; i++) &#123;                for (int j = 0; j &lt;= i; j++) &#123;                    if (nums[j] &gt; nums[j + len]) &#123;                        int tmp = nums[j];                        nums[j] = nums[j + len];                        nums[j + len] = tmp;                    &#125;                &#125;            &#125;            len /= 2;        &#125;    &#125;    public static void main(String[] args) &#123;        int[] nums = &#123;3, 6, 2, 7, 9, 5&#125;;        insertSort(nums);        for (int num: nums) &#123;            System.out.print(num);        &#125;    &#125;&#125;
1234567891011121314151617181920212223242526272829package Sort;/** * @Author: hta * @Date: 2018/03/26 * @Time: 19:52 * @Description: 直接插入排序，当前位置与它前面的数字比较，看插入哪一个位置 * o(n^2) */public class insertSort &#123;    public static void insertSort(int[] nums) &#123;        for (int i = 1; i &lt; nums.length; i++) &#123;            for (int j = i - 1; j &gt;= 0; j--) &#123;                if (nums[j] &gt; nums[j + 1]) &#123;                    int tmp = nums[j];                    nums[j] = nums[j + 1];                    nums[j + 1] = tmp;                &#125;            &#125;        &#125;    &#125;    public static void main(String[] args) &#123;        int[] nums = &#123;3, 6, 2, 7, 9, 5&#125;;        insertSort(nums);        for (int num: nums) &#123;            System.out.print(num);        &#125;    &#125;&#125;
12345678910111213141516171819202122232425262728293031323334353637383940package Sort;/** * Created by hta on 17-5-5. */public class QuickSort &#123;    public static void main(String[] args) &#123;        int[] nums = &#123;3, 2, 1, 4, 5&#125;;        quickSort(nums, 0, nums.length - 1);        for (int num : nums) &#123;            System.out.println(num);        &#125;    &#125;    public static void quickSort(int[] nums, int start, int end) &#123;        if (start &gt;= end) &#123;            return;        &#125;        int left = start;        int right = end;        int pivot = nums[(start + end) / 2];        while (left &lt;= right) &#123;            while (left &lt;= right &amp;&amp; nums[left] &lt; pivot) &#123;                left++;            &#125;            while (left &lt;= right &amp;&amp; nums[right] &gt; pivot) &#123;                right--;            &#125;            if (left &lt;= right) &#123;                int temp = nums[left];                nums[left] = nums[right];                nums[right] = temp;                left++;                right--;            &#125;        &#125;        quickSort(nums, start, right);        quickSort(nums, left, end);    &#125;&#125;
12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package Sort;/** * author: hta * since: 上午10:45 17-5-6 * time: O(nlogn) * param: int[] nums, int[] temp, int start, int end * return: void */public class mergeSort &#123;    public static void main(String[] args) &#123;        int[] nums = &#123;2,3,1,55,6,4,7,3,0&#125;;        int[] temp = new int[nums.length];        mergeSort(nums, temp, 0, nums.length - 1);        for (int num : nums) &#123;            System.out.println(num);        &#125;    &#125;    public static void mergeSort(int[] nums, int[] temp, int start, int end) &#123;        if (start &gt;= end) &#123;            return;        &#125;        int left = start;        int right = end;        int mid = (start + end) / 2;        mergeSort(nums, temp, left, mid);        mergeSort(nums, temp, mid + 1, right);        merge(nums, temp, start, mid, end);    &#125;    public static void merge(int[] nums, int[] temp, int start, int mid, int end) &#123;        int leftIndex = start;        int rightIndex = mid + 1;        int index = start;        while (leftIndex &lt;= mid &amp;&amp; rightIndex &lt;= end) &#123;            if (nums[leftIndex] &lt;= nums[rightIndex]) &#123;                temp[index++] = nums[leftIndex++];            &#125; else &#123;                temp[index++] = nums[rightIndex++];            &#125;        &#125;        while (leftIndex &lt;= mid) &#123;            temp[index++] = nums[leftIndex++];        &#125;        while (rightIndex &lt;= end) &#123;            temp[index++] = nums[rightIndex++];        &#125;        for (int i = start; i &lt;= end; i++) &#123;            nums[i] = temp[i];        &#125;    &#125;&#125;
12345678910111213141516171819202122232425262728293031package Sort;/** * @Author: hta * @Date: 2018/03/26 * @Time: 20:59 * @Description: 简单选择排序 * o(n^2) */public class selectSort &#123;    public static void selectSort(int[] nums) &#123;        for (int i = 0; i &lt; nums.length; i++) &#123;            int min = nums[i];            for (int j = i + 1; j &lt; nums.length; j++) &#123;                if (nums[j] &lt; min) &#123;                    int tmp = nums[j];                    nums[j] = min;                    min = tmp;                &#125;            &#125;            nums[i] = min;        &#125;    &#125;    public static void main(String[] args) &#123;        int[] nums = &#123;3, 6, 2, 7, 9, 5&#125;;        selectSort(nums);        for (int num: nums) &#123;            System.out.print(num);        &#125;    &#125;&#125;
</div><a class="more" href="/algorithm-sort/#more" style="margin-top: 14px">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/system-summary/">操作系统总结</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-08-15</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/">基础知识总结</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></span><div class="content"> Linux内核空间和用户空间详解
 基础知识
Linux简化了分段机制，使得虚拟地址与线性地址总是一致，因此，Linux的虚拟地址空间也为0~4G。Linux内核将这4G字节的空间分为两部分。**将较高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为“内核空间”。而将较低的3G字节（从虚拟地址 0x00000000到0xBFFFFFFF），供各个进程使用，称为“用户空间”。**因为各个进程可以通过系统调用进入内核，因此，Linux内核是系统内的所有进程共享。于是，从具体进程的角度来看，每个进程可以拥有4G字节的虚拟空间。
**Linux使用两级保护机制：0级供内核使用，3级供用户程序使用。**每个进程有各自的私有用户空间（0~3G），这个空间对系统中的其他进程是不可见的。最高的1GB字节虚拟内核空间则为所有进程以及内核所共享。

内核空间中存放的是内核代码和数据，而进程的用户空间中存放的是用户程序的代码和数据。不管是内核空间还是用户空间，它们都处于虚拟空间中。

虽然内核空间占据了每个虚拟空间中的最高1GB字节，但映射到物理内存却总是从最低地址（0x00000000）开始。对内核空间来说，其地址映射是很简单的线性映射，0xC0000000就是物理地址与线性地址之间的位移量，在Linux代码中就叫做PAGE_OFFSET。
常见问题：

内核空间和用户空间之间如何进行通讯？
一般通过系统调用进行通信
如何判断一个驱动是用户模式还是内核模式驱动？判断的标志是什么？
用户空间模式的驱动一般通过系统调用来完成对硬件的访问，如通过系统调用将驱动的io空间映射到用户空间等。因此，主要的判断依据就是系统调用。

 内核态和用户态
当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）。此时处理器处于特权级最高的（0级）内核代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。当进程在执行用户自己的代码时，则称其处于用户运行态（用户态）。即此时处理器在特权级最低的（3级）用户代码中运行。当正在执行用户程序而突然被中断程序中断时，此时用户程序也可以象征性地称为处于进程的内核态。因为中断处理程序将使用当前进程的内核栈。这与处于内核态的进程的状态有些类似。
 进程上下文和中断上下文
处理器总处于以下状态中的一种：

内核态，运行于进程上下文，内核代表进程运行于内核空间；
内核态，运行于中断上下文，内核代表硬件运行于内核空间；
用户态，运行于用户空间。

用户空间的应用程序，通过系统调用，进入内核空间。这个时候用户空间的进程要传递很多变量、参数的值给内核，内核态运行的时候也要保存用户进程的一些寄存器值、变量等。所谓的“进程上下文”，可以看作是用户进程传递给内核的这些参数以及内核要保存的那一整套的变量和寄存器值和当时的环境等。
硬件通过触发信号，导致内核调用中断处理程序，进入内核空间。这个过程中，硬件的一些变量和参数也要传递给内核，内核通过这些参数进行中断处理。所谓的“中断上下文”，其实也可以看作就是硬件传递过来的这些参数和内核需要保存的一些其他环境（主要是当前被打断执行的进程环境）。
</div><a class="more" href="/system-summary/#more" style="margin-top: 14px">Read more</a><hr></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/public/blog.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2020 By Toyan</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script src="/js/search/local-search.js"></script><script id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zIndex="-1" data-click="false"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"superSample":2,"width":210,"height":420,"position":"left","hOffset":0,"vOffset":-20},"log":false,"tagMode":false});</script><script>'use strict';'serviceWorker'in navigator&&navigator.serviceWorker.register('service-worker.js').then(function(a){a.onupdatefound=function(){var b=a.installing;b.onstatechange=function(){switch(b.state){case'installed':navigator.serviceWorker.controller?console.log('New or updated content is available.'):console.log('Content is now available offline!');break;case'redundant':console.error('The installing service worker became redundant.');}}}}).catch(function(a){console.error('Error during service worker registration:',a)});
</script></body></html>