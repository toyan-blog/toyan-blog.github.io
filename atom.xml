<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ToyanのBlog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://toyan.top/"/>
  <updated>2021-07-26T14:18:16.637Z</updated>
  <id>https://toyan.top/</id>
  
  <author>
    <name>Toyan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>硅谷来信2-谷歌方法论</title>
    <link href="https://toyan.top/letter/"/>
    <id>https://toyan.top/letter/</id>
    <published>2021-02-23T14:55:12.000Z</published>
    <updated>2021-07-26T14:18:16.637Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第001封信-职业天花板来自认识的局限性"><a class="markdownIt-Anchor" href="#第001封信-职业天花板来自认识的局限性"></a> 第001封信 职业天花板来自认识的局限性</h2><p><strong>重点笔记</strong><br />很多人和企业缺失了一种信息时代的思维方式，我把它叫做计算机思维。这并不是说计算机有思维，而是因为这种思维方式是伴随着计算机出现的。<br />在后信息时代，或者即将进入的智能时代，所有人都要升级自己的思维方式，让自己的思维方式跟上这个时代。只有这样，才能不断突破职业发展的天花板。</p><p><strong>思考</strong><br />未来十年，世界上什么东西增长最快，或者世界上什么地方变化最快？<br />我认为是数据。随着5G的到来，人类将进入到万物互联的时代，万物都将成为有“生命”的物体，无时不刻地在生成着数据，而数据又会驱动着算法的进步。<br />未来一定是中美之间的竞争，变化最大的也是中美。美国掌握着除中国以外所有国家的数据，中国因为人口基数的缘故，也生成了大量的数据，因此考虑未来的技术和数据储备，也都存在于这两个国家。</p><h2 id="第002封信-思维方式决定商业模式"><a class="markdownIt-Anchor" href="#第002封信-思维方式决定商业模式"></a> 第002封信 思维方式决定商业模式</h2><p><strong>重点笔记</strong><br />我们生活在小数字世界，从小数字世界总结出来的方法论无法应用到更高量级的大数世界。<br />对于企业，提前把自己定义在大数世界里，才能建立更有竞争力的商业模式。<br />作为个人，必须升级思维模式，才能适应增长迅速的大数世界，成为新时代前2%的受益者。</p><p><strong>思考</strong><br />人其实对大数字是无感的，能否从人的这个局限性，思考一下如何做好报告？（以下摘抄自评论）</p><ul><li>善用图表，让听众视觉上有明显感觉</li><li>善用类比，来连接该数字与听众熟悉的认知</li><li>善用比例，来突显数字之间的关系</li></ul><ol><li><p>方法一：换算数字<br />有这样一组数字：每年有3万人自杀。相信你和我一样并没有什么特别的感觉，因我你平时接触最多的可能只有十几个人而已。你可以计算下每天有多少人自杀：<br />30000/365=82<br />82人还是太多，没关系，你可以继续换算每小时自杀的人数：<br />82/24=3.4<br />相比于“每年3万人”，你更容易理解“每小时3.4人”的含义。你还可以计算每过多长时间就有一个人自杀：<br />60/3.4=17<br />每17分钟有1个人自杀。</p></li><li><p>方法二：形象化<br />将数字形象化，乔布斯是当之无愧的大师。乔布斯在一次产品发布会上说，我们的集成电路上有5亿个晶体管，5亿个晶体管是什么概念呢？如果把每个晶体管看作一只蚂蚁，这些蚂蚁首尾相连，可以绕地球两圈。<br />绕地球两圈，听上去是不是很耳熟？没错，后来的香飘飘奶茶就用了乔布斯的这一招，它在广告词里说，一年卖出七亿多杯，杯子连起来可绕地球两圈。<br />还记得ipod的广告词吗？同样很形象：<br />把一千首歌装进口袋。当年乔布斯为了给ipod找一款体积更小、容量更大的硬盘，亲自带队飞到日本，去他们的供应商东芝那里做调研。东芝正好研制出了新产品，一种只有硬币大小的硬盘，而且容量达到了5G。<br />一首歌的大小大约5M左右，5G的硬盘可以装下1000首歌，于是那句经典的广告词诞生了：把一千首歌曲装进口袋。</p></li><li><p>方法三：整体缩放<br />对于单一数字，你可以先换算再将它形象化，对于多个数字该怎么办呢？<br />多个数字，主要是为了比较数字之间的关系，可以整体缩放，使之处于读者的认知范围内。<br />下面是宇宙年表，时间跨度长达百亿年，远远超出了人类的理解范围。<br />130亿年前：宇宙诞生。<br />46亿年前：太阳系形成。<br />6亿年前：最早的大型、多细胞生物出现。<br />6500万年前：恐龙灭绝。<br />25万年前：智人出现。<br />10万年前：智人迁徙到中东地区。<br />10000——5000年前：最后冰川期结束，农业出现。<br />200年前：工业革命。<br />百亿年太难理解，不如把10亿年缩小到1年，整体缩小后，我们得到如下数字：<br />13年前：宇宙诞生。<br />4.6年前：太阳系形成。<br />7个月前：最早的大型、多细胞生物出现。<br />3个星期前：恐龙灭绝。<br />2小时前：智人出现。<br />53分钟前：智人迁徙到中东地区。<br />5——2.5分钟前：最后冰川期结束，农业出现。<br />6秒前：工业革命。</p></li></ol><h2 id="第003封信-工程思维直觉和极限"><a class="markdownIt-Anchor" href="#第003封信-工程思维直觉和极限"></a> 第003封信 工程思维：直觉和极限</h2><p><strong>重点笔记</strong><br />直觉很容易误导人，掌握工程中的“极限”概念可以让我们突破认识的限制，比常人更快地看清楚问题的本质。所谓掌握工程思维的技巧，就是要比生活超越一个层次。这就如同你看蚂蚁的爬行轨迹时，不能跟在它的后面，而要从它的上方看。</p><p><strong>思考</strong><br />从极限这个工程思维出发，谈谈为什么一个国家的经济增长（扣除通货膨胀），不可能长期（一个世纪）维持在7%以上？<br />我们可以计算，中国大致持续了三十多年的高速增长，1.07<sup>(30)约等于7.6，即30年前经济总量的7.6倍，我们按照100年的高速增长，1.07</sup>(100)约等于867，倍数已经很恐怖了，说明到后来基本是成倍的增长，这个是完全不可能实现。</p><h2 id="第004封信-为什么计算机不是万能的"><a class="markdownIt-Anchor" href="#第004封信-为什么计算机不是万能的"></a> 第004封信 为什么计算机不是万能的</h2><p><strong>重点笔记</strong><br />1、图灵和常人思维方式的差别在于：图灵是先找到极限所在，然后在极限里寻找具体问题的答案，而不是浪费时间去做那些试图超越极限的事情；<br />2、图灵机是一个数学模型，今天所有的计算机，包括正在设计的新的计算机，从解决问题的能力来讲，都没有超出图灵机的范畴；<br />3、人工智能所能解决的问题只是世界上问题的很小一部分。现在世界上没有解决的问题太多，要想办法解决各种问题，而不是杞人忧天，担心人工智能太强大。</p><p><strong>思考</strong><br />能否分享下图灵思考问题的方式给你的启示？<br />1、做事情前，要考虑事情的边界和极限所在，而不是盲目地达成不可能完成的目标；<br />2、多与高人交流，这样才能不断突破自身的限制，从而达到自身的极限。</p><h2 id="周末放送-历史上最轰动的ipo"><a class="markdownIt-Anchor" href="#周末放送-历史上最轰动的ipo"></a> 周末放送 历史上最轰动的IPO</h2><p>以下摘抄自评论<br />从Google的上市行动学到<br />1、高筑墙、广积粮、缓称王。直到2004年上市时基础已经非常稳固；<br />2、保护原有股东及执行团队。不过度稀释股份、掌握投票权，让Google在融资的同时也保持原样；<br />3、轻预测重反应。未来兼顾原有股东和市场规则，改变27亿的融资计划，分三次逐步到位。<br />在“不得不”的上市行动中，不得不说这群聪明人依然打了一手好牌。</p><h2 id="周末放送-google的早期岁月"><a class="markdownIt-Anchor" href="#周末放送-google的早期岁月"></a> 周末放送 Google的早期岁月</h2><p>以下摘抄自评论<br />1、夫夷以近，则游者众；险以远，则至者少。而世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也。<br />2、然力足以至焉，于人为可讥，而在己为有悔；尽吾志也而不能至者，可以无悔矣，其孰能讥之乎？</p><h2 id="第005封信-成就成功率x事情的量级x做事的速度"><a class="markdownIt-Anchor" href="#第005封信-成就成功率x事情的量级x做事的速度"></a> 第005封信 成就=成功率x事情的量级x做事的速度</h2><p><strong>重点笔记</strong><br />1、解决问题时，先梳理出各个因素在量级上的不同，然后把那些无关紧要的事情从To Do List上删掉；<br />2、成就=成功率x事情的量级x做事的速度；<br />3、不要老想多做1%的事情，而要想着如何在更有影响力的事情中，参与1%，提高事情的量级。</p><p><strong>思考</strong><br />能否举几个生活中有量级之差的例子？</p><h2 id="第006封信-在边界里面做事情"><a class="markdownIt-Anchor" href="#第006封信-在边界里面做事情"></a> 第006封信 在边界里面做事情</h2><p><strong>重点笔记</strong><br />1、在边界里做事情，既是一种工程思维，也是让我们事半功倍的做事方法；<br />2、不要幻想突破边界。边界明确了方向和极限，我们能做到，就是在边界内找到相对好的答案；<br />3、明确自己所处行业的边界，并在边界处设防，规避可预见的风险和意外。<br />再来评论中的经典语句作为结尾，来自《塔木德》里的一句祷告语，“主啊，求你赐我勇气去改变可以改变的，求你赐我耐心去接受不能改变的，求你赐我智慧去分辨哪些可以改变、哪些不能改变。”</p><p><strong>思考</strong><br />生活中也有很多边界，有些是可以突破的，有些是难以突破的，哪些边界属于后一种呢？</p><h2 id="第007封信-苹果成功的奥秘从科学和技术的区别说起"><a class="markdownIt-Anchor" href="#第007封信-苹果成功的奥秘从科学和技术的区别说起"></a> 第007封信 苹果成功的奥秘：从科学和技术的区别说起</h2><p><strong>重点笔记</strong><br />苹果成功有四个独到之处：<br />1、了解时代的技术边界；<br />2、技术没有公司边界和国界，只要技术或者产品好，用谁的都行；<br />3、从来不把新产品的命运，寄托在还没有结果的科学研究上；<br />4、在边界内尽可能地平衡各种需求，给一个整体上最好的答案。</p><p><strong>思考</strong><br />能否谈谈你对苹果那种整体优化产品，而不是只关注每个指标的思维方式的看法？<br />这就如同数学中经常解决的在有限条件下求得全局最优解，苹果就是这样的公司，虽然单一指标的最优可以给人一种直观的冲击感，就如同我们刚学习总想让每个值达到最优，但是这并不是最好的结果，但是苹果给出了最好的答案，这也是其成功的奥秘。</p><h2 id="第008封信-把事情做好的三条边"><a class="markdownIt-Anchor" href="#第008封信-把事情做好的三条边"></a> 第008封信 把事情做好的三条边</h2><p><strong>重点笔记</strong><br />把事情做好需要搞清楚三条边：<br />第一条边是基线，你可以理解成直到今天为止人类或者你所掌握的知识。不同人的基线不一样，我们所有的工作，都应该建立在这条线的基础上，并想办法提升它。我们接受教育的目的，就是提高自己的基线，学历越高基线也越高。<br />第二条边是理论给出的极限，它无法突破。<br />第三条边是能够扶着向上攀登的绳索，或者说阶梯。它需要你把目标拆解为具体的行动步骤，并专注其中。<br />最后再来优秀的评论作为结尾：<br />基线————刘润：你以为的顿悟，可能是他人的基本功。<br />极限————吴军：“极限”这个概念是可以让我们突破认识的限制，比常人更快地看清楚问题的本质。<br />向上攀登的绳索————罗振宇：判断一个人的工作能力，其实很简单。不管他的学历有多高，本事有多大。而是遇到一个大难题，他的第一反应不是有畏难情绪和抱怨情绪，是不管这个难题有多大，第一反应是要分解问题，把大难题变成小难题，或者是马上就可以做的动作。</p><p><strong>思考</strong><br />能否给自己定一个今年的目标？分析一下自己的基线，找到一个能够攀附向上的阶梯。</p><h2 id="答读者问02-如何用计算机思维解决问题"><a class="markdownIt-Anchor" href="#答读者问02-如何用计算机思维解决问题"></a> 答读者问02 如何用计算机思维解决问题</h2><p><strong>重点笔记</strong><br />计算机思维即：<br />1、宏观：找到现实世界和虚拟世界的对应；<br />2、中观：在有限资源的情况下做到全局最优；<br />3、微观：合理组织和利用资源，凡是留有余地。</p><h2 id="周末放送-google的商业模式"><a class="markdownIt-Anchor" href="#周末放送-google的商业模式"></a> 周末放送 Google的商业模式</h2><p>以下摘抄自评论<br />从谷歌的商业模式，总结了五点思考：<br />1、能解决多少问题，决定你能挣多少钱——最成功的计算机公司是能帮助世界上每个人使用。<br />2、向高手学习，汲取行业智慧——Google经常请各行各业的精英来公司报告，不管他们做的事和Google有无关系。<br />3、做连结者，不必做制造者——只要把互联网的内容送到千家万户就行，至于内容是谁的不重要。<br />4、销售的本质是把东西卖出去——Google服务的特点是直接面向最终用户，这和投资大师巴菲特一样。<br />5、简单目标，专一致志——Google成功的原因是将中间环节减至最少。</p><h2 id="周末放送-本周回信精选"><a class="markdownIt-Anchor" href="#周末放送-本周回信精选"></a> 周末放送 本周回信精选</h2><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2021/letter/WechatIMG330.jpeg" alt="1.回信一" /><br /><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2021/letter/WechatIMG329.jpeg" alt="2.回信二" /></p><p>思考一：<br />量级之差，不在于问题本身，而在于看问题的角度，在于见识和胸怀。<br />以前读过一则楚王失弓的故事，楚王去云梦泽打猎，不小心把自己心爱的弓丢了，随从们要循原路去找，楚王却说，算了吧，楚人失之，楚人得之，不必去找了，随从们都很敬佩楚王的胸怀。<br />楚王的胸襟足够开阔宏大，他不介意自己失去弓，也不介意让楚国的平民得到自己的弓，身为帝王就应该有这样的气度和胸怀。<br />而孔子听说了这个故事，仍然叹息楚王的气量不够大，为什么不说人失之，人得之呢？<br />在孔子心中，无论是楚人还是其他国家的人，都是一样平等的，都是“天下人”，何必分为某一国家的人呢。<br />孔子以人为核心，“人”和“楚人”确实不在一个量级。<br />老子也听说了这件事，他提出了更宽广的说法，去掉“人”的限制，直接“失之，得之”，从人的范畴走到天地万物的范畴，因为他认为，人和天地万物一样，都是造化和自然的产物，何必区别对待？<br />老子的思想已经达到了天地万物的宇宙之境界，和“人”又不在一个量级了。<br />思考二：<br />1、成就=成功率x事情的量级x做事的速度<br />2、个人财富的量级=加杠杆。一个人的收入要想有量级的增长，就要用杠杆，一是加技能稀缺的杠杆，二是加团队杠杆，三是利用资本杠杆，这样财富才能呈指数级增长。很多人开了一辈子的店，到老了还是这么一家店；有些人当了一辈子理发师，到老了依然还只是一个理发师，不会升级，仅仅靠自己的努力，不吃不喝不睡，也无济于事。<br />3、个人能力的量级=做乘法。一个人的能力要想有量级的提升，就需要多维度地培养自己的能力，而且要让这些能力发挥协同效应，而不是做简单的加法，这也会那也懂，但是然并卵。<br />4、产品的量级=幂律增长，一个产品要想有量级增长，就要让产品在技术上、品牌上有量级突破，建立壁垒，让别人无法超越，而不是想着怎么降低成本，外观做得更好看，就像谷歌做的搜索算法，就是量级的差别。<br />思考三：<br />许多人一直想的是捡芝麻，确实如此。我们经常看到媒体的文章说，现在的大学生毕业工资那么低，就算按每年10%的增幅，还不是连一套学区房都买不起。<br />但是，有量级思维的人即使处于低工资的水平，但也会想如何提升自己的能力，让自己几年后能有几倍甚至几十倍的收入，会想如何通过投资等方式，尽快实现财务自由，而不会简单地根据现在的工资水平相加，确定自己一生的收入。</p><h2 id="第009封信-上帝喜欢笨人上"><a class="markdownIt-Anchor" href="#第009封信-上帝喜欢笨人上"></a> 第009封信 上帝喜欢笨人（上）</h2><p><strong>重点笔记</strong><br />我一生感悟最深的一句话：上帝喜欢笨人。既然自己能力有限，就按照有限的能力尽力而为就好，不要以为有了什么高科技的时间管理工具就能做更多事情。人有多大本事，做多大事情。</p><p><strong>思考</strong><br />能否就“上帝为什么喜欢笨人”这个问题谈谈你的看法？<br />这个“笨”不是指真正字面含义的笨，而是指踏实做事、对任何人负责的态度，这句话也让我想起来本科最喜欢的一句话，用英文直接表述更为合适，Steve Jobs的名言，“Stay hungry. Stay foolish”。</p><h2 id="第010封信-上帝喜欢笨人下"><a class="markdownIt-Anchor" href="#第010封信-上帝喜欢笨人下"></a> 第010封信 上帝喜欢笨人（下）</h2><p><strong>重点笔记</strong><br />1、这个世界上永远不缺聪明的人，只缺少傻子。作为一个傻子，不会像聪明人那样天天门庭若市，后面跟着一大堆的追随者，但是能够得到自己应得的生意伙伴、合作者和朋友。<br />2、不仅做人可以傻一点，做事情其实也不妨傻一点。我们接受信息的带宽其实很窄，因此很难并行做好几件事情。因此，一件事一件事地做，不用并行处理，或许是效率最高的工作方式。做事情，不在于开了多少个头，而在于结了多少次尾。</p><p><strong>思考</strong><br />能否分享一下你对鲁迅这段话的看法：“不错，半农确是浅。但他的浅，却如一条清溪澄澈见底，纵有多少沉渣和腐草，也不掩其大体的清。倘使装的是烂泥，一时就看不出它的深浅来了；如果是烂泥的深渊呢，那就不如浅一点的好。”<br />心智比较简单的人，做事踏实，看事情简单，目光清澈，反倒容易直奔目标，剔除不必要的枝节。反而思想太复杂城府极深的人，容易绕路，你凝视深渊的时候，深渊也在看着你。</p><h2 id="第011封信-笨人威灵顿vs天才拿破仑"><a class="markdownIt-Anchor" href="#第011封信-笨人威灵顿vs天才拿破仑"></a> 第011封信 笨人威灵顿VS天才拿破仑</h2><p><strong>重点笔记</strong><br />1、威灵顿的特点就是知道自己的边界在哪里，从不相信自己能创造什么人间奇迹，然后就在边界里把事情做好。因此他每次在战前都是事无巨细地安排好每一件事情，也正因为如此，在他军旅生活的后一半时间，没有因为自己事先考虑不周而出什么差错。<br />2、人如果存在先天不足，首先要承认它们，这是我们的边界，然后要提前准备好应对的方式。既然不是拿破仑那样的天才，就不妨学惠灵顿当笨人，用笨办法做事情。</p><p><strong>思考</strong><br />库旦普教授和辛格博士做事的笨办法，对你有什么启发？<br />1、充分准备，用“笨办法”做事情，是面对未知困境的积极状态，既包括内部心理的准备，也包括外部的人、方案、物资的准备，这样面对没有“地图”的场景时，我们的“航船”不会因为经不起风浪或者缺少淡水和食物无法前行。<br />2、面对未知更好的办法，就是把已有的能力和资源优化成“指南针”，把可控的部分做到最好，至少已经减少了部分的风险。不存在没有风险的事情，但是降低风险就提升了做好事情的概率。<br />随意应变并非不做准备，而是在已有的最大可能的准备的基础上，随机应变的灵活程度会更强、心理压力会比较小，从而获得更多思考空间。</p><h2 id="第012封信-一生的五件事"><a class="markdownIt-Anchor" href="#第012封信-一生的五件事"></a> 第012封信 一生的五件事</h2><p><strong>重点笔记</strong><br />1、每个人的生活都独一无二，既不能由别人代替，也不可能在以后有时间补上。以后有时间，等于永远没有时间；人一辈子至少该尝试一次做自己喜欢的事；<br />2、回馈完全不在于多少，而在于从现在开始身体力行；<br />3、信仰最能够给予我们勇气和力量，一个有信仰的人，如果知道自己是对的，就不怕恐吓，敢于行动；<br />4、每一个人最后都应该考虑留下什么遗产。可以问自己：这个世界如果没有我，是否会完全一样？</p><p><strong>思考</strong><br />人生，至少要实现一次阶级的跨越，哪怕只比家族过去好一点点，也要为之而努力。无关乎物质金钱，而是思维的跨越，考虑问题的方式，一代比一代强的，不该仅仅是物质的丰盈，是掌握知识转换知识的能力，更重要的是，将这样的智慧与获取智慧的方式，传承下去。<br />犹太人之所以在世界有举足轻重的地位，不是因为他们很有钱，恰恰相反，过去漫长的历史长河中，无数次犹太人赚的钱，都被人掠夺，他们在不断被人洗劫财富跟驱赶中，因为不能拥有土地而四处漂泊，最终一代又一代的传承一个思想：智慧，是永远无法被掠夺的。也正是如此，犹太人对下一代教育的重视，远远超过我们任何一个民族。<br />因此，无论是学习工作还是结婚生子，智慧的增长，能够将所有的努力都变得更有意义。</p><h2 id="答读者问03-敢于承认傻才是自信的表现"><a class="markdownIt-Anchor" href="#答读者问03-敢于承认傻才是自信的表现"></a> 答读者问03 敢于承认傻，才是自信的表现</h2><p><strong>重点笔记</strong><br />世界不公平，没有亏欠你。<br />理解处处存在不公平、人人各有所偏好，那么就能知道，成功并非一个人的努力和运气，而是周围有多少人愿意帮他成功。<br />威灵顿打仗前的准备，是做好“看地图”的功课，而非预测；做足准备后，在现场指挥则是要“重反应”，跟着指南针找方向。<br />真实世界是复杂的，懂了世界运行的残酷，才能心安理得地认傻，智慧地做笨人。</p><h2 id="周末放送-google的个人英雄主义和群众路线"><a class="markdownIt-Anchor" href="#周末放送-google的个人英雄主义和群众路线"></a> 周末放送 Google的个人英雄主义和群众路线</h2><p><strong>重点笔记</strong><br />评论一：<br />管理是一种很大的成本。<br />很多公司不重视招人，以为可以通过管理来解决人的问题。其实大多数人的大多数习惯都不会改变，通过制度来管理人，只能是事倍功半。<br />就象婚姻，如果人错了，再怎么努力，也很难幸福。<br />最好的管理，就是每个人都能够管理自己，要想达到这个目标，就是招对人。<br />评论二：<br />1、群众不创造历史，他们从来都只是历史的参与者，而非决策者；<br />2、个人价值的实现需要依靠集体来展现；<br />3、精英的能力要远大于三个臭皮匠能力总和，线性的叠加永远赶不上做乘法指数级的增长；<br />4、运气很重要，前提是你要足够优秀；<br />5、自下而上的管理有时能出现意想不到的效果。</p><h2 id="周末放送-如何避免成为耍小聪明的人"><a class="markdownIt-Anchor" href="#周末放送-如何避免成为耍小聪明的人"></a> 周末放送 如何避免成为耍小聪明的人</h2><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2021/letter/WechatIMG343.jpeg" alt="" /></p><p><strong>重点笔记</strong><br />1、这篇文章让我想起来一个故事。<br />清朝有个卖大米的小铺，家里掌柜的为了挣更多的钱，特意把秤往低调了一下，一斤米现在只需要卖出去0.95斤。<br />这件事碰巧被儿媳妇看见了。儿媳妇就悄悄地瞒着公公把秤改成了1.08斤。这样米铺每卖一斤米就亏0.08斤。<br />奇怪的是，从此以后，这家米铺生意越来越好。20年后这家米铺已经成了全省最大的米铺，过年的时候老太爷问大家知不知道为什么米铺越来越好，大家说不出一个一二三来。老太爷得意地把当年的事说了出来。<br />这时，儿媳妇却告诉了大家事情的真相。从小父母就教育自己吃亏是福，生活和工作中自己经常吃亏，反而自己过得非常轻松。<br />我们农村还有一句话，叫做你骗“地皮”，“地皮”骗你肚皮。<br />自作聪明，掩耳盗铃的人也许就是我们每个人吧！<br />2、当我们在说做事“笨”的时候，其实是在说“做事慢但有效”，而在说做事“聪明”时，是在说“做事虽快但效果差、甚至无效”。<br />3、“其实为了追求更好的生活，每一个人都不容易，这些早起上班的人，背后可能都隐藏着不为人知的辛酸故事，但都为自己的梦想在打拼，我并不孤单。”<br />有一句古希腊谚语，他是从外公那儿学来的：能够到达金字塔顶端的只有两种动物，一种是雄鹰，一种是蜗牛。<br />外公讲完后问他：“昭阳啊，你想做雄鹰，还是做蜗牛？”<br />他想都没想就说：“我想做雄鹰。”<br />他记得外公说过：“昭阳，很多人身上充满了天赋，就像雄鹰靠自身的翅膀飞上了金字塔顶端；但蜗牛不一样，需要日复一日、年复一年不停地向上爬，而且会遇到各种困难，比如狂风暴雨的阻挡。<br />只要蜗牛爬上去了，它眼中的世界，它收获的成果，跟雄鹰是一模一样的。<br />昭阳，记住了，只要你朝着目标一直爬，哪怕没有登上最高点，所到之处都会留下痕迹，当生命走到尽头时，那过程也足以感动你自己，这就足够了。”<br />我的话，将来你会明白的。<br />——来自小说《绝情华尔街》<br />4、还记得《海贼王》中的一个岛上，一名医生在临死前说：<br />人会在什么时候死亡，是心跳停止时吗？是万箭穿心时吗？<br />都不是。<br />人只有在被人遗忘时才是真正的死亡。然后他笑着离开了。</p><h2 id="第013封信-超越免费上"><a class="markdownIt-Anchor" href="#第013封信-超越免费上"></a> 第013封信 超越免费（上）</h2><p><strong>重点笔记</strong><br />1、雅虎的杨致远和费罗首创了免费的互联网服务，让互联网成为了一个开放、免费的工具；<br />2、免费带来的一个结果是迅速形成垄断，也让商家的收入大幅减少，甚至让一些国家和地区的经济陷入缓慢发展的阶段；<br />3、免费能够成功，是因为过去一些东西有稀缺性，当那些东西不再有稀缺性时，再免费就没有意义了；<br />4、超越免费的第一条是制造一种稀缺性，而这需要产品、服务本身具有一种难以复制的特性。</p><p><strong>思考</strong><br />在我讲述的如何增加自己的稀缺性方面，你有什么思考和体会？<br />稀缺，过去我们从经济学中，看供给需求；今天套用到个人成长及工作，看人才过剩。<br />从踏入职场的实习阶段，即是劳动市场中“自己能力”和“工作需求”的较量。当市场上人浮于事，同样岗位对学历要求变高、针对其它领域（才艺、关系）进行筛选就更强；当市场处于上升期、急缺人才，则劳动一方有议价权。除此外在环境之外，能在劳动市场拿回议价权的方法，就是增加稀缺性。<br />查理芒格说，想要得到一件东西，首先要让自己配得上。与其追求高工资，不如先让自己有价值。超越免费，也就是理解量级思维：不在芝麻中争大小，而是想办法成为西瓜。</p><h2 id="第014封信-超越免费中"><a class="markdownIt-Anchor" href="#第014封信-超越免费中"></a> 第014封信 超越免费（中）</h2><p><strong>重点笔记</strong><br />1、在未来，超越免费不仅是我们做生意的原则，也是我们做人，自我成长所必须注意的地方；<br />2、超越免费的第二个办法是时效性。了解了时效性，你会体会到终身学习的重要性，因为这样总是可以领先同辈人一步，让自己成为具有时效性的人才，而不是廉价的人；<br />3、超越免费的第三个办法是个性化。不论是做产品还是做人，都要追求无法复制的个性化。</p><p><strong>思考</strong><br />我们教育的一点不足之处是，培养的人都是从一个模子中刻出来的。能否分享一下如何把自己变成一个个性化的人？<br />1、不要用专业限制自己，让自己多元化。<br />无论是在校还是工作中，我常常听到别人说“我是一个理/工/文科生，所以XX方面我不擅长”。事实上，没有哪方面的研究或工作只需要你具备一种能力的，做一个有文艺气息的攻城狮，或拥有科学素养的文科生，自己不限制自己，世界也不会限制你；<br />2、让自己变得“有趣”<br />与幽默和搞笑不同，它的独特之处是“让人觉得意外”。“搞笑”激发的是人的感官和情绪；而“有趣”是一种精神享受，激发的是人的思考。如何让别人哈哈大笑之后，还能有所启发。<br />给大家分享一个马伯庸的故事：他说他在产房见到妻子一脸疲惫，就对第一次看到的儿子说：”为你这孺子，几损我一位大将！“<br />3、有长期目标感<br />在上周的话题中，我一度的思考是”和聪明人相比，笨人看得更长远“。做好了准备就撸起袖子加油干，没做好准备就低声埋头打基础。但是殊途同归，你在你擅长的、需要加强的地方不断积累，与同龄人相比，你就会越来越专业，越来越个性。</p><h2 id="第015封信-超越免费下"><a class="markdownIt-Anchor" href="#第015封信-超越免费下"></a> 第015封信 超越免费（下）</h2><p><strong>重点笔记</strong><br />1、超越免费的第四个绝招是提供可用性（易理解性）的产品和服务。任何时代能够把事情解释清楚不仅是一个有用的本领，而且是一个很赚钱的生意；<br />2、超越免费的第五个绝招是提供可靠而易用的服务；<br />3、超越免费的第六个绝招是具有数据黏性的服务。越是善用数据黏性的公司，后来的发展越顺利。而开始靠免费拉用户，甚至花钱买用户的公司，常常后劲不足。</p><p><strong>思考</strong><br />生活中还有哪些产品和服务的可用性有待提高？<br />超越免费的六个方法：<br />1.稀缺性，它是用户愿意选择和购买的前提，轻易可得，即便是免费送大家，也不见得有用户，稀缺性是产品或服务不可或缺的一点。<br />2.个性化，同质化的产品、类似的服务如果都采取了免费的策略，就需要在满足用户个性化需求方面展开竞争。<br />3.时效性，抢占先发优势，在第一时间向用户提供服务，在时间上领先竞争者。<br />4.可用性，提供的产品和服务，要方便需求者使用，使用者不必在使用上投入太多成本便可享受服务。<br />5.可靠性，稳定而可靠的服务是消费者长期使用的基础，无法保障可靠性，消费者早晚会选择离开。<br />6.数据粘性，在提供的产品上要能够将用户的资源和信息保存在产品和服务中，随着使用时间的加长用户在产品和服务中积累的个人资源也就越多，用户越无法轻易更换。<br />在吴老师分享的6点中，个人最受启发的是可行性（可理解性），原来提高现有产品或服务的可理解性和可用性也是蕴含巨大的价值，这也是得到这个平台的价值。</p><h2 id="第016封信-他人的关注可能很不值钱"><a class="markdownIt-Anchor" href="#第016封信-他人的关注可能很不值钱"></a> 第016封信 他人的关注可能很不值钱</h2><p><strong>重点笔记</strong><br />1、他人的关注可能很不值钱，把精力花在那些根本不值得关注的事情上，是一件收益极低的事情；<br />2、不同人的关注是不平等的，同一个人不同状态下的关注也是不平等的；<br />3、阅读免费低质量的内容，远没有付费高质量的内容有意义；<br />4、对于商家来讲，重要的是ARPU值（每用户平均收入），关注能给核心客户带去什么价值；<br />5、找一些真正能够帮助我们的朋友（高ARPU值群体），为他们提供一些价值。</p><p><strong>思考</strong><br />能否举几个ARPU值高的公司，分析下它们有什么特点？<br />探讨ARPU值，是每用户平均收入=总收入/用户数，更精确来看，像苹果公司那样能明确指出谁是用户（那些买了手机的人），而像谷歌和腾讯不太能区分“用几次”的人算得上用户，则看使用的活跃度，因此ARPU=月收入/月活跃用户数，平摊到所有用户（包括付费及未付费的），那么ARPU的量级就次于苹果公司。<br />概括来看，ARPU值高的公司，产品价格/替换周期通常较高，通常价格高、产品周期短的公司占优势。从原本公式来看，总收入固定之下，若是用户数相对较小，ARPU也会比较高。这有点反直觉，然而拥有10个了解你的用户，比找到100个用户还好，这样解释或许能容易理解。<br />回到个人身上，能有真正互益的朋友，胜过认识一群泛泛之交。真正的朋友不多、而你们之间的互助价值高，以及交流频次高，都能让互相成为高ARPU的对象。一个人的见识是周围五个朋友的平均，此言不假。</p><h2 id="答读者问04-教会徒弟会饿死师父吗"><a class="markdownIt-Anchor" href="#答读者问04-教会徒弟会饿死师父吗"></a> 答读者问04 教会徒弟，会饿死师父吗？</h2><p><strong>重点笔记</strong><br />1、凡是世界上大部分人都能做到的，就没有稀缺性；<br />2、至于怎么比徒弟快，不完全是比徒弟更努力，因为这只是在低层次上的竞争，而是首先在见识和格局上要比徒弟高，气度要更大；<br />3、一个组织里，永远不缺乏那种掌握了一点技能的人，恰恰缺乏愿意分享，愿意相互提携的人；<br />4、什么是效率？效率=得到的结果/投入；<br />5、我们宁可需要慢一点，但是能产生正向效果的员工，而不需要关键时候掉链子，凡事都指望不上的人。</p><h2 id="周末放送-佩奇和布林google的绝代双骄"><a class="markdownIt-Anchor" href="#周末放送-佩奇和布林google的绝代双骄"></a> 周末放送 佩奇和布林——Google的绝代双骄</h2><p><strong>重点笔记</strong><br />Google的独到眼光和先发优势，不仅把搜索广告变成金矿，还确立了游戏规则。占领制高点、让大家按照你规则来玩，即增加自己稀缺性的好办法。<br />之后的雅虎和微软的MSN，与Google拼搜索，实际也是落入Google的棋盘，因为拼起搜索，就必须遵守Google制定的游戏规则。<br />看透一个产业发展的趋势不容易，能重设游戏规则更是稀缺人才。而重设规则，正不是创新的起源吗？过去人们以为酒店旅馆要有资本才能做，Airbnb改写规则；过去人们认为出行打车需要有车队，Uber也重设游戏。所谓创新，即是在原有游戏中，发现新的玩法，先发制定规则，自然成为稀缺的行业霸主。</p><h2 id="周末互动-如何增加自己的稀缺性"><a class="markdownIt-Anchor" href="#周末互动-如何增加自己的稀缺性"></a> 周末互动 如何增加自己的稀缺性</h2><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2021/letter/WechatIMG359.jpeg" alt="" /></p><p><strong>重点笔记</strong><br />1、在生存法则中，有两条线。忍是一条线，能是另一条线。<br />这两条线之间的宽度就是生存的空间，忍人所不忍，能人所不能，生存空间就越宽，这种人的稀缺性就越高。<br />人不是生而知之，是学而知之，增加自己稀缺性的砝码，客观环境造成了大多数人一开始不能往高处着眼，而是踏实做好眼下的事，做别人不愿意、不屑做的事，把小事做好，而后慢慢向高处发展。<br />企业也如此，在当今竞争激烈的市场环境下，胜负往往在毫厘之间，多一丝生存空间，不断拓展生存空间的两条线，就有更高的概率“剩者为王”。<br />2、超越免费有六个办法，而在我看来，其实是”稀缺性+五个维度“。<br />时效性，即在时间上的稀缺；个性化，是空间上的独特；可用性，即资源利用的能力；可靠性，代表信任资本的累积；而数据黏性，是善用数据的护城河。<br />五个维度，总结为”稀缺“的技术壁垒。<br />3、吴军老师说的效率，我认定是一条曲线而非静态值，横轴是时间，纵轴才是效率。<br />平庸的效率是一条水平线，卓越的效率则是指数上升的，同样计量的前期投入，投入方法不同，表现的曲线截然不同。<br />作为一个十年坚持写函数库给自己使用的程序员，我深刻体会到这一点，只不过我周围能熬得过时间的人好像太少了，也或许他们常常只看到了一个静态的时间点。<br />4、总结一下我知道的有趣的人，他们有以下显著特点：</p><ul><li>他们是某个领域的精英，却博学且涉猎广泛，他们能持续输出有价值的东西影响别人。</li><li>他们善于表达和讲故事，言之有物，总让人受益匪浅。</li><li>他们富有，无论是在精神上还是物质上。精神上的富有使他们的生活妙趣横生，物质上的富有让他们更自由地发展和发挥他们的个性。</li><li>他们的有趣是自然流出的，仿佛池子里的水满了溢了出来。</li></ul><p>最后，我想到《1843》中的一句话：”personality is who we are in front of other people, our audience is our identity.“</p><h2 id="第017封信-美国vs中国在哪里生活更好上"><a class="markdownIt-Anchor" href="#第017封信-美国vs中国在哪里生活更好上"></a> 第017封信 美国VS中国，在哪里生活更好（上）</h2><p><strong>重点笔记</strong><br />1、中美之间在生活上，最大的区别是在家庭生活方面。美国中等以上的家庭，家庭观念比中国人要强，中国人强的是家族观念，不是家庭观念；<br />2、美国人的家庭观念，主要体现在三个方面：全家人要一起活动，家比工作重要，父母要参加孩子在学校的演出、体育比赛活动；<br />3、中美之间生活习惯上的第二个差异是在做事的方式上。美国人做事总是要事先计划好，按部就班地做，很多计划一做就是一年，中间要想插进去事情很难。</p><p><strong>思考</strong><br />计划性本身也是双刃剑，太规范做事情就失去了灵活性和新的机会，当然没有机会也是不行的。能否就这个问题谈谈你的看法。<br />1、罗胖的《计划的用处》，讲到制定计划的目的不是为了刻板地完成计划，而恰恰是为了应对变化，为可能发生的变化做出各个方面的资源准备；<br />2、罗胖的《骆驼策略和兔子策略》，讲到在高风险时代，做万全准备的骆驼策略是必要的，而在我们这个低风险时代，边吃边走边找目标的兔子策略没准也是明智的。</p><h2 id="第018封信-美国vs中国在哪里生活更好中"><a class="markdownIt-Anchor" href="#第018封信-美国vs中国在哪里生活更好中"></a> 第018封信 美国VS中国，在哪里生活更好（中）</h2><p><strong>重点笔记</strong><br />1、美国人和人之间的距离比较大，不仅是物理距离，还包括心理距离。其中最明显的特征就是对隐私的看重；<br />2、在美国的文化中，父母认同孩子是独立的个体，有自己的意识；<br />3、美国人公私分明，下了班之后，大部分人是不会在家里查收邮件的，因为那是他们私人的时间了。此外，美国人更看重利益，而不是交情；<br />4、主动管理好自己生活的社区在美国非常重要。</p><p><strong>思考</strong><br />1、你觉着什么样的亲子关系既能维持中华文化的传统，又能与时俱进？<br />2、能否就主动性谈谈改善人和人之间关系的技巧。<br />在中国，不管是在生活还是工作中，大多数人的思维习惯是向下管理，自己要做什么事，听命于上级的指挥，时间久了，自己就会很被动，像似沦为一个工具。<br />因此，”向上管理“便是通过主动性来改善人与人之间关系的好方法。<br />向上管理，就是对有管理你权力的人，施加影响力的方法论。向上管理有以下几点心法：<br />1、主动向老板汇报自己的工作进展，建立信任。信任，是影响力的基础。如果老板不相信你的人品、可靠性和专业能力，你对老板就没有什么影响力。<br />2、始终兑现自己的承诺。值得信任，可靠，是不让老板担心。<br />3、帮助老板节省时间，储蓄影响力。</p><ul><li>向上沟通，注重套路</li><li>不只是提问题，还要提出建议</li><li>提出两个以上的建议，并作出分析</li><li>与上司讨论，并由上司作裁决</li></ul><h2 id="第019封信-美国vs中国在哪里生活更好下"><a class="markdownIt-Anchor" href="#第019封信-美国vs中国在哪里生活更好下"></a> 第019封信 美国VS中国，在哪里生活更好（下）</h2><p><strong>重点笔记</strong><br />想要移民美国想要搞清楚5个问题：<br />1、能否吃西餐；<br />2、能否欣赏英语诗，你能不能享受美国文化和制度好的那一方面；<br />3、是否是边界内玩游戏的高手，美国经济体量很大，但要在边界内寻找发展机会；<br />4、生活目标是否明确；<br />5、是否认同小家生活的重要性，如果你喜欢过小家的日子，美国很适合你，如果喜欢热闹，中国似乎更适合。</p><p><strong>思考</strong><br />很多时候目标不明确是做事情不成功，或者效率不高的根本原因。能否分享一下你在明确目标方面的经验？<br />从两方面思考目标性不明确从而带来的收益不大原因：<br />一、我是谁？<br />”海阔任鱼游，天高任鸟飞“，再好的千里马在沙漠里跑不过骆驼~当想知道哪里更合适自己的时候，首先要根据不同环境里的人文环境结合自身优势劣势分析自我，先认清自己，然后才能更明智做出适合自己的环境，之后明确的目的，才更有意义。<br />二、这是哪？<br />有句话说：”如果你无法承受我最差的一面，就不配拥有我最好的一面。“在中国经济高速腾飞的当下，不仅仅中美之间的优缺点慢慢的在倾斜，整个世界在过去比中国优越性很多都已经消散。中国的高铁、支付宝、共享单车等等这些，整个世界都是望尘莫及的，在美国，去银行买个支票都要提前两周预约，人们已经习惯了把生活节奏放慢。所以，出发之前，一定要透传全面分析，要去的地方全部的优缺点，看看自己到底需要哪些，目标地所带来的诸多不确定因素与缺陷，我们是否能够承受。</p><h2 id="第020封信-是否该出国读书中美教育全面比较"><a class="markdownIt-Anchor" href="#第020封信-是否该出国读书中美教育全面比较"></a> 第020封信 是否该出国读书：中美教育全面比较</h2><p><strong>重点笔记</strong><br />国内大学的长处：<br />1、考试成绩好；<br />2、学生群体水平整齐；<br />3、毕业时绝大部分都达到了培养目标。<br />HYPMS的长处：<br />1、全面发展，综合素质好；<br />2、很早地接触到最新的研究成果；<br />3、学生们的生活自理能力强；<br />4、自由选课，选择专业，因材施教培养每一个人；<br />5、同学之间相互交流和学习的机会比较多；<br />6、双学位的毕业生比例很高，有的大学比例高达一半。</p><h2 id="来信补充-大学是怎么来的"><a class="markdownIt-Anchor" href="#来信补充-大学是怎么来的"></a> 来信补充 大学是怎么来的？</h2><p><strong>重点笔记</strong><br />在几千年来的教育史中，一所大学能否传授这些大行之道，一个学生能否学到它们，是衡量高等教育水平最重要的因素。</p><p><strong>思考</strong><br />大学最重要的是学术自由，不理解这层含义，就无法理解耶鲁大学最根本的价值观。<br />曾任耶鲁大学校长20年之久的理查德·莱文曾说过：真正的教育不传授任何知识和技能，却能令人胜任任何学科和职业，这才是真正的教育。专业的知识和技能，是学生们根据自己的意愿，在大学毕业后才需要去学习和掌握的东西，那不是耶鲁大学教育的任务。耶鲁致力于领袖人物的培养，本科教育的核心是通识，是培养学生批判性独立思考的能力，并为终身学习打下基础。<br />通识教育的核心，是自由的精神、公民的责任、远大的志向；是批判性的独立思考、时时刻刻的自我觉知、终身学习的基础。自由地发挥个人潜质，自由地选择学习方向，不为功利所累，为生命的成长确定方向，为社会、为人类的进步做出贡献。</p><h2 id="回信精选-人生赢家懂得把握动态平衡"><a class="markdownIt-Anchor" href="#回信精选-人生赢家懂得把握动态平衡"></a> 回信精选 人生赢家懂得把握动态平衡</h2><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2021/letter/WechatIMG358.jpeg" alt="" /></p><p><strong>重点笔记</strong><br />评论一：<br />计划和灵活性，让我想起了如何把大石头、小石子和沙子放入一个杯子里。正确的方法是先放大石头，再放小石子，最后放沙子。这个是”要事优先原则“。<br />做计划：<br />设定一个目标，并安排进度和每阶段需要花的时间，它们是大石头，要最先确定和安排好时间，并留出足够的盈余时间。<br />灵活性：<br />1、小石子和沙子的时间，要用来处理突发事件的；<br />2、要定期检视自己的目标、查看计划的完成情况，如果偏离了坐标，就要修正。<br />评论二：<br />很久之前，读过海明威的一句话：”如果你足够幸运，年轻时候在巴黎居住过，那么此后无论你到哪里，巴黎都将一直跟着你。“<br />你居住过的城市，它们会深深地影响着你，同样适用于国家。每个国家都有它与生俱来的气质，并且这样的气质会消无声息地浸润你、影响你、改变你。<br />比如吴军老师在美国生活，养成了做计划的习惯。对于计划，我在学习吴军老师的来信过程中，也渐渐地养成了做计划的习惯。<br />也知道这个世界唯一不变的就是变化，从而导致计划赶不上变化。在实践过程中，深有体会。但拿自己以往不做计划的日子相比，还是做了计划的日子，过得比以前满意。<br />所以，对于计划，不要太过死板，要灵活运用，要辩证来看，选择对自己有利的，才是关键。<br />评论三：<br />目标明确的作用是”矫正“行为。<br />1、每一次行动的效果通过回顾目标，能够得到评估、发现问题；<br />2、评估结果能够引发思考、分析原因；<br />3、总结经验，为以后的行动带来建议。</p><h2 id="第021封信-莎士比亚的智慧之二"><a class="markdownIt-Anchor" href="#第021封信-莎士比亚的智慧之二"></a> 第021封信 莎士比亚的智慧之二</h2><p><strong>重点笔记</strong><br />1、莎士比亚认为爱情是冲动的，婚姻是理性的；<br />2、爱和婚姻都是要把自己的一切付出，也就是一种牺牲。</p><p><strong>思考</strong><br />能否分享一句你喜欢的莎士比亚的名句，谈谈你的感受和启发。<br />1、This above all: to thine self be true. (Hamlet)<br />最重要的是，你必须对自己忠诚。——《哈姆雷特》<br />一个人对自己忠诚，其实是面对真实的自己，敢于面对自己，才有机会正视自己，方能客观地评价自己，活出自己。这是爱自己、对自己负责的一种表现。当要求一个人爱他人、对他人负责时，首先这个人必须爱自己、对自己负责。<br />2、我荒废了时间，时间便把我荒废了。<br />不做时间奴隶，也不妄想做时间主人，只想做时间的朋友，不负良辰美景、不负韶光岁月！<br />3、爱所有人，信任少数人，不负任何人。<br />爱所有人，是指一开始假定所有人都是好的，真心付出。我们对待这个世界也假设一切都是美好的，总会有点瑕疵，但无伤大雅。<br />因此，就有了”信任少数人“。信任最亲近的人，这类人不需要很多，知心就够了。<br />不负任何人，指的是大丈夫活得坦荡，安心。<br />宁可天下人负我，不可我负天下人。这是笨道理，也是大智慧。<br />4、老老实实最能打动人心。<br />最平淡简单的道理往往是最有价值的道理。比如：如何避免用谎言掩盖谎言？那就是一开始就别说谎。一个真诚，并且言行一致，前后一致的人才能打动人心。我们不能说做了坏事不一定会被发现，成为不真诚的人本身就是惩罚。这也是上帝喜欢笨人的另一种表达方式。</p><h2 id="第022封信-年终总结"><a class="markdownIt-Anchor" href="#第022封信-年终总结"></a> 第022封信 年终总结</h2><p><strong>重点笔记</strong><br />1、为教育、家乡、社会做出贡献和为他人提供价值，在付出的过程中就会获得满足感和成就感。<br />2、想做的事要立马行动起来。”将来有时间或者有机会“这句话的真实含义是：永远没时间，永远没机会。<br />3、对待困难，解决问题的态度应该是问问自己能不能找到更好的办法，然后就身体力行地去做。</p><h2 id="第023封信-年终所做的减法"><a class="markdownIt-Anchor" href="#第023封信-年终所做的减法"></a> 第023封信 年终所做的减法</h2><p><strong>重点笔记</strong><br />1、不要过高估计自己能够承担的负荷，做事不能半途而废，而不能试图超越极限胡来。<br />真正能完成大任务的人，总是怀着敬畏的心情，本着十二分负责的态度去做事情。<br />2、如果人的生命是无限的，或许反而一事无成，因为永远有明天。<br />拖延症不一定好改，唯一能做的事情，就是进一步做减法。<br />3、不用介意把没做完的事摆出来让大家评判，因为人非完人。更重要的是把自己接受的教训告诉大家，让一个群体共同进步，才是目的。</p><h2 id="第024封信-新年计划和对未来五年的展望"><a class="markdownIt-Anchor" href="#第024封信-新年计划和对未来五年的展望"></a> 第024封信 新年计划和对未来五年的展望</h2><p><strong>重点笔记</strong><br />1、人要主动做事情，把握时机。今天，利用信息技术改造各种产业的大机会就在眼前，不应该错过。<br />2、如果要进入一个新领域，最好是找到一个能够发挥你特长的切入点。虽然不能确信能走多远，但是这可能是比较省力的方式。<br />3、今后五年的做事原则：步子要比别人迈得大一些，落脚要比别人稳一些，对前途的信心要比别人坚定一些。</p><p><strong>思考</strong><br />最后，能否谈谈你对未来的判断和思考，分享下你的应对策略和行动计划。<br />1、未来社会不懂计算机就是文盲，人工智能会替代越来越多工作。<br />2、吴军老师说”极端情况下，只做这5件事就够了“。吴军老师不断提醒要做减法，第一季中提到”如果你做的事，别人觉着可有可无，那就没有做的必要“，我也知道二八定律，知道一件事都不好，不可能做好其他事。<br />3、上帝喜欢主动的人，这是第一季《硅谷来信》中我印象最深的一句话之一，但这种主动不是匹夫之勇，而是对”局和势“洞察之后、对资源和优势盘点清楚之后的一招制敌、一击即溃。<br />4、我们的命运由时代和时机决定。在去年看到万维刚老师谈论”运气动力学“时，我只是隐隐约约记得”选择大于努力“，从来没有想过个人主观能动性和时机之间的关系。到后来，我知道了很多创业公司因为时机不对过早或过晚进入一个市场而倒闭，过早是在帮忙培育市场，”前浪死在沙滩上“，过晚是红利期已过，时常被瓜分尽了。而现在，我是怀着对历史、科技、时间、宇宙、人类、生死的敬畏之心来看待自个体生命。<br />5、星星之火，可以燎原。很多人现在唱衰人工智能，是没有看到乱象之下蓬勃的成长力量。想起当年苹果手机横空出世时，包括鲍尔默在内的科技大佬也在唱衰苹果。<br />6、风险防范意识。想起芒格说：漫长的一生，我都在期待麻烦的到来。</p><h2 id="答读者问06-怎样锻炼成为一个决策者"><a class="markdownIt-Anchor" href="#答读者问06-怎样锻炼成为一个决策者"></a> 答读者问06 怎样锻炼成为一个决策者？</h2><p><strong>重点笔记</strong><br />1、刻意练习从多维度考虑问题，站在不同人的角度去想问题，特别是站在自己的对立面想问题。<br />2、首先需要搞清楚他们不赞同的原因，接下来要搞清楚在什么条件下，他们会赞同。这就是一个主动的做事态度。<br />3、每次在做事情之前，能否换一个思维方式问问自己，这件事是否真的有必要做？如果有，是否还有更好的办法？<br />4、一个人在单位里，要主动找好的领导沟通，给他当徒弟。</p><h2 id="第025封信-粗调和精调从一道google的面试题谈起"><a class="markdownIt-Anchor" href="#第025封信-粗调和精调从一道google的面试题谈起"></a> 第025封信 粗调和精调：从一道Google的面试题谈起</h2><p><strong>重点笔记</strong><br />1、世界上顶级的公司在招人时越来越强调一个人未来的可塑性，因为大部分公司招人是做未来的事情，而不是重复过去的事情。<br />2、任何一个机器学习的过程，都是不断调整数学模型参数的过程，直到参数收敛到最佳点。每一次调整被称为是一次迭代，调整的幅度被称为迭代的步长。<br />3、粗调：先确定大致范围，效率更高；精调：缩小调整的幅度，精度高，准确性高。</p><p><strong>思考</strong><br />粗调和精调的思维方式其实在生活中也有应用。很多时候我们先用低成本解决主要问题，然后再想办法把最后5%，10%做好。<br />所谓工程思维，就是你不仅仅要知道目标在哪里，而且必须设计一个能达到目标的路径！要想提高工程思维，必须掌握粗调和精调的思维模式！<br />在软件编程中，所谓的粗调就是：不管结果怎样，先让自己写的代码运行起来，哪怕结果很不好；所谓精调就是：根据所得结果和最终想要的结果对比，再一点点修改调试以至于达到最终结果！<br />其实生活中这样的例子很多，很多人不管做什么事，都想着当自己准备好一切之后再行动，这些都是一些追求完美的人，可结果是这些人开始做的事很少，做成事的人更少！所以，我们应该采用粗调和精调的思维模式进行改进，先粗调：不管什么事，准备一下后，就行动起来，开始的结果肯定不会像你想的那么好，但是不要害怕，我们紧接着进行精调：根据结果我们再精细的调整自己的方向。在开始时采用粗调思维模式，在行动中采用精调思维模式。</p><h2 id="第026封信-微软为什么面试这道题井盖该是圆的还是方的"><a class="markdownIt-Anchor" href="#第026封信-微软为什么面试这道题井盖该是圆的还是方的"></a> 第026封信 微软为什么面试这道题：井盖该是圆的还是方的？</h2><p><strong>重点笔记</strong><br />1、公司发展大了，相应的规章制度要与时俱进，过去行之有效的制度，对于一个规模扩大了十倍的企业未必适用。<br />2、大公司面试并非纯粹的考察学生知识点，而是考察他们的思考过程和应用知识的能力。例如：微软并不期待某个”正确“答案，而是看候选人如何解决问题，如何证明自己的观点。</p><h2 id="第027封信-微软曾经最大的竞争对手高盛"><a class="markdownIt-Anchor" href="#第027封信-微软曾经最大的竞争对手高盛"></a> 第027封信 微软曾经最大的竞争对手——高盛</h2><p><strong>重点笔记</strong><br />1、高盛对人的软实力非常看重，特别看重一个人的思维方式，以及遇到问题解决问题的方法。<br />2、高盛选拔人才三原则：基本的专业知识和与人沟通的基本技巧；用什么样的思路解决问题，比知道答案更重要；知道自己能力的边界，如果遇到超过自己能力的问题，懂得求助于别人。<br />3、世界上各行各业的精英的共性：善于解决问题，更看重方式方法，而不是简单地要结果。</p><p><strong>思考</strong><br />高盛的第三道面试题，如果你被压缩成一根铅笔，掉进了果汁搅拌机中，怎么出来？你有什么好的想法么？<br />1、避免危险。芒格曾说，如果知道自己会死在某个地方，就不去那里，而投资亦然。风险意识优先于报酬，损失50%，则需要获利100%才能回到初始资金。既然刀子在正中间，则首要任务是避免接近，尽力向边缘靠着，才能安全。<br />2、适时求救。保留体力，在能帮你的人出现时，才大声呼救。职场上防人之心不可无，若找到没能力或压根不想帮你的人，费尽唇舌转述目前困境，也得不到任何帮助。<br />3、最后，若没人能适时帮助你，一定要在deadline前，向上级报告任务的困难，以及要求将工作分配给适任的同事。<br />当然，出来后要复盘，避免再次发生危机，是下次进步的基础。李宗盛的《山丘》里歌词，世界上有两类人，”无知地索求“和”羞耻于求救“，后者有更多的好奇心，勇于探索答案；但，遇上大麻烦、超出自己边界的事，一定要有意识地积极向外索求。</p><h2 id="第028封信-信息时代对人才技能的要求晶体管发明者肖克利的经验教训"><a class="markdownIt-Anchor" href="#第028封信-信息时代对人才技能的要求晶体管发明者肖克利的经验教训"></a> 第028封信 信息时代对人才技能的要求——晶体管发明者肖克利的经验教训</h2><p><strong>重点笔记</strong><br />1、如今选拔人才的特点：竞争某一个职位的众多候选人，通常专业水平都不差，因此要比专业水平以外的能力；很多工作未来所需要的技能在当下的大学里并没有教授，掌握新知识得靠自己的悟性和努力。<br />2、肖克利强调智力和研究能力的重要性，而不太看重年轻人的专业背景。并且认为人的智力水平可能比起跑早了半拍要重要得多，这一点今天美国的跨国公司都认可。</p><p><strong>思考</strong><br />结合肖克利的做法，今天请大家思考一下，在信息时代个人的什么素质，比知识本身更重要？<br />未来社会比知识更重要的是个人核心素质：<br />第一，个人能力<br />创新力；思维能力；全球化视野<br />包括：独立思考，分析和解决问题，多元思维，跨文化交流，外语学习，快速适应力<br />第二，群体中能力<br />领导力；有效沟通能力；人际交往和协作能力<br />包括：语言沟通，同理心，良好关系，结成伙伴，团队协作，群体认同</p><p>特点：<br />1、长期培养，不易丧失<br />这些能力是逐步增强培养获得的，必须在不断的使用中积累，它不是一个公式或者一个概念，同样在获得之后也不容易被很快超越和淘汰；<br />2、交叉综合，多个维度<br />这些能力都不是单一概念，不是某个学科，某个专业技能，而是一个人整体协同的行动和思考能力，是多方面、多角度的因素共同融合形成的复杂系统。<br />所以未来我们获得教育的目的不仅仅是获得一项技能，更是培养个人在未来世界中生存的综合能力。技能也许是会过时，但综合能力却能让个人更好地适应环境的变化。</p><h2 id="回信精选-知识之外的个人素养"><a class="markdownIt-Anchor" href="#回信精选-知识之外的个人素养"></a> 回信精选 知识之外的个人素养</h2><p><strong>重点笔记</strong><br />总结一：<br />知识之外尤其重要的个人素质包括三类意识，分别是：<br />1、明确方向和目标的交付意识：<br />一个人倘若知道自己要去哪儿、要做什么，他才会去积累相应的知识，才会为了那个方向去努力。而交付，是对方向和目标的反馈，可以在积累知识的过程中不断获得调整和修正的空间。<br />2、直面未知和未来的愿景意识：<br />我们进入了一个高速发展和变革的时代，知识迭代的速度越来越快，老方法解决不了新问题，这都是无法逃避的现实。这时候，坦然接受自己当下的不足，接受自己很多经验已经无用过时的现状，学会不断清空自己、谦卑地做一个终生学习者才是立足的根本。<br />3、开放坦诚地沟通和分享意识：<br />这一点在日常的沟通交流中格外重要。沟通是双向的，选择也是相互的，能把要求放到明面上来探讨，反而多了达成协作的可能，比相互试探、彼此迁就弄得大家都不舒服来得好。</p><p>总结二：<br />因为社会发展的一些趋势，我们的学习发生了很大的变化：<br />1、学习和工作无法区分、相辅相成。<br />未来，在你20多岁从大学毕业之后，一直到你退休之前，你仍然要继续更新你的知识体系。<br />2、跨领域的通用人才更受欢迎。<br />新时代的模糊、无界等等趋势，导致我们无法区分专业，我们需要复合型人才。<br />3、思考和实践在学习中占比更高。<br />大脑被解放出来干嘛呢？思考和创新。学习思考方法，比背诵知识，在这个时代要有用得多。<br />4、沟通、创新等能力的学习更重要。<br />5、需要理解整个商业社会的运行规则。<br />达沃斯世界经济论坛，在2016年公布的一份报告显示，2020年职场最重要的十项能力分别为：解决复杂问题的能力；批判性思维；创新力；人才管理能力；协作能力；情商；决策能力；服务意识；谈判能力；认知的灵活性。以上十条，都是软实力。</p><p>总结三：<br />知识之外的个人素质还有以下几点：<br />1、洞察力<br />罗胖在罗辑思维中谈到，好的洞察就是对事物最精准的比喻。这就要求我们对事情能进行深刻分析和理解，并且真正消化后，以准确的语言进行再解释。<br />2、组织与执行能力<br />工作中不仅需要提出好的想法，同时要有强有力的执行能力。知道该如何组织团队、制订计划、分解任务，并且达到目标。<br />3、社会交往能力<br />从项目管理上看，善于交往的人，能在工作中妥善处理矛盾，协调团队关系，推动项目向既定目标前进。<br />从公司经营上看，善于交往的人能更好地连接外部资源。<br />作为一个工科技术人员，我想我们不仅仅要在专业技术上提升，也要拓展自己的社交能力，才能实现“两条腿”走路。</p><p>总结四：<br />在当今信息时代，一个人除了所拥有的知识本身外，还有以下几方面的素质是不可或缺的，甚至是极其重要的。<br />1、眼界，洞察未来趋势的能力。<br />身处一个行业，如果看不到客户明天的需求，触摸不到用户的真正痛点，换句话说，无法为用户创造出新的需求和新体验，在很大程度上，这样的组织和个人，往往只能跟跑，无法领跑。<br />2、驾驭趋势。<br />在大趋势到来时，找准切入点，顺应大趋势，成就组织发展的同时，完成个人进化的能力。<br />凡事预则立，不预则废。在洞察到一个新趋势、新潮流即将到来之前，能否主动厘清并深入思考，个体或所在组织与新趋势的关系，找到切入点，将个体和组织融入到浪潮之中，这不仅需要专业知识，更需要大局观和强大的魄力，尤其是在众人皆醉我独醒时，坚持特立独行且正确的抗压能力。<br />3、践行，把想法一步一步转化为做法的能力。<br />能否把理想和新年愿望，转变成较为具体的目标；能否将目标变成切实可行的每日计划；能否把每日计划转化成实实在在的每日行动。想法与做法、想到与做到之间的距离远超出人们想象。这很可能是绝大多数人，常立志、常废志，立了废，废了再立，在这个死循环无法自拔的主要原因。<br />4、协作，知道自己能力的边界后，该怎么做的能力。<br />最高效简捷的做法就是：让专业的人做专业的事。两个现实的例子就足以说明协作在信息时代具有怎样的意义。十多年前几乎独霸手机业的巨头——诺基亚之死；苹果持续多年独占鳌头且持续辉煌，前者因不愿协作而死，后者因全方位、立体式协作而生。<br />从商业巨头的成败兴衰就不难理解协作的重要性。<br />5、容错，即在错误中学习的能力。<br />严以律己、宽以待人是一种容错能力；接受自己的不完美更是一种容错能力。我时常提醒自己，很多人把犯错看成是终点，而对于一个不断学习、持续成长、随时进化的个体和组织来说，犯错恰好是成长的试金石，是改善提高的基石，接受错误，拥抱失败，才是当下快速迭代的信息时代最应履行的原则之一。</p><p>总结五：<br />除了知识之外，优秀的人应具备的素质——自我驱动的能力。<br />驱动若来自内在，能有源源不绝的动力，能有力求完美的决心；驱动若来自外在，则会适得其反地学习，把乐趣磨耗成待办事项。<br />自我驱动，是知识以外，最重要的素质。以乔布斯的话来说就是： “找到自己热爱的工作，如果还没找到，不要放弃”。<br />因为热爱，所以不会满足于平庸；因为不满足，所以能耐心练习；而因为死磕，能发现同样有趣的灵魂，一起解决不可能的问题。这一切，都来自内心的驱动。<br />自我驱动，具体来说是热情、耐心和开放的态度。热情，所以保有好奇心，不断优化手艺和产品；耐心，愿意静下心打磨，透过自律来完成Z字型中的努力方程式；开放的态度，让偏执的人能具有团队意识。因为内心的驱动，让人明白，把事做成比什么都还重要。<br />再具体到如何培养和锻炼，就是从工作中，发现驱动自己的小事。情绪是骗不了自己的，当人对一件事的差池无法忍受，代表他有动力把事情做好，像乔布斯愿意在发布会前练习上百次演讲，并不单纯是他追求完美的性格，而是他对于差强人意的演讲，无法忍受。<br />回想自己在工作中，对什么地方很介意，即便下了班仍在思考如何完善、即便不在考核范围内也想做好，那正是你能发挥热情的地方。找到不满足之处，发挥热情，然后耐心、反复地练习，这或许是工作最快乐的时光。接着，遇见怀抱同样热情的人，一起把“小事”做成“大事”。<br />数学家H.W伊弗斯曾说：“一个难题的解答者，必须具备两种不协调的素养：永不安分的想像，以及极具耐心的执拗。”<br />边界，需要自我驱动的勇者去开拓。怀抱好奇，耐心坚持，世界因你而不一样。</p><h2 id="第029封信-发明背后的逻辑飞行"><a class="markdownIt-Anchor" href="#第029封信-发明背后的逻辑飞行"></a> 第029封信 发明背后的逻辑——飞行</h2><p><strong>重点笔记</strong><br />1、当一个人有条件，在考虑做点什么有益的事情时，不妨把目标定得高远一些。<br />2、模仿是人类学习的第一步，这本身没有什么可耻的，真正可耻的是走不出模仿，永远模仿。<br />3、很多违背理论的行为，源于我们感性的想法和做法。<br />4、要勇于承认错误，这样才不至于在错误的道路上滑的太远。</p><h2 id="第030封信-莱特兄弟成功的关键不打无准备的仗"><a class="markdownIt-Anchor" href="#第030封信-莱特兄弟成功的关键不打无准备的仗"></a> 第030封信 莱特兄弟成功的关键——不打无准备的仗</h2><p><strong>重点笔记</strong><br />1、人的天性是喜欢做新的东西，匆匆忙忙就使用，不喜欢反复测试。恰恰试验和测试非常重要，这一点是很多人所忽视的。<br />从莱特兄弟的经验可以看出，宁可多试验，多测试，也不要莽撞地把产品推出去冒险。<br />2、成功最重要的是靠走出模仿。<br />3、重大的发明需要经历两波甚至更多的失败，才能获得最后的成果，而发明的功劳总是给予最后一个发明家。</p><p><strong>思考</strong><br />为什么重大的发明，总是归功于最后一个发明家？<br />对于重大的发明，最后一个发明家所完成的往往是具有方向性的临界突破。一个发明，从无到有，在他的努力下最终呈现出来，他自然就在聚光灯下。聚光灯效应会使得人们更多地把目光放在他的身上。<br />这就像足球运动，此前所有的积累固然引人入胜，但最后临门一脚的入门，不管是运气还是实力都会让人欢呼。</p><h2 id="第031封信-为什么飞机不能飞得更快"><a class="markdownIt-Anchor" href="#第031封信-为什么飞机不能飞得更快"></a> 第031封信 为什么飞机不能飞得更快？</h2><p><strong>重点笔记</strong><br />1、把超音速飞机创新和超越的过程概括成三步就是：“回到原点重新思考，重复过去成功的工作方法，根据新问题适当增加新方法”。这适用于各行各业。<br />2、任何让人花钱找罪受的产品都很难盈利。<br />3、在商业上，不仅要关心一个东西好不好，还要问一下贵不贵。</p><h2 id="第032封信-航空业需要一个特斯拉"><a class="markdownIt-Anchor" href="#第032封信-航空业需要一个特斯拉"></a> 第032封信 航空业需要一个特斯拉</h2><p><strong>重点笔记</strong><br />1、飞机行业发展缓慢，除了9.11的冲击，还要就是航空公司的垄断。飞机制造公司、航空公司和机场早已形成了巨大的利益共同体。<br />2、外来者进入一个新行业时，通常会采取低价格的方式，在不起眼的边缘市场和传统的行业巨头展开竞争，然后当自己发展壮大后，再试着挑战行业的主导者。而特斯拉则是反其道而行之，先从最高端的市场开始进入。<br />3、航空业需要一个特斯拉一样的公司来“搅局”。</p><p><strong>思考</strong><br />个人觉着贴近平民生活的事物更适合走“农村包围城市”的策略，比如手机的搅局者——小米、电商的搅局者——拼多多、物流的搅局者——极兔等等，但是远离平民，靠近较为富有的人们的事物更适合走“城市包围农村”的策略，比如国内汽车搅局者——蔚来等等。</p><h2 id="答读者问08-为什么发明的荣誉总是给予最后一个发明家"><a class="markdownIt-Anchor" href="#答读者问08-为什么发明的荣誉总是给予最后一个发明家"></a> 答读者问08 为什么发明的荣誉总是给予最后一个发明家</h2><p><strong>重点笔记</strong><br />1、不要纠结谁早、谁晚，关键看谁能产生效果。<br />2、发明是一个漫长的过程，不会简单地一次完成。醉心于发明的人，需要有长期持久战的心理准备。<br />3、发明常常需要在前人量变的基础上形成质变，因此不太能够从0开始，需要站在前人的肩上。</p><p><strong>思考</strong><br />你考了99分，学霸考了100分，不要觉着你距离学霸已经很近了，你考了99分说明你实力只有99分，而学霸考了100分是因为试卷只有100分。</p><h2 id="google文化的最大特色之一tgif"><a class="markdownIt-Anchor" href="#google文化的最大特色之一tgif"></a> Google文化的最大特色之一：TGIF</h2><p><strong>思考</strong><br />你见过哪些公司比较有特色、有意义的企业文化？或者你自己在生活工作中有哪些对你有价值的仪式感？<br />小王子驯养狐狸后，第二天又去看它。<br />“你每天最好在相同时间来。”狐狸说。<br />小王子问：“为什么？”<br />“比如，你下午四点来，那么从三点起，我就开始感到幸福。时间越临近，我就越感到幸福。我就发现了幸福的价值…所以，应当有一定的仪式。”<br />“仪式是什么？”小王子问。<br />“它就是使某一天与其他日子不同，使某一个时刻与其他时刻不同。”狐狸说。</p><p>所以生活需要仪式感，这是对生活的热爱。<br />甚至是一种结束，或是一种开始。</p><p>节日的时候给朋友问候和礼物。<br />一个人也记得按时吃饭。<br />喝茶的时候要喝热茶。<br />收藏自己喜欢的东西。<br />偶尔弹奏一首自己喜欢的歌曲。<br />取得阶段性成果的时候奖励一顿大餐。<br />在喜欢她（他）的时候就去行动，安排一次浪漫的约会。</p><p>仪式感是即便你孤身一人也能做到，让自己感受这种感觉，就不会那么孤独。<br />仪式感的目的，是为了让你知道自己是在生活，而不仅是生存。</p><p>之所以需要仪式感，是因为它能让我们得到的小惊喜和喜悦更加延长更有价值。在很多乌云密布的日子，正是这些小快乐，才支持我们走过一天又一天。</p><h2 id="你从发明中得到了什么"><a class="markdownIt-Anchor" href="#你从发明中得到了什么"></a> 你从发明中得到了什么？</h2><p><strong>思考</strong><br />1、基因虽然决定了一个人发展的上限和下限，但是后天非智力因素如个人努力、成长性思维、刻意练习、家庭环境、专业指导同样非常重要。<br />2、印刷术发明的技术基础是两河文明的楔形文字、印度的印章文化、中国本土的纸张，这个时空中如果没有集齐其中任何一个技术，想破头也很难发明印刷术。这就好比怀孕，怀胎10月是最起码的时间要求，有了第一层积累，才会有下一层。<br />3、向没有借东西。发明创造的方法：找到一个值得解决的问题，然后研究它“不能做什么、没有什么、相反是什么、可以减少什么”。</p><h2 id="第033封信-为什么算盘是计算机"><a class="markdownIt-Anchor" href="#第033封信-为什么算盘是计算机"></a> 第033封信 为什么算盘是计算机？</h2><p><strong>重点笔记</strong><br />1、算盘是计算机。有了口诀控制，或者说指令控制，算盘才能算计算机，否则，它只是一个辅助的计数工具。<br />2、计算机可以做很多事情，具体做什么，则看背后的人是如何操控它们了。<br />3、有些发明，虽然一开始是为了某一个目的，但是后来很多人在此基础上将它进行功能性的扩张，它就成为了一个平台。比如：Google的搜索引擎，最初它只是用于查找信息，后来变成了互联网入口。</p><p><strong>思考</strong><br />硬件是舞台，软件是舞者。<br />舞台宽阔，当然能同时容纳成千上万名舞者。但如果有一个最好的舞娘，在一个小平台上。她依然会跳舞。她婀娜多姿，风情万种。<br />正如舞者比舞台重要，软件也比硬件重要。当今时代，欣赏舞蹈花的钱应该比搭场子多。为舞蹈付费，是因遇到了好舞娘，而非大场面。<br />软件亦如此。</p><h2 id="第034封信-计算机从简单到复杂"><a class="markdownIt-Anchor" href="#第034封信-计算机从简单到复杂"></a> 第034封信 计算机从简单到复杂</h2><p><strong>重点笔记</strong><br />1、发明的轨迹，就是为了让一种设备完成更多、更复杂的功能，发明会变得越来越复杂。这是发明的常态。<br />2、“控制”是计算机的本质之一。控制从人，到简单机械，这是一个渐进的过程，但是设计这些控制过程的永远是人。<br />3、当什么东西变得太复杂后，就要有人换一个思路进行发明，将它重新变得简单，这也是发明的大趋势。</p><h2 id="第035封信-计算机从专用到通用背后的逻辑"><a class="markdownIt-Anchor" href="#第035封信-计算机从专用到通用背后的逻辑"></a> 第035封信 计算机从专用到通用背后的逻辑</h2><p><strong>重点笔记</strong><br />1、人类总是根据不断增加的需求逐渐增加所发明的东西的复杂度，但是等非常复杂之后，就会有人开始进行更高层次的思考，搞清楚问题的本质，然后用简单的方法把它解决。<br />2、无论是自然界的物质、生命，还是人发明的计算机，都由大量极小的基本单元构成，探索世界奥秘和改变世界的过程，其实就是搞清楚它们的基本单元和构建它们之间关系的过程。</p><h2 id="第036封信-事倍功半-vs-事半功倍"><a class="markdownIt-Anchor" href="#第036封信-事倍功半-vs-事半功倍"></a> 第036封信 事倍功半 vs 事半功倍</h2><p><strong>重点笔记</strong><br />1、当世界上任何东西越做越复杂的时候，就是开始从复杂往简单转变的时候了。<br />2、一口吃一个胖子的结果可能是零。大的目标要分解成简单的，一个个解决。一个复杂的问题如果能拆成两个等价的简单的问题，成功的可能性就大很多，就可以事半功倍。<br />3、复杂度通常不是随着问题的规模呈线性增长的，而是呈指数上升。对不同规模的问题要采用不同的方法。</p><h2 id="来信补充-五级工程师和职业发展"><a class="markdownIt-Anchor" href="#来信补充-五级工程师和职业发展"></a> 来信补充 五级工程师和职业发展</h2><p><strong>重点笔记</strong><br />第五级，需要的是定义目标，完成任务的能力；<br />第四级，需要的是对领域内各个岗位和环节的了解，以及管理沟通的能力；<br />第三级，需要的是对行业、现状和需求的透彻理解；<br />第二级，需要的是对人性的理解，以及天赋；<br />第一级，需要的是对未来的洞见，以及运气。<br />可以看到的是，努力在提升自己的过程中起到的作用是有限的，充其量只是必要条件，而不会是充分条件。</p><h2 id="答读者问09-如何锻炼差异化思维"><a class="markdownIt-Anchor" href="#答读者问09-如何锻炼差异化思维"></a> 答读者问09 如何锻炼差异化思维？</h2><p><strong>重点笔记</strong><br />如果我们的心中想的是把事情做得更好，做出来的，自然和以前的不一样，不用强调差异化，必然有差异化。因此，对于这方面的训练，重要的是把东西做得更好。</p><h2 id="回信精选-可提升的思维方式"><a class="markdownIt-Anchor" href="#回信精选-可提升的思维方式"></a> 回信精选 可提升的思维方式</h2><p><strong>重点笔记</strong></p><h2 id="第037封信-我们真的清楚为什么上大学么"><a class="markdownIt-Anchor" href="#第037封信-我们真的清楚为什么上大学么"></a> 第037封信 我们真的清楚为什么上大学么？</h2><p><strong>重点笔记</strong><br />1、时间一长我们已经忘记了当时做那些事情的真实目的，只剩下形式了。如果做到了这个地步，我们的努力显然就和结果不相关了。<br />2、搞清楚为什么上大学很重要。目的没搞清楚，将来的动力就成问题，结果也就要大打折扣了。</p><p><strong>思考</strong><br />与其说大学最应该培养哪些技能，不如说哪些技能对未来一辈子都有用。<br />1、独立思考的能力。<br />无论是追求形式、忘记初衷，还是随大流，都是丧失了独立思考能力的表现。独立思考能力主要有以下三个方面：</p><ul><li>整合信息、抽丝剥茧的能力。如今信息洪流随时就能把我们淹没，如何将纷繁复杂的信息整合成自己的理解，如何通过现象找到背后的本质越来越重要，只有整合成自己理解的信息才谈得上是真正的知识。上周吴军老师认为算盘有了口令控制才是计算机，这个口令控制就是有洞察的知识。</li><li>批判性思维。多佛尔角哨兵和洛阳皇宫宫女的故事，让我想起梁宁老师在《产品思维课》提到的去角色化思考：其实我们每个人在无法灵活切换自己的角色时，就是把自己变成了哨兵和宫女，一直在按照某个特定角色所框定的行为去处事。批判性思维从这个角度理解就是去角色化思考，回归那个有血有肉、真实的人。</li><li>系统思考能力。无论是在某个具体的当下陷入不良情绪无法自拔，还是工作中只对着一个非重点工作精雕细琢，还是无法思考当下某个具体行为对未来产生的影响，都是因为缺乏系统性思考能力，被困在当下这个特定的时空无法逃脱。<br />2、自主定义目标和任务的能力。<br />这点也是应试教育对大部分学生最具体的毒害，从小到大是父母一直催我们上学，是老师的唠叨一直催我们提高成绩，是学校的制度在安排我们的测验、期中考、期末考。即使是到了大学，也还是完全按照学校的考试安排来生活——期末考前复习一下就好了。我们从小就习惯了被安排的生活，于是大多数人都被“无痛截肢”般剥夺了自主定义目标和任务的能力，而这种能力恰恰是职场上非常需要的。<br />3、人际交往能力、写作和演讲能力。<br />每个人都生活在一张网里，这张网时间和空间上把我们和过去、现在和未来的人联系起来，即使我们不在网络中心，也一定要意识到自己在这张网里。同时，这张网不仅是物理世界的网，也是精神世界的网，一代人与一代人之间，个体与个体之间，传递其实是意义，肉身不过是意义的临时住所，对自我和社会的关系有了这个基本认识，就会知道这三种能力有多重要。沟通和表达的第一要义不是技能和套路，而是真诚——我在乎和你的关系，我关注你的感受和需要，我是不是发自内心地有话要说。<br />4、做事的专业素养。<br />除了吴军老师之前提到过的“不断追求更好的答案”，最主要的专业素养是围绕对方的需求、以产品化思维去做事。</li></ul><h2 id="第038封信-为什么现在的大学教育已不足以培养出精英了"><a class="markdownIt-Anchor" href="#第038封信-为什么现在的大学教育已不足以培养出精英了"></a> 第038封信 为什么现在的大学教育已不足以培养出精英了？</h2><p><strong>重点笔记</strong><br />1、求学和谋生是分开的，求学要么是为了进入上层社会，要么是为了追求真理，不是为了简单地找一份工作。<br />2、今天很多认为上大学无用的人，评判有用和无用的标准其实比古人那种读书能否成为士绅的标准，并没有什么进步。<br />3、以培养技能为核心的高等教育不仅对社会有好处，在工业革命初期对平民脱贫致富也是最有效的。</p><p><strong>思考</strong><br />为什么要上大学，为什么要上好大学？<br />读好大学为了让我们可塑性最强的时候，因学校优秀的氛围形成正确的世界观。<br />专业，即为在大学所学专业、专业配套设施和学科名师，你若在北大光华经济管理学院学习，想必经济专业知识要比普通大学培养的学生要强。<br />氛围，则指你身边同学、老师、学校的作风，比如同学孜孜不倦的求知欲，老师教授你知识还有做人的道理，学校的校风、校训等。<br />那么多年过去，专业知识有的遗忘，有的迭代升级，而学校氛围引导我塑造的世界观影响至最深。</p><h2 id="第039封信-为什么要上大学还要上好大学"><a class="markdownIt-Anchor" href="#第039封信-为什么要上大学还要上好大学"></a> 第039封信 为什么要上大学，还要上好大学？</h2><p><strong>重点笔记</strong><br />1、上大学不仅让人成为未来社会精英的可能性增加很多，退一步讲，即使不能成为精英，获得幸福生活的可能性也大很多。<br />2、上大学很重要的目的是提高自己的格局。<br />3、上大学的目的之一，其实是要完成从草根到中产阶级，从平民到精英，从一个社会的消费者到一个贡献者的准备工作或者所必要的训练。</p><p><strong>思考</strong><br />完成大学教育和成为精英之间所欠缺的是哪些地方？<br />看见的和听到的，经常会另你们沮丧。世俗是这样强大，强大到生不出改变它们的念头。可是如果有机会提前了解了你们的人生，知道青春也不过是只有这些日子，不知你们是否还会在意那些世俗希望你们在意的事情。——《无问西东》</p><h2 id="第040封信-在大学你需要补充自己哪五种训练"><a class="markdownIt-Anchor" href="#第040封信-在大学你需要补充自己哪五种训练"></a> 第040封信 在大学，你需要补充自己哪五种训练？</h2><p><strong>重点笔记</strong><br />在大学你需要补充的五种训练：<br />1、看透钱<br />2、先学会服从、合作；学会当助手、当领导<br />3、认清边界，学会在边界里做事情<br />4、把自己培养成健全的人<br />5、树立信仰</p><p><strong>思考</strong><br />你认为在大学，学会哪些技能最重要？<br />在大学，最重要的目标之一，就是从会考试的学生，到成为懂得生活的社会人。<br />以《见识》中提的三件事：谈场恋爱、培养挚友和参加活动，展开论述。<br />前两者，是为了明白人情世故；末者，是要能通达事理。从健全的人、拥有信仰，到服从合作、学当领导，这是从个人自控到影响众人的修习之路。关于信仰，早已不限于已往认知的宗教，包括信仰爱情、艺术或权力，都是人文主义体现，在认知的茫茫大海中，抓着什么浮木前行，决定自己成为什么样的人。<br />通达事理，就是能把事情尽可能做好和完善。虽然讲起来容易，但实际上围绕一个核心——风险意识，因此得出防御思维、先谋败，以及缓存的重要。当中，钱，就占了决定性的角色，它左右一件事能不能成功的关键。看透钱，就是会用钱。攒着守财不是个明智之举，真正有钱的人，不是他拥有多少财富，而是他能运用多少财富。<br />知书达礼，从书本到生活，从知识到人情事理，这是在大学成为精英的必备训练。</p><h2 id="来信补充-高等教育的目的是什么"><a class="markdownIt-Anchor" href="#来信补充-高等教育的目的是什么"></a> 来信补充 高等教育的目的是什么？</h2><p><strong>重点笔记</strong><br />1、知识分道和术，道不能解决生存问题，但能改变人的一生，让人不断获取术。术能解决生存问题，但只是一时的。大学里还是学习道更加重要，短短四年，应追求改变一生的东西。<br />2、大学塑造一个人的格局，包括外在视野的格局，和内在精神的格局。视野格局决定你能走多远，精神格局决定你能走多稳。秉承大学教育的宗旨，即便没有大展宏图，也能在自己的领域和岗位发光发热，在平凡的生活中领悟幸福的真谛。</p><h2 id="答读者问10-为什么要学会服从"><a class="markdownIt-Anchor" href="#答读者问10-为什么要学会服从"></a> 答读者问10 为什么要学会服从？</h2><p><strong>重点笔记</strong><br />服从的本质，是在某一个自己刚进入或不熟悉的领域，通过先跟从前人制定的规则，把与人合作的成本降到最低。那些前人制定的规则，或许是因为比你更有经验，所以总结出了更有效率的方法；或许是站在了更高的视野，为了全局的利益放弃一部分个性。<br />所以无论如何，在任何领域刚起步的时候，服从都是最理性的选择，因为个人的智慧实在很难超过前人的积累和高处的视野，且分工合作才能带来更高的效率。<br />而“特立独行且正确”，在对一个领域没有超过大多数人认知的情况下，常常是错觉。</p><h2 id="回信精选-在大学学会哪些技能很重要"><a class="markdownIt-Anchor" href="#回信精选-在大学学会哪些技能很重要"></a> 回信精选 在大学学会哪些技能很重要？</h2><p><strong>重点笔记</strong><br />大学生要学会最重要的四个技能：<br />一、赚钱<br />一个人想独立的前提首先是经济独立。在大学毕业之前的20多年，我们都受到了全社会的刻意照顾，但此后不再有了。真实社会并不会对你再像对待学生一样友好，掌握赚钱技能是维持生活的基本要求。在踏出校园的那一刻，无论做什么工作，都至少要能养活自己，不再向父母伸手要钱。况且只有你能养活了自己，才能让爱你的人放心。<br />二、社交<br />简单来说，世界上的顶级学府在知识层面的传授与第一梯队的大学相差不多，但差别就在学生本身。无论是身处一流大学，还是二流大学，都要融入一个好圈子。<br />社交并不意味着只在同龄人之间，也在于与长辈沟通。在踏入社会以后，我们会与各年龄的人交流、合作。如果能学会与长辈相处，并向之学习，你会收获良多。倘若有欣赏你的长辈愿意提供成长机会，也会比自己走快多了。<br />要进好圈子。<br />要与优秀人相处。<br />要虚心，要说不懂，别怕脸红。<br />三、品鉴<br />人生的本质是生活，但生活可不只学习与工作。在大学，我们有意识地培养自己做有趣味、有格调的人。社会等级的划分在今天早已不再是财富这一标准，而是由品位、格调决定。<br />当你开始有了品鉴上的追求，再面对那些华丽却无内涵的事物时，更能做到心静。当你考虑如何分配闲暇时间时，会把精力聚焦到真正有意义的事上，那会对你受用终身。<br />四、学习<br />到今天，大学绝对不再意味着学业终结，反而是终身学习的开始。在这飞速变化的时代，只有通过不断学习才可能跟上世界疾驰的速度。<br />在大学最该学的技能是“深入学习”，掌握一套最适合自己的方法论。这件事情上有三点分享：<br />1、管理时间<br />每个人时间有限，并不能如愿学完所有内容，因此一定要做减法。把注意力集中到重要的事上，一件事做到100分远比两件事做到90分更重要。<br />2、阅读学术论文<br />大部分学生是在要写论文的时才开始了解论文的，但论文价值远远被低估了。好论文是作者精心编辑后的系统输出，信息冗余度远比教科书低。研究透一篇论文，需要补充很多知识。而发现这些知识的过程也是一种精进。此外我们清楚，学习的最好方法是“扑名师”。但倘若没有顶尖老师，论文的价值就显现出来了，它能在一定程度起替代作用。<br />3、阅读<br />阅读是件终身受益的事。在不知不觉中，读者会在阅读时把书的线性思维在心中重构成体，这是件了不起的事儿。阅读对语言能力的影响颇深，会随着年龄越大越明显。演讲、写作等一切大规模影响力武器也都少不了阅读的输入。<br />阅读既是偶遇新知、积累素材的重要手段，又是了解大师思想的重要途径。因此，终身学习少不了它。</p><h2 id="第041封信-为什么要学习语文"><a class="markdownIt-Anchor" href="#第041封信-为什么要学习语文"></a> 第041封信 为什么要学习语文？</h2><p><strong>重点笔记</strong><br />1、阅读理解能力在通信上可以被看成是接收信息。信息既然有接收，就有发送，而发送信息是我们所谓的表达能力。它包括书面表达能力和口头表达能力。今天，没有表达能力的人，不仅不会有很好的职业发展，交朋友也会有障碍。<br />2、学好语文能够让我们做事情更职业化。<br />3、通识教育更重要的目的是它对其他学科学习的影响，对于表达和沟通的作用，以及对于成为职业人士的必要性。</p><h2 id="第042封信-为什么要学习数学课"><a class="markdownIt-Anchor" href="#第042封信-为什么要学习数学课"></a> 第042封信 为什么要学习数学课？</h2><p><strong>重点笔记</strong><br />1、要想考好数学，首先是阅读理解，其次是建立比较完整的数学知识体系，第三是善用逻辑。<br />2、在阅读理解中，很重要的一条是理解暗喻，也就是从字的表面理解深层的意思。<br />3、学习数学的目的首先是阅读理解，第二是培养逻辑能力。</p><p><strong>思考</strong><br />请你谈谈，通识教育中，哪个科目比较重要，为什么？<br />理解暗喻，在特定条件下的暗喻，是解决难题的核心条件。<br />在做题时，可以把条件在脑海里罗列出来。然后看解题所需要哪个条件。一般来说，总是那个特殊的暗喻对解题最有帮助。除此之外，暗喻与明条件的结合，往往是为了解决核心步骤。总有一些难题比较绕，但如果用好暗喻，一步步推倒一般都能解出来。如果不能解出来，直接跳过，把全卷做完了，再看一次，说不定就明白了。<br />学数学能做到推出定理，基本就证明知识水平达标了。但我们的老师很多时候，会让学生“背定理”，然后再运用。这其实是本末倒置了，如果能按逻辑推倒出来，那么对待各种题都知道该怎么拆分，该怎么解。<br />学一门课目最好的方法就是：学定理。<br />检验是否学好定理的方法在于，证明定理。在学霸眼中，一条定理，是活的，是能兼容很多情况的。就一条定理，学霸或许能写下一个网状知识链。<br />数学是培养逻辑思维与读懂暗喻的最便捷的方式，因此，适合大多数人学习。</p><h2 id="第043封信-为什么要学习历史"><a class="markdownIt-Anchor" href="#第043封信-为什么要学习历史"></a> 第043封信 为什么要学习历史？</h2><p><strong>重点笔记</strong><br />1、学习历史是为了清楚我们自己所处的位置，并且看清楚未来的方向，以便在一个大规模的时间和空间内看待问题。<br />2、学习历史是掌握一种客观公允，而且能够超出时代的看问题的方法。<br />3、学习历史是为了学会做研究。<br />4、最后，学习历史可以了解今天世界文化的多样性，培养自己的包容性。</p><p><strong>思考</strong><br />请你谈谈，通识教育中，哪个科目比较重要，为什么？<br />历史教会我们的是跨越时代的迷雾来培养一种大局观，现在发生的很多事情放到历史长河中只是沧海一粟、昙花一现。另外，熟知历史可以给当下提供很好的借鉴，历史不会重复，但总是惊人的相似。熟知历史的经验教训可以帮助我们博采众长、取长补短，也可以避免在类似的悲剧上重蹈覆辙。<br />施展老师在他的《中国史纲》中说过，看待历史要分两个方面，一是历史事实，二是对事实意义的解读，这是两回事。通过对史事意义见仁见智的解读，可以培养我们辩证看待问题的能力，不会被单一事件局限了思想。任何匪夷所思的事件放在当时的历史背景下都有其存在的意义，我们能够跳出当下走进历史当中看问题，才算是学习历史的正确打开方式。</p><h2 id="第044封信-为什么要学习科学"><a class="markdownIt-Anchor" href="#第044封信-为什么要学习科学"></a> 第044封信 为什么要学习科学？</h2><p><strong>重点笔记</strong><br />1、学习科学首先是掌握一种看待世界和解决问题的方法。<br />2、学习科学的第二个目的是培养基本的科学素养。<br />3、学习科学的第三个目的是帮助我们获得可叠加的进步。<br />4、学习科学的第四个目的是成为一个讲道理的人。</p><p><strong>思考</strong><br />请你谈谈，通识教育中，哪个科目比较重要，为什么？<br />通识教育能让人拥有一个优秀的操作系统，有了优秀的操作系统才能安装运行各类优质的应用，不然根本运行不了。<br />语文是最基础的，学好了语文才能通过阅读理解学好其他科目。数学则是在语文基础之上的逻辑框架。学习历史和科学则能够帮助我们更好的选择自己需要的应用，并且写好“代码注释”，让后人能看得懂，用得上。</p><h2 id="答读者问11-成年后如何进行通识教育"><a class="markdownIt-Anchor" href="#答读者问11-成年后如何进行通识教育"></a> 答读者问11 成年后如何进行通识教育？</h2><p><strong>思考</strong><br />1、最好的学习方法，就是把自己看成是一个学校里的学生，读教科书，做作业，找人讨论，向人请教。这也顺道解释了“碎片化学习”的正确姿势应该是：通过“碎片化时间”了解，再用“系统化时间”阅读、练习、思考、讨论、请教。“打开一扇门”和“走完一条路”的水准和深度是全然不同的，不能本末倒置。<br />关于投资和防范风险，“先弄懂再尝试”是前提，“有定力”是保障，“自我升值”才是必须。<br />2、国内外的大学，不管是一流的如哈佛，耶鲁，普林斯顿，霍普金斯，斯坦福，还是国内的清华北大等，无一不是强调学习的重要性，在这样的大学门口，很少会有商业气息浓郁的地方，大学宿舍和图书馆，也是侧面体现出一个学校的学习氛围。<br />所以，上一流大学首先得到的是一种环境的熏陶，在那种高强度的学习环境中，个人是很难放纵自己敷衍了事的，除了正常的作息之外，已经很难挤出时间去做其他事情了。而如果在这样注意力高度集中的情况下，还能把时间安排得游刃有余，这就锻炼了人的规划统筹能力了。在这样的环境下训练出来的人，走入社会后大多数会在工作压力中很快适应，因为对他们养成的习惯来说，忙碌才是常态。而且，由于长期高强度的学习，他们走入社会后，也会把终生学习作为长期坚持的事。</p><h2 id="硅谷来信哈佛校长艾略特的教育思想"><a class="markdownIt-Anchor" href="#硅谷来信哈佛校长艾略特的教育思想"></a> 《硅谷来信》——哈佛校长艾略特的教育思想</h2><p><strong>重点笔记</strong><br />1、艾略特的考察不是“术”的考察，不仅是学习学科设置或培养方法，而是考察受教育者如何通过受教育改变自己的人生。还进一步体会到高等教育和实业发展之间的密切关系，这种思想的收获，使得他后来对哈佛的改革方向非常符合社会需要，是所有哈佛教育创新中的核心思想。<br />2、艾略特有机会进入美国最大的纺织企业做高管，但他选择从事教育，其原因是“在他看来，当一名公司老板，只能影响这个公司，而去做一名教育家，则有可能影响整个社会。”他的个人发展道路选择，也是战略性的思考，而不仅是眼前的利害得失。<br />3、几乎所有改革是要得罪人的，既有利益者往往会阻挠改革创新，《大学之路》中引用萨缪尔·莫里森的话评价艾略特成功的原因“……原因之一是他比自己的反对者们更有活力，活得更长（以高寿92岁过世）。”我感觉这不是笑话，而是很多人战胜环境、战胜对手是战略，就是坚持到对手们都过世。也足见坚持锻炼、克己养性的重要性。<br />4、实事求是的创新精神。艾略特对学科的升级改造和对于学生选课方式的改革都是基于美国当时的国情和自己教育理念的结合。基于国情，改革就会受到国内的欢迎，理念先进但不盲目照抄，使得学习欧洲的大学不流于形式，而是“取其精华”、因地制宜、因时制宜。</p><p>教育者要想做到“因材施教”就应该理解“因材施教”背后的哲学思想是以人为中心，灵活的根据受教育者的状况与需求提供适当的教育类型，而不是刻板的执行自己的教学理念，而不顾长期效果是否有利于学生成才。</p><h2 id="回信精选-你认为通识教育中哪个科目最重要"><a class="markdownIt-Anchor" href="#回信精选-你认为通识教育中哪个科目最重要"></a> 回信精选 你认为通识教育中哪个科目最重要？</h2><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2021/letter/WechatIMG408.jpeg" alt="回信" /></p><h2 id="第045封信-幸福的含义"><a class="markdownIt-Anchor" href="#第045封信-幸福的含义"></a> 第045封信 幸福的含义</h2><p><strong>重点笔记</strong><br />1、人和当地的价值观相匹配利于提升幸福感。<br />2、国家对每个人有基本保障利于提升幸福感。<br />3、人与人之间相互信任利于提升幸福感。<br />4、丰富的社会生活利于提升幸福感。</p><p><strong>思考</strong><br />你认为什么是幸福？<br />共度一生的伴侣应具有的素质：灵魂契合、后盾、信任和丰富的生活。<br />话不投机半句多，灵魂契合的两人往往能想到一起，一个眼神就传递一件事的感受，当然，这来自两人细腻的观察和体贴。后盾指的是经济的支撑，信任指的是情感的堡垒，双方能在这两者之上建立共生的生活圈，才能有稳健的关系。<br />丰富的生活，代表双方都有高自尊和积极主动的个性。不健全的一种伴侣关系，是其中一人无所事事，成天倚靠对方而生活，没有自己的目标。不论是一人主外一人主内，或是双薪的家庭，本质都是协作发展，而不是背人过河。<br />这四点之中，省心让人想到了减法，生活要善做减法，除去不必要的事，保留余裕享受人生。忙碌会使人磨去洞察，走慢一点，让灵魂跟上。</p><h2 id="第046封信-休闲旅游的意义"><a class="markdownIt-Anchor" href="#第046封信-休闲旅游的意义"></a> 第046封信 休闲旅游的意义</h2><p><strong>重点笔记</strong><br />1、旅行的第一个意义是增长见识，对于他人告知的事情，亲身验证一下，才能记住，变成自己身体中的一部分。<br />2、旅行的第二个好处是帮我们走出自己平时生活和工作的圈子。<br />3、旅行的第三个目的是让我们了解自己。<br />4、任何人出门旅行，一定会有想法的，把它们记录下来，就成为了人生的阅历。有了这样的记录，旅行的收获会很大。</p><p><strong>思考</strong><br />旅行的意义其实就是寻找，寻找世界，寻找自己。<br />绝大多数人工作都会限定在比较窄的范围，接触到的人和事也有限，时间久了不自觉感到这就是生活的全部，视野和心胸可能就狭窄起来。旅行就是让我们走出日常的生活，看到原来世界这么广大这么精彩，那么多人幸福愉悦，那么多人饥寒交迫。增长见闻，亲身体验，切换视角看自己，都是旅行给我们带来的收获。<br />山本耀司说，“自己”这个东西是看不见的。撞上一些别的什么，反弹回来，才了解“自己”。旅行就是让我们去撞见未知的人，未知的事，未知的世界，未知的自己。</p><h2 id="第047封信-冬日冰岛之旅"><a class="markdownIt-Anchor" href="#第047封信-冬日冰岛之旅"></a> 第047封信 冬日冰岛之旅</h2><p><strong>重点笔记</strong><br />1、美和思想源自生活。吴军老师总是能从别人眼中平淡无奇的琐事和风景中发现美、提炼出反思，这种基于强大知识基础上对美和思想的探寻，领略到一种潇洒而精致的力量。<br />2、学会逆向思考。<br />3、旅游业发达的国家，不仅有美景，还有服务的周到。在《硅谷来信》中反复提到：只要做好那么一点点，就能给人带来更好的体验和感受。其实像前台的久候、对客房基础设施的介绍，原本完全是非必要的服务，但只要做到了，就会给人超出期待的惊喜，让人难忘。<br />4、世界上很多事情不完美，为以后留白，未必不是好事。为什么大家普遍认为，断臂的维纳斯比身体完整的维纳斯还要美？很大一部分原因就是这种残缺美反而给人更多的遐想空间，而“太满”反而会失去一种神秘。</p><h2 id="第048封信-歌剧浅谈"><a class="markdownIt-Anchor" href="#第048封信-歌剧浅谈"></a> 第048封信 歌剧浅谈</h2><p><strong>重点笔记</strong><br />1、很多品牌，它们会因为一种产品做得特别好而出名，然后它们又做了其他的东西。<br />2、在挑选学校时，想学什么，想成为什么样的人，就挑选最适合自己的大学，而不是仅仅看名气和排名做选择。</p><p><strong>思考</strong><br />你认为什么是幸福？<br />场景一：食品柜的最高顶，仰望的脖子发酸，搬起小桌子，摞起小板凳，踩着拉开的抽屉，终于够到糖果盒。打开的一瞬间，剥开糖纸的那一刻，含在嘴里眯起眼睛享受甜甜的滋味，窃喜着没有被大人逮到。——这便是小孩子的幸福时刻</p><p>场景二：教室安静亦紧张的空气里，数学题做累了抬起头，看到窗边那个人，也在同样的冥思苦想。紧促眉头，蛾翼般的浓密睫毛，映在金色温暖的午后阳光里翩飞。心下即随之一动：要是能在一起，就好了。——少年轻狂时的幸福时刻</p><p>场景三：多年在国外忙碌打拼，隔着时差，也隔着峰峦海洋。吃苦受挫隐忍不表，只报喜乐与平安。几番转机旅途劳顿，带着大包小包虽不昂贵却温暖贴心的礼物，带着思念和期盼，如夸父逐日般赶过春运狂潮。亲人相见时深深的拥抱，久别重逢下的执手泪眼，珍馐美味皆远不及的家常饺子。——这是成年后最弥足珍贵的幸福时刻</p><p>场景四：自编自导的舞曲，配着单纯喜乐的笑脸。步伐尚不熟练，动作也时有偏差。台下，却是那些残障老人激动欢喜的鼓掌叫好。演出后，和义工们合力做一顿百家爱宴。我常说，教会里的清茶淡饭，不知放下何种调味料，总是极美味可口。牧师有时会笑着说：大概有味调料，叫做爱。</p><p>幸福，最初是终于拥有自己所朝思暮想之物。然得到的同时，伴随继来怅然若失，于是效能总不持久。<br />幸福，是后来明白子女的成长，父母的老去，都像不断飞逝的时光一般。珍惜与家人的相伴，大过功名财富的追求。<br />幸福，是拥有健康的身体，能享受吃食的原始美味，香甜的安睡，干净和谐的自然资源。<br />幸福，是不再仅关注当下的自我。而是分享，关爱，给予，祝福。<br />谁言慈善是少数有钱人的专权？少一点冷漠，多一些关爱，陪伴，都是力所能及的慈善。<br />并且，拥有多少算是有钱？欲望没有终点，一旦拥有，我们就会自动的选择“视而不见”。幸福不是积攒堆砌，而是不断的开拓新知，体验新见。<br />幸福是管道，爱在其中源源不断的流淌，点亮世界阴暗的角落。<br />幸福，是对以往过去没有悔恨苦毒执念。<br />幸福，是对未来没有疑虑担忧惧怕。<br />幸福那里，没有信息不断狂轰滥炸的手机，那里没有挖井心思p图的虚假。幸福是用双眼拍下一个个动人的时刻，用心记录下所有温馨的瞬间。<br />愿每个人都能找到并珍惜所有的幸福时刻。</p><h2 id="来信补充-演奏大师的作品给我的启示"><a class="markdownIt-Anchor" href="#来信补充-演奏大师的作品给我的启示"></a> 来信补充 演奏大师的作品给我的启示</h2><p><strong>重点笔记</strong><br />透过音乐理解时代，透过死亡理解生命，我们往往就是因为这样一股力量和智慧而不断前行。<br />“过去一岁，我们一同经历了读书的乐趣，音乐的惊喜，电影的欢愉，旅行的际遇，知识的热情，友谊的福气。<br />过去一岁，我们一同体会了学习的魅力，遇见的神奇，付出的欣喜，生活的不易，情感的艰辛，时代的回应。<br />过去一岁，希望你不会气馁，没有失去。<br />因为既然选择了道路和前行，唯一的唯一，就是踏实和努力；一切的一切，就是继续和不屈。<br />所有的坚持、坚毅、坚强、坚定不移都不值一提。<br />所有的苦恼、苦难、苦衷、苦不堪言都应熟视无睹。<br />新的一岁，愿我能继续陪伴你，心有所想，劳有所得，学有所成，行有所获。”<br />生命不易，生命不息，把握当下，用尽全力。<br />祝老师和所有小伙伴新年快乐！</p><h2 id="答读者问12-为什么要学会一项技能"><a class="markdownIt-Anchor" href="#答读者问12-为什么要学会一项技能"></a> 答读者问12 为什么要学会一项技能</h2><p><strong>重点笔记</strong><br />1、不要被自己低效的重复感动到；<br />2、学会拒绝，不能表演勤奋；<br />3、再忙也能抽时间锻炼，越光鲜亮丽的人越能意识到这一点；<br />4、体质差除了天生，重点是自己不保养；<br />5、少抱怨，多行动。<br />任何事情做之前不要畏难，也不要空想，先去做，然后在遇到阻碍的时候想想可以怎样优化。<br />宁向东老师曾经提到了德鲁克的“成长逻辑图”，表现为“专注工作-担任责任-获得自信”的循环。这也正说明了进入任何一个新领域（包括职场），一切的源头在于“专注用心”地“做事”。<br />所以，别以为看起来的拼命有啥了不起，谁都可以健康到很娇气。</p><h2 id="回信精选-人生中的幸福时刻"><a class="markdownIt-Anchor" href="#回信精选-人生中的幸福时刻"></a> 回信精选 人生中的幸福时刻</h2><p><strong>重点笔记</strong><br />尼采说过：“知道为什么而活的人，便能生存。”<br />寻找生命意义的三个途径：工作（做有意义的事）、爱（关爱他人）以及拥有克服困难的勇气。<br />苦难本身毫无意义，但我们可以通过自身对苦难的反应赋予其意义。<br />在苦难中，一个人可能仍然保持勇敢、自尊、无私，也可能为了自我保护在激烈的斗争中丧失了人的尊严而无异于低等动物。<br />一些不可控的力量可能会拿走你很多东西，但它唯一无法剥夺的是你自主选择如何应对不同处境的自由。<br />你无法控制生命中会发生什么，但你可以控制面对这些事情时自己的情绪和行动。<br />只要我们拥有自主选择如何应对处境的自由，我们就不会一无所有。<br />不要只想着成功——你越想成功，就越容易失败。成功就像幸福一样，可遇而不可求。它是一种自然而然的产物，是一个人无意识地投身于某一伟大的事业时产生的衍生品，或者是为他人奉献时的副产品。<br />希望对那些正在经历苦难和挫折的朋友一些鼓励和面对之道。<br />撑过痛苦并且有所收获，也是幸福。</p><h2 id="第049封信-什么是风险投资"><a class="markdownIt-Anchor" href="#第049封信-什么是风险投资"></a> 第049封信 什么是风险投资？</h2><p><strong>重点笔记</strong><br />1、风险投资无需抵押，也不需要偿还。<br />2、风险投资的资金是让创业者在一定时期内，能够专心致志做自己想做的事情，不必为收入和成本发愁，而不是用来烧钱买市场。<br />3、风险投资的规模相比股市、私募基金、房地产、债券等市场，是非常非常小的。<br />4、风险投资的管理者擅长发现有潜力的创业者和项目，而不需要专注于资本运作。<br />5、从结果来讲，极少数的风险投资基金拿走了整个行业绝大部分利润。</p><p><strong>思考</strong><br />风险投资的利与弊<br />1、高额回报的诱惑。就好像做演员只有成为明星的很少的一部分人才赚了大钱，大部分的演员其实生活非常拮据，但依然有大批的年轻人投身其中一个道理。<br />2、推动进步的信念。一些已经财务自由的人，拿出一小部分资本，支持年轻人去改变世界。<br />3、幸存者偏误。人们太容易看到那些成功的风险投资，而失败者成为了沉默的大多数。</p><h2 id="第050封信-风险投资的起源和神话"><a class="markdownIt-Anchor" href="#第050封信-风险投资的起源和神话"></a> 第050封信 风险投资的起源和神话</h2><p><strong>重点笔记</strong><br />1、风险投资是和创始人共同把事情做好，共享利益。<br />2、高风险并不意味着必然有高回报。<br />3、高回报的投资通常来自于，对技术和产业独到的见解，而不是因为善于算经济账。</p><p><strong>思考</strong><br />风险投资的利与弊<br />风险投资对世界最大的贡献是鼓励了技术创新，并为技术进步筛选出了方向。<br />风险投资的项目，是技术和资本的合作。技术只管负责创新，资本负责买断风险。因为技术创新没有方向，人类技术进步是随机的，那么失败的风险其实等于被风险投资买走了，虽然它们因此也得到了巨大盈利的可能。<br />单个的风险投资基金可能失败，但风险投资资金的整体，是笃定相信人类技术进步的概率，他们买断的是一个概率权！从统计学的期望来看，他们是一群相信技术进步的力量，能够带来足够回报的人！<br />在我看来，风险投资是逐利资本和渴望改变世界的偏执天才们最好的结合，资本在为他们的梦想买单，因为资本相信明天会更好。</p><h2 id="第051封信-风险投资基金是如何运作的"><a class="markdownIt-Anchor" href="#第051封信-风险投资基金是如何运作的"></a> 第051封信 风险投资基金是如何运作的？</h2><p><strong>重点笔记</strong><br />1、风险投资与私募的投资不同，它是追求几倍，几十倍甚至更多的回报，估价差出50%问题不大，但是看错了人，则要血本无归。<br />2、在风险投资基金中，人员的职级和管理的权限和其他金融公司没有太大的区别，职位最高的也是基金的合伙人。</p><h2 id="第052封信-风险投资如何帮助创业公司成长并获利"><a class="markdownIt-Anchor" href="#第052封信-风险投资如何帮助创业公司成长并获利"></a> 第052封信 风险投资如何帮助创业公司成长并获利？</h2><p><strong>重点笔记</strong><br />1、对于没有上市的公司，不管估值多高，创始人的财富都不过停留在纸上，只有钱落袋为安之后才是自己的。<br />2、总的来讲，投资人和创始人的利益是一致的，除非到了关门清算的时候。<br />3、投资人的股份在清算时有优先权，也被称为优先股。最早期的投资人常常能拿回大部分投资，甚至有利可图，后期的可能会亏损。<br />4、一个公司最终要靠盈利来获得财富，靠烧投资人钱，早晚有一天资金链会断裂。</p><p><strong>思考</strong><br />从风险公司多拿还是少拿，要看行业，看融资阶段，看公司情况。<br />1、因为公司估值是在变化的，所以一般创业公司都会多轮融资，而不是一次融资到位；在天使轮，一般企业要融到公司正常运营1到1.5年的资金；<br />2、如果公司很快就能自我盈利，那么创始人可能会考虑少拿钱，把股份留给自己和员工；<br />3、对于有网络效应的行业，尽量多拿钱。因为一般这种行业需要通过补贴来获取用户，竞争激烈。在没有形成7-2-1格局前，要持续烧钱，否则可能面临出局。<br />易到用车就是典型例子，当时周航认为手里的钱足够用了，本来可以多融资一些却没有多拿。结果滴滴等企业融资7亿美金，大肆砸钱的时候。易到无法跟进，市场份额都被滴滴快的抢走；<br />4、融资有一点要注意，就是尽快拿到钱。因为从接触到谈判，然后财务调查，再到确认投资意向，尽职调查，签订投资协议，最后打款，中间一般有好几个月的时间。如果企业不能提前进行融资，一旦资金吃紧，就可能出现股份贱卖的情况。</p><h2 id="来信补充-硅谷三家顶级风险投资公司的做事原则"><a class="markdownIt-Anchor" href="#来信补充-硅谷三家顶级风险投资公司的做事原则"></a> 来信补充 硅谷三家顶级风险投资公司的做事原则</h2><p><strong>重点笔记</strong><br />创始人讲故事不能按照公司发展的时间顺序来讲，这样篇幅长，也缺乏特点。<br />在一张名片背后应该清楚以下三点：<br />1、我们提供什么；（对所进入的市场做一个简要描述）<br />2、为谁服务；（消费者才是核心，有了消费者公司才有存在的价值）<br />3、为什么我们与众不同。（团队中有哪些成员，公司的价值观和信奉的原则）</p><h2 id="第53封信-风投之王约翰杜尔的投资哲学上"><a class="markdownIt-Anchor" href="#第53封信-风投之王约翰杜尔的投资哲学上"></a> 第53封信 “风投之王”约翰.杜尔的投资哲学（上）</h2><p><strong>重点笔记</strong><br />按照你的希望给你投资后，世界会有什么不同，哪怕有一点微小的，但是是正向的改变，也是好的。</p><p><strong>思考</strong><br />你从大人物身上学到过哪些经验？他们的智慧对你的工作、生活有哪些影响。<br />杜尔其实关注了三个问题：<br />1、你要做什么？（是改变不是提升）<br />2、为什么别人不做？（是否考虑周全）<br />3、为什么是你做？（是否具备核心竞争力）<br />其实这样的思路可以运用到很多场景中，比如“相亲”。<br />让我们模拟一个场景：假如你正在相亲，作为一名男生，如何通过一个简短的自我介绍给心仪的女孩儿留下一个好的第一印象呢？<br />1、你要做什么？（告诉她你的真实想法：想要认识你）<br />2、为什么不选择别人？（从她个人的角度出发，分析她理想中男生的形象：阳光、积极、有担当、顾家等，一般人不具备）<br />3、为什么选择你？（从男生的角度，告诉她你的优点，不仅以上都具备，而且睿智且有趣）</p><h2 id="第54封信-风投之王约翰杜尔的投资哲学下"><a class="markdownIt-Anchor" href="#第54封信-风投之王约翰杜尔的投资哲学下"></a> 第54封信 “风投之王”约翰.杜尔的投资哲学（下）</h2><p><strong>重点笔记</strong><br />1、第一个原则，就是要看创业者做的事情能对世界产生多大的影响。<br />2、创业除了人靠谱，项目好，时机也很重要。<br />3、风险投资的最好阶段是所谓的“潜行”阶段，也就是说在发展，但是大家并没有太关注到。</p><p><strong>思考</strong><br />你从大人物身上学到过哪些经验？他们的智慧对你的工作、生活有哪些影响。<br />绝大多数人虽然成为不了杜尔那种风险投资人，但杜尔的投资理念值得我们每个人借鉴。<br />1、看到机会、困难和风险。<br />现实中更多人是只看到了成功的机会，就幻想成功后带来的巨大利益和荣耀，却没有充分发现别人看不到的困难和风险。好的投资人都是知道如何避险的，预见困难程度，提前想出对策，评估最大风险，看是否能够承担。未谋胜，先谋败，才更有底气去做事。<br />2、今天的创始人=明天的企业家<br />新的领域总是要由新的人才和玩法引领突破的，识人就是从他今天的想法和表现是否具备开拓未来的能力，认准以后就做甩手掌柜，给予支持，让他放手去闯去干。<br />3、杜尔让所有被他投资的公司相互帮助。<br />联想到第一季吴军老师说的狗熊掰棒子的困境，努力需要一个积累的效应，第二次的努力要最大程度地复用前一次努力的结果，而不是每一次都是从头开始。投资公司之间互相帮助就是利用过往的优势资源，重视存量，积累增量，这样做事才能事半功倍，说不定公司间还能意外合作出新的创意火花。</p><h2 id="第55封信-股神彼得林奇成功的秘密武器"><a class="markdownIt-Anchor" href="#第55封信-股神彼得林奇成功的秘密武器"></a> 第55封信 股神彼得.林奇成功的秘密武器</h2><p><strong>重点笔记</strong><br />1、不要从众，既然大部分人在股市上都是赔钱的，从众一定不会有好结果。<br />2、要想得到别人得不到的回报，就需要找到别人不知道的信息。<br />3、当我们对未来一无所知或者所知甚少时，多一些尝试是无妨的，但是，要懂得止损，同时，要有耐心把好的东西长期持有。在这一点上，我把它扩展到交友的方法上了。<br />4、最多的资源要用到最有效的地方。在工程上也是如此，不要把80%的时间，浪费在不重要的小事上，而要集中精力，把最重要的事情做好。</p><p><strong>思考</strong><br />作为一个普通的工薪阶层，我很少能够与大人物近距离地接触，比如李笑来、罗振宇和樊登等。但是，这些我心目中的大人物对我的影响却是无法估量的。他们对我的影响有几个方面。<br />影响1：耐心。<br />罗振宇在经营“得到”之前，在《罗辑思维》栏目中，每天早上做60秒钟的语音分享，持续时间长达2年之久，也正是从那时候起，倾听“每条60秒语音”并及时记录自己的思考成了我每日精神早餐必备，也让我重新拾起了写作习惯。<br />影响2：精耕细作。<br />即在一个很窄的领域深挖细嚼的拼劲。有一个形象的类比，绝大多数的人是在很多个领域挖掘深度通常是1毫米，而只有极少一部分人，是在那1毫米宽的领域（如给人读书、让专家给普通人解读专业规律、和更多的人一起建设一所未来大学、持续思考数字货币的未来等）挖掘的深度是1公里，比如罗振宇的每天60秒语音，李笑来老师在比特币（区块链）领域连续数年的探索，吴军老师的《谷歌方法论》等。都是在自己熟知的领域持续地、深入地、精耕细作所沉淀出的可以给更多人带来价值的事情。<br />影响3：链接他人。<br />无论是罗振宇的《逻辑思维》还是“得到”；李笑来的“学习学习 再学习”还是“新生大学”，吴军老师的《硅谷来信》还是《谷歌方法论》，这些都无一例外地成为把具有共同志向、兴趣和对未来抱有希望的无数个体链接起来的，形成了无形而巨大的群体的驱动力，即创建部落、营造部落文化、与部落一起共成长。这种不同寻常的“部落”已经和正在成为现代社会的一种标尺，一种持续的正向驱动力，为社会的进步注入源源不断的动力。<br />回头看，虽然与这些大人物连一面都没有见过，但这丝毫不影响像我这样不甘平庸、向往并身体力行地追求未来的人们追随和学习这些大人物的愿望和动力。值得庆幸的是：每天阅读、思考并写作成为我每日早晨的必修课，我因此而获益匪浅。我特别喜欢李笑来老师对于“希望”的诠释：所谓希望，是指相信通过自己今天的努力能够让明天变得更好。言简意赅。</p><h2 id="第56封信-投资大师比尔米勒的成功秘诀"><a class="markdownIt-Anchor" href="#第56封信-投资大师比尔米勒的成功秘诀"></a> 第56封信 投资大师比尔.米勒的成功秘诀</h2><p><strong>重点笔记</strong><br />1、做人也应该有米勒所说的“最大价值”，也就是说，我们到底能提供什么别人提供不了的价值。<br />2、我们做一件事，不要简单重复他人的工作，要看看这件事是否能对社会产生一些正面的影响。<br />3、平衡好利益（利润）和发展速度之间的关系。<br />4、对没有意义的事情，要坚决止损，对自己所相信的事情，要长期投入做下去。</p><h2 id="来信补充-谈谈全球股市震荡"><a class="markdownIt-Anchor" href="#来信补充-谈谈全球股市震荡"></a> 来信补充 谈谈全球股市震荡</h2><p><strong>重点笔记</strong><br />股市投资的“三看”法则：<br />一是看原因，就是冷静分析股市波动的原因，如果仅仅是技术性调整，那么就不应该恐慌。<br />二是看关联，对于“不要把鸡蛋放在同一个篮子里”有了更深刻的认识，就是还要看篮子之间有无关联性及关联性的强弱，如果不同资产配置之间关联性强，那么即使不在一个篮子里，影响也会很大。<br />三是看趋势，如果股市波动对全球经济影响较小，而全球经济依然发展良好，则不但不该恐慌，还应该看到新的更好的投资机会。</p><h2 id="答读者问14-如果给你1000万欧元你会买一栋五星级酒店还是5个小旅馆"><a class="markdownIt-Anchor" href="#答读者问14-如果给你1000万欧元你会买一栋五星级酒店还是5个小旅馆"></a> 答读者问14 如果给你1000万欧元，你会买一栋五星级酒店还是5个小旅馆？</h2><p><strong>重点笔记</strong><br />要想脱颖而出，给人眼前一亮，你的思维表达要经历三个层次。<br />1、讲事实，合逻辑。分清观点和事实，找到事实，通过合理的逻辑推导，阐明自己的观点。<br />2、多角度看，多元化思考。一种现象，从不同的角度去看，会有不同解读；一个问题，在不同的语境下，通过多元化思考，会得到不同的答案。不同解读、不同答案之中，就有新颖和具有创新性的结果。<br />3、高见识，有深度。如果说能够找准事实，用合理的逻辑阐明自己的观点，是基础能力，那么多角度看问题、多元化思考就是在基础上的一种升级，而具有远见卓识和进行有深度的思考，就是在以上基础上的进一步拔高。同时，高见识也是多元思考的基础和进一步拓展的源动力。通过阅读积累，与智者交流，并不断思考，相信每个人都有机会达到第三层。</p><h2 id="回信精选-大人物的智慧对你有哪些启发"><a class="markdownIt-Anchor" href="#回信精选-大人物的智慧对你有哪些启发"></a> 回信精选 大人物的智慧对你有哪些启发？</h2><p><strong>重点笔记</strong><br />历史上总会出现一些伟人。与伟人同时代的人不一定能够认同他，因为伟人所做的事情往往是超越当时所处环境的，是面向未来的。<br />深度思考能够促进对于事情的认知，对于事情认知得越深刻，才越有可能提出自己的观点，成为有独立思考能力的人。<br />在这样一个信息泛滥的世界，能够做到独立思考是件非常了不起的事情。</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2021/letter/WechatIMG444.jpeg" alt="" /></p><h2 id="第057封信-什么是好的计算机算法对效率影响有多大"><a class="markdownIt-Anchor" href="#第057封信-什么是好的计算机算法对效率影响有多大"></a> 第057封信 什么是好的计算机算法？对效率影响有多大？</h2><p><strong>重点笔记</strong><br />1、在比较算法的快慢时，需要考虑数据量特别特别大，大到近乎无穷大时的情况。<br />2、决定算法快慢的因素虽然可能很多，但是所有的因素都可以被分为两类。第一类是不随数据量变化的因素，第二类是随着数据变化的。<br />3、如果两种算法在量级上相当，在计算机科学里，就认为它们是一样好的。</p><p><strong>思考</strong><br />本周的计算机算法中，有哪些对你实际的生活、工作有帮助？<br />量级思维给我的启发：<br />1、人和人之间的差异是数量级的。因此，要有较高的目标和要求，可以提高一个数量级，不要纠结在同一个数量级的多多少少。<br />2、忽略掉次要点，聚焦到重点上。抽象出最核心的要点。<br />3、思考问题时要有前瞻性的眼光、要有长期思维。不仅要考虑目前的问题，更要考虑未来可能会出现的问题。</p><h2 id="第058封信-从计算机的算法谈谈提高效率的本质"><a class="markdownIt-Anchor" href="#第058封信-从计算机的算法谈谈提高效率的本质"></a> 第058封信 从计算机的算法，谈谈提高效率的本质</h2><p><strong>重点笔记</strong><br />效率=产出/所做的事情。人的产出是很难提高的，但是所做的事情是可以减少的。</p><p><strong>思考</strong><br />本周的计算机算法中，有哪些对你实际的生活、工作有帮助？<br />1、归并算法这事情让我想到了经济学里的分工产生效率。<br />归并算法将数组每一次的分解，都降低了事情的复杂度，将一件看上去很大的事情，分解到足够小的时候，对应的难度就足够低，自上而下的分解，自下而上的组合，这就是现代工业流水线的模型。<br />往往人生的困惑，在于对目标理解不够清晰，不知道如何分解大目标。<br />2、我们为什么经常面对工作任务不知所措，就是觉得任务或问题太复杂，无从下手。很多情况下，只要能够把复杂问题拆解成一个个简单的问题，解决起来就会有的放矢。曾经看过一个谷歌广告部门如何提升广告业务收入的例子，就是将复杂问题拆解成简单问题找到解决方案的典型案例。一个麦肯锡的人跳槽到了谷歌的一个广告部门，主要任务就是负责提升广告业务的收入。通过沟通，得出了一个业务公式，即广告收入=展现量×点击率×每个点击的价格 。通过这样的拆解，解决问题的路径就非常清晰了，无非是提高展现量，或提高点击率，或提高每个点击的价格。</p><h2 id="第059封信-快速排序要想提高效率就要少做事情"><a class="markdownIt-Anchor" href="#第059封信-快速排序要想提高效率就要少做事情"></a> 第059封信 快速排序：要想提高效率就要少做事情</h2><p><strong>重点笔记</strong><br />其实，计算机算法和组织的管理，乃至社会的管理，在道理上有相通性，想要提高效率就是要少做事情。</p><p><strong>思考</strong><br />本周的计算机算法中，有哪些对你实际的生活、工作有帮助？<br />快速排序在生活中的应用，帮助我们有效率地辨别事情的轻重缓急，学做减法和把握重要且紧急的事。<br />把事情依“重要/不重要”和“紧急/不紧急”两个维度，划分成四个象限，这是很多时间管理一类的书，常会提供的工具。然而如此一来，会使每件事都得从头考量、评断后再放进分类，尚未开始工作就花费时间在规划，顾此失彼。<br />更有效率的方法，能用今天提到的快速排序。当然，很多人或许已经常常在用的算法，却不知其所以然。首先找到一个显而易见的待办事项（枢纽），接着综合考虑急迫性和重要性，分成两拨；再将两拨事情再找枢纽，就把所有工作，依照评分分成四份了。<br />再接下来，快速检查后两部分的事情，将不必要的事减法删除、将重要但不急迫的事先预定计划。然后专注完成前两部分的事，透过排序和减法，一天要完成的工作就只剩约一半。枢纽这个节点，帮我们树立参考点，而事情一件件单看，很难取舍；但有了参考，一比较就能掂量差别，勇敢做减法了。</p><h2 id="第060封信-计算机科学和计算机工程的区别"><a class="markdownIt-Anchor" href="#第060封信-计算机科学和计算机工程的区别"></a> 第060封信 计算机科学和计算机工程的区别</h2><p><strong>重点笔记</strong><br />1、科学常常指出正确的方向，而工程则是沿着科学指出的方向建设道路。<br />2、科学和工程需要关注不同的事情，工作的环境也不同。<br />3、科学家和工程师跟钱的距离不同。</p><p><strong>思考</strong><br />本周的计算机算法中，有哪些对你实际的生活、工作有帮助？<br />科学理想，工程实际；<br />科学指导，工程落地；<br />科学创新，工程改进。<br />今天得到最大的启发：思维方式有差异并非坏事，应正视差异，思考如何用差异做“增量”。<br />很多事情，“知道不做”与“不知道”的结果是截然不同的，所以我们在长期从事一个行业/岗位工作后，应该尽可能地了解下其他岗位的不同点。<br />例如在互联网上，运营重细节，产品重体验，开发重实现，数据重逻辑，算法重推导，销售重人性，市场重策略。<br />从本岗位出发，多了解不同工种的思维模式、工作侧重点、技能偏好等的差异，能做到老师介绍科学与工程之间的不同那样清晰和切换自如，就会具备其他人没有的“稀缺性”。</p><h2 id="答读者问15-年轻人该如何平衡多做事和做减法两者关系"><a class="markdownIt-Anchor" href="#答读者问15-年轻人该如何平衡多做事和做减法两者关系"></a> 答读者问15 年轻人该如何平衡“多做事”和“做减法”两者关系？</h2><p><strong>重点笔记</strong><br />年轻人做事要特别注重“赋能”二字，无论是多做事还是少做事，其核心都是要让自己成长。<br />少做事的逻辑在于：把重要的几件事做好，因为成功比失败更能让人增长经验，成功给人以信心做好下一件事。尽管做的事少，但你若都能成功，相必一定少不了对细节的考虑。等你再面对新事时，相信也已经掌握了一套方法论。<br />多做事的逻辑在于：遇见、看见、了解更多的事，方便在其中找到自己真正喜爱之物。由于年龄所限经历的少，大学生可能并不知道自己的天赋和爱好所在。而多做事有机会让你开发天赋，将自己价值最大化。<br />做事在多与少之前要有一个度，它要保证：你既能出色地完成重要的事，又能寻找到自己真正的心之所爱。<br />可谓是自由了罢。</p><h2 id="第一季度复盘-智能时代的思维方式指南"><a class="markdownIt-Anchor" href="#第一季度复盘-智能时代的思维方式指南"></a> 第一季度复盘 智能时代的思维方式指南</h2><p><strong>重点笔记</strong><br />今天的作业是第一季复盘，感觉脑子里非常多东西，可是动手写的时候却发现没什么好写的。<br />反思:没什么写的本质上就是两方面:<br />1、是你并没有真正内化这些知识和道理，一想到就是细枝末节的东西，没有成为体系。<br />2、只是表面的学到，真正实践比较少，所以复盘的时候觉得没有太多印象特别深刻的内容。<br />一、学到的方法论<br />1、粗调，精调<br />想要做成一件事，边做边调试很重要，不要指望一上来就把事情给做好，也不要一开始就抓细节，这样只会又累又低效。粗调就是要先抓住主要矛盾，解决主要问题，构建解决思路和框架并执行至百分之八九十。当然细节是魔鬼，最后精调的过程就是解决细节问题，以细补粗，完成统一的整体。如每天专栏的留言，凭最初思考写下的文字就是为了表达核心思想，是粗调，写完之后再检查语句是否通顺，关键词有无必要，是否重复，要不要删减精炼，是精调。<br />2、先模仿，再内化创新<br />在得到上学习到的知识和道理，用自己的话再输出再传播需要经历模仿到内化创新的过程。我想把好的洞见传达给朋友，开始我单纯尝试去回忆复述专栏老师的话语和例子，但发现连基本的复述都不容易，还得常打开专栏再复习研读，这一阶段是模仿。后来我发现要想使他人更易接受和理解，就要从他们的生活中找切入点，用他们习惯的语言，他们身边的例子，这样知识与观点的输出就事半功倍了，也就达到内化创新的新阶段。<br />3、构建稀缺性和可靠性<br />周围人很多都不爱学习，看书，越是这样，作为一个终身学习者，就越具备稀缺性。他人刷朋友圈和微博的时间我可以听两个专栏，他人看剧的时间我可以看10页书，长期之后我自然能够得到回报。去年秋招我们班我最早投简历，找工作，最后拿了几份offer，其他同学还是面试菜鸟的时候我已经总结出了套路和经验，稀缺性就彰显出来了，后来有同学主动打电话，请我吃饭请教我。做人上我努力变为靠谱的人，事事有回应，件件有着落，让事情在自己手上完成一个闭环，最近觉得越熟悉的人可能越容易忽略人家事情的紧迫性，常提醒自己尽快帮人家做完事情。<br />二、改变生活的思维方式<br />1、极限思维<br />以前的生活里没有清晰的极限思维，想的就是怎么学更多得到的课程，看更多的书，期待自己快速的成长。经过一段时间后发现自己陷入一种疲于奔命的学习状态，快速听完课程，快速看了多本书，但真正的收获却越来越少。有了极限思维后我知道每天的心力是有极限的，接近极限时学习效率就迅速下降，只是在消耗时间寻求心理安慰。我决定在极限里做事情，探索学习效率的最佳点，不盲目追课，不再浪费多余时间，学累了就去娱乐，这才能保持良性的学习循环。<br />2、上帝喜欢笨人<br />不论一个人的智商情商如何，他都希望成为聪明人。可绝大多数的我们必须承认，我们是笨人，只有承认自己是笨人，才能在笨人的边界内做好事情，一次只做一件事，一件一件做事。</p><h2 id="回信精选-你从计算机算法中得到什么"><a class="markdownIt-Anchor" href="#回信精选-你从计算机算法中得到什么"></a> 回信精选 你从计算机算法中得到什么？</h2><p><strong>重点笔记</strong><br />概率思维，这是高手和普通人思维方式的一个重要区别。<br />法国数学家拉普拉斯说：人生中最重要的问题，在绝大多数情况下，真得就只有概率问题。<br />高手做事看概率，看长期的、多次博弈下的回报概率；一件事值不值得做，一笔钱可不可以投，就看这个回报的概率是多大；只有回报概率大于1，这件事才有可为的基础。<br />有一个公式（凯利判据）可以帮朋友们判断在面临一项投入时，投入多少比例较为合适。<br />F=[P(B+A)-A]/B<br />其中：F是合理下注比例，P是赢的概率，A是单次下注金额，B是每次下注A后赢的话能获得的净利。<br />阿尔法狗战胜人类围棋顶尖高手采取的就是概率思维，它每一步棋都通过大量运算，选择可赢棋的最大概率点落子，最终结果不言而喻。</p><h2 id="第061封信-如何有效地找到一个目标"><a class="markdownIt-Anchor" href="#第061封信-如何有效地找到一个目标"></a> 第061封信 如何有效地找到一个目标？</h2><p><strong>重点笔记</strong><br />1、当一个问题的规模大到一定程度之后，它就不再是同类小问题的放大，就变成了另一个问题，解决的方法需要完全不同。<br />2、凡是都有成本，一种方法好不好，是有前提条件的。<br />3、世界上大部分事情不是一成不变的，很难处理一次就能一劳永逸地享受成果。</p><p><strong>思考</strong><br />举例说明计算机算法对你的工作和生活有哪些启发。<br />1、只要我能拥抱世界，那拥抱得笨拙又有什么关系。<br />2、一切伟大的行动和思想，都有一个微不足道的开始。<br />3、多少人犯下罪行仅仅因为不能忍受邪恶！<br />4、当我听某个人说话听烦了，想要摆脱他时，就装出欣然同意的样子。<br />5、我的灵魂与我之间的距离如此遥远，而我的存在却如此真实。</p><h2 id="第062封信-google如何在一毫秒内找到你想要的上百万份文档"><a class="markdownIt-Anchor" href="#第062封信-google如何在一毫秒内找到你想要的上百万份文档"></a> 第062封信 Google如何在一毫秒内找到你想要的上百万份文档？</h2><p><strong>重点笔记</strong><br />1、为了方便地查找信息，一个简单有效的方法就是根据信息的内容，建立索引。<br />2、索引有很多好处，不仅带来搜索的效率，而且带来灵活性。<br />3、善于建索引，不仅是Google搜索引擎查找信息非常快的根本原因，也是保证Google的产品在信息爆炸时代能体现出高质量的原因。<br />4、在工作中，把东西整理好，有条不紊，一定是提高效率的好方法。</p><p><strong>思考</strong><br />举例说明计算机算法对你的工作和生活有哪些启发。<br />所有数据库的底层表都是单一维度，比方说，用户基础信息表，订单明细表，交易流水表。它们之间会通过“主键”关联，这个主键，可以是用户id（给用户赋予的编号），也可以是订单id，这样就可以在此基础上将各种基础表串起来，建立各种具体业务场景的统计数据表。<br />结合昨天和今天的内容，搜索和寻找中特别重要的一个方法就是“建立规则”，通过对具体实例进行抽象，可以从纷繁复杂的现象中寻找本质，从最简维度的数字结果中再进行搜索将会简单很多。<br />这两天最大的启发和之前很多场景很相似：遇到问题先别急，尽量抓本质，所以在生活中应该多总结多归纳，容易抽象出浅显易懂的道理。</p><h2 id="第064封信-计算机科学中的随机化比特币的基础之一"><a class="markdownIt-Anchor" href="#第064封信-计算机科学中的随机化比特币的基础之一"></a> 第064封信 计算机科学中的随机化——比特币的基础之一</h2><p><strong>重点笔记</strong><br />1、从查找到比特币，很多技术背后的道理是相通的，这也就是我喜欢讲原理，不喜欢讲具体的实战技术的原因，原理搞懂了，一通百通。<br />2、世界上很多时候，好和坏和我们想象的不一样，而且这种客观性不随我们的好恶而改变。<br />3、技术无止境，我们对自己的要求也不应该有止境。</p><p><strong>思考</strong><br />举例说明计算机算法对你的工作和生活有哪些启发。<br />计算机中的随机化。<br />我们人类都喜欢确定性，而不喜欢随机性。但计算机并非如此，甚至有时候还需要用到随机化。<br />查找一个人的名字。建立索引固然是一个好办法。但是有时候索引太大。需要查找，也是花费很长时间。即便是使用二分查找。<br />有没有更好的办法？<br />方法一，将每字进行编号，然后编号之后。将两个字编号相乘，然后再加上后一个字的编号。这样每个人的名字就对应了唯一的一个编码。查找的时候直接查找对应的编码即可。<br />但是这个方法的缺点有两个。首先是浪费，因为有些字是不会放到名字里。其实是占用的空间太大。计算机可能放不下。<br />方法二，取编号的尾数。这样占用的空间就会减少。但是这样会出现另外一个问题。就是编号会重复。<br />方法三，使用随机数。每个人名字都有一个随机数表示。这样重复的可能性就相对较小。<br />后来可以发现，如果一个信息对应的伪随机数足够长，那么他们是无法通过这个随机数还原出来原来的信息。这就是加密。<br />比特币就是用的这个原理。<br />思考。<br />遇到问题两种方法，要么解决问题，要么退回来。<br />我们知道遇到问题应该解决问题。但是有时候退回来也不失为一种办法。<br />因为有时候遇到的问题可能是我们自己创造的。可能是我们上一步就走错了，所以才在这一步遇到的问题。这时如果我们能够回到上一步，重新解决上一步的问题。那么之前的问题可能就不会存在了。<br />记录，是一个好的方法。<br />我们不记录有时候忘了上一步我们解决的是什么问题。记录，然后我们就知道自己处在哪一步。这样就有一个回退机制。但是其中不可避免的就会浪费的时间。因为时间无法回去。<br />技术是没有止境的。<br />在时间的维度上来说，没有最好，只有更好。<br />进步应该就是不断的提高自己的标准。</p><h2 id="来信补充-美国近年来在发展的行业有哪些"><a class="markdownIt-Anchor" href="#来信补充-美国近年来在发展的行业有哪些"></a> 来信补充 美国近年来在发展的行业有哪些？</h2><p><strong>重点笔记</strong><br />自工业革命以来每一次技术革命都会使得社会化分工越来越细，智能革命也不例外，会冲击所有的行业。但是这样一来带来的另一个结果是头部效应会越来越明显，之前讲到我们要成为人群中前2%的人，增加自己的稀缺性，让自己拥有别人无法替代的技能也是如此。多数行业努力成为前2%就不愁生活不好！<br />但是另一方面我们现在不少人并没有处在这2%的人群之中，如何挤进去，我认为做事之前可以考虑应用“双十原则”：做一件事十个月后能给自己带来什么，十年后又是怎样。这样一来可以给自己做减法，让自己有更多的精力投入到重要的事情上；另一方面能让自己有时间思考未来的方向，正所谓：迷茫是前进最大的障碍。</p><h2 id="答读者问16-如何平衡计算机的内存空间和运算时间"><a class="markdownIt-Anchor" href="#答读者问16-如何平衡计算机的内存空间和运算时间"></a> 答读者问16 如何平衡计算机的“内存空间”和“运算时间”？</h2><p><strong>重点笔记</strong><br />吴军老师今天提到的相信技术，就一条路走到黑的执拗非常震撼。让我想起曾鸣老师提到过的活数据概念，提到数据就是决策，或者说数据智能的引擎机器要直接做决策，而不是传统的利用数据分析来支持人的决策。只要是数据被用来支持人的决策，活数据的闭环就断线了。<br />又想起老师专栏前面提到的，计算机不是万能的文章指出的目前图灵机能解决问题的边界，我想正是因为谷歌的视野看到边界，相信边界之内机器一定做得比人好，才能把技术的力量发挥到极致吧。<br />老师提到的普通人见识的差别，一定程度上还是缺乏对概念理解的深度，有些人习惯用所谓辩证来看逃避实际问题，其实边界之内，只有极致，没有辩证。</p><h2 id="第065封信-为什么悲观主义会盛行"><a class="markdownIt-Anchor" href="#第065封信-为什么悲观主义会盛行"></a> 第065封信 为什么悲观主义会盛行？</h2><p><strong>重点笔记</strong><br />1、悲观主义和怀疑主义会让我们乱了方寸。<br />2、悲观主义和怀疑主义的第二个危害是，它们本身是毒素，毒害我们的灵魂。</p><p><strong>思考</strong><br />乌鸦在社会中的角色，总是报忧不报喜，这让他们显得清高。有时矇对了，他们就被捧成先知；有时矇错了，他们说是上帝恩赐。<br />理解做每件事都有风险，没有确定保本赚钱的好事；凡选择必有歧视，凡歧视必得付出代价。因此我对未来的看法，是在明白选择的成本后，做好风险控管，勇敢保持乐观的想法。就像印度电影《三个傻瓜》中，主角常说的一句话：“All is well. ”我们的心灵确实太容易受惊，必须好好安抚才行。</p><h2 id="第066封信-悲观主义是怎么产生的"><a class="markdownIt-Anchor" href="#第066封信-悲观主义是怎么产生的"></a> 第066封信 悲观主义是怎么产生的？</h2><p><strong>重点笔记</strong><br />1、人过分的自信以及因此而造成的自己和现实之间的反差，是导致悲观主义的根本原因。<br />2、坏消息总是不断地被放大的，通信和传媒手段越发达，这个效应越明显。<br />3、从信息论上讲，越是与众不同的说法，信息量越大。</p><p><strong>思考</strong><br />好事不出门，坏事传千里的说法可以用老师今天提到的三个原因来解释。<br />第一，好事坏事的感觉来源于自我评估，人们常常错误的估计自己的能力和事情的难度，这就导致有可能自己以为的好事在别人眼中并不认为是好事，更谈不上传播价值。<br />人性的弱点中也有一种叫看不得别人的好。可能出现当别人真遇到好事的时候，有一种怎么好事没落到自己的损失感，也就不会传播别人的好事。<br />第二，坏消息让人记忆深刻，会在传播中不断放大。<br />对于自己，由于厌恶损失，坏消息记忆会更深。对于别人，幸灾乐祸本来就是笑话的理论基础，大家喜欢笑话和段子，自然喜欢传播别人的坏事。<br />第三，坏事更有信息量。人们心中的愿望一般都是明天会更好，哪怕悲观主义的人，其实也是明天会更好的愿望和现实落差导致的，所以人们会本能觉得，发生好事是应该的，遇到坏事就是一件意外值得传播的事。</p><h2 id="第067封信-未来会比过去更好我们每个人都该有的信心"><a class="markdownIt-Anchor" href="#第067封信-未来会比过去更好我们每个人都该有的信心"></a> 第067封信 未来会比过去更好——我们每个人都该有的信心</h2><p><strong>重点笔记</strong><br />1、人类比过去会更有选择做什么事情的自由。<br />2、所有的悲观主义者，都对今天相比昨天的变化视而不见。</p><p><strong>思考</strong><br />“过往不恋，当下不杂，未来不迎”一直是我秉持的处世之道。回首过去，再美好或者再痛苦的时光已然过去，往事可以回忆，可以作为前行的经验或者教训，仅此而已。展望未来，充满未知、不可预测，可以憧憬但无需焦虑。唯有努力过好当下，今天，我们获取知识和机会的渠道和方式超过以往任何一个时代，心无旁骛地努力做好自己，才会在未来拥有更多可能。<br />分享一个小故事：一个小和尚问得道的师傅：“您得道前后有没有什么变化？”老和尚说：“变化很大。”那到底有什么变化呢，老和尚告诉小和尚：“在得道之前，我每天砍柴、挑水、做饭。得道之后，我每天砍柴、挑水、做饭。”小和尚不理解：“师傅，这不是一样吗？”老和尚说：“不一样，在得道之前，我每天砍柴的时候想着挑水，挑水的时候想着做饭，做饭的时候又想着砍柴。得道之后，我每天砍柴的时候只想着砍柴，挑水的时候只想着挑水，做饭的时候只想着做饭。”</p><h2 id="第068封信-以正合以奇胜乐观主义者的做事方法"><a class="markdownIt-Anchor" href="#第068封信-以正合以奇胜乐观主义者的做事方法"></a> 第068封信 以正合，以奇胜——乐观主义者的做事方法</h2><p><strong>重点笔记</strong><br />1、作战，先要把正面的兵排好，要排得不偏斜，合乎法则，这叫做正。如果这时你还有多余的兵力，你就赢了。<br />2、在无限长的时间里，变是常态，不变是非常态。但是在有限的时间里不变和渐变是常态，巨变是非常态。<br />3、往前走是常态，回头看是非常态。<br />4、实力派获胜是常态，机会主义者获胜是非常态。</p><p><strong>思考</strong><br />1、生活是慢慢前进的，你需要有敏锐觉察细小变化的能力，及将自己变强大的信心，将脚步放缓，你会看见未来的美好生活。<br />2、培养敏锐觉察细小变化的能力，强化将自己变强大的信心。保持一个健康可持续的节奏，让自己成为实力派。</p><h2 id="来信补充-大人物系列拉里佩奇的人生智慧"><a class="markdownIt-Anchor" href="#来信补充-大人物系列拉里佩奇的人生智慧"></a> 来信补充 大人物系列——拉里佩奇的人生智慧</h2><p><strong>重点笔记</strong><br />1、做产品要有牙刷和爆款的功能。牙刷就是每天都要用，但是要可靠稳定。爆款就是每隔一段时间要给用户惊喜。<br />2、任何一件事物其实都是有生死的。没有永生不死的东西。认识到这点就好了。我们要做的并不是维持一件东西的不死，而是我们要做的是从未来寻找机会，寻找新生。</p><p><strong>思考</strong><br />找一些关于拉里佩奇的事迹，看看你从他身上可以学到哪些做事方法。<br />在被问及他管理公司的方法时，佩奇曾经对谷歌员工说，他解决复杂问题的方法就是将其简化到二选一，然后选择最佳答案。无论此举会带来什么附加损害，他都能接受。多年来，谷歌一直在这种管理方式下繁荣发展。我总结了一下佩奇的管理原则：</p><ul><li>不要推诿：亲自做事，加快进度。</li><li>如果不能增加价值，就不要干涉其中。让那些真正做事的人互相讨论，你去做其他的事情。</li><li>不要官僚主义。</li><li>想法比年龄重要，年龄小并不意味着他不值得尊重与合作。</li><li>你所做的最糟糕的事情就是用一个“不”字就阻止别人做事。如果说不出来，你就要帮助他们找到更好的方法。<br />佩奇曾经每天与布林进行激烈的争论，这也是他们关系的发展方式。佩奇会说布林的想法很蠢，布林则会说佩奇的主意太幼稚，他们互相都会称对方为混蛋，佩奇从没感觉他与布林的关系因为这些争论而恶化，真正好的关系，有价值的关系不会因为表面上的冲突恶化。</li></ul><h2 id="答读者问17-渐变与突变是什么关系"><a class="markdownIt-Anchor" href="#答读者问17-渐变与突变是什么关系"></a> 答读者问17 渐变与突变是什么关系？</h2><p><strong>思考</strong><br />古龙在《新月传奇》中说，爱笑的女孩，运气不会太差。其实每个爱笑的人，运气都不会太差，世界本是客观的，但你所感知到的世界，则取决于你是用“笑”还是用“丧”的方式来看待。悲观主义者和乐观主义者，就像是拿到开启心灵世界的不同钥匙，如果你拿到的是悲观主义的钥匙，那你打开门看到的就是一个充满怀疑、焦虑、恐惧的世界，然后你会很“丧”地不断寻找相关的证据来坐实这个认识；如果你拿到的是乐观主义的钥匙，那你打开门看到的就是充满幸运、快乐、开心的世界，你会笑着撞到各种各样的“小确幸”，这些小确幸汇集成你的幸福生活。<br />毋庸置疑，我们都应该做一个乐观的人。我们对幸福、美好的生活是如此向往，真的不应该被太多的怀疑、焦虑和恐惧所绑架，而应该不断在生活中寻找自己的那把乐观主义钥匙。但是，盲目的乐观又容易让我们陷入另外的一些不自知的困境：<br />第一个困境：高估自己的能力，降低了改变现状的行动力。正如吴军老师在文章提到的很多大学生，一直都盲目乐观地以为成绩好就能出人头地，高估了考试能力和考试成绩的重要性，从而缺乏了增强其他方面素质的动力。现在很多在捧着铁饭碗而不再继续学习的人，也是如此，泰坦尼克号很快就要被撞沉了，还坐在头等舱上享受着最后的繁华。<br />第二个困境：总是在期望奇迹，不愿面对现实。之前在销售公司工作，就常常遇到这样的同事，他们平时没有好好积累和拜访客户，月初常常制定不切实际的业绩目标，快到月底就开始用非常乐观的态度鼓励自己：<br />“一切都会好起来的”、“一定会有奇迹发生的”……如果总是用盲目的乐观来鼓励自己，就容易没法看清现实。<br />第三个困境：忽视细微的变化，导致积重难返。有一个持续了将近100年的实验：1921年，斯坦福大学的心理学家路易斯·推曼召集了1500名1910年左右出生的男孩和女孩，追踪他们的一生。第一个研究者推曼去世后，有继任的研究者继续他的研究，这样一代一代地传下来。这些活到现在的实验者，都超过一百岁了，实验者发现，外向开朗的人，活得反而没有内向严肃的人久，为什么会这样呢？这是因为，太过乐观的人会忽视身体释放的信号，即使身体出现问题，也没能及时就医，耽误了治疗。想要长寿，适度关注身体释放的细微信号，不能太“看得开”，否则积重难返。<br />吴军老师在前几天的文章说，悲观主义会让我们乱了方寸、停滞不前，而今天看来，盲目乐观也有诸多坏处，这种盲目的乐观，被吴伯凡老师称为“消极的乐观主义者”，而我们要做的，应该是成为“积极的悲观主义者”。“积极的悲观主义者”会认为：世界本身就是矛盾密布的，生活原本就是悲观的。我们在生活中就是会不断遇到各种问题，然后不断解决问题。吴军老师在周五的来信中提到，谷歌的创始人佩奇早早认识到“企业和生物一样，从小到大，慢慢老化再到衰亡，难以避免”，这是悲观的认识，但佩奇希望谷歌能不断创造新的产品部门，就像海蜇不断发育出来的新细胞。</p><h2 id="回信精选-你对悲观主义和乐观主义有哪些看法"><a class="markdownIt-Anchor" href="#回信精选-你对悲观主义和乐观主义有哪些看法"></a> 回信精选 你对悲观主义和乐观主义有哪些看法？</h2><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2021/letter/WechatIMG482.jpeg" alt="" /></p><h2 id="第069封信-是谁奠定了欧洲教育原则"><a class="markdownIt-Anchor" href="#第069封信-是谁奠定了欧洲教育原则"></a> 第069封信 是谁奠定了欧洲教育原则？</h2><p><strong>重点笔记</strong><br />1、洪堡破除了工业革命之前欧洲沿袭了几百年的修道院教育的传统，不仅强调研究的重要性，而且强调研究的课题要和当时的工业相结合。<br />2、洪堡也强调一种叫做“知识的总和”的理念，也就是我们今天所说的跨学科教育。<br />3、一个人学习和做事的方法，一定要切合自己的性格特点。</p><p><strong>思考</strong><br />能否请你讨论一下“同伴的压力”和“做更好的自己”的关系？<br />在同伴的压力下，我们常常妄自菲薄，急于求成，不追根溯源，明白同伴当下的成就有基于自身实际情况的长时间的积累。于是盲目跟风模仿，期望一蹴而就，然而现实是不以个人主观意愿转移的，水平低水平差不可能通过“表面上的看齐”而达到真正的一致或者赶超，因为质变需要量变的积累，我们更应该踏踏实实做更好的自己，让明天比今天进步一点点。</p><h2 id="特别加餐-我所了解的拉里佩奇"><a class="markdownIt-Anchor" href="#特别加餐-我所了解的拉里佩奇"></a> 特别加餐 我所了解的拉里佩奇</h2><p><strong>思考</strong><br />吴军老师好，感谢您的加餐，从今天的内容，受到了2点重要启发：<br />1、谨慎选择你的对手，这很重要，但比这更为重要的，是时刻关注你的对手<br />“要谨慎选择你的竞争对手，因为你们最终会变得很像”，这是隔壁张潇雨老师的一句名言，也是商业世界的一大真理。<br />当然，总有些东西比选对对手更重要，比如————时刻关注你的对手。<br />照理说，谷歌那时候已经是小有成绩的公司，佩奇完全可以不用那么累，可偏偏佩奇要凭着大摞打印的文件聆听第一线的炮火声，且，不是一时心血来潮，而是长期习惯，再看看我们国内某些大老板，不仅喜欢躺在功劳簿上不动，久而久之，也失去了对商业的绝对灵敏嗅觉，令人不禁感叹：一份耕耘一分收获，这个世界倒也公平。<br />2、作为领导者，要允许下属充分试错，但，必须建立在“有条件”的基础上<br />只要留意中国足球我们就会发现，每次国足一失利，有关领导往往就会站出来说我们这是在练兵，要给予年轻球员充分的试错空间。可是几十年过去了，试错的球员换了一批又一批，中国足球还是那个中国足球，这样做，真的对吗？<br />试错当然很有必要，但作为领导，以大局为重，让大家有条件地试错就更成了必要。<br />如果大家都能像谷歌这样做，类似国足这样哀其不幸怒其不争的“试错”案例是不是就会少很多呢？</p><h2 id="第070封信-为什么大学诞生在欧洲中世纪"><a class="markdownIt-Anchor" href="#第070封信-为什么大学诞生在欧洲中世纪"></a> 第070封信 为什么大学诞生在欧洲中世纪？</h2><p><strong>重点笔记</strong><br />1、教育首先是在精神层面的追求。<br />2、做学问要有宗教般的虔诚。<br />3、读书和研究要有一定的自由，而这是靠权力保障的。</p><p><strong>思考</strong><br />精神财富的目标是达到一种自我评价为有些知识、有些理想、具备理性思维能力的人。<br />对于知识，自然是通过学习获得。在大学教育阶段之后，越发感觉到对通识教育的需求，所以自己学习是主要方式，读书和学习他人都是方法。<br />对于理想，不忍心把他们扼杀，而是泛化，把具象的理想变成宽泛的为社会提供价值的总合，不至于让理想变得遥不可及。<br />对于理性，需要从不断重新认识自己、重新理解时代做起，每次阅人、经事、读书、感悟都是一次次认识上的迭代。<br />最后引用尼采的一段话：<br />“人的精神有三种境界：骆驼、狮子和婴儿。第一境界是骆驼，忍辱负重，被动地听命于别人或命运的安排；第二境界是狮子，把被动变成主动，由“你应该”到“我要”，一切由我主动争取，主动负起人生责任；第三境界为婴儿，这是一种“我是”的状态，活在当下，享受现在的一切。”<br />我们都是从婴儿长大，但精神上都是从被动到主动的变化，对于外界和自我的互动也逐渐变成自我与周围的良性关系。</p><h2 id="第071封信-从大学的出现追溯高等教育的目的"><a class="markdownIt-Anchor" href="#第071封信-从大学的出现追溯高等教育的目的"></a> 第071封信 从大学的出现追溯高等教育的目的</h2><p><strong>重点笔记</strong><br />1、人的好奇心和求知欲是天生的，我们需要保持它。<br />2、早期的大学是非功利的。<br />3、每一所名牌大学能成为一流，都有一两个确立它历史地位的教育家，没有他们，那些大学就不是今天的样子了。<br />4、学校需要系统化。</p><p><strong>思考</strong><br />子女教育<br />1、心灵的成长需要自由和尊重<br />父母如果常常帮孩子作出选择，选择学校，选择衣服，选择玩具等，就要反思一下了，是否我们常常帮孩子作出回答。因而，孩子没有选择，没有思考。所以，他缺少创新思维，也不会有太多尝试。你可以让他学到很多知识，你却无法让他举一反三，也无法让他有更好的想像力。尊重孩子，把他看作一个独立的人，尊重他的隐私，尊重他的选择，尊重他的朋友，常跟他交流，多加尊重，合理引导。<br />2、罗森塔尔效应：对孩子进行积极期望<br />罗森塔尔的试验对两组随意组合的学生分别给予积极和消极的评价，后来，果真就是那样的积极或消极的结果。积极的期望，其实就是一种外界的支持。在人的心目中，家人、朋友是这种支持力量的核心，家人、朋友的期望支持也更有塑造力。在你挫折的时候，无论是孩子，还是我们成人，对这种力量都非常期待。反过来，缺少这种积极的期望与支持，他就变得消极，或者在挫折后一撅不振。<br />3、帮助孩子养成爱读书的好习惯<br />父母帮助孩子守好边界，积极引导，也表现在父母不可能全知全能，以后的路还要孩子自己走，从小的时候开始就陪孩子阅读，他在喜欢上读书之后，以后会自我驱动地解决遇到的问题，去读书去实践，而那个时候，父母也许真的什么都做不了，但看着孩子和作者对话，成长很快，无疑是一种幸福。<br />4、延迟满足主义：从小培养孩子的耐心<br />人有无耐心，表现出两个方向。一个是，想要什么就要什么；另一个是，能够等到自己需要的东西到来。这中间，区别的就在于是否有耐心，所以如果想孩子养宠物的话，不如换成植物吧。<br />5、感觉剥夺：让孩子自己去品尝生活的真滋味<br />感觉是人最基本的心理现象，通过感觉我们才能获得外界的信息，才能适应环境求得生存。大脑的发育、人的成长、成熟是建立在与外界环境是智力和情绪等心理因素发展的必要条件，我们应该让孩子积极感受丰富多彩的外界环境，从环境中获得更多的知识和信息。<br />6、能够包容和理解<br />一个错误一旦发生，即便生气抱怨，它也已经发生，我们要做的是，如何避免重复犯这个错误，并要收拾这个错误带来的残局。另一方面，从孩子的角度出发，他的一切都在尝试与成长的阶段，多加宽容，注重引导，不正是我们都需要的吗？而如果，孩子并不喜欢与信任你，你说的一切都很难凑效。<br />7、孩子的成长需要梦想<br />当西方老师努力挖掘学生的想像力的时候，我们的教育在告诉孩子“标准答案”。当我们给一个未成年的孩子交待一件事时，不要急着教他怎么去做，只要告诉他应该做成什么样就行了，并且作一些安全方面的注意提醒。至于方法，让孩子自我探索，而在这期间，我们只需要鼓励再鼓励。</p><h2 id="第072封信-牛津和剑桥的学院制"><a class="markdownIt-Anchor" href="#第072封信-牛津和剑桥的学院制"></a> 第072封信 牛津和剑桥的学院制</h2><p><strong>重点笔记</strong><br />学院制可以说是剑桥和牛津的第一大特色。用一个字来概括，那就是“家”，用两个字来概括，那就是“社会”。在这两所大学，学院就是一个熔炉，将青涩的大学生变成能够立足于社会的人。</p><p><strong>思考</strong><br />大学这段期间，最重要的是要让一个学生能转变成一个成熟的社会人。<br />从中学到大学，亚裔的父母往往告诉孩子，“学生的任务只有一个，就是把学业顾好”，而忽略了社交技能和与周遭协作应对能力。学院制度，让大学生能在家庭的氛围下继续成长，全方位地培养未来独立生活的能力。在这样的小型社会中，学到的不仅仅是书本上的知识，更多是课堂外的风景。我想这也是为什么他们至今仍坚持学院制的关系。<br />我向往中的师生关系，是亦师亦友的谈笑风生。然而，我所经历的，往往只是在课堂上遇见教授、下课以Email交流而已。若遇见人生难题，诸如感情、家庭困扰，能够第一时间请教这样的“心灵导师”，真可谓学院制才容易形成的环境，可遇不可求。</p><h2 id="来信补充-比贫穷更可怕的是什么"><a class="markdownIt-Anchor" href="#来信补充-比贫穷更可怕的是什么"></a> 来信补充 比贫穷更可怕的是什么？</h2><p><strong>思考</strong><br />#子女教育#<br />我们常听人说，贫穷限制了想像力，其实不准确，实际是“缺乏想像力让人逃不开贫穷”。而想像力，正是由见识创造出来。<br />跟随吴军老师，了解通识涵养、大学起源和继续教育等等，也认识贵族精神和学院制的特色，引申到子女教育，我认为三件事最重要：见识、爱与被爱，以及规矩边界。<br />夏虫不可语冰，一人缺乏视野，很多深度谈话、进阶学习就无法接收。因此不论是学童还是已经离开学校，都要不断扩充见识。如果能由父母有意识地将世界将给子女，将会是一辈子的财富。<br />爱与被爱，犹如领导与服从，是相辅相成的能力。很多成年人心态仍像孩子般幼稚，就是在需要关爱的阶段留了空白，因此不知道如何正确地爱人。而除了中小学阶段，父母占据主要角色；到了大学，如果有段美好的爱情，这个能力也会更完善。我自己就是在大学，重新理解爱与被爱的真谛。<br />最后，提到规矩，我们常说这是孩子能否定下心来学习的能力。其实守规矩并非盲从，而是要清楚组织的边界。在学校有校规、在国家中有法律，而各国的文化不同、每个人的边界也不同，规矩就是要我们能理解这个“度”。若父母能给子女清楚的规距教育，待及成人也就能把握人与人之间的边界了。</p><h2 id="答读者问18-如何看待系统学习的重要性"><a class="markdownIt-Anchor" href="#答读者问18-如何看待系统学习的重要性"></a> 答读者问18 如何看待系统学习的重要性</h2><p><strong>思考</strong><br />系统学习，是取得一个专业的最佳途径。如果略过此阶段，效果不仅打折，也会事倍功半。理解各学科的背景，从而发掘相关道理，能得到更多收获。<br />关于父母见识局限，以及孩子对考试外的事没有兴趣，我认为缺乏的是“有效碰撞”。化学分子结合时，不仅需要碰撞，还需要有效的分子相位。引申到学习上，就是要多与不同领域的人交流，触类旁通的偶然性，就有可能意外出现。<br />我们得在生活中，把握或是刻意营造这样随机碰撞的机会，比较常见的还有读书会、社区大会，或是教会的礼拜也有类似的功能。打开心胸，世界自然走进你的视野。</p><h2 id="第073封信-计算机领域大人物冯诺依曼"><a class="markdownIt-Anchor" href="#第073封信-计算机领域大人物冯诺依曼"></a> 第073封信 计算机领域大人物：冯.诺依曼</h2><p><strong>重点笔记</strong><br />1、人类需要见识超过同时代的人。<br />2、人需要做具有长远影响力的事情，我们做事情宁可少一些，也需要一件事情的影响力大一些。<br />3、再聪明的人要想做好事情也需要专注。<br />4、世界上有很多成就比我们大得多的人。</p><p><strong>思考</strong><br />能否就一通百通谈谈你的看法？<br />一通百通，尤其是在科学研究上，这是因为像冯诺依曼这样的人，都是看到事物的本质，而事物的本质，或者底层逻辑，往往是相通的。<br />打个比方，在化学世界里面，所有物质都是有原子组成，虽然它外在的形态和形状千奇百怪。普通人看到的是一个个不同的物体，而在科学家眼里，这些物体都是由化学元素周期表上的那些元素，按照不同的原子结构排列而成。<br />物质世界的底层逻辑是物理和数学，而冯诺依曼又精通数学和理论物理的每一个领域，因此，他有如此成就就不足为奇了。<br />还有一个例子，就是俄罗斯虽然制造业尤其轻工业不发达，经济结构也很单一。但是，由于其在数学和物理方面的理论基础非常扎实，所以，很多材料和设备的原创制造工艺，都是源自俄罗斯，虽然这些材料最后商业化多是在欧美。</p><h2 id="第074封信-计算机领域大人物计算机算法的鼻祖高德纳"><a class="markdownIt-Anchor" href="#第074封信-计算机领域大人物计算机算法的鼻祖高德纳"></a> 第074封信 计算机领域大人物：计算机算法的鼻祖——高德纳</h2><p><strong>重点笔记</strong><br />1、利用艺术和科学的相通性。<br />2、起跑线一说不必太在意。<br />3、既要能头顶青天，也要能脚踏实地。<br />4、遇到问题解决问题的积极态度。</p><p><strong>思考</strong><br />能否就头顶青天、脚踏实地谈谈你的体会？<br />我很欣赏高德纳“力争一次全对、做最好”的态度。虽然在我看来没有“最好”一说（总是“天外有天、人外有人”），但当一个人本着这样的态度去做事时，总会有收获，也会有较高的做事效率。<br />在学习、工作中，我们特别需要这样的态度，因为人就这一辈子，我们没有很多时间可以浪费，更要争取一次把事情做对、做好，不要回头再重新做一遍，虽说这样可以吸取教训经验，但有多少人因为这样而成功的呢？我想这样的人不多，时间和精力是最昂贵的试错成本。<br />阅读是一个很有的例子，好多人给自己制定了读书计划，比如完成多少本书的阅读。往往很多人为了实现目标，而囫囵吞枣地看完一本又一本，然后说有时间再复习，然而往往都没有时间。在我看来，有些书是可以快速阅读，但营养价值高的书值得慢慢品读，争取一次把它看懂（精读），标记值得反复研读的地方，再去体会体会。与其读十几本书后不知道讲什么，不如精读一两本好书。</p><h2 id="第075封信-计算机领域大人物机器翻译专家弗朗兹奥科"><a class="markdownIt-Anchor" href="#第075封信-计算机领域大人物机器翻译专家弗朗兹奥科"></a> 第075封信 计算机领域大人物：机器翻译专家——弗朗兹.奥科</h2><p><strong>重点笔记</strong><br />1、成功的人要学会将自己不擅长的领域转化为自己擅长的领域。<br />2、成功的人永不满足。</p><p><strong>思考</strong><br />奥科博士的哪些经验值得你借鉴？<br />奥科博士的经验，又佐证到昨天说的“遇到问题解决问题”的决心和能力。而在解决问题上，厉害的人不仅完成一两种语言间的翻译，而是想办法让其他种语言也能顺利完成，因此做事就不是平面的思维，而是立体结构、互补形成。再者，善于分解问题也是做事成功的秘诀，当然，在先前内容已经不断强调。若从A语言翻译成C语言，有困难，那么就找到B语言，能完成A—&gt;B—&gt;C的过程。<br />找到人类进化的终极目标、遇事具体解决，以及拆分问题，这是我从奥科博士身上学到的事。</p><h2 id="第076封信-计算机领域大人物机器翻译专家弗朗兹奥科"><a class="markdownIt-Anchor" href="#第076封信-计算机领域大人物机器翻译专家弗朗兹奥科"></a> 第076封信 计算机领域大人物：机器翻译专家——弗朗兹.奥科</h2><p><strong>重点笔记</strong><br />1、成功的人对所从事领域有着深刻理解。<br />2、成功的人做事情十分专注。<br />3、成功的人善用优势。<br />4、成功的人擅于用合作取代颠覆。<br />5、成功的人更看重产出的质量。</p><p><strong>思考</strong><br />Google用“一堆胶带纸粘起来”的服务器集群，和SpaceX绑在一起的火箭集群有相似之处，能否就这种方法谈谈你的看法？<br />”一堆胶带纸粘起来“的服务器集群的新颖之处并不在于它采用了多么令人惊讶的新技术，而在于它采用廉价的商用计算机集群构建分布式文件系统，在降低成本的同时经受了实际应用的考验。这是一种不将成败压在单兵战斗力，而是用科学的方法将普通的资源进行整合，利用被规划过的整体资源优势来解决问题的方法。<br />采用这种集群的策略，有两个前提条件：<br />1、不是所有的廉价都可以吸纳进来，要进行合理的规划。<br />2、各要素之间要进行调控、布局、整合，能融洽的协作。<br />其实生活中方方面面都是如此，一支球队不是吸纳11个有特长的明星球员就可以赢球，如果这些队员不能相互配合，一样是一盘散沙；一个公司如果只依靠一两个特别有能力的销售人员，为了留住他们需要耗费大量财力不说，一旦他们单点失败，会造成公司巨大的损失。<br />而集群则反其道而行之，虽然单看每个人的实力未必是最强的，但是只要每一项布置的任务经过考量，科学拆分，对应的人员足以胜任应付，则可以利用更低的成本完成原本复杂而且代价高昂的任务。</p><h2 id="来信补充-计算机领域大人物艾伦图灵牛在哪"><a class="markdownIt-Anchor" href="#来信补充-计算机领域大人物艾伦图灵牛在哪"></a> 来信补充 计算机领域大人物：艾伦.图灵牛在哪？</h2><p><strong>思考</strong><br />能否就呼吸巨人的气息发表你的看法？<br />呼吸巨人的气息，本身这句话就是有巨人的气息，听完老师的课每次就像站在山顶上深深地吸了一口清鲜又有营养。概括以下几点：<br />首先，老师能从某一件事或某一个人身上发现其本质和优点，且概括简明扼要，这是我该学习也必须该具备的。因为这本身就是其学习中该具备的。以前我做事，很多时候因未看出事物的本质，往往被表象所蒙蔽导致创业多次不理想，现在则不同，先观察其事物发展，不轻易下定结论，一直追问自己，还有比这更重的因素吗，直到发现任何推理都能成功的因素就是其最重要，解决它就是最好的方法。<br />其次，看过《追梦环游记》与这些巨人中发现，一个人在世上就是一条河流，主要取决于一个人深度宽度和长度，其中深度是最重要的，有好梦就去追，不在乎身边的如何看你，而是更应该在乎世界另一端有多少人已把你遗忘。只要一件深度够，总有很多人记得你，难怕你已离开他们。<br />在过去，总是这山望那山高，好高骛远，经常高估自己的能力，于是总是经常看到一个行业没做起就会放弃，就像很多人在工作时总是觉得别人挣钱容易，工作又轻松，但他没看到别人的付出一面，所以我现在总告诉身边的人，把一件事做到极致才是最重要的。就像老师说的，世界上顶级的学校包括哈佛在招生录取时，先看你的专擅，这专擅还要在州一级以上才是门槛。而不是像中国一样，先看你的成绩再看专业，显然他们的教育更注重应用，因为一个人在得到专业领域的荣誉路上，他已经具备分析并解决事情的能力了。<br />最后，人的智商都有限，不要把自己的孩子棒得太高。任何高智商的人离开学习将终身无成大业。记得马云说过，一个人离开了学习，就是离开了成功之路。谦虚学习，匠工精神都是现代人包括创业者该具备的。</p><h2 id="google的服务器集群和space-x的火箭集群有哪些不同"><a class="markdownIt-Anchor" href="#google的服务器集群和space-x的火箭集群有哪些不同"></a> Google的服务器集群和Space X的火箭集群有哪些不同？</h2><p><strong>思考</strong><br />追求的目标越远大，所要付出的劳动就越多，所要进行的时间也越长，而且，有些工作越到后来难度越大。开始完成的多是些外围或简单的工作，到接近尾声时剩下的都是些硬骨头，这时就更需要热情、耐力和毅力。人们做事情，总是在快要成功时失败，所以当事情快要完成的时候，也要像开始时那样慎重。短期内耐心取决于价值，长期来讲，耐心决定价值。</p><h2 id="回信精选-计算机牛人身上有哪些值得你学习的品质"><a class="markdownIt-Anchor" href="#回信精选-计算机牛人身上有哪些值得你学习的品质"></a> 回信精选 计算机牛人身上有哪些值得你学习的品质？</h2><p><strong>思考</strong><br />一切事情都来自驱动自己做事开始，在这个时代每个人都希望自己效能再高一点，可以多抓住一些机会，可以多做一些事情，但为什么效能总达不到自己的期待呢，很多人说这个时代最怕的就是优秀的人比你还努力，其实不然，因为努力这个事情个体差异不会超过特别大，即使他不眠不休也不会超过50%。但是人和人之间价值差别是可能会上百倍，因为怕的是优秀的人做的事情比你高价值很多。他选择做的事情就是高价值的，他还比你优秀。也就越做差别越远。<br />所以冯琨大哥要求，自我管理的第一要务是少做事，做那些更少却更好的事。所以成洁师妹强调，做好“断舍离”，断绝不重要的事，舍弃不重要的事，远离做事之后虚伪的成就感，而真正关注那些重要的事情。<br />鸟随鸾凤飞腾远,人伴贤良品自高。</p><p><a href="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2021/letter/WechatIMG531.jpeg" target="_blank" rel="noopener"></a></p><h2 id="第077封信-什么是计算机的数据结构"><a class="markdownIt-Anchor" href="#第077封信-什么是计算机的数据结构"></a> 第077封信 什么是计算机的数据结构？</h2><p><strong>重点笔记</strong><br />专业人士和业余人士做东西的一个重要差别在于，前者掌握了如何使用基本图形、结构和组成部分来构建复杂设计和产品的方法，后者根据自己脑子里的构思和直觉，直接构建最终的产品和设计。</p><p><strong>思考</strong><br />作为一名软件开发工程师，正如吴军老师所说，业余人士拿到需求后上来立马开始一行行敲代码，想到哪写到哪，代码可以说是东拼西凑，漏洞百出，这种代码对于其他工程师来说就是噩梦，所以软件工程师很多时候宁愿重写也不愿意维护其他人的代码；而专业人士会花很多时间对需求进行分析，对程序的实现进行设计，自顶向下进行功能分解并切分出恰当的功能模块，然后再确定每一个模块所需的数据结构和算法，接着构思出代码逻辑、选定具体数据类型，并进行伪代码测试或者评审，通过后才开始代码，真正写代码的时间大概只能占到1/3左右，因为“只有想清楚才能写清楚”，所以优秀软件工程师经常给大家留下的印象就是“发呆”，而业余人士却是不停地敲代码。</p><h2 id="第078封信-从二叉树数据结构到对具体问题共性的抽象化"><a class="markdownIt-Anchor" href="#第078封信-从二叉树数据结构到对具体问题共性的抽象化"></a> 第078封信 从二叉树数据结构到对具体问题共性的抽象化</h2><p><strong>重点笔记</strong><br />1、有什么样的问题，就有什么样的工具<br />2、在计算机科学中，数据的相对大小比绝对的数值重要<br />3、和很多抽象的工具一样，二叉树其实能在现实生活中找到很多对应<br />4、所有能够对应到二叉树的问题，都有一些共性，解决它们之间问题的方法是可以触类旁通的</p><h2 id="第079封信-计算机经典算法锦标赛排序算法"><a class="markdownIt-Anchor" href="#第079封信-计算机经典算法锦标赛排序算法"></a> 第079封信 计算机经典算法：锦标赛排序算法</h2><p><strong>重点笔记</strong><br />锦标赛排序算法的优点是：<br />1、少做无用功<br />2、善用信息</p><p><strong>思考</strong><br />从锦标赛排序，你获得了什么启发？<br />1、普通人和天才的差距真的很大，作为普通人来讲，要想做天才能做的事，你就必须努力学习，掌握更多的工具，来弥补自己的不足。<br />2、通过今天的面试题，我们要做A1，做不到A1，也要做A2，不能做D1、E1。一个人所处的圈子和平台太重要了，不要以为在你那个圈子当个第一，就很得意，在今天的试题中的，你连决赛都没进去。要突破自己的舒适区，始终保持学习状态，往更高的圈子混。</p><h2 id="第080封信-google面试题如何设计一个地图功能找到离当前最近的加油站"><a class="markdownIt-Anchor" href="#第080封信-google面试题如何设计一个地图功能找到离当前最近的加油站"></a> 第080封信 Google面试题：如何设计一个地图功能，找到离当前最近的加油站</h2><p><strong>重点笔记</strong><br />1、不要做无用功。<br />2、很多事情都遵循同一个规律。<br />3、在做产品时则不应该有这样的主观假设，否则就把自己限制死了。<br />4、好的面试官是不怕面试者刷题的，因为他总是可以一层层深入地问下去。</p><p><strong>思考</strong><br />少做无用功的第一步就是要把事情想清楚，需要解决什么样的问题，可选择的方法有几种，比较研究后哪种是最有效的。只有想清楚，才能在做事时思维不跑偏，不乱发散，抓住本质，提升效率。<br />聚焦是提升效率的关键，我们要将力量集中在一点，如果关注不相关的事，力量就被分散了，无用功就产生了。做事过程中要时常省察自身注意力是否集中，是否做了无用功，如果有，立马停止，做正确的事情远远好过把事情做正确。</p><h2 id="第080封信-google面试题如何设计一个地图功能找到离当前最近的加油站-2"><a class="markdownIt-Anchor" href="#第080封信-google面试题如何设计一个地图功能找到离当前最近的加油站-2"></a> 第080封信 Google面试题：如何设计一个地图功能，找到离当前最近的加油站</h2><p><strong>思考</strong><br />1、工具的重要性。今天有同学提出工具可以弥补智商或者专业性不足的差距，我认为工具具有杠杆效用，专业的人可以运用工具高效解决问题，而业务的人如果能够善用工具也能极大的提高效率。<br />2、少做无用功的方法。做无用功浪费资源、影响效率，减少或不做无用功必须做到：一是全面掌握并运用信息，去除冗余，减少不必要的资源浪费；二是事后及时总结复盘，做一件事要对过程进行梳理，将经验和教训记录下来，确保今后不再犯类似错误的同时，还能够找到一些捷径，少走弯路。</p><h2 id="第081封信-货币的起源及其特征"><a class="markdownIt-Anchor" href="#第081封信-货币的起源及其特征"></a> 第081封信 货币的起源及其特征</h2><p><strong>重点笔记</strong><br />1、货币是一种媒介，相当于记账工具，用于等价交换。<br />2、在早期，一种东西要想成为货币，本身需要有价值。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第001封信-职业天花板来自认识的局限性&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#第001封信-职业天花板来自认识的局限性&quot;&gt;&lt;/a&gt; 第001封信 职业天花板来自认识的局限性&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;重点笔记&lt;/stro
      
    
    </summary>
    
    
      <category term="吴军" scheme="https://toyan.top/categories/%E5%90%B4%E5%86%9B/"/>
    
      <category term="谷歌方法论" scheme="https://toyan.top/categories/%E5%90%B4%E5%86%9B/%E8%B0%B7%E6%AD%8C%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
    
      <category term="方法论" scheme="https://toyan.top/tags/%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>刷题汇总</title>
    <link href="https://toyan.top/algorithm/"/>
    <id>https://toyan.top/algorithm/</id>
    <published>2020-04-24T16:00:00.000Z</published>
    <updated>2021-02-22T16:03:10.449Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://toyan.top/algorithm-sort/">排序算法</a></p><p><a href="https://www.cnblogs.com/tongan-java/p/7599922.html" target="_blank" rel="noopener">剑指offer</a></p><p><a href="https://www.cnblogs.com/tongan-java/p/7284094.html" target="_blank" rel="noopener">leetcode</a></p><p><a href="https://www.cnblogs.com/tongan-java/p/8579047.html" target="_blank" rel="noopener">动态规划</a></p><p><a href="https://www.cnblogs.com/tongan-java/p/12774542.html" target="_blank" rel="noopener">背包九讲</a></p><p><a href="https://www.cnblogs.com/tongan-java/p/14433734.html" target="_blank" rel="noopener">LeetCode 热题 HOT 100</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://toyan.top/algorithm-sort/&quot;&gt;排序算法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/tongan-java/p/7599922.html&quot; target=&quot;_blank&quot; 
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://toyan.top/categories/algorithm/"/>
    
      <category term="leetcode" scheme="https://toyan.top/categories/algorithm/leetcode/"/>
    
    
      <category term="算法" scheme="https://toyan.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://toyan.top/hello-world/"/>
    <id>https://toyan.top/hello-world/</id>
    <published>2020-01-31T16:00:00.000Z</published>
    <updated>2020-02-04T11:07:11.655Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="quick-start"><a class="markdownIt-Anchor" href="#quick-start"></a> Quick Start</h2><h3 id="create-a-new-post"><a class="markdownIt-Anchor" href="#create-a-new-post"></a> Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="run-server"><a class="markdownIt-Anchor" href="#run-server"></a> Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="generate-static-files"><a class="markdownIt-Anchor" href="#generate-static-files"></a> Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="deploy-to-remote-sites"><a class="markdownIt-Anchor" href="#deploy-to-remote-sites"></a> Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
      <category term="hexo" scheme="https://toyan.top/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://toyan.top/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Java日志框架</title>
    <link href="https://toyan.top/spring-logger/"/>
    <id>https://toyan.top/spring-logger/</id>
    <published>2020-01-12T16:00:00.000Z</published>
    <updated>2020-02-08T11:47:57.590Z</updated>
    
    <content type="html"><![CDATA[<p>在Java开发中，常用的日志框架有<code>JDKLog、Log4J、LogBack、SLF4J</code>。这些日志记录框架各有各的特点，各有各的应用场景。了解这些框架的特点及应用场景，有利于我们做技术选型的时候做出正确的判断。</p><h1 id="java日志框架简要介绍"><a class="markdownIt-Anchor" href="#java日志框架简要介绍"></a> JAVA日志框架简要介绍</h1><h2 id="jdklog日志小刀"><a class="markdownIt-Anchor" href="#jdklog日志小刀"></a> JDKLog——日志小刀</h2><p>JDKLog是JDK官方提供的一个记录日志的方式，直接在JDK中就可以使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.logging.Logger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDKLog</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Logger logger = Logger.getLogger(<span class="string">"JDKLog"</span>);</span><br><span class="line">        logger.info(<span class="string">"Hello World."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​JDKLog的有点是使用非常简单，直接在 JDK 中就可以使用。但 JDKLog 功能比较太过于简单，不支持占位符显示，拓展性比较差，所以现在用的人也很少。</p><h2 id="log4j日志大炮"><a class="markdownIt-Anchor" href="#log4j日志大炮"></a> Log4J——日志大炮</h2><p>Log4J是Apache的一个日志开源框架，有多个分级（<code>DEBUG/INFO/WARN/ERROR</code>）记录级别，可以很好地将不同日志界别的日志分开记录，极大地方便了日志的查看。<br />Log4J有1.X和2.X两个版本，现在官方推荐使用2.X版本，2.X版本在架构上进行了一些升级，配置文件也发生了一些变化。<br />使用Log4J框架首先需要引入依赖的包：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>增加log4J2.xml放在resource目录下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Configuration</span> <span class="attr">status</span>=<span class="string">"WARN"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Appenders</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Console</span> <span class="attr">name</span>=<span class="string">"Console"</span> <span class="attr">target</span>=<span class="string">"SYSTEM_OUT"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"%d&#123;HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Console</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Appenders</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Loggers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Root</span> <span class="attr">level</span>=<span class="string">"info"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">"Console"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Loggers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中&lt;ROOT&gt;节点的level级别表示输出的最低级别。<br />最后编写一个测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.logging.log4j.LogManager;</span><br><span class="line"><span class="keyword">import</span> org.apache.logging.log4j.Logger;</span><br><span class="line"></span><br><span class="line"><span class="comment">/****</span></span><br><span class="line"><span class="comment"> ** Log4J Demo</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Log4jLog</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        Logger logger = LogManager.getLogger(Log4jLog<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        logger.debug(<span class="string">"Debug Level"</span>);</span><br><span class="line">        logger.info(<span class="string">"Info Level"</span>);</span><br><span class="line">        logger.warn(<span class="string">"Warn Level"</span>);</span><br><span class="line">        logger.error(<span class="string">"Error Level"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有配置log4j2.xml配置文件，那么LOG4J将自动启用类似于下面的配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Configuration</span> <span class="attr">status</span>=<span class="string">"WARN"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Appenders</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Console</span> <span class="attr">name</span>=<span class="string">"Console"</span> <span class="attr">target</span>=<span class="string">"SYSTEM_OUT"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"%d&#123;HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Console</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Appenders</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Loggers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Root</span> <span class="attr">level</span>=<span class="string">"error"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">"Console"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Loggers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用默认配置文件的输出结果：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERROR StatusLogger No log4j2 configuration file found. Using default configuration: logging only errors to the console.</span><br><span class="line">11:40:07.377 [main] ERROR com.chanshuyi.Log4jLog - Error Level</span><br></pre></td></tr></table></figure><p>从上面的使用步骤可以看出Log4J的使用稍微复杂一些，但是条理还是很清晰的。而且因为Log4J有多个分级（DEBUG/INFO/WARN/ERROR）记录级别，所以可以很好地记录不同业务问题。因为这些优点，所有在几年前几乎所有人都使用LOG4J作为日志记录框架。<br />但LOG4J本身也存在一些缺点，比如不支持使用占位符，不利于代码阅读等缺点，但是相比JDKLog，LOG4J已经是非常好的日志记录框架了。</p><h2 id="logback日志火箭"><a class="markdownIt-Anchor" href="#logback日志火箭"></a> LogBack——日志火箭</h2><p>LogBack其实可以说是Log4J的进化版，因为它们两个都是同一个人设计的开源框架。LogBack 除了具备 Log4j 的所有优点之外，还解决了 Log4J 不能使用占位符的问题。<br />使用LogBack需要首先引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- LogBack --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置logback.xml配置文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"STDOUT"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.PatternLayout"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Pattern</span>&gt;</span>%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n<span class="tag">&lt;/<span class="name">Pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"com.chanshuyi"</span> <span class="attr">level</span>=<span class="string">"TRACE"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"debug"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"STDOUT"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>LogBack的日志级别区分可以细分到类或者包，这样就可以使日志记录变得更加灵活。之后在类文件中引入Logger类，并进行日志记录。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/****</span></span><br><span class="line"><span class="comment"> ** LogBack Demo</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogBack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(LogBack<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        logger.trace(<span class="string">"Trace Level."</span>);</span><br><span class="line">        logger.debug(<span class="string">"Debug Level."</span>);</span><br><span class="line">        logger.info(<span class="string">"Info Level."</span>);</span><br><span class="line">        logger.warn(<span class="string">"Warn Level."</span>);</span><br><span class="line">        logger.error(<span class="string">"Error Level."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LogBack解决了Log4J不能使用占位符的问题，这使得阅读日志代码非常方便。除此之外，LogBack比Log4J有更快的运行速度，更好的内部实现。并且LogBack内部集成了Slf4J可以更原生地实现一些日志记录的实现。</p><h2 id="slf4j适配器"><a class="markdownIt-Anchor" href="#slf4j适配器"></a> SLF4J——适配器</h2><p>为了避免切换日志组件时要改动代码，这时候一个叫做SLF4J（Simple Logging Facade for Java，即Java简单日志记录接口集）的东西出现。<br />SLF4J是一个日志的接口规范，它对用户提供了统一的日志接口，屏蔽了不同日志组件的差异。这样我们在编写代码的时候只需要看SLF4J这个接口文档即可，不需要去理会不同日志框架的区别。而当我们需要更换日志组件的时候，我们只需要更换一个具体的日志组件Jar包就可以。<br />下面是整合SLF4J和日志框架的使用方式</p><p><strong>SLF4J + JDKLog</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.21<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-jdk14<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.21<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>SLF4J + LOG4J</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.21<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.21<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置log4J.xml文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">log4j</span>:configuration <span class="meta-keyword">SYSTEM</span> <span class="meta-string">"log4j.dtd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">log4j:configuration</span> <span class="attr">xmlns:log4j</span>=<span class="string">'http://jakarta.apache.org/log4j/'</span> &gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"myConsole"</span> <span class="attr">class</span>=<span class="string">"org.apache.log4j.ConsoleAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">"org.apache.log4j.PatternLayout"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"ConversionPattern"</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">value</span>=<span class="string">"[%d&#123;dd HH:mm:ss,SSS\&#125; %-5p] [%t] %c&#123;2\&#125; - %m%n"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--过滤器设置输出的级别--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"org.apache.log4j.varia.LevelRangeFilter"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"levelMin"</span> <span class="attr">value</span>=<span class="string">"debug"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"levelMax"</span> <span class="attr">value</span>=<span class="string">"error"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"AcceptOnMatch"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 根logger的设置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">priority</span> <span class="attr">value</span> =<span class="string">"debug"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"myConsole"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">log4j:configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>SLF4J + LogBack</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.21<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置logBack.xml文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"STDOUT"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.PatternLayout"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Pattern</span>&gt;</span>%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n<span class="tag">&lt;/<span class="name">Pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"com.chanshuyi"</span> <span class="attr">level</span>=<span class="string">"TRACE"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"warn"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"STDOUT"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="java日志框架的抉择"><a class="markdownIt-Anchor" href="#java日志框架的抉择"></a> JAVA日志框架的抉择</h1><p>现在最流行的日志框架解决方案莫过于SLF4J + LogBack。其有以下几个优点：</p><ul><li>LogBack自身实现了SLF4J的日志接口，不需要SLF4J去做进一步的适配</li><li>LogBack自身是在Log4J的基础上优化而成的，其运行速度和效率都比LOG4J高</li><li>SLF4J + LogBack支持占位符，方便日志代码的阅读，而Log4j则不支持</li></ul><p>LogBack被分成三个组件：<code>logback-core、logback-classic和logback-access</code></p><ul><li><code>logback-core</code>提供了LogBack的核心功能，是另外两个组件的基础</li><li><code>logback-classic</code>则实现了SLF4J的API，所以当想配合SLF4J使用时，需要将它引入</li><li><code>logback-access</code>是为了集成Servlet环境而准备的，可提供HTTP-access的日志接口</li></ul><p>了解LogBack日志的日志流向，对于我们后面学习日志框架的配置很有帮助。从下图可以看出LogBack的日志记录数据流是从Class或Package流到Logger，再从Logger到Appender，最后从Appender到具体的输出终端</p><p><img src="https://img.mukewang.com/5a2e524700012d5213020826.png" alt="" /></p><h1 id="logback配置文件介绍"><a class="markdownIt-Anchor" href="#logback配置文件介绍"></a> LogBack配置文件介绍</h1><p>LogBack配置文件可以分为几个节点，其中Configuration是根节点，Appender、Logger和Root是Configuration的子节点。</p><h2 id="appender节点"><a class="markdownIt-Anchor" href="#appender节点"></a> Appender节点</h2><p>&lt;appender&gt;是&lt;configuration&gt;的子节点，是负责写日志的组件。appender有两个必要属性name、class。name指定appender的名称，class指定appender的全限定名</p><p>class主要包括：</p><ul><li><code>ch.qos.logback.core.ConsoleAppender</code> 控制台输出</li><li><code>ch.qos.logback.core.FileAppender</code> 文件输出</li><li><code>ch.qos.logback.core.RollingFileAppender</code> 文件滚动输出</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">debug</span>=<span class="string">"true"</span> <span class="attr">scan</span>=<span class="string">"true"</span> <span class="attr">scanPeriod</span>=<span class="string">"2"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- conf consoel out --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span> =<span class="string">"console_out"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- conf file out --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"file_out"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.FileAppender"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- conf file out --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"file_out"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.RollingFileAppender"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span>&gt;</span><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span>&gt;</span><span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="consoleappender"><a class="markdownIt-Anchor" href="#consoleappender"></a> ConsoleAppender</h3><p>把日志添加到控制台，有如下节点：</p><ul><li><code>&lt;encoder&gt;</code>：对日志进行格式化</li><li><code>&lt;target&gt;</code>：字符串System.out 或者 System.err, 默认 System.out</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- conf consoel out --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span> =<span class="string">"console_out"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%date [%thread] %-5level %logger - %message%newline<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"INFO"</span>&gt;</span>             </span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"console_out"</span> /&gt;</span>   </span><br><span class="line">  <span class="tag">&lt;/<span class="name">root</span>&gt;</span>     </span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="fileappender"><a class="markdownIt-Anchor" href="#fileappender"></a> FileAppender</h3><p>把日志添加到文件，有如下节点：</p><ul><li><code>&lt;file&gt;</code>：被写入的文件名，可以是相对目录，也可以是绝对目录，如果目录不存在则会自动创建</li><li><code>&lt;append&gt;</code>：如果是true，日志被追加到文件末尾，如果是false，清空现存文件，默认是true</li><li><code>&lt;encoder&gt;</code>：对日志进行格式化</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"file_out"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.FileAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>logs/debug.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%date [%thread] %-5level %logger - %message%newline<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="rollingfileappender"><a class="markdownIt-Anchor" href="#rollingfileappender"></a> RollingFileAppender</h3><p>滚动记录文件，先将日志记录到指定文件，当符合某种条件时，将日志记录到其他文件，有如下节点：</p><ul><li><code>&lt;file&gt;</code>：被写入的文件名，可以是相对目录，也可以直接目录，如果目录不存在则自动创建</li><li><code>&lt;append&gt;</code>：如果是true，日志被追加到文件末尾，如果是false，清空现存文件，默认是true</li><li><code>&lt;encoder&gt;</code>：对日志进行格式化</li><li><code>&lt;rollingPolicy&gt;</code>：当发生滚动时，决定RollingFileAppender的行为，涉及文件移动和重命名</li></ul><h3 id="rollingpolicy"><a class="markdownIt-Anchor" href="#rollingpolicy"></a> rollingPolicy</h3><ul><li>TimeBaseRollingPolicy：最常用的滚动策略，根据时间来制定滚动策略，即负责滚动也负责除非滚动。有如下节点<ul><li><code>&lt;fileNamePattern&gt;</code>：必要节点，包含文件及&quot;%d&quot;转换符，&quot;%d&quot;可以包含一个<code>java.text.SimpleDateFormat</code>制定的时间格式，如：%d{yyyy-MM}，如果直接使用%d ，默认格式是 yyyy－MM－dd</li><li><code>&lt;maxHistory&gt;</code>：可选节点，控制保留的归档文件的最大数量，超出数量就删除旧文件，假设设置每个月滚动，且&lt;maxHistory&gt;是6，则只保存最近6个月的文件，删除之前的旧文件，注意：删除旧文件是哪些为了归档而创建的目录也会被删除</li><li><code>&lt;filenamePattern&gt;</code>：必须包含&quot;%i&quot;，例如：设置最小值，和最大值分别为1和2，命名模式为<code>log%i.log</code>，会产生归档文件<code>log1.log</code>和<code>log2.log</code>，还可以指定文件压缩选项，例如<code>log%i.log.gz</code>或者<code>log%i.log.zip</code></li></ul></li><li>triggeringPolicy：告知RollingFileAppender，激活RollingFileAppender滚动</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 03:conf errorAppender out --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"errorAppender"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.RollingFileAppender"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">file</span>&gt;</span>logs/error.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设置滚动策略 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!--设置日志命名模式--&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>errorFile.%d&#123;yyyy-MM-dd&#125;.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--最多保留30天log--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>30<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 超过150MB时，触发滚动策略 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">triggeringPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>150<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">triggeringPolicy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d [%p] %-5level %logger - %msg%newline<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="logger节点"><a class="markdownIt-Anchor" href="#logger节点"></a> logger节点</h2><p>logger是&lt;configuration&gt;的子节点，来设置某一个包或者具体的某一个类的日志打印级别，以及指定&lt;appender&gt;。logger仅有一个name属性，两个可选属性level/addtivity</p><ul><li>name：用来指定受此logger约束的某一个包或者具体的某一个类</li><li>level：用来设置打印级别，大小写无关。可选值有TRACE、DEBUG、INFO、WARN、ERROR、ALL和OFF。还有一个特殊值INHERITED或者同义词NULL，代表强制执行上级的级别。如果未设此属性，那么当前logger将会继承上级的级别</li><li>addtivity：是否向上级logger传递打印信息，默认为true</li></ul><p>&lt;logger&gt;可以包含零个或多个&lt;appender-ref&gt;元素，表示这个appender将会添加到logger</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- conf consoel out --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span> =<span class="string">"console_out"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.LevelFilter"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 过滤掉非INFO级别 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>INFO<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--  conf infoAppender out --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"infoAppender"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.RollingFileAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>logs/info.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 设置滚动策略 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPoliy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span>  </span><br><span class="line">            <span class="comment">&lt;!--设置日志命名模式--&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>infoFile.%d&#123;yyyy-MM-dd&#125;.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--最多保留30天log--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>30<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPoliy</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 超过150MB时，触发滚动策略 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">triggeringPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>150<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">triggeringPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d [%p] %-5level %logger - %msg%newline<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 添加两个appender节点 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"logback.olf.log"</span> <span class="attr">level</span>=<span class="string">"info"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span> = <span class="string">"console_out"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span> = <span class="string">"infoAppender"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="root节点"><a class="markdownIt-Anchor" href="#root节点"></a> root节点</h2><p>元素配置根logger。该元素有一个level属性，没有name属性，因为已经被命名为root。Level属性的值大小写无关，其值为下面其中一个字符串：TRACE、DEBUG、INFO、WARN、ERROR、ALL和OFF。如果root元素没有引用任何appender，就会失去所有appender。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- conf consoel out --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span> =<span class="string">"console_out"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.LevelFilter"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 过滤掉非INFO级别 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>INFO<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 01:conf infoAppender out --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"infoAppender"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.RollingFileAppender"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>logs/info.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 设置滚动策略 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPoliy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span>  </span><br><span class="line">            <span class="comment">&lt;!--设置日志命名模式--&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>infoFile.%d&#123;yyyy-MM-dd&#125;.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--最多保留30天log--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>30<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPoliy</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 超过150MB时，触发滚动策略 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">triggeringPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>150<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">triggeringPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d [%p] %-5level %logger - %msg%newline<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 02:conf debugAppender out --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"debugAppender"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.RollingFileAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>logs/debug.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 设置滚动策略 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPoliy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span>  </span><br><span class="line">            <span class="comment">&lt;!--设置日志命名模式--&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>debugFile.%d&#123;yyyy-MM-dd&#125;.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--最多保留30天log--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>30<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPoliy</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 超过150MB时，触发滚动策略 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">triggeringPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>150<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">triggeringPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d [%p] %-5level %logger - %msg%newline<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 03:conf errorAppender out --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"errorAppender"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.RollingFileAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>logs/error.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 设置滚动策略 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPoliy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span>  </span><br><span class="line">            <span class="comment">&lt;!--设置日志命名模式--&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>errorFile.%d&#123;yyyy-MM-dd&#125;.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--最多保留30天log--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>30<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPoliy</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 超过150MB时，触发滚动策略 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">triggeringPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>150<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">triggeringPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d [%p] %-5level %logger - %msg%newline<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"ALL"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"infoAppender"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"debugAppender"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"errorAppender"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="filter过滤节点"><a class="markdownIt-Anchor" href="#filter过滤节点"></a> filter过滤节点</h2><h3 id="级别过滤器levelfilter"><a class="markdownIt-Anchor" href="#级别过滤器levelfilter"></a> 级别过滤器（LevelFilter）</h3><p>LevelFilter根据记录级别对记录事件进行过滤。如果事件的级别等于配置的级别，过滤器会根据onMatch和onMismatch属性接收和拒绝时间。下面是和配置文件例子：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- conf consoel out --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span> =<span class="string">"console_out"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.LevelFilter"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 过滤掉非INFO级别 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>INFO<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%-4relative [%thread] %-5level %logger&#123;30&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"DEBUG"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"console_out"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="临界值过滤器thresholdfilter"><a class="markdownIt-Anchor" href="#临界值过滤器thresholdfilter"></a> 临界值过滤器（ThresholdFilter）</h3><p>ThresholdFilter过滤掉低于指定临界值的事件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- conf consoel out --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span> =<span class="string">"console_out"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.ThresholdFilter"</span>&gt;</span>  </span><br><span class="line">　　　　　　　　<span class="comment">&lt;!-- 过滤掉TRACE和DEBUG级别的日志 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>INFO<span class="tag">&lt;/<span class="name">level</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%-4relative [%thread] %-5level %logger&#123;30&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"DEBUG"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"console_out"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="求值过滤器evaluatorfilter"><a class="markdownIt-Anchor" href="#求值过滤器evaluatorfilter"></a> 求值过滤器（EvaluatorFilter）</h3><p>评估是否符合指定的条件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- conf consoel out --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span> =<span class="string">"console_out"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.EvaluatorFilter"</span>&gt;</span>  </span><br><span class="line">             <span class="tag">&lt;<span class="name">evaluator</span>&gt;</span></span><br><span class="line">             <span class="comment">&lt;!--过滤掉所有日志中不包含hello字符的日志--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">expression</span>&gt;</span></span><br><span class="line">                    message.contains("hello")</span><br><span class="line">                <span class="tag">&lt;/<span class="name">expression</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>NEUTRAL<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;/<span class="name">evaluator</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%-4relative [%thread] %-5level %logger&#123;30&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"DEBUG"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"console_out"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="匹配器matchers"><a class="markdownIt-Anchor" href="#匹配器matchers"></a> 匹配器（Matchers）</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- conf consoel out --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span> =<span class="string">"console_out"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.EvaluatorFilter"</span>&gt;</span>  </span><br><span class="line">             <span class="tag">&lt;<span class="name">evaluator</span>&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">matcher</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">Name</span>&gt;</span>odd<span class="tag">&lt;/<span class="name">Name</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!-- 过滤掉序号为奇数的语句--&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">regex</span>&gt;</span>statement [13579]<span class="tag">&lt;/<span class="name">regex</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">matcher</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">expression</span>&gt;</span>odd.matches(formattedMessage)<span class="tag">&lt;/<span class="name">expression</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>NEUTRAL<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;/<span class="name">evaluator</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%-4relative [%thread] %-5level %logger&#123;30&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"DEBUG"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"console_out"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="logback配置文件实例"><a class="markdownIt-Anchor" href="#logback配置文件实例"></a> logback配置文件实例</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">debug</span>=<span class="string">"true"</span> <span class="attr">scan</span>=<span class="string">"true"</span> <span class="attr">scanPeriod</span>=<span class="string">"30 seconds"</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"STDOUT"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- encoders are  by default assigned the type</span></span><br><span class="line"><span class="comment">         ch.qos.logback.classic.encoder.PatternLayoutEncoder --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss&#125; [%level] - %m%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 常用的Pattern变量,大家可打开该pattern进行输出观察 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">          &lt;pattern&gt;</span></span><br><span class="line"><span class="comment">              %d&#123;yyyy-MM-dd HH:mm:ss&#125; [%level] - %msg%n</span></span><br><span class="line"><span class="comment">              Logger: %logger</span></span><br><span class="line"><span class="comment">              Class: %class</span></span><br><span class="line"><span class="comment">              File: %file</span></span><br><span class="line"><span class="comment">              Caller: %caller</span></span><br><span class="line"><span class="comment">              Line: %line</span></span><br><span class="line"><span class="comment">              Message: %m</span></span><br><span class="line"><span class="comment">              Method: %M</span></span><br><span class="line"><span class="comment">              Relative: %relative</span></span><br><span class="line"><span class="comment">              Thread: %thread</span></span><br><span class="line"><span class="comment">              Exception: %ex</span></span><br><span class="line"><span class="comment">              xException: %xEx</span></span><br><span class="line"><span class="comment">              nopException: %nopex</span></span><br><span class="line"><span class="comment">              rException: %rEx</span></span><br><span class="line"><span class="comment">              Marker: %marker</span></span><br><span class="line"><span class="comment">              %n</span></span><br><span class="line"><span class="comment">          &lt;/pattern&gt;</span></span><br><span class="line"><span class="comment">           --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 按日期区分的滚动日志 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"ERROR-OUT"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">file</span>&gt;</span>logs/error.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss&#125; [%class:%line] - %m%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.LevelFilter"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">level</span>&gt;</span>ERROR<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- daily rollover --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>error.%d&#123;yyyy-MM-dd&#125;.log.zip<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">&lt;!-- keep 30 days' worth of history --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>30<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 按文件大小区分的滚动日志 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"INFO-OUT"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">file</span>&gt;</span>logs/info.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss&#125; [%class:%line] - %m%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.LevelFilter"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">level</span>&gt;</span>INFO<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.FixedWindowRollingPolicy"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>info.%i.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">minIndex</span>&gt;</span>1<span class="tag">&lt;/<span class="name">minIndex</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">maxIndex</span>&gt;</span>3<span class="tag">&lt;/<span class="name">maxIndex</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">triggeringPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>5MB<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">triggeringPolicy</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 按日期和大小区分的滚动日志 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"DEBUG-OUT"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">file</span>&gt;</span>logs/debug.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss&#125; [%class:%line] - %m%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.LevelFilter"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">level</span>&gt;</span>DEBUG<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- rollover daily --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>debug-%d&#123;yyyy-MM-dd&#125;.%i.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">timeBasedFileNamingAndTriggeringPolicy</span></span></span><br><span class="line"><span class="tag">            <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- or whenever the file size reaches 100MB --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>100MB<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">timeBasedFileNamingAndTriggeringPolicy</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- 级别阀值过滤 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"SUM-OUT"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">file</span>&gt;</span>logs/sum.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss&#125; [%class:%line] - %m%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- deny all events with a level below INFO, that is TRACE and DEBUG --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.ThresholdFilter"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">level</span>&gt;</span>INFO<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- rollover daily --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>debug-%d&#123;yyyy-MM-dd&#125;.%i.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">timeBasedFileNamingAndTriggeringPolicy</span></span></span><br><span class="line"><span class="tag">            <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- or whenever the file size reaches 100MB --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>100MB<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">timeBasedFileNamingAndTriggeringPolicy</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"debug"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"STDOUT"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"ERROR-OUT"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"INFO-OUT"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"DEBUG-OUT"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"SUM-OUT"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="日志系统转换"><a class="markdownIt-Anchor" href="#日志系统转换"></a> 日志系统转换</h1><h2 id="从日志框架转向slf4j"><a class="markdownIt-Anchor" href="#从日志框架转向slf4j"></a> 从日志框架转向slf4j</h2><ul><li>jul-to-slf4j：jdk-logging到slf4j的桥梁</li><li>log4j-over-slf4j：log4j1到slf4j的桥梁</li><li>jcl-over-slf4j：commons-logging到slf4j的桥梁</li></ul><h2 id="从slf4j转向具体的日志框架"><a class="markdownIt-Anchor" href="#从slf4j转向具体的日志框架"></a> 从slf4J转向具体的日志框架</h2><ul><li>slf4j-jdk14：slf4j到jdk-logging的桥梁</li><li>slf4j-log4j12：slf4j到log4j1的桥梁</li><li>log4j-slf4j-impl：slf4j到log4j2的桥梁</li><li>logback-classic：slf4j到logback的桥梁</li><li>slf4j-jcl：slf4j到commons-logging的桥梁</li></ul><h2 id="日志框架技术一览"><a class="markdownIt-Anchor" href="#日志框架技术一览"></a> 日志框架技术一览</h2><ul><li><p>JUL：JDK中的日志记录工具，也常称为JDKLog、jdk-logging。</p></li><li><p>LOG4J1：一个具体的日志实现框架。</p></li><li><p>LOG4J2：一个具体的日志实现框架，是LOG4J1的下一个版本。</p></li><li><p>LOGBACK：一个具体的日志实现框架，但其性能更好。</p></li><li><p>JCL：一个日志门面，提供统一的日志记录接口，也常称为commons-logging。</p></li><li><p>SLF4J：一个日志门面，与JCL一样提供统一的日志记录接口，可以方便地切换看具体的实现框架。</p><p>JUL、LOG4J1、LOG4J2、LOGBACK是<strong>日志实现框架</strong>，而JCL、SLF4J是<strong>日志实现门面</strong></p></li></ul><h1 id="注意"><a class="markdownIt-Anchor" href="#注意"></a> 注意</h1><ul><li>一般建议日志对象logger声明为private static final。声明为private可防止logger对象被其它类非法使用。声明为static可防止重复new出logger对象，造成资源浪费；还可防止logger被序列化，造成安全风险。声明为final是因为在类的声明周期内无需变更logger</li><li>如果日志不分级别或级别设置不合理，则定位问题时就无法快速有效地屏蔽大量低级别信息，给快速定位问题带来难度。<strong>建议与具体实现的日志使用debug级别，一般的业务处理日志使用info级别，不影响业务进行的错误使用warn级别，而记录异常或重要错误的日志应为error级别</strong></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Java开发中，常用的日志框架有&lt;code&gt;JDKLog、Log4J、LogBack、SLF4J&lt;/code&gt;。这些日志记录框架各有各的特点，各有各的应用场景。了解这些框架的特点及应用场景，有利于我们做技术选型的时候做出正确的判断。&lt;/p&gt;
&lt;h1 id=&quot;java日志框
      
    
    </summary>
    
    
      <category term="Web" scheme="https://toyan.top/categories/Web/"/>
    
      <category term="Spring" scheme="https://toyan.top/categories/Web/Spring/"/>
    
    
      <category term="Spring" scheme="https://toyan.top/tags/Spring/"/>
    
      <category term="log" scheme="https://toyan.top/tags/log/"/>
    
  </entry>
  
  <entry>
    <title>红黑树深入剖析及Java实现</title>
    <link href="https://toyan.top/RBTree/"/>
    <id>https://toyan.top/RBTree/</id>
    <published>2019-12-12T16:00:00.000Z</published>
    <updated>2020-02-08T17:22:21.890Z</updated>
    
    <content type="html"><![CDATA[<h2 id="bst"><a class="markdownIt-Anchor" href="#bst"></a> BST</h2><p>二叉查找树（Binary Search Tree，简称BST）是一颗二叉树，它的左子节点的值比父节点的值要小，右节点的值要比父节点的值大。它的高度决定了它的查找效率。</p><p>在理想情况下，二叉查找树增删改查的时间复杂度为o(logN)（其中N为节点数），最坏的情况下为o(N)。当它的高度为log(N) + 1时，我们就说二叉查找树是平衡的。</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/v2-e64df5b2126506c59bad4604d298d818_hd.png" alt="" /></p><h3 id="bst的查找操作"><a class="markdownIt-Anchor" href="#bst的查找操作"></a> BST的查找操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// T key = a search key</span></span><br><span class="line"><span class="comment">// Node root = point to the root of a BST</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (root.value.equals(key)) &#123;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.compareTo(root.value) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    root = root.left;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    root = root.right;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>从程序中可以看出，当BST查找的时候，先与当前节点进行比较：</p><ul><li>如果相等的话就返回当前节点</li><li>如果小于当前节点则继续查找当前节点的左节点</li><li>如果大于当前节点则继续查找当前节点的右节点</li></ul><p>直到当前节点指针为空或者查找到对应的节点，程序查找结束</p><h3 id="bst的插入操作"><a class="markdownIt-Anchor" href="#bst的插入操作"></a> BST的插入操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Node node = create a new node with specify value</span></span><br><span class="line"><span class="comment">// Node root = point the root node of a BST</span></span><br><span class="line"><span class="comment">// Node parent = null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// find the parent node to append the new node</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  parent = root;</span><br><span class="line">  <span class="keyword">if</span> (node.value.compareTo(root.value) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    root = root.left;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    root = root.right;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (node.value.compareTo(parent.value) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    parent.left = node;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    parent.right = node;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入操作先通过循环查找到待插入的节点的父节点，和查找父节点的逻辑一样，都是比大小，小的往左，大的往右。找到父节点后，对比父节点，小的就插入到父节点的左节点，大就插入到父节点的右节点上</p><h3 id="bst的删除操作"><a class="markdownIt-Anchor" href="#bst的删除操作"></a> BST的删除操作</h3><p>删除操作的步骤如下：</p><ul><li>查找到要删除的节点</li><li>如果待删除的节点是叶子节点，则直接删除</li><li>如果待删除的节点不是叶子节点，则先找到待删除的节点的中序遍历的后继节点，用该后继节点的值替换待删除的节点的值，然后删除后续节点</li></ul><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/v2-caf8927ad71613b1f93393931029b5a4_hd.png" alt="" /></p><h3 id="bst存在的问题"><a class="markdownIt-Anchor" href="#bst存在的问题"></a> BST存在的问题</h3><p>BST存在的主要问题是，在插入的时候会导致树倾斜，不同的插入顺序会导致树的高度不一样，而树的高度直接地影响了树的查找效率。理想的高度是logN，最坏的情况是所有的节点都在一条斜线上，这样的树的高度是N</p><h2 id="rbtree"><a class="markdownIt-Anchor" href="#rbtree"></a> RBTree</h2><p>基于BST存在的问题，一种新的树——平衡二叉查找树(Balanced BST)产生了。平衡树在插入和删除的时候，会通过旋转操作将高度保持在logN。其中两款具有代表性的平衡树分别为AVL树和红黑树。AVL树由于实现比较复杂，而且插入和删除性能差，在实际环境下的应用不如红黑树。</p><p>红黑树（Red-Black Tree，以下简称RBTree）的实际应用非常广泛，比如Linux内核中的完全公平调度器、高精度计时器、ext3文件系统等等，各种语言的函数库如Java的TreeMap和TreeSet，C++ STL的map、multimap、multiset等。</p><p>RBTree也是函数式语言中最常用的持久数据结构之一，在计算几何中也有重要作用。值得一提的是，Java 8中HashMap的实现也因为用RBTree取代链表，性能有所提升。</p><h3 id="avl树"><a class="markdownIt-Anchor" href="#avl树"></a> AVL树</h3><ul><li><p>简介：AVL树是带有平衡条件的二叉查找树，一般使用平衡因子差值判断是否平衡，平衡因子为左右子树高度之差，绝对值不能大于1，失衡时通过旋转来实现平衡，与红黑树相比，AVL树是严格的平衡二叉树，旋转是十分耗时的，因此AVL树适合用于插入删除次数较少，但查找较多的情况（中序遍历为有序序列，时间复杂度为o(n*logn)）</p></li><li><p>局限性：由于维护了这种高度平衡所付出的代价比从中获得的效益收益还大，故而实际的应用不多，更多的地方是用追求局部而不是非常严格整体平衡的红黑树。当然，如果应用场景中对插入删除不频繁，只是对查找要求较高，那么AVL还是较优于红黑树</p></li><li><p>应用：Windows NT内核中广泛存在</p></li></ul><h3 id="2-3树"><a class="markdownIt-Anchor" href="#2-3树"></a> 2-3树</h3><p>2-3树是一种绝对平衡树。它的节点元素个数可以为1个或者2个。如图，下面就是一个2-3树：</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/21.png" alt="" /></p><p>2-3树中的2代表一个节点有两个孩子，3代表一个节点有三个孩子</p><h4 id="2-3树的操作"><a class="markdownIt-Anchor" href="#2-3树的操作"></a> 2-3树的操作</h4><h5 id="插入"><a class="markdownIt-Anchor" href="#插入"></a> 插入</h5><p>这里结合一个例子来查看2-3树是如何实现绝对平衡的。例如，现在我们要依次增加1、2、3、4、5、6、7这7个元素，如图</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2020/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-12-10%20%E4%B8%8B%E5%8D%884.44.58.png" alt="" /></p><p>如果所示，下面一个步骤一个步骤分析：</p><ul><li>插入1，判断无根节点，直接将1封装为节点并设置为根节点</li><li>插入2，这是因为1节点没有孩子节点并且只有1节点，所有直接将2加入到节点1中</li><li>插入3，和2节点一样，将3节点放入到根节点中，这是根节点有3个元素了，就需要变化为步骤4的样子。可以理解为将1、2、3的中间元素提取到根节点，也就是将2提出来，1作为左孩子，3作为右孩子</li><li>插入4，4比2大，增加到节点3</li><li>插入5，5比2大，增加到节点3、4中，这是节点3、4变为节点3、4、5，节点3、4、5按照第三步中将中间元素提取为双亲节点，而4提取出来的4回去找双亲节点2，2节点只有一个元素，所以4加入到2节点中</li><li>插入6，6大于根节点的2和4，进入最右边，5没有孩子只有一个元素，加入6到5节点</li><li>插入7，这时5、6、7将6提取出放入6的双亲节点，6的双亲节点（根节点）变为2、4、6。2、4、6提取出4变成最后的样子</li></ul><p>总的来说，插入方法和二分搜索相似。但是每个节点可以有1-2个元素，当节点元素个数为3时，就会分成3个节点并向上合并，直到合并完成。</p><h5 id="查找"><a class="markdownIt-Anchor" href="#查找"></a> 查找</h5><p>2-3树的查找和二分搜索树类似，不过因为一个节点可能有2个元素，需要对这两个元素进行比较，分别前往这两个节点的左、中、右孩子继续比较</p><h5 id="删除"><a class="markdownIt-Anchor" href="#删除"></a> 删除</h5><p>2-3树的删除稍微复杂一点儿，删除可分为两大情况，就是删除叶子节点和非叶子节点</p><p>这里只说理论情况，不结合代码实现，实际上代码实现会变得复杂也只是因为考虑的东西更多，代码实现会变得复杂</p><p><strong>删除叶子节点（不太懂）</strong></p><ul><li>当前节点是3节点，直接删除</li><li>当前节点是2节点：删除并判断<ul><li>双亲是2节点，判断兄弟节点<ul><li>兄弟节点是3节点，将兄弟节点移到双亲节点，再将双亲节点的另一个元素移到当前节点</li><li>兄弟节点是2节点，先通过移动兄弟节点的中序遍历直接后驱到兄弟节点，以使兄弟节点变为3节点，再进行删除</li></ul></li><li>双亲节点是3节点，拆分双亲节点使其变成2节点，再将双亲节点中最接近的一个拆分key与中孩子合并，将合并后的节点作为当前节点</li></ul></li><li>若2-3树是棵满二叉树，删除节点，将2-3树层树减少，并将兄弟节点合并到双亲节点中，同时将双亲节点的所有兄弟节点合并到双亲节点的双亲节点中，如果变为4节点，就做分解操作</li></ul><p><strong>删除非叶子节点</strong></p><p>使用中序遍历下的直接后继节点key来覆盖当前节点key，再删除用来覆盖的后继节点key</p><h3 id="rbtree定义"><a class="markdownIt-Anchor" href="#rbtree定义"></a> RBTree定义</h3><p>在开始红黑树之前，我们要知道红黑树并非只有2-3树这一种实现方式，虽然2-3树实现红黑树比较方便。RBTree的定义如下：</p><ul><li>任何一个节点都有颜色，黑色或者红色</li><li>根节点是黑色的</li><li>父子节点之间不能出现两个连续的红色节点</li><li>任何一个节点向下遍历到其子孙节点的叶子节点，所经过的黑色节点个数必须相等</li><li>空节点被认为是黑色的，即每一个叶子节点是黑色</li></ul><p>2-3树与红黑树的关系</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2020/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-12-10%20%E4%B8%8B%E5%8D%888.40.54.png" alt="" /></p><p>如图，我们可以看到，可以将2-3树中的3节点中的左元素弄成一个新节点，这个节点就是红黑树中的红节点，并且将红节点统一进行左偏向，得出右图的红黑树，这样的红黑树也叫左倾红黑树。</p><p>数据结构表示如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 排序也是通过key进行排序</span></span><br><span class="line">  <span class="keyword">public</span> K key;</span><br><span class="line">  <span class="keyword">public</span> V value;</span><br><span class="line">  <span class="keyword">public</span> Node left, right;</span><br><span class="line">  <span class="comment">// 红为true，黑为false，默认节点为红</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">boolean</span> color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RBTree在理论上还是一颗BST树，但是它在对BST的插入和删除操作时会维持树的平衡，即保证树的高度在[logN, logN + 1]（理论上，极端情况下可以出现RBTree的高度达到2*logN，但实际上很难遇到）。这样RBTree的查找时间复杂度始终保持在o(logN)从而接近于理想的BST。RBTree的删除和插入操作的时间复杂度也是o(logN)。RBTree的查找操作就是BST的查找操作</p><h4 id="rbtree的旋转操作"><a class="markdownIt-Anchor" href="#rbtree的旋转操作"></a> RBTree的旋转操作</h4><p>旋转操作（Rotate）的目的是使节点的颜色符合定义，让RBTree的高度达到平衡。</p><p>Rotate分为left-rotate（左旋）和right-notate（右旋），区分左旋和右旋的方法是：<strong>待旋转的节点从左边上升到父节点就是右旋，待旋转节点从右边上升到父节点就是左旋。</strong></p><p><strong>左旋转</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//   node                     x</span></span><br><span class="line"><span class="comment">//  /   \     左旋转         /  \</span></span><br><span class="line"><span class="comment">// T1   x   ---------&gt;   node   T3</span></span><br><span class="line"><span class="comment">//     / \              /   \</span></span><br><span class="line"><span class="comment">//    T2 T3            T1   T2</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">leftRotate</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">  Node x = node.right;</span><br><span class="line">  <span class="comment">// 左旋转</span></span><br><span class="line">  node.right = x.left;</span><br><span class="line">  x.left = node;</span><br><span class="line">  x.color = node.color;</span><br><span class="line">  node.color = RED;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>右旋转</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//     node                   x</span></span><br><span class="line"><span class="comment">//    /   \     右旋转       /  \</span></span><br><span class="line"><span class="comment">//   x    T2   -------&gt;   y   node</span></span><br><span class="line"><span class="comment">//  / \                       /  \</span></span><br><span class="line"><span class="comment">// y  T1                     T1  T2</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">rightRotate</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">  Node x = node.left;</span><br><span class="line">  <span class="comment">// 右旋转</span></span><br><span class="line">  node.left = x.right;</span><br><span class="line">  x.right = node;</span><br><span class="line">  x.color = node.color;</span><br><span class="line">  node.color = RED;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>颜色翻转</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 颜色翻转</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flipColors</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">  node.color = RED;</span><br><span class="line">  node.left.color = BLACK;</span><br><span class="line">  node.right.color = BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>左旋和右旋总结</strong></p><p>树的旋转，能保持不变的只有树的二叉查找性质，而原树的红黑性质则不能保持，在红黑树的数据插入和删除后，可利用旋转和颜色翻转来恢复树的红黑性质</p><h4 id="rbtree的查找操作"><a class="markdownIt-Anchor" href="#rbtree的查找操作"></a> RBTree的查找操作</h4><p>RBTree的查找操作和BST的查找操作是一样的。请参考BST的查找操作代码。</p><h4 id="btree的插入操作介绍一"><a class="markdownIt-Anchor" href="#btree的插入操作介绍一"></a> BTree的插入操作介绍一</h4><p>向一颗含有n个节点的红黑树插入一个新的节点的操作可以在o(logn)时间完成</p><p>在插入操作分析之前，再复习下红黑树的性质：</p><blockquote><p>1、每个节点要么是红色，要么是黑色<br />2、根节点是黑色<br />3、所有叶子节点是黑色，即空节点（NIL）<br />4、如果一个节点是红色的，则它的两个子节点必须是黑色的，也就是父子节点不能都为红色<br />5、从一个节点到其所有叶子节点的所有路径上包含相同数目的黑节点</p></blockquote><p><strong>规则预定</strong></p><ol><li>在红黑树中插入节点，节点的初始颜色都是红色，因为这样可以在插入过程中尽量避免对树的结构进行调整（参考第5点性质）</li><li>初始插入按照二叉查找树的性质插入，即找到合适大小的节点，在其左边或者右边插入子节点</li></ol><p>我们在插入一个节点后，会使树的那些性质改变呢？</p><ol><li>由于是以二叉查找树的性质插入，因此节点的查找性质不会被破坏</li><li>如果插入空树中，成为根节点，则性质2会被破坏，需要重新涂色</li><li>如果插入节点的父节点是红色，则性质4会被破坏，需要以插入的当前节点为中心进行旋转或重新涂色来恢复红黑树的性质。<strong>执行旋转或重新涂色后有可能红黑树仍然不满足性质，则需要将当前节点变换回溯到其父节点或祖父节点，以父节点或祖父节点为中心继续旋转或重新涂色，如此循环到根节点直到满足红黑树的性质。</strong></li></ol><p><strong>恢复红黑树性质的策略</strong></p><p>根据上面说到的性质改变，对应的恢复策略其实就简单很多</p><ol><li><p>把出现违背红黑树性质的结点向上移（通过旋转操作或变换当前节点到父节点或祖父节点后再旋转达到向上移动的目的），如果能移到根结点，那么很容易就能通过直接修改根结点的颜色，或旋转根节点来恢复红黑树的性质</p></li><li><p>旋转或涂色处理可分5种情况进行处理</p><blockquote><p>情况1：空树中插入根节点<br />情况2：插入节点的父节点是黑色<br />情况3：当前节点的父节点是红色，且叔叔节点（祖父节点的另一个子节点）也是红色<br />情况4：当前节点的父节点是红色，叔叔节点是黑色，当前节点是右子节点<br />情况5：当前节点的父节点是红色，叔叔节点是黑色，当前节点是左子节点</p></blockquote></li></ol><p><strong>情况1：空树中插入根节点</strong><br />违反：性质2<br />恢复策略：初始插入的节点均为红色，因此简单将红色重涂为黑色即可。</p><p><strong>情况2：插入节点的父节点是黑色</strong><br />违反：插入的红色节点，未违反任何性质。<br />恢复策略：什么也不做，无需调整。</p><p><strong>情况3：当前节点的父节点是红色，且叔叔节点也是红色</strong><br />违反：性质4<br />此时祖父节点一定存在，否则插入前就已不是红黑树。<br />与此同时，又分为父节点是祖父节点的左子还是右子，由于对称性，我们只要解开一个方向就可以了。在此，我们只考虑父节点为祖父左子的情况。<br />同时，还可以分为当前结点是其父结点的左子还是右子，但是处理方式是一样的。我们将此归为同一类。<br />恢复策略：将当前节点的父节点和叔叔节点涂黑，祖父结点涂红，把当前结点指向祖父节点，以祖父节点为中心重新开始新一轮的旋转或涂色。<br />以插入节点4为例，按照恢复策略，做如下图的涂色：</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2020/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-12-10%20%E4%B8%8B%E5%8D%8810.23.41.png" alt="" /></p><p>以插入节点4为当前节点，判断父节点和叔叔节点是否都为红色，如果为红色，则将祖父节点7的颜色改为红色，父节点5和叔叔节点8的颜色改为黑色。同时当前节点移动到祖父节点7。此时，当前节点7的父节点也为红色，出现父子节点都为红色的情况，且叔叔节点为黑色，因此适用于<strong>情况4：当前节点的父节点是红色，叔叔节点是黑色，当前节点是右子节点</strong>，那么按照<strong>情况4</strong>的恢复策略，进行新一轮的旋转或涂色，如下看<strong>情况4</strong>如何进行调整。</p><p><strong>情况4：当前节点的父节点是红色，叔叔节点是黑色，当前节点是右子节点</strong><br />违反：性质4<br />恢复策略：以当前节点的父节点作为新的当前节点，以新的当前节点为支撑，进行左旋操作。旋转操作后再按新的情况进行旋转或涂色。</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2020/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-12-10%20%E4%B8%8B%E5%8D%8810.25.21.png" alt="" /></p><p>这里作的操作为：当前节点由原来的7变换为其父节点2，以新的当前节点2，作左旋操作，如上图。操作完成后，发现父子节点仍都是红色，继续进行旋转或涂色。这里适用于<strong>情况5：当前节点的父节点是红色，叔叔节点是黑色，当前节点是左子节点</strong>来进行再次调整，请看下面的<strong>情况5</strong>如何进行调整。</p><p><strong>情况5：当前节点的父节点是红色，叔叔节点是黑色，当前节点是左子节点</strong><br />违反：性质4<br />恢复策略：父节点改变为黑色，祖父节点改变为红色，然后再以祖父节点为新的当前节点，做右旋操作。</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2020/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-12-10%20%E4%B8%8B%E5%8D%8810.26.51.png" alt="" /></p><p>此时，树已经满足红黑树的性质，如果仍不满足，则仍按照情况1——情况5的方式进行旋转和重新涂色。</p><h4 id="rbtree的插入操作介绍二"><a class="markdownIt-Anchor" href="#rbtree的插入操作介绍二"></a> RBTree的插入操作介绍二</h4><p>RBTree的插入与BST的插入方式是一致的，只不过是在插入过后，可能会导致树的不平衡，这是就需要对树进行旋转操作的颜色修复（这里简称插入修复），使得它符合RBTree的定义。</p><p>新插入的节点是红色的，插入修复操作如果遇到父节点的颜色为黑则修复结束。也就是说，只有在父节点为红色节点的时候是需要插入修复操作的。</p><p>插入修复操作分为以下三种情况，而且新插入的节点的父节点都是红色的：</p><ul><li>叔叔节点也是红色</li><li>叔叔节点为空，且祖父节点、父节点和新节点处于一条斜线上</li><li>叔叔节点为空，且祖父节点、父节点和新节点不处于一条斜线上</li></ul><h5 id="插入操作case1"><a class="markdownIt-Anchor" href="#插入操作case1"></a> 插入操作——case1</h5><p>case1的操作是将父节点和叔叔节点与祖父节点的颜色互换，这样就符合了RBTree的定义。即维持了高度的平衡，修复后颜色也符合RBTree的定义的第三条和第四条。下图中，操作完成后A节点变成了新节点，如果A节点的父节点不是黑色的话，则继续做修复操作</p><p><img src="https://pic1.zhimg.com/80/v2-85d7be8e54ae9f904d86bf5f5ee3b4bc_hd.png" alt="" /></p><h5 id="插入操作case2"><a class="markdownIt-Anchor" href="#插入操作case2"></a> 插入操作——case2</h5><p>case2的操作是将B节点进行右旋操作，并且和父节点A互换颜色。通过该修复操作RBTree的高度和颜色都符合红黑树的定义。如果B和C节点都是右节点的话，只要将操作变成左旋就可以</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/v2-cd2171937e0ed68bca55214357e6669e_hd.png" alt="" /></p><h5 id="插入操作case3"><a class="markdownIt-Anchor" href="#插入操作case3"></a> 插入操作——case3</h5><p>case3的操作是将C节点进行左旋，这样就从case3转换成case2，然后针对case 2进行操作处理就行了。case 2操作做了一个右旋操作和颜色互换来达到目的。如果树的结构是下图的镜像结构，则只需要将对应的左旋变成右旋，右旋变成左旋即可。</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/v2-8594087429e54acbbc2aa6ae9da8cc5f_hd.png" alt="" /></p><h5 id="插入操作的总结"><a class="markdownIt-Anchor" href="#插入操作的总结"></a> 插入操作的总结</h5><p>插入后的修复操作是一个从root节点回溯的操作，一旦牵扯的节点都符合了红黑树的定义，修复操作结束。之所以会向上回溯是由于case1操作会将父节点、叔叔节点和祖父节点进行颜色互换，有可能会导致祖父节点不平衡（红黑树定义3）。这个时候需要对祖父节点为起点进行调节（向上回溯）</p><p>祖父节点调节后如果还是遇到它的祖父节点颜色问题，操作就会继续向上回溯，直到root节点为止，根据定义root节点永远是黑色的。在向上的追溯的过程中，针对插入的情况3中情况进行调节。直到符合红黑树定义为止。知道牵扯的节点都符合了红黑树的定义，修复操作结束。</p><p>如果上面的3中情况如果对应的操作是在右子树上，做对应的镜像操作就是了。</p><h4 id="rbtree的删除操作"><a class="markdownIt-Anchor" href="#rbtree的删除操作"></a> RBTree的删除操作</h4><p>删除操作首先需要做的也是BST的删除操作，删除操作会删除对应的节点，如果是叶子节点就直接删除，如果是非叶子节点，会用对应的中序遍历的后继节点来顶替要删除节点的位置。删除后就需要做删除修复操作，使得树符合红黑树的定义，符合定义的红黑树高度是平衡的。</p><p>删除修复操作在遇到被删除的节点是红色节点或者到达root节点后，修复操作完毕。</p><p>删除修复操作是针对删除黑色节点才有的，当黑色节点被删除后会让整个树不符合RBTree的定义的第四条。需要做的处理是从兄弟节点上借调黑色的节点过来，如果兄弟节点没有黑节点可以借调的话，就只能往上追溯，将每一级的黑节点数减去一个，使得整棵树符合红黑树的定义。</p><p>删除操作的总体思想是从兄弟节点借调黑色节点使树保持局部平衡，如果局部的平衡达到了，就看整体的树是否是平衡的，如果不平衡就接着向上追溯调整。</p><p>删除修复操作分为四种情况（删除黑节点后）：</p><ul><li>待删除节点的兄弟节点是红色的节点</li><li>待删除的节点的兄弟节点是黑色的节点，且兄弟节点的子节点都是黑色的</li><li>待调整的节点的兄弟节点是黑色的节点，且兄弟节点的左子节点是红色的，右节点是黑色的（兄弟节点在右边），如果兄弟节点在左边的话，就是兄弟节点的右子节点是红色的，左节点是黑色的</li><li>待调整节点的兄弟节点是黑色的节点，且右子节点是红色的（兄弟节点在右边），如果兄弟节点在左边，则就是对应的就是左节点是红色的</li></ul><h5 id="删除操作case1"><a class="markdownIt-Anchor" href="#删除操作case1"></a> 删除操作——case1</h5><p>由于兄弟节点是红色节点的时候，无法借调黑色节点，所以需要将兄弟节点提升到父节点，由于兄弟节点是红色的，根据RBTree的定义，兄弟节点的子节点是黑色的，就可以从它的子节点借调了。</p><p>case1这样转换之后就会变成后面的case2、case3，或者case4进行处理。上升操作需要对C做一个左旋操作，如果是镜像结构的树只需要做对应的右旋操作即可。</p><p>之所以要做case1操作是因为兄弟节点是红色的，无法借到一个黑节点来填补删除的黑节点。</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/v2-46e732e84148b9bca53e995689e9ba9f_hd.png" alt="" /></p><h5 id="删除操作case2"><a class="markdownIt-Anchor" href="#删除操作case2"></a> 删除操作——case2</h5><p>case2的删除操作是由于兄弟节点可以消除一个黑色节点，因为兄弟节点和兄弟节点的子节点都是黑色的，所以可以将兄弟节点变红，这样就可以保证树的局部的颜色符合定义了。这个时候需要将父节点A变成新的节点，继续向上调整，直到整棵树的颜色符合RBTree的定义为止。</p><p>case2这种情况下之所以要将兄弟节点变红，是因为如果把兄弟节点借调过来，会导致兄弟的结构不符合RBTree的定义，这样的情况下只能是将兄弟节点也变成红色来达到颜色的平衡。当将兄弟节点也变红之后，达到局部的平衡了，但是对于祖父节点来说不符合定义4的。这样就需要回溯到父节点，接着进行修复操作。</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/v2-7975d1b235cd30c0bafb716b585ba45d_hd.png" alt="" /></p><h5 id="删除操作case3"><a class="markdownIt-Anchor" href="#删除操作case3"></a> 删除操作——case3</h5><p>case3的删除操作是一个中间状态，它的目的是将左边的红色节点借调过来，这样就可以转换成case4状态，在case4状态下可以将D、E节点借调过来，通过将两个节点变成黑色来保证红黑树的平衡。</p><p>之所以说case3是一个中间状态，是因为根据红黑树的定义来说，下图并不是平衡的，它是通过case 2操作完后向上回溯出现的状态。之所以会出现C。</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/v2-04dbb22d25de3849d902582809198596_hd.png" alt="" /></p><h5 id="删除操作case4"><a class="markdownIt-Anchor" href="#删除操作case4"></a> 删除操作——case4</h5><p>case4操作是真正的节点借调操作，通过将兄弟节点以及兄弟节点的右节点借调过来，并将兄弟节点的右子节点变成红色来达到借调两个黑色节点的目的，这样的话，整棵树还是符合RBTree的定义。</p><p>case4这种情况的发生只有在待删除的节点的兄弟节点为黑，且子节点不全部为黑，才有可能借调到两个节点来做黑节点使用，从而保持整棵树都符合红黑树的定义</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/v2-a559407bb4847a140642d16c6301d7db_hd.png" alt="" /></p><h5 id="删除操作的总结"><a class="markdownIt-Anchor" href="#删除操作的总结"></a> 删除操作的总结</h5><p>红黑树的删除操作是最复杂的操作，复制的地方在于当删除了黑色节点的时候，如何从兄弟节点去借调节点，以保证树的颜色符合定义。由于红色的兄弟节点是没法借调出黑节点的，这样只能通过选择操作让他上升到父节点，而由于它是红节点，所以它的子节点就是黑的，可以借调。</p><p>对于兄弟节点是黑色节点的可以分为三种情况来处理，当所有的兄弟节点的子节点都是黑色节点时，可以直接将兄弟节点变红，这样局部的红黑树颜色是符合定义的。但是整棵树不一定是符合红黑树定义的，需要往上追溯继续调整。</p><p>对于兄弟节点的子节点为左红右黑（全部为红，右红左黑）两种情况，可以先将前面的情况通过选择转换为后一种情况，在后一种情况下，因为兄弟节点为黑，兄弟节点的右节点为红，可以借调出两个节点出来做黑节点，这样就可以保证删除了黑节点，整棵树还是符合红黑树定义的，因为黑色节点的个数没有改变。</p><p>红黑树的删除操作是遇到删除的节点为红色，或者追溯调整到了root节点，这时删除的修复操作完毕。</p><h2 id="三-rbtree的java实现"><a class="markdownIt-Anchor" href="#三-rbtree的java实现"></a> 三、RBTree的Java实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RBTreeNode</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// node value</span></span><br><span class="line">  <span class="keyword">private</span> T value;</span><br><span class="line">  <span class="comment">// left child pointer </span></span><br><span class="line">  <span class="keyword">private</span> RBTreeNode&lt;T&gt; left;</span><br><span class="line">  <span class="comment">// right child pointer</span></span><br><span class="line">  <span class="keyword">private</span> RBTreeNode&lt;T&gt; right;</span><br><span class="line">  <span class="comment">// parent pointer</span></span><br><span class="line">  <span class="keyword">private</span> RBTreeNode&lt;T&gt; parent;</span><br><span class="line">  <span class="comment">// color is red or not red</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> red;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">RBTreeNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">RBTreeNode</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">RBTreeNode</span><span class="params">(T value, <span class="keyword">boolean</span> isRed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">    <span class="keyword">this</span>.red = isRed;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> RBTreeNode&lt;T&gt; <span class="title">getLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeft</span><span class="params">(RBTreeNode&lt;T&gt; left)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.left = left;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> RBTreeNode&lt;T&gt; <span class="title">getRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRight</span><span class="params">(RBTreeNode&lt;T&gt; right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.right = right;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> red;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBlack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !red;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLeaf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRed</span><span class="params">(<span class="keyword">boolean</span> red)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.red = red;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeRed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    red = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeBlack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    red = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value.toString();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RBTree</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> RBTreeNode&lt;T&gt; root;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// node number</span></span><br><span class="line">  <span class="keyword">private</span> java.util.concurrent.atomic.AtomicLong size = </span><br><span class="line">    <span class="keyword">new</span> java.util.concurrent.atomic.AtomicLong(<span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// in overwrite mode, all node's value cannot has same value</span></span><br><span class="line">  <span class="comment">// in non-overwrite mode, node can have same value, suggest don't use non-overwrite mode</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> overrideMode = <span class="keyword">true</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">RBTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.root = <span class="keyword">new</span> RBTreeNode&lt;T&gt;();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="concurrenthashmap二叉树的构造过程"><a class="markdownIt-Anchor" href="#concurrenthashmap二叉树的构造过程"></a> ConcurrentHashMap二叉树的构造过程</h2><p>对于ConcurrentHashMap，链表的长度超过8时，会调用<code>treeifyBin()</code>方法将链表结构转换为红黑树。</p><p>下面是ConcurrentHashMap中节点类型和继承关系</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2020/Snipaste_2019-12-11_17-28-46.png" alt="" /></p><p>**注意点：**Node是链表中的元素，而TreeBin和TreeNode也继承自Node节点，也自然继承了next属性，同样拥有了链表的性质，其实真正在存储时，红黑树仍然是以链表形式存储的，只是逻辑上TreeBin和TreeNode多了支持红黑树的root、first、parent、left、right和red属性，在附加的属性上进行了逻辑上的引用和关联，也就造就了一棵树</p><p>所以理解了上面的红黑树其实也是一个链表，再来看源码就不难理解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Replaces all linked nodes in bin at given index unless table is</span></span><br><span class="line"><span class="comment"> * too small, in which case resizes instead.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tab table表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 转换为红黑树的链表在table中的索引下标</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  Node&lt;K,V&gt; b; <span class="keyword">int</span> n, sc;</span><br><span class="line">  <span class="keyword">if</span> (tab != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 一开始并非直接转换为红黑树，而是通过扩容table到2倍的方式</span></span><br><span class="line">    <span class="comment">// 只有table的长度大于64之后，才会将超过8个元素的链表转换为红黑树</span></span><br><span class="line">    <span class="keyword">if</span> ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">      tryPresize(n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// b.hash &gt;= 0 即为普通的Node链表节点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((b = tabAt(tab, index)) != <span class="keyword">null</span> &amp;&amp; b.hash &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 锁住链表头</span></span><br><span class="line">      <span class="keyword">synchronized</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tabAt(tab, index) == b) &#123;</span><br><span class="line">          TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">          <span class="comment">// 将原Node链表转换成以TreeBin节点为元素的链表</span></span><br><span class="line">          <span class="keyword">for</span> (Node&lt;K,V&gt; e = b; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p =</span><br><span class="line">              <span class="keyword">new</span> TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,</span><br><span class="line">                                <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> ((p.prev = tl) == <span class="keyword">null</span>)</span><br><span class="line">              hd = p;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">              tl.next = p;</span><br><span class="line">            tl = p;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// TreeBin的构造方法构造树，根据TreeBin链表构造</span></span><br><span class="line">          setTabAt(tab, index, <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hd));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码可以看出，一开始并非直接转换为红黑树，而是通过扩容table到2倍的方式，只有table的长度大于64之后，才会将超过8个元素的链表转红黑树。红黑树的构造过程是在TreeBin的构造方法中完成的。</p><h3 id="红黑树的构造过程"><a class="markdownIt-Anchor" href="#红黑树的构造过程"></a> 红黑树的构造过程</h3><p>假设待构造的红黑树TreeNode链表如下，节点中的数值代表元素的hash值：</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2020/Snipaste_2019-12-11_17-59-57.png" alt="" /></p><p>源码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates bin with initial set of nodes headed by b.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">TreeBin(TreeNode&lt;K,V&gt; b) &#123;</span><br><span class="line">  <span class="keyword">super</span>(TREEBIN, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">  <span class="keyword">this</span>.first = b;</span><br><span class="line">  TreeNode&lt;K,V&gt; r = <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">// 遍历TreeNode链表进行构造</span></span><br><span class="line">  <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = b, next; x != <span class="keyword">null</span>; x = next) &#123;</span><br><span class="line">    next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">    x.left = x.right = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (r == <span class="keyword">null</span>) &#123;</span><br><span class="line">      x.parent = <span class="keyword">null</span>;</span><br><span class="line">      x.red = <span class="keyword">false</span>;</span><br><span class="line">      r = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      K k = x.key;</span><br><span class="line">      <span class="keyword">int</span> h = x.hash;</span><br><span class="line">      Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = r;;) &#123;</span><br><span class="line">        <span class="comment">// 执行插入，dir为比对节点hash的大小的标识，决定插入时是左还是右</span></span><br><span class="line">        <span class="keyword">int</span> dir, ph;</span><br><span class="line">        K pk = p.key;</span><br><span class="line">        <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">          dir = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">          dir = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                  (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                 (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">          dir = tieBreakOrder(k, pk);</span><br><span class="line">        TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">        <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">          x.parent = xp;</span><br><span class="line">          <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">            xp.left = x;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            xp.right = x;</span><br><span class="line">          <span class="comment">// 插入后，执行恢复操作，重新涂色或者旋转</span></span><br><span class="line">          r = balanceInsertion(r, x);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.root = r;</span><br><span class="line">  <span class="function"><span class="keyword">assert</span> <span class="title">checkInvariants</span><span class="params">(root)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码中，balanceInsertion方法为恢复操作。所以根据上述源码和红黑树的恢复策略，依次遍历链表节点插入到红黑树中，我们构造如下：</p><ul><li>节点80</li></ul><p>第一个节点80，插入到空树中，设置为根节点，并为黑色：</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2020/Snipaste_2019-12-11_18-34-51.png" alt="" /></p><ul><li>节点60</li></ul><p>节点60按二叉树插入后，未违反任何红黑树的性质，不做任何动作</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2020/Snipaste_2019-12-11_18-35-52.png" alt="" /></p><ul><li>节点50</li></ul><p>节点50插入后，违反了性质4，按照<strong>情况5：当前节点的父节点是红色，叔叔节点是黑色，当前节点是左子节点</strong>进行恢复。</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2020/Snipaste_2019-12-11_18-36-56.png" alt="" /></p><p>按照情况5的恢复策略调整如下：<br />把当前节点的父节点变为黑色，祖父节点变为红色，将祖父节点更新为当前节点，以新的当前节点为支点进行右旋操作。</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2020/Snipaste_2019-12-11_18-41-03.png" alt="" /></p><ul><li>节点70</li></ul><p>节点70插入后，违反红黑树性质5，按照<strong>情况3：当前节点的父节点是红色，且叔叔节点也是红色</strong>进行调整。</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2020/Snipaste_2019-12-11_18-41-53.png" alt="" /></p><p>调整如下，需要经过两次涂色调整，将当前节点70的父节点和叔叔节点改为黑色，祖父节点改为红色。由于祖父节点为根节点，根节点只能为黑色，因此在此将根节点改为黑色，调整完成。</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2020/Snipaste_2019-12-13_14-59-47.png" alt="" /></p><ul><li>节点20</li></ul><p>节点20插入后未违反任何特性，无需调整。</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2020/Snipaste_2019-12-11_18-43-15.png" alt="" /></p><ul><li>节点65</li></ul><p>节点65插入后违反性质4，按照<strong>情况5：当前节点的父节点是红色，叔叔节点是黑色，当前节点是左子节点</strong>进行恢复。</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2020/Snipaste_2019-12-11_18-43-58.png" alt="" /></p><p>恢复调整如下，需要经过两个步骤，当前节点65的父节点改为黑色，祖父节点改为红色，然后将祖父节点设为最新的当前节点。涂色后的新树违反了性质5，因此还要以最新的当前节点为支点进行右旋操作：</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2020/Snipaste_2019-12-11_18-47-34.png" alt="" /></p><ul><li>节点40</li></ul><p>节点40插入后，违反红黑树性质4:父子节点不能都为红色，插入后的红黑树见下图：</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2020/Snipaste_2019-12-11_18-48-19.png" alt="" /></p><p>根据前文的调整策略，此处当前节点为红色，叔叔节点NIL为黑色，且当前节点为右子节点，**按情况4进行调整恢复：<br />步骤一：以当前节点40的父节点20为新的当前节点（见下图1）；<br />步骤二：以图1中新的当前节点20为支点，左旋（见下图2）；</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2020/Snipaste_2019-12-11_18-57-23.png" alt="" /></p><p>旋转完成后，发现当前节点20和父节点40都为红色，仍然违反了红黑树的性质4，需要继续回溯当前节点再次旋转或涂色。此时，当前节点是左子节点，**按情况5进行调整恢复：<br />步骤一：将当前节点的父节点40重涂为黑色，祖父节点50重涂为红色（见下图3）；得到的红黑树发现不满足红黑树的性质5：从一个节点到其所有叶子节点的所有路径上包含相同数目的黑节点，继续执行步骤二的调整。<br />步骤二：以当前节点20的祖父节点50为新的当前节点，进行右旋（见下图5）；</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2020/Snipaste_2019-12-11_18-58-01.png" alt="" /></p><p>到此，成功将节点40插入红黑树，满足所有红黑树的性质.</p><ul><li>节点10</li></ul><p>节点10插入后违反性质4，按照<strong>情况3：当前节点的父节点是红色，且叔叔节点（祖父节点的另一个子节点）也是红色</strong>进行恢复。</p><p><img src="/Users/haotongan/MyDocument/summary/personal/%E5%9B%BE%E7%89%87/Snipaste_2019-12-11_18-58-56.png" alt="" /></p><p>恢复调整如下，当前节点10的父节点和叔叔节点改为黑色，祖父节点40重涂为红色，调整就完成了：</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2020/Snipaste_2019-12-11_18-59-33.png" alt="" /></p><p>至此，红黑树的构造完成。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;bst&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#bst&quot;&gt;&lt;/a&gt; BST&lt;/h2&gt;
&lt;p&gt;二叉查找树（Binary Search Tree，简称BST）是一颗二叉树，它的左子节点的值比父节点的值要小，右节点的值要比父节点的值大。
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://toyan.top/categories/algorithm/"/>
    
      <category term="RBTree" scheme="https://toyan.top/categories/algorithm/RBTree/"/>
    
    
      <category term="算法" scheme="https://toyan.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>服务雪崩、降级与熔断</title>
    <link href="https://toyan.top/service-avalanche/"/>
    <id>https://toyan.top/service-avalanche/</id>
    <published>2019-10-31T16:00:00.000Z</published>
    <updated>2020-02-08T11:39:50.959Z</updated>
    
    <content type="html"><![CDATA[<h2 id="服务雪崩"><a class="markdownIt-Anchor" href="#服务雪崩"></a> 服务雪崩</h2><p>假设存在如下调用链</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/725429-20190130225819816-259073605.png" alt="" /></p><p>而此时，<code>Service A</code>的流量波动很大，流量经常会突然性增加！那么在这种情况下，就算<code>Service A</code>能扛得住请求，<code>Service B</code>和<code>Service C</code>未必能扛得住这突发的请求。</p><p>此时，如果<code>Service C</code>因为抗不住请求，变得不可用。那么<code>Service B</code>的请求也会阻塞，慢慢耗尽<code>Service B</code>的线程资源，<code>Service B</code>就会变得不可用。紧接着，<code>Service A</code>也会不可用，这一过程如下图所示</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/725429-20190130225824355-156743654.jpg" alt="" /></p><p><strong>如上图所示，一个服务失败，导致整条链路的服务都失败的情形，我们称之为服务雪崩。</strong></p><p>那么，服务熔断和服务降级就可以视为解决服务雪崩的手段之一</p><h2 id="服务熔断"><a class="markdownIt-Anchor" href="#服务熔断"></a> 服务熔断</h2><p>服务熔断：当下游的服务因为某种原因变得突然不可用或响应过慢，上游服务为了保证自己整体服务的可用性，不再继续调用目标服务，直接返回，快速释放资源。如果目标服务情况好转则恢复调用</p><p>需要说明的是熔断其实是一个框架级的处理，那么这套熔断机制的设计，基本上业内用的是<code>断路器模式</code>，如下图所示</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/725429-20190130230717121-435467568.jpg" alt="" /></p><ul><li>最开始处于<code>closed</code>状态，一旦检测到错误到达一定阈值，便转为<code>open</code>状态；</li><li>这时候会有个 reset timeout，到了这个时间了，会转移到<code>half open</code>状态；</li><li>尝试放行一部分请求到后端，一旦检测成功便回归到<code>closed</code>状态，即恢复服务；</li></ul><p>业内目前流行的熔断器很多，例如阿里出的Sentinel,以及最多人使用的Hystrix</p><p>在Hystrix中，对应配置如下</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 滑动窗口大小，默认是20</span></span><br><span class="line"><span class="attr">circuitBreaker.requestVolumeThreshold</span></span><br><span class="line"><span class="comment"># 过多长时间，熔断器再次检测是否开启，默认为5000，即5s</span></span><br><span class="line"><span class="meta">circuitBreaker.sleepWindowInMilliseconds</span> <span class="string"></span></span><br><span class="line"><span class="comment"># 错误率，默认50%</span></span><br><span class="line"><span class="attr">circuitBreaker.errorThresholdPercentage</span></span><br></pre></td></tr></table></figure><p>每当20个请求中，有50%失败后，熔断器就会打开，此时再调用服务，将会直接返回失败，不再调远程服务。直到5s后，重新检测该触发条件，判断是否把熔断器关闭，或者继续打开。</p><p>这些属于框架层级的实现，我们只要实现对应接口就好！</p><h2 id="服务降级"><a class="markdownIt-Anchor" href="#服务降级"></a> 服务降级</h2><p>下面有两种场景</p><ul><li>当下游的服务因为某种原因响应过慢，下游服务主动停掉一些不太重要的业务，释放出服务器资源，增加响应速度</li><li>当下游的服务因为某种原因不可用，上游主动调用本地的一些降级逻辑，避免卡顿，迅速返回给用户<br />其实要这么理解</li><li>服务降级有很多种降级方式！如开关降级、限流降级、熔断降级</li><li>服务熔断属于降级方式的一种</li></ul><p>从实现上来说，熔断和降级必定是一起出现。因为当发生下游服务不可用的情况，这个时候为了对最终用户负责，就需要进入上游的降级逻辑了。因此，将熔断降级视为降级方式的一种<br />服务降级大多是属于一种业务级别的处理。当然，这里要讲的是另一种降级方式，也就是开关降级，这也是我们生产中常用的另一种降级方式<br />做法很简单，做个开关，然后将开关放在配置中心，在配置中心更改开关，决定哪些服务进行降级。<br /><strong>那么，在应用程序中部下开关的这个过程，业内也有一个名词，称为埋点！</strong><br />那接下来最关键的一个问题，哪些业务需要埋点？一般有以下方法：</p><ol><li>简化执行流程<br />自己梳理出核心业务和非核心业务流程，然后在非核心业务流程加上开关，一旦发现系统扛不住，关掉开关，结束这些次要流程</li><li>关闭次要功能<br />一个微服务下肯定有很多功能，那自己区分出主要功能和次要功能。然后次要功能加上开关，需要降级的时候，把次要功能关了</li><li>降级一致性<br />假设，你在业务上发现执行流程没法简化了，愁啊！也没啥次要功能可以关了，桑心啊！那只能降低一致性了，即将核心业务流程的同步改异步，将强一致性改最终一致性！</li></ol><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><h3 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h3><p>分布式系统环境下，服务间类似依赖非常常见，一个业务调用通常依赖多个基础服务，如下图，对于同步调用，当库存服务不可用时，商品服务请求线程被阻塞，当有大批量请求调用库存服务时，最终可能导致整个商品服务资源耗尽，无法继续对外提供服务。并且这种不可用可能沿请求调用链向上传递，这种现象被称为雪崩效应。</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/170502_7fqS_2663573.png" alt="" /></p><h3 id="雪崩效应常见场景"><a class="markdownIt-Anchor" href="#雪崩效应常见场景"></a> 雪崩效应常见场景</h3><ul><li>硬件故障：如服务器宕机，机房断电、光纤被挖断等</li><li>流量激增：如异常流量，重试加大流量</li><li>缓存穿透：一般发生在应用重启，所有缓存失效时，以及短时间内大量缓存失效时。大量的缓存不命中，使请求直击后端服务，造成服务提供者超负荷运行，引起服务不可用</li><li>程序BUG：如程序逻辑导致内存泄漏，JVM长时间FullGC等</li><li>同步等待：服务间采用同步调用模式，同步等待造成的资源耗尽</li></ul><h3 id="雪崩效应应对策略"><a class="markdownIt-Anchor" href="#雪崩效应应对策略"></a> 雪崩效应应对策略</h3><p>针对造成雪崩效应的不同场景，可以使用不同的应对策略，没有一种通用所有场景的策略，参考如下：</p><ul><li>硬件故障：多机房容灾、异地多活等</li><li>流量激增：服务自动扩容、流量控制（限流、关闭重试）等</li><li>缓存穿透：缓存预加载、缓存异步加载等</li><li>程序BUG：修改程序bug、及时释放资源等</li><li>同步等待：资源隔离、MQ解耦、不可用服务调用快速失败等。资源隔离通常指不同服务调用采用不同的线程池；不可用服务调用快速失败一般通过熔断器模式结合超时机制实现</li></ul><p>综上所述，如果一个应用不能对来自依赖的故障进行隔离，那该应用本身就处于被拖垮的风险中。因此，为了构建稳定、可靠的分布式系统，我们的服务应当具有自我保护意识，当依赖服务不可用时，当前服务启动自动保护功能，从而避免发生雪崩效应。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;服务雪崩&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#服务雪崩&quot;&gt;&lt;/a&gt; 服务雪崩&lt;/h2&gt;
&lt;p&gt;假设存在如下调用链&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://toyandemachinelearning.oss-cn-s
      
    
    </summary>
    
    
      <category term="Web" scheme="https://toyan.top/categories/Web/"/>
    
      <category term="服务" scheme="https://toyan.top/categories/Web/%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="Web" scheme="https://toyan.top/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>服务容灾</title>
    <link href="https://toyan.top/disaster-recovery/"/>
    <id>https://toyan.top/disaster-recovery/</id>
    <published>2019-10-30T16:06:39.000Z</published>
    <updated>2020-02-07T16:15:58.571Z</updated>
    
    <content type="html"><![CDATA[<h2 id="技术指标"><a class="markdownIt-Anchor" href="#技术指标"></a> 技术指标</h2><p>RPO（Recovery Point Objective）：即数据恢复点目标，主要指的是业务系统所能容忍的数据丢失量</p><p>RTO（Recovery Time Objective）：即数据时间目标，主要指的是所能容忍的业务停止服务的最长时间，也就是从灾难发生到业务系统恢复服务功能所需要的最短时间周期</p><blockquote><p>RPO针对的是数据丢失，而RTO针对的是服务丢失，二者没有必然的联系。RTO和RPO的确定必须在进行风险分析和业务影响分析后根据不同的业务需求确定。对于不同企业的同一种业务，RTO和RPO的需求也会有所不同。</p></blockquote><h2 id="服务容灾"><a class="markdownIt-Anchor" href="#服务容灾"></a> 服务容灾</h2><h3 id="常见事故及如何容灾"><a class="markdownIt-Anchor" href="#常见事故及如何容灾"></a> 常见事故及如何容灾</h3><p>服务器故障死机——备份（硬件方案、软件方案）<br />服务雪崩——负载均衡、过载保护<br />网络环境恶劣——多运营商、异步部署就近服务</p><h3 id="设计方案"><a class="markdownIt-Anchor" href="#设计方案"></a> 设计方案</h3><h4 id="逻辑层容灾"><a class="markdownIt-Anchor" href="#逻辑层容灾"></a> 逻辑层容灾</h4><p>容灾模型：1+1容灾、1+n容灾、n+1容灾<br />切换方式主要有冷切、热切、双在线三种方式</p><p><strong>冷切</strong></p><blockquote><p>主系统跑100%业务，备系统跑0%业务；当主系统出现问题，切到备系统<br />通用性，切换到备系统有一定的时间不能提供服务，并且备系统的可信度低<br />MFS网盘文件备份数据路径<br />简单（保序），有业务无关的解决方案（HB），切换后是否正常</p></blockquote><p><strong>热切</strong></p><blockquote><p>主备系统各跑一部分业务，主系统出现问题，业务全部由备系统提供服务<br />通用性，备系统可用性较高<br />大多数系统使用：Gateway/Ad Server/Retrieval/Sku/User<br />与业务无关的解决方案（名字服务），注意切换时带宽，负载压力</p></blockquote><p><strong>双在线</strong></p><blockquote><p>主备系统提供相同的服务，各跑100%业务，请求者丢弃其中一个系统的数据<br />专用性，备系统可用性高，流量高<br />高成功率要求（RPO短），极少数核心系统用<br />复杂，通常是业务相关（有开发量），资源浪费</p></blockquote><h4 id="数据层容灾"><a class="markdownIt-Anchor" href="#数据层容灾"></a> 数据层容灾</h4><p>考虑恢复时间，采用1+n容灾<br />主要有一个主机多个备机（中心化）和不分主备（完全分布式）两种方式<br /><strong>中心化：采用快同步（增量同步）+慢同步（全量同步）的方式来保持数据一致性</strong></p><blockquote><p>快同步：当有数据写入的时候，先写到主机上，再由主机同步到备机上，主机维护同步信息队列，同步信息列表<br />慢同步：主机的同步进程定时给备机发送数据信息验证码，通过备机返回的应答，确定需要传送的缺失数据</p></blockquote><p>同时需要监控，保证不能有两个中心节点<br /><strong>去中心化（完全分布式）：数据的一致性难以保证</strong><br />简单的案例</p><blockquote><p>在t1时刻，修改D1机器上的数据，发送同步数据包给D2<br />在t2时刻，修改D2机器上的数据，发送同步包给D1<br />在t3时刻，D2收到D1的同步数据包，发现时间戳比自己的小，丢弃数据<br />在t4时刻，D1收到D2的同步数据包，校验时间通过，更新D1上的数据，如此，D1在t1时刻的修改就作废</p></blockquote><p>优化方式：给每个数据（或每组）添加一个时间戳，同步数据只校验数据本身的时间戳</p><blockquote><p>如上所述，分布式的数据存储在使用上确实不如中心化的便捷；但在某些场景下，却非常适用：数据有效性短</p><ul><li>频繁变化的最后一次操作,最后一次登录时间，IP等；在最遭的情况下，可以使用当前登录的时间，IP信息</li><li>登录的通行证：此场景下，可以在通行正中添加生成证书的服务器信息，在同步失败或其他原因引起的在提供服务器上找不到证书时，只要能解开通行证，取出生成的信息，即可到生成服务器上验证；在最糟的情况下，可重新登录，再生成新的通行证</li></ul></blockquote><p><strong>R + W &gt; N（Amazon的存储）</strong><br />大致描述为：当有5个数据节点时，设置写入成功的节点数为W时，那么在读的时候，成功的节点数达到R，满足R + W &gt; N，那么表示这个数据已经被正确读取</p><p>当系统设计只需要写3个数据节点便可以认为数据写入成功，那么当我们去读取数据时，只要能至少从3个节点中读出数据便可以认为读取数据成功<br /><em>3 + 3 &gt; 5 均衡    5 + 1 &gt; 5 重写  1 + 5 &gt; 5 重读</em></p><p><strong>对等模型的RWN方案</strong><br />Nr + Nw &gt; N（强一致性，抽屉原理）<br />Nr + Nw &lt;= N（弱一致性）<br />Quorum协议：Nw &gt; N/2（每次写入保证写入大于N/2个节点，每次读保证从大于N/2个节点读）<br />数据副本数N：N &gt;= 2，N大，安全，高qps，同步成本高</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;技术指标&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#技术指标&quot;&gt;&lt;/a&gt; 技术指标&lt;/h2&gt;
&lt;p&gt;RPO（Recovery Point Objective）：即数据恢复点目标，主要指的是业务系统所能容忍的数据丢失量&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
    
      <category term="Web" scheme="https://toyan.top/categories/Web/"/>
    
      <category term="服务" scheme="https://toyan.top/categories/Web/%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="Web" scheme="https://toyan.top/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>JVM中Metaspace理解</title>
    <link href="https://toyan.top/jvm-metaspaceSize/"/>
    <id>https://toyan.top/jvm-metaspaceSize/</id>
    <published>2019-10-23T16:00:00.000Z</published>
    <updated>2020-02-08T17:18:51.471Z</updated>
    
    <content type="html"><![CDATA[<h2 id="jvm参数metaspacesize的误解"><a class="markdownIt-Anchor" href="#jvm参数metaspacesize的误解"></a> JVM参数MetaspaceSize的误解</h2><p>以笔者测试环境上某个服务为例，配置了<code>-XX:MetaspaceSize=256m -XX:MaxMetaspaceSize=256m</code>，通过<code>jstat -gcutil pid</code>查看<code>M</code>的值为<code>98.32</code>，即Meta区使用率达到了<code>98.32%</code></p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2020/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-10-23%20%E4%B8%8A%E5%8D%8810.43.52.png" alt="" /></p><p>然后，再通过<code>jstat -gc 4210 2s 3</code>命名查看，结果如下图所示，计算MU/MC即Meta区的使用率确实达到了<code>98.32%</code>，但是MC，即Metaspace Capacity只有55296K，并不是参数<code>MetaspaceSize</code>指定的256M</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2020/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-10-23%20%E4%B8%8A%E5%8D%8810.44.16.png" alt="" /></p><p>那么<code>-XX:MetaspaceSize=256m</code>的含义到底是什么呢？其实，这个JVM参数是指Metaspace扩容时触发FGC的初始化阈值，也是最小的阈值。这里有几个要点需要明确：</p><ul><li>如果没有配置<code>-XX:MetaspaceSize</code>，那么触发FGC的阈值就是21807104(20.8M)，可以通过<code>jinfo -flag MetaspaceSize pid</code>得到这个值</li><li>如果配置了<code>-XX:MetaspaceSize</code>，那么触发FGC的阈值就是配置的值</li><li>Metaspace由于使用不断扩容到<code>-XX:MetaspaceSize</code>参数指定的量，就会发生FGC；且之后每次Metaspace扩容都可能会发生FGC（至于什么时候会，比较复杂，跟几个参数有关）</li><li>如果old区配置CMS垃圾回收，那么扩容引起的FGC也会使用CMS算法进行回收</li><li>如果MaxMetaspaceSize设置过小，可能会导致频繁发生FGC，甚至OOM</li></ul><blockquote><p>任何一个JVM参数的默认中可以通过java -XX:+PrintFlagsFinal -version | grep JVMParamName获取，例如<code>java -XX:+PrintFlagsFinal -version |grep MetaspaceSize</code></p></blockquote><h3 id="jdk7的permsize"><a class="markdownIt-Anchor" href="#jdk7的permsize"></a> JDK7的PermSize</h3><p>JDK8+移除了Perm，引入了Metaspace，它们两者的区别是什么呢？Metaspace上面已经总结了，无论<code>-XX:MetaspaceSize</code>和<code>-XX:MaxMetaspaceSize</code>两个参数如何设置，随着类加载越来越多不断扩容调整，直到MetaspaceSize（如果没有配置就是默认20.8m）触发FGC，上限是<code>-XX:MaxMetaspaceSize</code>，默认是无穷大。而Perm的话，我们通过配置<code>-XX:PermSize</code>以及<code>-XX:MaxPermSize</code>来控制这块内存的大小，JVM在启动的时候会根据<code>-XX:PermSize</code>初始化分配一块连续的内存块，这样的话，如果<code>-XX:PermSize</code>设置过大，就是一种赤裸裸的浪费。很明显，Metaspace比Perm好多了。</p><h2 id="permgen与metaspace"><a class="markdownIt-Anchor" href="#permgen与metaspace"></a> PermGen与Metaspace</h2><h3 id="permgen"><a class="markdownIt-Anchor" href="#permgen"></a> PermGen</h3><p>绝大部分的都见过<code>“java.lang.OutOfMemoryError:PermGen space”</code>这个异常，这里的<code>PermGen space</code>其实指的就是方法区。不过方法区和<code>PermGen space</code>又有着本质的区别。前者是JVM的规范，而后者是JVM规范的一种实现，并且只有Hotspot才有<code>PermGen space</code>，对于其他的虚拟机，并没有这个区域。由于方法区主要存储类的相关信息，所以对于动态生成类的情况比较容易出现永久代的内存溢出。最典型的应用场景就是，在JSP页面比较多的情况，容易出现永久代的内存溢出。下面我们举例说明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.paddx.test.memory;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.paddx.test.memory;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.net.URLClassLoader;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PermGenOomMock</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        URL url = <span class="keyword">null</span>;</span><br><span class="line">        List&lt;ClassLoader&gt; classLoaderList = <span class="keyword">new</span> ArrayList&lt;ClassLoader&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            url = <span class="keyword">new</span> File(<span class="string">"/tmp"</span>).toURI().toURL();</span><br><span class="line">            URL[] urls = &#123;url&#125;;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                ClassLoader loader = <span class="keyword">new</span> URLClassLoader(urls);</span><br><span class="line">                classLoaderList.add(loader);</span><br><span class="line">                loader.loadClass(<span class="string">"com.paddx.test.memory.Test"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/820406-20160327005846979-1124627174.png" alt="" /></p><h3 id="metaspace"><a class="markdownIt-Anchor" href="#metaspace"></a> Metaspace</h3><p>JDK1.7中，存储在永久代的部分数据就已经转移到了Java Heap或者是Native Heap。但永久代仍存在于JDK1.7中，并没完全移除，譬如符号引用（Symbols）转移到了native heap；字面量（interned strings）转移到了java heap；类的静态变量（class statics）转移到了java heap。我们可以通过一段程序来比较 JDK 1.6 与 JDK 1.7及 JDK 1.8 的区别，以字符串常量为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.paddx.test.memory;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringOomMock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String  base = <span class="string">"string"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Integer.MAX_VALUE; i++)&#123;</span><br><span class="line">            String str = base + base;</span><br><span class="line">            base = str;</span><br><span class="line">            list.add(str.intern());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段程序以2的指数级不断的生成新的字符串，这样可以比较快速的消耗内存。我们通过 JDK 1.6、JDK 1.7 和 JDK 1.8 分别运行：</p><p>JDK 1.6 的运行结果</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/820406-20160327005929386-409283462.png" alt="" /></p><p>JDK 1.7的运行结果</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/820406-20160327010033823-1341228280.png" alt="" /></p><p>JDK 1.8的运行结果</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/820406-20160327010143776-1612977566.png" alt="" /></p><p>从上述结果可以看出，JDK1.6下，会出现<code>PermGen Space</code>的内存溢出，而在JDK1.7和JDK1.8中，会出现堆内存溢出，并且JDK1.8中<code>PermSize</code>和<code>MaxPermGen</code>已经无效。因此，可以大致验证JDK1.7和1.8将字符串常量由永久代转移到堆中，并且JDK1.8中已经不存在永久代。</p><blockquote><p>元空间的本质和永久代相似，都是JVM规范中对方法区的实现。**不过元空间和永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。**因此，默认情况下，元空间的大小仅受本地内存的限制，但可以通过以下参数来指定元空间的大小</p></blockquote><ul><li><code>XX:MetaspaceSize</code>：初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值</li><li><code>XX:MaxMetaspaceSize</code>：最大空间，默认是没有限制的</li></ul><p>除了指定上面两个参数，还有两个与GC相关的属性</p><ul><li><code>XX:MinMetaspaceFreeRatio</code>：在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集</li><li><code>XX:MaxMetaspaceFreeRatio</code>：在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集</li></ul><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>通过上面分析，大家应该大致了解了 JVM 的内存划分，也清楚了 JDK 8 中永久代向元空间的转换。不过大家应该都有一个疑问，就是为什么要做这个转换？所以，最后给大家总结以下几点原因：</p><ul><li>字符串存在永久代中，容易出现性能问题和内存溢出</li><li>类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出</li><li>永久代会为 GC 带来不必要的复杂度，并且回收效率偏</li><li>Oracle 可能会将HotSpot 与 JRockit 合二为一</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;jvm参数metaspacesize的误解&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#jvm参数metaspacesize的误解&quot;&gt;&lt;/a&gt; JVM参数MetaspaceSize的误解&lt;/h2&gt;
&lt;p&gt;以笔者测试环境上某个服务为例，
      
    
    </summary>
    
    
      <category term="Java" scheme="https://toyan.top/categories/Java/"/>
    
      <category term="JVM" scheme="https://toyan.top/categories/Java/JVM/"/>
    
    
      <category term="Java" scheme="https://toyan.top/tags/Java/"/>
    
      <category term="JVM" scheme="https://toyan.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis缓存机制</title>
    <link href="https://toyan.top/mybatis-cache/"/>
    <id>https://toyan.top/mybatis-cache/</id>
    <published>2019-09-25T16:00:00.000Z</published>
    <updated>2020-02-08T17:20:23.739Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一级缓存"><a class="markdownIt-Anchor" href="#一级缓存"></a> 一级缓存</h2><h3 id="一级缓存介绍"><a class="markdownIt-Anchor" href="#一级缓存介绍"></a> 一级缓存介绍</h3><p>在应用运行过程中，我们有可能在一次数据库会话中，执行多次查询条件完全相同的SQL，Mybatis提供了一级缓存的方案优化这部分场景，如果是相同的SQL语句，会优先命中一级缓存，避免直接对数据库进行查询，提高性能，具体执行过程如下图所示</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/6e38df6a.jpg" alt="" /></p><p>每个SqlSession中持有了Executor，每个Executor中有一个LocalCache。当用户发起查询时，Mybatis根据当前执行的语句生成MappedStatement，在LocalCache进行查询，如果命中缓存的话，直接返回结果给用户，如果缓存没有命中的话，查询数据库，结果写入LocalCache，最后返回结果给用户。具体实现类的类关系图如下图所示。</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/d76ec5fe.jpg" alt="" /></p><h3 id="一级缓存配置"><a class="markdownIt-Anchor" href="#一级缓存配置"></a> 一级缓存配置</h3><p>我们来看看如何使用Mybatis一级缓存。开发者只需在Mybatis的配置文件中，添加如下语句，就可以使用一级缓存。共有两个选项，<code>session</code>和<code>statement</code>，默认是<code>session</code>级别，即在一个Mybatis会话中执行的所有语句，都会共享这一个缓存，一种是<code>statement</code>级别，可以理解为缓存只对当前执行的这一个statement有效。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"localCacheScope"</span> <span class="attr">value</span>=<span class="string">"SESSION"</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="一级缓存实验"><a class="markdownIt-Anchor" href="#一级缓存实验"></a> 一级缓存实验</h3><p>首先创建实例表，创建对应的POJO类和增改的方法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`student`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">200</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`age`</span> <span class="built_in">tinyint</span>(<span class="number">3</span>) <span class="keyword">unsigned</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">4</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COLLATE</span>=utf8_bin;</span><br></pre></td></tr></table></figure><p>在以下实验中，id为1的学生名称是凯伦</p><h4 id="实验1"><a class="markdownIt-Anchor" href="#实验1"></a> 实验1</h4><p>开启一级缓存，范围为会话级别，调用三次<code>getStudentById</code>，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getStudentById</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  SqlSession sqlSession = factory.openSession(<span class="keyword">true</span>); <span class="comment">// 自动提交事务</span></span><br><span class="line">  StudentMapper studentMapper = sqlSession.getMapper(StudentMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  System.out.println(studentMapper.getStudentById(<span class="number">1</span>));</span><br><span class="line">  System.out.println(studentMapper.getStudentById(<span class="number">1</span>));</span><br><span class="line">  System.out.println(studentMapper.getStudentById(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/9e996384.jpg" alt="" /></p><p>我们能够看到，只要第一次真正查询了数据库，后续地查询使用了一级缓存</p><h4 id="实验2"><a class="markdownIt-Anchor" href="#实验2"></a> 实验2</h4><p>增加了对数据库的修改操作，验证在一次数据库会话中，如果对数据库发生了修改操作，一级缓存是否会失效</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addStudent</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  SqlSession sqlSession = factory.openSession(<span class="keyword">true</span>);</span><br><span class="line">  StudentMapper studentMapper = sqlSession.getMapper(StudentMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  System.out.println(studentMapper.getStudentById(<span class="number">1</span>));</span><br><span class="line">  System.out.println(<span class="string">"增加了"</span> + studentMapper.addStudent(buildStudent()) + <span class="string">"个学生"</span>);</span><br><span class="line">  System.out.println(studentMapper.getStudentById(<span class="number">1</span>));</span><br><span class="line">  sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/fb6a78e0.jpg" alt="" /></p><p>我们能够看到，在修改操作后执行的相同查询，查询了数据库，一级缓存失效</p><h4 id="实验3"><a class="markdownIt-Anchor" href="#实验3"></a> 实验3</h4><p>开启了两个SqlSession，在sqlSession中查询数据，使一级缓存生效，在sqlSession2中更新数据库，验证一级缓存只在数据库会话内部共享</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLocalCacheScope</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SqlSession sqlSession1 = factory.openSession(<span class="keyword">true</span>); </span><br><span class="line">        SqlSession sqlSession2 = factory.openSession(<span class="keyword">true</span>); </span><br><span class="line">        StudentMapper studentMapper = sqlSession1.getMapper(StudentMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        StudentMapper studentMapper2 = sqlSession2.getMapper(StudentMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(<span class="string">"studentMapper读取数据: "</span> + studentMapper.getStudentById(<span class="number">1</span>));</span><br><span class="line">        System.out.println(<span class="string">"studentMapper读取数据: "</span> + studentMapper.getStudentById(<span class="number">1</span>));</span><br><span class="line">        System.out.println(<span class="string">"studentMapper2更新了"</span> + studentMapper2.updateStudentName(<span class="string">"小岑"</span>,<span class="number">1</span>) + <span class="string">"个学生的数据"</span>);</span><br><span class="line">        System.out.println(<span class="string">"studentMapper读取数据: "</span> + studentMapper.getStudentById(<span class="number">1</span>));</span><br><span class="line">        System.out.println(<span class="string">"studentMapper2读取数据: "</span> + studentMapper2.getStudentById(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/f480ac76.jpg" alt="" /></p><p>sqlSession2更新了id为1的学生的姓名，从凯伦改为了小岑，但session1之后的查询中，id为1的学生的姓名还是凯伦，出现了脏数据，也证明了之前的设想，一级缓存只在数据库会话内部有效</p><h3 id="一级缓存工作流程源码分析"><a class="markdownIt-Anchor" href="#一级缓存工作流程源码分析"></a> 一级缓存工作流程&amp;源码分析</h3><p>那么，一级缓存的工作流程是怎样的呢？我们从源码层面来学习一下</p><h4 id="工作流程"><a class="markdownIt-Anchor" href="#工作流程"></a> 工作流程</h4><p>一级缓存执行额时序图，如下图所示</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/bb851700.png" alt="" /></p><h4 id="源码分析"><a class="markdownIt-Anchor" href="#源码分析"></a> 源码分析</h4><p>接下来将对Mybatis查询相关的核心类和一级缓存的源码进行走读。这对后面学习二级缓存也有帮助</p><p>**SqlSession：**对外提供了用户和数据库之间交互需要的所有方法，隐藏了底层的细节，默认实现类是<code>DefaultSqlSession</code></p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2020/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-09-22%20%E4%B8%8A%E5%8D%8810.44.50.png" alt="" /></p><p><strong>Executor：</strong><code>SqlSession</code>向用户提供操作数据库的方法，但和数据库操作有关的职责都会委托给Executor</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2020/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-09-22%20%E4%B8%8A%E5%8D%8810.51.12.png" alt="" /></p><p>如下图所示，Executor有若干个实现类，为Executor赋予了不同的能力，大家可以根据类名，自行学习每个类的基本作用</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/83326eb3.jpg" alt="" /></p><p>在一级缓存的源码分析中，主要学习<code>BaseExecutor</code>的内部实现</p><p><strong>BaseExecutor：</strong><code>BaseExecutor</code>是一个实现了Executor接口的抽象类，定义若干抽象方法，在执行的时候，把具体的操作委托给子类进行执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">doUpdate</span><span class="params">(MappedStatement ms, Object parameter)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> List&lt;BatchResult&gt; <span class="title">doFlushStatements</span><span class="params">(<span class="keyword">boolean</span> isRollback)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> &lt;E&gt; <span class="function">Cursor&lt;E&gt; <span class="title">doQueryCursor</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException</span>;</span><br></pre></td></tr></table></figure><p>在一级缓存的介绍中提到对<code>LocalCache</code>的查询和写入是在<code>Executor</code>内部完成的，在阅读<code>BaseExecutor</code>的代码中发现<code>LocalCache</code>是<code>BaseExecutor</code>内部的一个成员变量，如下代码所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"> <span class="keyword">protected</span> ConcurrentLinkedQueue&lt;BaseExecutor.DeferredLoad&gt; deferredLoads;</span><br><span class="line">    <span class="keyword">protected</span> PerpetualCache localCache;</span><br></pre></td></tr></table></figure><p>**Cache：**Mybatis中的Cache接口，提供了和缓存相关的最基本的操作，如下图所示</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2020/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-09-22%20%E4%B8%8B%E5%8D%885.17.34.png" alt="" /></p><p>有若干个实现类，使用装饰器模式互相组装，提供丰富的操控缓存的能力，部分实现类如下图所示：</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/cdb21712.jpg" alt="" /><br /><code>BaseExecutor</code>成员变量之一的<code>PerpetualCache</code>，是对Cache接口最基本的实现，其实现非常简单，内部持有HashMap，对一级缓存的操作实则是对HashMap的操作。如下代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PerpetualCache</span> <span class="keyword">implements</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Object, Object&gt; cache = <span class="keyword">new</span> HashMap();</span><br></pre></td></tr></table></figure><p>为执行和数据库的交互，首先需要初始化<code>SqlSession</code>，通过<code>DefaultSqlSessionFactory</code>开启<code>SqlSession</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SqlSession <span class="title">openSessionFromDataSource</span><span class="params">(ExecutorType execType, TransactionIsolationLevel level, <span class="keyword">boolean</span> autoCommit)</span> </span>&#123;</span><br><span class="line">  Transaction tx = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  DefaultSqlSession var8;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Environment environment = <span class="keyword">this</span>.configuration.getEnvironment();</span><br><span class="line">    TransactionFactory transactionFactory = <span class="keyword">this</span>.getTransactionFactoryFromEnvironment(environment);</span><br><span class="line">    tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);</span><br><span class="line">    <span class="comment">// 重要的两行代码</span></span><br><span class="line">    Executor executor = <span class="keyword">this</span>.configuration.newExecutor(tx, execType);</span><br><span class="line">    var8 = <span class="keyword">new</span> DefaultSqlSession(<span class="keyword">this</span>.configuration, executor, autoCommit);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception var12) &#123;</span><br><span class="line">    <span class="keyword">this</span>.closeTransaction(tx);</span><br><span class="line">    <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error opening session.  Cause: "</span> + var12, var12);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ErrorContext.instance().reset();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> var8;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在初始化<code>SqlSession</code>时，会使用<code>Configuration</code>类创建一个全新的<code>Executor</code>，作为<code>DefaultSqlSession</code>构造函数的参数，创建Executor代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Executor <span class="title">newExecutor</span><span class="params">(Transaction transaction, ExecutorType executorType)</span> </span>&#123;</span><br><span class="line">  executorType = executorType == <span class="keyword">null</span> ? <span class="keyword">this</span>.defaultExecutorType : executorType;</span><br><span class="line">  executorType = executorType == <span class="keyword">null</span> ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">  Object executor;</span><br><span class="line">  <span class="keyword">if</span> (ExecutorType.BATCH == executorType) &#123;</span><br><span class="line">    executor = <span class="keyword">new</span> BatchExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorType.REUSE == executorType) &#123;</span><br><span class="line">    executor = <span class="keyword">new</span> ReuseExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    executor = <span class="keyword">new</span> SimpleExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 这里需要注意的是，如果两级缓存开关开启的话，是使用CachingExecutor装饰BaseExecutor的子类</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.cacheEnabled) &#123;</span><br><span class="line">    executor = <span class="keyword">new</span> CachingExecutor((Executor)executor);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Executor executor = (Executor)<span class="keyword">this</span>.interceptorChain.pluginAll(executor);</span><br><span class="line">  <span class="keyword">return</span> executor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SqlSession</code>创建完毕后，根据Statment的不同类型，会进入<code>SqlSession</code>的不同方法中，如果是<code>Select</code>语句的话，最后会执行到<code>SqlSession</code>的<code>selectList</code>，代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">selectList</span><span class="params">(String statement, Object parameter, RowBounds rowBounds)</span> </span>&#123;</span><br><span class="line">  List var5;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    MappedStatement ms = <span class="keyword">this</span>.configuration.getMappedStatement(statement);</span><br><span class="line">    var5 = <span class="keyword">this</span>.executor.query(ms, <span class="keyword">this</span>.wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception var9) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error querying database.  Cause: "</span> + var9, var9);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ErrorContext.instance().reset();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SqlSession</code>把具体的查询职责委托给了Executor。如果只开启一级缓存的话，首先会进入<code>BaseExecutor</code>的<code>query</code>方法。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  BoundSql boundSql = ms.getBoundSql(parameter);</span><br><span class="line">  CacheKey key = <span class="keyword">this</span>.createCacheKey(ms, parameter, rowBounds, boundSql);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.query(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，会先根据传入的参数生成CacheKey，进入该方法查看CacheKey是如何生成的，代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CacheKey <span class="title">createCacheKey</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.closed) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">"Executor was closed."</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    CacheKey cacheKey = <span class="keyword">new</span> CacheKey();</span><br><span class="line">    cacheKey.update(ms.getId());</span><br><span class="line">    cacheKey.update(rowBounds.getOffset());</span><br><span class="line">    cacheKey.update(rowBounds.getLimit());</span><br><span class="line">    cacheKey.update(boundSql.getSql());</span><br><span class="line">    <span class="comment">// 后面是update了sql中带的参数</span></span><br><span class="line">    List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();</span><br><span class="line">    TypeHandlerRegistry typeHandlerRegistry = ms.getConfiguration().getTypeHandlerRegistry();</span><br><span class="line">    Iterator var8 = parameterMappings.iterator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(var8.hasNext()) &#123;</span><br><span class="line">      ParameterMapping parameterMapping = (ParameterMapping)var8.next();</span><br><span class="line">      <span class="keyword">if</span> (parameterMapping.getMode() != ParameterMode.OUT) &#123;</span><br><span class="line">        String propertyName = parameterMapping.getProperty();</span><br><span class="line">        Object value;</span><br><span class="line">        <span class="keyword">if</span> (boundSql.hasAdditionalParameter(propertyName)) &#123;</span><br><span class="line">          value = boundSql.getAdditionalParameter(propertyName);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parameterObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">          value = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) &#123;</span><br><span class="line">          value = parameterObject;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          MetaObject metaObject = <span class="keyword">this</span>.configuration.newMetaObject(parameterObject);</span><br><span class="line">          value = metaObject.getValue(propertyName);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 最终需要的生成结果</span></span><br><span class="line">        cacheKey.update(value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.configuration.getEnvironment() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      cacheKey.update(<span class="keyword">this</span>.configuration.getEnvironment().getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cacheKey;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，将<code>MappedStatement</code>的Id、SQL的offset、SQL的limit、SQL本身以及SQL中的参数传入了CacheKey这个类，最终构成CacheKey。以下是这个类的内部结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MULTIPLYER = <span class="number">37</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_HASHCODE = <span class="number">17</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> multiplier;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> hashcode;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> checksum;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">private</span> List&lt;Object&gt; updateList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CacheKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.hashcode = DEFAULT_HASHCODE;</span><br><span class="line">  <span class="keyword">this</span>.multiplier = DEFAULT_MULTIPLYER;</span><br><span class="line">  <span class="keyword">this</span>.count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">this</span>.updateList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是成员变量和构造函数，有一个初始的<code>hashCode</code>和乘数，同时维护了一个内部的<code>updateList</code>。在<code>CacheKey</code>的<code>update</code>方法中，会进行一个<code>hashCode</code>和<code>checkSum</code>的计算，同时把传入的参数添加进<code>updateList</code>中，如下代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> baseHashCode = object == <span class="keyword">null</span> ? <span class="number">1</span> : ArrayUtil.hashCode(object);</span><br><span class="line">  ++<span class="keyword">this</span>.count;</span><br><span class="line">  <span class="keyword">this</span>.checksum += (<span class="keyword">long</span>)baseHashCode;</span><br><span class="line">  baseHashCode *= <span class="keyword">this</span>.count;</span><br><span class="line">  <span class="keyword">this</span>.hashcode = <span class="keyword">this</span>.multiplier * <span class="keyword">this</span>.hashcode + baseHashCode;</span><br><span class="line">  <span class="keyword">this</span>.updateList.add(object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时重写了<code>CacheKey</code>的<code>equals</code>方法，代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> == object) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(object <span class="keyword">instanceof</span> CacheKey)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    CacheKey cacheKey = (CacheKey)object;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.hashcode != cacheKey.hashcode) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.checksum != cacheKey.checksum) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.count != cacheKey.count) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.updateList.size(); ++i) &#123;</span><br><span class="line">        Object thisObject = <span class="keyword">this</span>.updateList.get(i);</span><br><span class="line">        Object thatObject = cacheKey.updateList.get(i);</span><br><span class="line">        <span class="keyword">if</span> (!ArrayUtil.equals(thisObject, thatObject)) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除去hashCode、checksum和count的比较外，只要updatelist中的元素一一对应相等，那么就可以认为是CacheKey相等。只要两条SQL的下列五个值相同，即可以认为是相同的SQL</p><blockquote><p>Statement Id + Offset + Limit + Sql + Params</p></blockquote><p>BaseExecutor的query方法继续往下走，代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">list = resultHandler == <span class="keyword">null</span> ? (List)<span class="keyword">this</span>.localCache.getObject(key) : <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (list != <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="keyword">this</span>.handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  list = <span class="keyword">this</span>.queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果查不到的话，就从数据库查，在<code>queryFromDataBase</code>中，会对<code>localCache</code>进行写入</p><p>在<code>query</code>方法执行的最后，会判断一级缓存级别是否是<code>STATEMENT</code>级别，如果是的话，就清空缓存，这也就是<code>STATEMENT</code>级别的一级缓存无法共享<code>localCache</code>的原因。代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) &#123;</span><br><span class="line">  <span class="keyword">this</span>.clearLocalCache();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在源码分析的最后，我们确认一下，如果是<code>insert/delete/update</code>方法，缓存就会刷新的原因</p><p><code>SqlSession</code>的<code>insert</code>方法和<code>delete</code>方法，就会统一走<code>update</code>的流程，代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insert</span><span class="params">(String statement, Object parameter)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.update(statement, parameter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(String statement, Object parameter)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.update(statement, parameter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(String statement, Object parameter)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> var4;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.dirty = <span class="keyword">true</span>;</span><br><span class="line">    MappedStatement ms = <span class="keyword">this</span>.configuration.getMappedStatement(statement);</span><br><span class="line">    var4 = <span class="keyword">this</span>.executor.update(ms, <span class="keyword">this</span>.wrapCollection(parameter));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception var8) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error updating database.  Cause: "</span> + var8, var8);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ErrorContext.instance().reset();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> var4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>update</code>方法也是委托给了<code>Executor</code>执行。<code>BaseExecutor</code>的执行方法如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(MappedStatement ms, Object parameter)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">"executing an update"</span>).object(ms.getId());</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.closed) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">"Executor was closed."</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.clearLocalCache();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.doUpdate(ms, parameter);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次执行<code>update</code>前都会清空<code>localCache</code></p><p>至此，一级缓存的工作流程讲解以及源码分析完毕</p><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>1、Mybatis一级缓存的生命周期和SqlSession一致</p><p>2、Mybatis一级缓存内部设计简单，只是一个没有容量限定的HashMap，在缓存的功能性上有所欠缺</p><p>3、Mybatis的一级缓存最大范围是SqlSession内部，有多个SqlSession或者分布式的环境下，数据库写操作会引起脏数据，建议设定缓存级别为Statement</p><h2 id="二级缓存"><a class="markdownIt-Anchor" href="#二级缓存"></a> 二级缓存</h2><h3 id="二级缓存介绍"><a class="markdownIt-Anchor" href="#二级缓存介绍"></a> 二级缓存介绍</h3><p>在上文中提到的一级缓存中，其最大的共享范围就是一个SqlSession内部，如果多个SqlSession之间需要共享缓存，则需要使用到二级缓存。开启二级缓存后，会使用CachingExecutor装饰Executor，进入一级缓存的查询流程前，先在CachingExecutor进行二级缓存的查询，具体的工作流程如下所示：</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/28399eba.png" alt="" /></p><p>二级缓存开启后，同一个namespace下的所有操作语句，都影响着同一个Cache，即二级缓存被多个SqlSession共享，是一个全局的变量</p><p>当开启缓存后，数据的查询执行的流程就是 <strong>二级缓存 --&gt; 一级缓存 --&gt; 数据库</strong></p><h3 id="二级缓存配置"><a class="markdownIt-Anchor" href="#二级缓存配置"></a> 二级缓存配置</h3><p>要正确的使用二级缓存，需完成如下配置的</p><p>1、在Mybatis的配置文件中开启二级缓存</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"cacheEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>2、在Mybatis的映射XML中配置cache或者cache-ref</p><p>cache标签用于声明这个namespace使用二级缓存，并且可以自定义配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>type</code>：cache使用的类型，默认是<code>PerpetualCache</code>，这在一级缓存中提到过</li><li><code>eviction</code>：定义回收的策略，常见的有FIFO、LRU</li><li><code>flushInterval</code>：配置一定时间自动刷新缓存，单位是毫秒</li><li><code>size</code>：最多缓存对象的个数</li><li><code>readOnly</code>：是否只读，若配置可读写，则需要对应的实体类能够序列化</li><li><code>blocking</code>：若缓存中找不到对应的key，是否会一直blocking，直到有对应的数据进入缓存</li></ul><p><code>cache-ref</code>代表引用别的命名空间的Cache配置，两个命名空间的操作使用的是同一个Cache</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache-ref</span> <span class="attr">namespace</span>=<span class="string">"mapper.StudentMapper"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="二级缓存实验"><a class="markdownIt-Anchor" href="#二级缓存实验"></a> 二级缓存实验</h3><p>接下来我们通过实验，了解Mybatis二级缓存在使用上的一些特点</p><p>在本实验中，id为1的学生名称初始化为点点</p><h4 id="实验1-2"><a class="markdownIt-Anchor" href="#实验1-2"></a> 实验1</h4><p>测试二级缓存效果，不提交事务，<code>sqlSession1</code>查询完数据后，<code>sqlSession2</code>相同的查询是否会从缓存中获取数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCacheWithoutCommitOrClose</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  SqlSession sqlSession1 = factory.openSession(<span class="keyword">true</span>);</span><br><span class="line">  SqlSession sqlSession2 = factory.openSession(<span class="keyword">true</span>);</span><br><span class="line">  </span><br><span class="line">  StudentMapper studentMapper = sqlSession1.getMapper(StudentMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  StudentMapper studentMapper2 = sqlSession2.getMapper(StudentMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  </span><br><span class="line">  System.out.println(<span class="string">"studentMapper读取数据: "</span> + studentMapper.getStudentById(<span class="number">1</span>));</span><br><span class="line">  System.out.println(<span class="string">"studentMapper2读取数据："</span> + studentMapper2.getStudentById(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/71e2bfdc.jpg" alt="" /></p><p>我们可以看到，当<code>sqlSession</code>没有调用<code>commit()</code>方法，二级缓存并没有起到作用</p><h4 id="实验2-2"><a class="markdownIt-Anchor" href="#实验2-2"></a> 实验2</h4><p>测试二级缓存效果，当提交事务时，<code>sqlSession1</code>查询完数据后，<code>sqlSession2</code>相同的查询是否会从缓存中获取数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCacheWithCommitOrClose</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  SqlSession sqlSession1 = factory.openSession(<span class="keyword">true</span>); </span><br><span class="line">  SqlSession sqlSession2 = factory.openSession(<span class="keyword">true</span>); </span><br><span class="line"></span><br><span class="line">  StudentMapper studentMapper = sqlSession1.getMapper(StudentMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  StudentMapper studentMapper2 = sqlSession2.getMapper(StudentMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">"studentMapper读取数据: "</span> + studentMapper.getStudentById(<span class="number">1</span>));</span><br><span class="line">  sqlSession1.commit();</span><br><span class="line">  System.out.println(<span class="string">"studentMapper2读取数据: "</span> + studentMapper2.getStudentById(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/f366f34e.jpg" alt="" /></p><p>从图上可知，<code>sqlSession2</code>的查询，使用了缓存，缓存的命中率是0.5</p><h4 id="实验3-2"><a class="markdownIt-Anchor" href="#实验3-2"></a> 实验3</h4><p>测试<code>update</code>操作是否会刷新该<code>namespace</code>下的二级缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCacheWithUpdate</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  SqlSession sqlSession1 = factory.openSession(<span class="keyword">true</span>); </span><br><span class="line">  SqlSession sqlSession2 = factory.openSession(<span class="keyword">true</span>); </span><br><span class="line">  SqlSession sqlSession3 = factory.openSession(<span class="keyword">true</span>); </span><br><span class="line"></span><br><span class="line">  StudentMapper studentMapper = sqlSession1.getMapper(StudentMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  StudentMapper studentMapper2 = sqlSession2.getMapper(StudentMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  StudentMapper studentMapper3 = sqlSession3.getMapper(StudentMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">"studentMapper读取数据: "</span> + studentMapper.getStudentById(<span class="number">1</span>));</span><br><span class="line">  sqlSession1.commit();</span><br><span class="line">  System.out.println(<span class="string">"studentMapper2读取数据: "</span> + studentMapper2.getStudentById(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">  studentMapper3.updateStudentName(<span class="string">"方方"</span>,<span class="number">1</span>);</span><br><span class="line">  sqlSession3.commit();</span><br><span class="line">  System.out.println(<span class="string">"studentMapper2读取数据: "</span> + studentMapper2.getStudentById(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/3ad93c3a.jpg" alt="" /></p><p>我们能够看到，在<code>sqlSession3</code>更新数据库，并提交事务后，<code>sqlSession2</code>的<code>studentMapper namespace</code>下的查询下走了数据库，没有走Cache</p><h4 id="实验4"><a class="markdownIt-Anchor" href="#实验4"></a> 实验4</h4><p>验证Mybatis的二级缓存不适应用于映射文件中存在多表查询的情况</p><p>通常我们会为每个单表创建单独的映射文件，由于Mybatis的二级缓存是基于<code>namespace</code>的，多表查询语句所在的<code>namespace</code>无法感应到其他<code>namespace</code>中的语句对多表查询中涉及的表进行的修改，引发脏数据问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCacheWithDiffererntNamespace</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  SqlSession sqlSession1 = factory.openSession(<span class="keyword">true</span>); </span><br><span class="line">  SqlSession sqlSession2 = factory.openSession(<span class="keyword">true</span>); </span><br><span class="line">  SqlSession sqlSession3 = factory.openSession(<span class="keyword">true</span>); </span><br><span class="line"></span><br><span class="line">  StudentMapper studentMapper = sqlSession1.getMapper(StudentMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  StudentMapper studentMapper2 = sqlSession2.getMapper(StudentMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  ClassMapper classMapper = sqlSession3.getMapper(ClassMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">"studentMapper读取数据: "</span> + studentMapper.getStudentByIdWithClassInfo(<span class="number">1</span>));</span><br><span class="line">  sqlSession1.close();</span><br><span class="line">  System.out.println(<span class="string">"studentMapper2读取数据: "</span> + studentMapper2.getStudentByIdWithClassInfo(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">  classMapper.updateClassName(<span class="string">"特色一班"</span>,<span class="number">1</span>);</span><br><span class="line">  sqlSession3.commit();</span><br><span class="line">  System.out.println(<span class="string">"studentMapper2读取数据: "</span> + studentMapper2.getStudentByIdWithClassInfo(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/5265ed97.jpg" alt="" /></p><p>在这个实验中，我们引入了两张新的表，一张class，一张classroom。class中保存了班级的id和班级名，classroom中保存了班级id和学生id。我们在StudentMapper中增加了一个查询方法<code>getStudentByIdWithClassInfo</code>，用于查询学生所在的班级，涉及到多表查询。在ClassMapper中添加了<code>updateClassName</code>，根据班级id更新班级名的操作</p><p>当<code>sqlSession1</code>的<code>studentMapper</code>查询数据后，二级缓存生效。保存在StudentMapper的namespace下的cache中。当<code>sqlSession3</code>的<code>classMapper</code>的<code>updateClassName</code>方法对class表进行更新时，<code>updateClassName</code>下的cache没有感应到变化，没有刷新缓存。当<code>StudentMapper</code>中同样的查询再次发起时，从缓存中读取了脏数据</p><h4 id="实验5"><a class="markdownIt-Anchor" href="#实验5"></a> 实验5</h4><p>为了解决实验4的问题，可以使用Cache ref，让<code>ClassMapper</code>引用<code>StudentMapper</code>命名空间，这样两个映射文件对应的SQL操作都使用的是同一个缓存了</p><p>执行结果：</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/a2e4c2d8.jpg" alt="" /></p><p>不过这样做的后果是，缓存的粒度变粗了，多个<code>Mapper namespace</code>下的所有操作都会对缓存使用造成影响</p><h3 id="四-二级缓存源码分析"><a class="markdownIt-Anchor" href="#四-二级缓存源码分析"></a> 四、二级缓存源码分析</h3><p>Mybatis二级缓存的工作流程和前文提到的一级缓存类似，只是在一级缓存处理前，用<code>CachingExecutor</code>装饰了<code>BaseExecutor</code>的子类，在委托具体职责给<code>delegate</code>之前，实现了二级缓存的查询和写入功能，具体类关系图如下图所示</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/090216b1.jpg" alt="" /></p><h4 id="源码分析-2"><a class="markdownIt-Anchor" href="#源码分析-2"></a> 源码分析</h4><p>源码分析从<code>CachingExecutor</code>的<code>query</code>方法展开</p><p><code>CachingExecutor</code>的<code>query</code>方法，首先会从<code>MappedStatement</code>中获得在配置初始化时赋予的Cache</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache cache = ms.getCache();</span><br></pre></td></tr></table></figure><p>本质上是装饰器模式的使用，具体的装饰链是：</p><blockquote><p>SynchronizedCache --&gt; LoggingCache --&gt; SerializedCache --&gt; LruCache --&gt; PerpetualCache</p></blockquote><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/1f5233b2.jpg" alt="" /></p><p>以下是具体这些Cache实现类的介绍，它们的组合为Cache赋予了不同的能力</p><ul><li><code>SynchronizedCache</code>：同步Cache，实现比较简单，直接使用synchronized修饰方法</li><li><code>LoggingCache</code>：日志功能，装饰类，用于记录缓存的命中率，如果开启了DEBUG模式，则会输出命中率日志</li><li><code>SerializedCache</code>：序列化功能，将值序列化后存到缓存中。该功能用于缓存返回一份实例的Copy，用于保存线程安全</li><li><code>LruCache</code>：采用了Lru算法的Cache实现，移除最近最少使用的Key/Value</li><li><code>PerpetualCache</code>：作为最基础的缓存类，底层实现比较简单，直接使用了HashMap</li></ul><p>然后是判断是否需要刷新缓存，代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.flushCacheIfRequired(ms);</span><br></pre></td></tr></table></figure><p>在默认的设置中<code>SELECT</code>语句不会刷新缓存，<code>insert/update/delete</code>会刷新缓存。进入该方法，代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flushCacheIfRequired</span><span class="params">(MappedStatement ms)</span> </span>&#123;</span><br><span class="line">  Cache cache = ms.getCache();</span><br><span class="line">  <span class="keyword">if</span> (cache != <span class="keyword">null</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;</span><br><span class="line">    <span class="keyword">this</span>.tcm.clear(cache);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Mybatis的<code>CachingExecutor</code>持有了<code>TransactionalCacheManager</code>，即上述代码中tcm</p><p><code>TransactionalCacheManager</code>中持有了一个Map，代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;Cache, TransactionalCache&gt; transactionalCaches = <span class="keyword">new</span> HashMap();</span><br></pre></td></tr></table></figure><p>这个Map保存了Cache和用<code>TransactionalCache</code>包装后的Cache的映射关系</p><p><code>TransactionalCache</code>实现了Cache接口，<code>CachingExecutor</code>会默认使用它包装初始生成的Cache，作用是如果事务提交，对缓存的操作才会生效，对缓存的操作才会生效，如果事务回滚或者不提交事务，则不对缓存产生影响</p><p>在<code>TransactionalCache</code>的clear，有以下两句。清空了需要在提交时加入缓存的列表，同时设定提交时清空缓存，代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.clearOnCommit = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">this</span>.entriesToAddOnCommit.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CachingExecutor</code>继续往下走，<code>ensureNoOutParams</code>主要是用来处理存储过程的，暂时不用考虑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ms.isUseCache() &amp;&amp; resultHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="keyword">this</span>.ensureNoOutParams(ms, parameterObject, boundSql);</span><br></pre></td></tr></table></figure><p>之后会尝试从tcm中获取缓存的列表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;E&gt; list = (List)<span class="keyword">this</span>.tcm.getObject(cache, key);</span><br></pre></td></tr></table></figure><p>在<code>getObject</code>方法中，会把获取值的职责一路传递，最终到<code>TransactionalCache</code>。如果没有查到，会把key加入到Miss集合，这个主要是为了统计命中率。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  Object object = <span class="keyword">this</span>.delegate.getObject(key);</span><br><span class="line">  <span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.entriesMissedInCache.add(key);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.clearOnCommit ? <span class="keyword">null</span> : object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CachingExecutor</code>继续往下走，如果查询到数据，则调用<code>tcm.putObject</code>方法，往缓存中放入值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (list == <span class="keyword">null</span>) &#123;</span><br><span class="line">  list = <span class="keyword">this</span>.delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">  <span class="keyword">this</span>.tcm.putObject(cache, key, list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tcm的<code>put</code>方法也不是直接操作缓存，只是在把这次的数据和key放入待提交的Map中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object object)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.entriesToAddOnCommit.put(key, object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以上的代码分析中，我们可以明白，如果不调用<code>commit</code>方法的话，由于<code>TransactionalCache</code>的作用，并不会对二级缓存造成直接的影响。因此我们看看<code>SqlSession</code>的<code>commit</code>的方法中做了什么。代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">(<span class="keyword">boolean</span> force)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.executor.commit(<span class="keyword">this</span>.isCommitOrRollbackRequired(force));</span><br><span class="line">    <span class="keyword">this</span>.dirty = <span class="keyword">false</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception var6) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error committing transaction.  Cause: "</span> + var6, var6);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ErrorContext.instance().reset();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我们使用了<code>CachingExecutor</code>，首先会进入<code>CachingExecutor</code>实现的commit方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">(<span class="keyword">boolean</span> required)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.delegate.commit(required);</span><br><span class="line">  <span class="keyword">this</span>.tcm.commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会把具体commit的职责委托给包装的<code>Executor</code>，主要是看下<code>tcm.commit()</code>，tcm最终又会调用到<code>TransactionalCache</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.clearOnCommit) &#123;</span><br><span class="line">    <span class="keyword">this</span>.delegate.clear();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.flushPendingEntries();</span><br><span class="line">  <span class="keyword">this</span>.reset();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这里的<code>clearOnCommit</code>就想起刚才<code>TransactionalCache</code>的<code>clear</code>方法设置的标志位，真正的清理Cache是放到这里来进行的。具体清理的职责委托给了包装的Cache类。之后进入<code>flushPendingEntries</code>方法。代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flushPendingEntries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Iterator var1 = <span class="keyword">this</span>.entriesToAddOnCommit.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(var1.hasNext()) &#123;</span><br><span class="line">    Entry&lt;Object, Object&gt; entry = (Entry)var1.next();</span><br><span class="line">    <span class="keyword">this</span>.delegate.putObject(entry.getKey(), entry.getValue());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var1 = <span class="keyword">this</span>.entriesMissedInCache.iterator();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(var1.hasNext()) &#123;</span><br><span class="line">    Object entry = var1.next();</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.entriesToAddOnCommit.containsKey(entry)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.delegate.putObject(entry, (Object)<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>flushPendingEntries</code>中，将待提交的Map进行循环处理，委托给包装的Cache类，进行<code>putObject</code>的操作</p><p>后续的查询操作会重复执行这套流程。如果是<code>insert|update|delete</code>的话，会统一进入<code>CachingExecutor</code>的<code>update</code>方法，其中调用了这个函数。代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flushCacheIfRequired</span><span class="params">(MappedStatement ms)</span> </span>&#123;</span><br><span class="line">  Cache cache = ms.getCache();</span><br><span class="line">  <span class="keyword">if</span> (cache != <span class="keyword">null</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;</span><br><span class="line">    <span class="keyword">this</span>.tcm.clear(cache);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在二级缓存执行流程后就会进入一级缓存的执行流程，因此不再累赘</p><h3 id="总结-2"><a class="markdownIt-Anchor" href="#总结-2"></a> 总结</h3><ol><li>Mybatis的二级缓存相对于一级缓存来说，实现了<code>SqlSession</code>之间缓存数据的共享，同时粒度更加的细，能够到<code>namespace</code>级别，通过Cache接口实现不同的组合，对Cache的可控性也更强</li><li>Mybatis在多表查询中，极大可能出现脏数据，有设计上的缺陷，安全使用二级缓存的条件比较苛刻</li><li>在分布式环境下，由于默认的Mybatis Cache实现都是基于本地的，分布式环境下必然出现读取到脏数据，需要使用集中式缓存将Mybatis的Cache接口实现，有一定的开发成本，直接使用Redis、Memcached等分布式存储可能成本更低，安全性也更高</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一级缓存&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一级缓存&quot;&gt;&lt;/a&gt; 一级缓存&lt;/h2&gt;
&lt;h3 id=&quot;一级缓存介绍&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一级缓存介绍&quot;&gt;&lt;/a&gt; 一级缓存
      
    
    </summary>
    
    
      <category term="Web" scheme="https://toyan.top/categories/Web/"/>
    
      <category term="Mybatis" scheme="https://toyan.top/categories/Web/Mybatis/"/>
    
    
      <category term="Mybatis" scheme="https://toyan.top/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>select加锁分析MySQL</title>
    <link href="https://toyan.top/mysql-lock/"/>
    <id>https://toyan.top/mysql-lock/</id>
    <published>2019-09-04T16:00:00.000Z</published>
    <updated>2020-02-08T13:00:55.259Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a class="markdownIt-Anchor" href="#引言"></a> 引言</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">id</span> = ?</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">id</span> &lt; ?</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">id</span> = ? <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">id</span> &lt; ? <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">id</span> = ? <span class="keyword">for</span> <span class="keyword">update</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">id</span> &lt; ? <span class="keyword">for</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure><p>要知道以上的区别，首先要知道以下问题</p><ul><li>当前事务隔离级别是什么</li><li>id列是否存在索引</li><li>如果存在索引是聚簇索引还是非聚簇索引呢？</li></ul><h2 id="正文"><a class="markdownIt-Anchor" href="#正文"></a> 正文</h2><ul><li>innodb一定存在聚簇索引，默认以主键作为聚簇索引</li><li>有几个索引，就有几棵B+树（不考虑hash索引的情形）</li><li>聚簇索引的叶子节点为磁盘上的真实数据。非聚簇索引的叶子节点还是索引，指向聚簇索引B+树</li></ul><h3 id="锁类型"><a class="markdownIt-Anchor" href="#锁类型"></a> 锁类型</h3><ul><li>共享锁(S锁)：假设事务T1对数据A加上共享锁，那么事务T2可以读数据A，<strong>不能</strong>修改数据A</li><li>排他锁(X锁)：假设事务T1对数据A加上共享锁，那么事务T2<strong>不能</strong>读数据A，<strong>不能</strong>修改数据A</li></ul><p>​我们通过<code>update</code>、<code>delete</code>等语句加上的锁都是行级别的锁。只有<code>LOCK TABLE … READ</code>和<code>LOCK TABLE … WRITE</code>才能申请表级别的锁。</p><ul><li>意向共享锁(IS锁)：一个事务在获取（任何一行/或者全表）S锁之前，一定会先在所在的表上加IS锁</li><li>意向排他锁(IX锁)：一个事务在获取（任何一行/或者全表）X锁之前，一定会先在所在的表上加IX锁</li></ul><h3 id="意向锁存在的目的"><a class="markdownIt-Anchor" href="#意向锁存在的目的"></a> 意向锁存在的目的</h3><p>假设事务T1，用X锁来锁住了表上的几条记录，那么此时表上存在IX锁，即意向排他锁，那么此时事务T2要进行LOCK TABLE…WRITE的表级别锁的请求，可以直接根据意向锁是否存在而判断是否有锁冲突。</p><h3 id="加锁算法"><a class="markdownIt-Anchor" href="#加锁算法"></a> 加锁算法</h3><ul><li>Record Locks：简单翻译为行锁，注意了，该锁是对索引记录进行加锁！锁是在加索引上而不是行上。注意了，innodb一定存在聚簇索引，因此行锁最终都会落到聚簇索引上</li><li>Gap Locks：简单翻译为间隙锁，是对索引的间隙加锁，其目的只有一个，防止其他事物插入数据。在Read Committed隔离级别下，不会使用间隙锁。隔离级别比Read Committed低的情况下，也不会使用间隙锁，如隔离级别为Read UnCommitted时，也不存在间隙锁。当隔离级别为Repeatable Read和Serializable时，就会存在间隙锁</li><li>Next-Key Locks：这个理解为Record Lock+索引前面的Gap Lock。记住了，锁住的是索引前面的间隙！比如一个索引包含值，10、11、13和20。那么，间隙锁的范围如下</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(negative infinity, 10]</span><br><span class="line">(10, 11]</span><br><span class="line">(11, 13]</span><br><span class="line">(13, 20]</span><br><span class="line">(20, positive infinity)</span><br></pre></td></tr></table></figure><h3 id="快照读和当前读"><a class="markdownIt-Anchor" href="#快照读和当前读"></a> 快照读和当前读</h3><p>在mysql中select分为快照读和当前读，执行下面的语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">id</span>=?;</span><br></pre></td></tr></table></figure><p>执行的是快照读，读的是数据库记录的快照版本，是不加锁的（这种说法在隔离级别为Serializable中不成立，后面我会补充）<br />那么，执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">id</span>=? <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span>;</span><br></pre></td></tr></table></figure><p>会对读取记录加S锁（共享锁），执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">id</span>=? <span class="keyword">for</span> <span class="keyword">update</span>；</span><br></pre></td></tr></table></figure><p>会对读取记录加X锁（排他锁），那么</p><p><strong>加的是表锁还是行锁呢？</strong></p><p>针对这点，下面是事务的四个隔离级别，他们由弱到强如下所示：</p><ul><li>Read Uncommitted(RU)：读未提交，一个事务可以读到另一个事务未提交的数据！</li><li>Read Committed(RC)：读已提交，一个事务可以读到另一个事务已提交的数据</li><li>Repeatable Read(RR)：可重复读，加入间隙锁，一定程度上避免了幻读的产生！注意了，只是一定程度上，并没有完全避免！另外记住从该级别才开始加入间隙锁</li><li>Serializable：串行化，该级别下读写串行化，且所有的select语句后都自动加上lock in share mode，即使用了共享锁。因此在该隔离级别下，使用的是当前读，而不是快照读</li></ul><p>那么关于是表锁还是行锁，大家可以看到网上最流传的一个说法是这样的：</p><blockquote><p>InnoDB行锁是通过给索引上的索引项加锁来实现的，这一点Mysql与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现。InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！</p></blockquote><blockquote><p>上面这句话有两处错误！<br />错误一：并不是用表锁来实现锁表的操作，而是利用了<code>Next-Key Locks</code>，也可以理解为是用了行锁+间隙锁来实现锁表的操作！为了便于说明，举例如下，其中，pid为主键索引。</p></blockquote><table><thead><tr><th>pid(int)</th><th>name(varchar)</th><th>num(int)</th></tr></thead><tbody><tr><td>1</td><td>aaa</td><td>100</td></tr><tr><td>2</td><td>bbb</td><td>200</td></tr><tr><td>7</td><td>ccc</td><td>200</td></tr></tbody></table><p>执行语句（name列无索引）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'aaa'</span> <span class="keyword">for</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure><p>那么此时在pid=1,2,7这三条记录上存在行锁（把行锁住了）。另外，在(-∞,1)(1,2)(2,7)(7,+∞)上存在间隙锁（把间隙锁住了）。因此，给人一种整个表锁住的错觉！</p><p><code>ps:</code>对该结论有疑问的，可自行执行<code>show engine innodb status;</code>语句进行分析。</p><blockquote><p>错误二：所有文章都不提隔离级别</p></blockquote><p>锁表是通过行锁+间隙锁实现的。由于RU和RC都不存在间隙锁，因此，该说法只在RR和Serializable中成立，如果隔离级别为RU和RC，无论条件列上是否有索引，都不会锁表，只锁行</p><h2 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h2><p>假设有下表如下，pid为主键索引</p><table><thead><tr><th style="text-align:center">pid(int)</th><th style="text-align:center">name(varchar)</th><th style="text-align:center">num(int)</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">aaa</td><td style="text-align:center">100</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">bbb</td><td style="text-align:center">200</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">bbb</td><td style="text-align:center">300</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">ccc</td><td style="text-align:center">200</td></tr></tbody></table><h3 id="rcru-条件列非索引"><a class="markdownIt-Anchor" href="#rcru-条件列非索引"></a> RC/RU + 条件列非索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">num</span> = <span class="number">200</span></span><br></pre></td></tr></table></figure><p>不加任何锁，是快照读</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">num</span> &gt; <span class="number">200</span></span><br></pre></td></tr></table></figure><p>不加任何锁，是快照读</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">num</span> = <span class="number">200</span> <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span></span><br></pre></td></tr></table></figure><p>当num=200，有两条记录。这两条记录对应的pid=2、7，因此在pid=2、7的聚餐索引上加行级S锁，采用当前读</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">num</span> &gt; <span class="number">200</span> <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span></span><br></pre></td></tr></table></figure><p>当num&gt;200，有一条记录。这条记录对应的pid=3，因此在pid=3的聚簇索引上加上行级S锁，采用当前读</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">num</span> = <span class="number">200</span> <span class="keyword">for</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure><p>当num=200，有两条记录。这两条记录对应的pid=2、7，因此在pid=2、7的聚簇索引上加行级X锁，采用当前读</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">num</span> &gt; <span class="number">200</span> <span class="keyword">for</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure><p>当num&gt;200，有一条记录。这条记录对应的pid=3，因此在pid=3的聚簇索引上加上行级X锁，采用当前读</p><h3 id="rcru-条件列是聚簇索引"><a class="markdownIt-Anchor" href="#rcru-条件列是聚簇索引"></a> RC/RU + 条件列是聚簇索引</h3><p>大家知道条件列是主键列，因此pid用的就是聚簇索引，此情况其实和<strong>RC/RU + 条件列非索引</strong>情况是类似的</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> pid = <span class="number">2</span></span><br></pre></td></tr></table></figure><p>不加任何锁，是快照读</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> pid &gt; <span class="number">2</span></span><br></pre></td></tr></table></figure><p>不加任何锁，是快照读</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> pid = <span class="number">2</span> <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span></span><br></pre></td></tr></table></figure><p>在pid=2的聚簇索引上，加S锁，为当前读</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> pid &gt; <span class="number">2</span> <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span></span><br></pre></td></tr></table></figure><p>在pid=3、7的聚簇索引上，加S锁，为当前读</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> pid = <span class="number">2</span> <span class="keyword">for</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure><p>在pid=2的聚簇索引上，加X锁，为当前读</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> pid &gt; <span class="number">2</span> <span class="keyword">for</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure><p>在pid=3、7的聚簇索引上，加X锁，为当前读</p><blockquote><p>为什么条件列加不加索引，加锁情况都是一样的？</p><p>Ok，其实是不一样的。在RC/RU隔离级别中，Mysql Server做了优化。在条件列没有索引的情况下，尽管通过聚簇索引来扫描全表，进行全表加锁。但是，Mysql Server层会进行过滤并把不符合条件的锁当即释放掉，因此你看起来最终结果都是一样的。但是<strong>RC/RU + 条件列非索引</strong>比本例多了一个释放不符合条件的锁的过程！</p></blockquote><h3 id="rcru-条件列是非聚簇索引"><a class="markdownIt-Anchor" href="#rcru-条件列是非聚簇索引"></a> RC/RU + 条件列是非聚簇索引</h3><p>我们在num列上建立非唯一索引，此时有一颗聚簇索引（主键索引，pid）形成的B+索引树，其叶子节点为硬盘上的真实数据。以及另一颗非聚簇索引（非唯一索引num）形成的B+索引树，其叶子节点依然为索引节点，保存了num列的字段值，和对应的聚簇索引</p><p>接下来分析开始</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">num</span> = <span class="number">200</span></span><br></pre></td></tr></table></figure><p>不加任何锁，快照读</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">num</span> &gt; <span class="number">200</span></span><br></pre></td></tr></table></figure><p>不加任何锁，快照读</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">num</span> = <span class="number">200</span> <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span></span><br></pre></td></tr></table></figure><p>当num=200，由于num列上有索引，因此先在num=200的两条索引记录上加行级S锁。接着，去聚簇索引树上查询，这两条记录对应的pid=2、7，因此在pid=2、7的聚簇索引上加行级S锁，采用当前读</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">num</span> &gt; <span class="number">200</span> <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span></span><br></pre></td></tr></table></figure><p>当num&gt;200，由于num列上有索引，因此先在符合条件的num=300的一条索引记录上加行级S锁。接着，去聚簇索引树上查询，这条记录对应的pid=3，因此在pid=3的聚簇索引上加行级S锁，采用当前读</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">num</span> = <span class="number">200</span> <span class="keyword">for</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure><p>当num=200，由于num列上有索引，因此先在num=200的两条索引记录上加行级X锁。接着，去聚簇索引树上查询，这两条记录对应的pid=2、7，因此在pid=2、7的聚簇索引上加行级X锁，采用当前读</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from tab;e where num &gt; 200 for update</span><br></pre></td></tr></table></figure><p>当num&gt;200，由于num列上有索引，因此先在符合条件的num=300的一条索引记录上加行级X锁。接着，去聚簇索引树上查询，这条记录对应的pid=3，因此在pid=3的聚簇索引上加行级X锁，采用当前读</p><h3 id="rrserializable-条件列非索引"><a class="markdownIt-Anchor" href="#rrserializable-条件列非索引"></a> RR/Serializable + 条件列非索引</h3><p>RR级别需要多考虑的就是gap lock，它的加锁特征在于，无论你怎么查都是锁全表，如下所示，分析开始</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">num</span> = <span class="number">200</span></span><br></pre></td></tr></table></figure><p>在RR级别下，不加任何锁，是快照读。在Serializable级别下，在pid=1、2、3、7（全表所有记录）的聚簇索引上加S锁。并且在聚簇索引的所有间隙(-∞,1)(1,2)(2,3)(3,7)(7,+∞)加gap lock</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">num</span> &gt; <span class="number">200</span></span><br></pre></td></tr></table></figure><p>在RR级别下，不加任何锁，是快照读。在Serializable级别下，在pid=1、2、3、7（全表所有记录）的聚簇索引上加S锁。并且在聚簇索引的所有间隙(-∞,1)(1,2)(2,3)(3,7)(7,+∞)加gap lock</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">num</span> = <span class="number">200</span> <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span></span><br></pre></td></tr></table></figure><p>在pid=1、2、3、7（全表所有记录）的聚簇索引上加S锁，并且在聚簇索引的所有间隔(-∞,1)(1,2)(2,3)(3,7)(7,+∞)加gap lock</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">num</span> &gt; <span class="number">200</span> <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span></span><br></pre></td></tr></table></figure><p>在pid=1、2、3、7（全表所有记录）的聚簇索引上加S锁，并且在聚簇索引的所有间隔(-∞,1)(1,2)(2,3)(3,7)(7,+∞)加gap lock</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">num</span> = <span class="number">200</span> <span class="keyword">for</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure><p>在pid=1、2、3、7（全表所有记录）的聚簇索引上加X锁，并且在聚簇索引的所有间隔(-∞,1)(1,2)(2,3)(3,7)(7,+∞)加gap lock</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">num</span> &gt; <span class="number">200</span> <span class="keyword">for</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure><p>在pid=1、2、3、7（全表所有记录）的聚簇索引上加X锁，并且在聚簇索引的所有间隔(-∞,1)(1,2)(2,3)(3,7)(7,+∞)加gap lock</p><h3 id="rrserializable-条件列是聚簇索引"><a class="markdownIt-Anchor" href="#rrserializable-条件列是聚簇索引"></a> RR/Serializable + 条件列是聚簇索引</h3><p>大家都知道pid是主键列，因此pid用的就是聚簇索引。该情况的加锁特征在于，如果where后的条件为精确查询（=的情况），那么只存在record lock。如果where后的条件为范围查询（&gt;或&lt;的情况），那么存在的是record lock + gap lock</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> pid = <span class="number">2</span></span><br></pre></td></tr></table></figure><p>在RR级别下，不加任何锁，是快照读；在Serializable级别下，是当前读，在pid=2的聚簇索引上加S锁，不存在gap lock</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> pid &gt; <span class="number">2</span></span><br></pre></td></tr></table></figure><p>在RR级别下，不加任何锁，是快照读。在Serializable级别下，是当前读，在pid=3、7的聚簇索引上加S锁，在(2,3)(3,7)(7,+∞)加上gap lock</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> pid = <span class="number">2</span> <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span></span><br></pre></td></tr></table></figure><p>是当前读，在pid=2的聚簇索引上加S锁，不存在gap lock</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> pid &gt; <span class="number">2</span> <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span></span><br></pre></td></tr></table></figure><p>是当前读，在pid=3、7的聚簇索引上加S锁，在(2,3)(3,7)(7,+∞)加上gap lock</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> pid = <span class="number">2</span> <span class="keyword">for</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure><p>是当前读，在pid=2的聚簇索引上加X锁</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> pid &gt; <span class="number">2</span> <span class="keyword">for</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure><p>是当前读，在pid=3、7的聚簇索引上加X锁，在(2,3)(3,7)(7,+∞)加上gap lock</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> pid = <span class="number">6</span> [<span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span>|<span class="keyword">for</span> <span class="keyword">update</span>]</span><br></pre></td></tr></table></figure><p><strong>注意了，pid=6是不存在的列，这种情况会在（3，7）加上gap lock</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> pid &gt; <span class="number">18</span> [<span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span>|<span class="keyword">for</span> <span class="keyword">update</span>]</span><br></pre></td></tr></table></figure><p><strong>注意了，pid&gt;18，查询结果是空的。在这种情况下，是在(7,+∞)上加gap lock</strong></p><h3 id="rrserializable-条件列是非聚簇索引"><a class="markdownIt-Anchor" href="#rrserializable-条件列是非聚簇索引"></a> RR/Serializable + 条件列是非聚簇索引</h3><blockquote><p>这里是非聚簇索引，需要区分是否为唯一索引。因为如果是非唯一索引，间隙锁的加锁方式是有区别的<br />先说一下，唯一索引的情况。如果是唯一索引，情况和RR/Serializable+条件列是聚簇索引类似，唯一有区别的是：<strong>这个时候有两颗索引树，加锁是加在对应的非聚簇索引树和聚簇索引树上</strong><br />下面说一下，非聚簇索引是非唯一索引的情况，它和唯一索引的区别就是通过索引进行精确查询后，不仅存在record lock，还存在gap lock。而通过唯一索引进行精确查询后，只存在record lock，老规矩在num列建立非唯一索引</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">num</span> = <span class="number">200</span></span><br></pre></td></tr></table></figure><p>在RR级别下，不加任何锁，是快照读。在Serializable下，是当前读，在pid=2、7的聚簇索引上加S锁，在num=200的非聚簇索引上加S锁，在(100,200)(200,300)加上gap lock</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">num</span> &gt; <span class="number">200</span></span><br></pre></td></tr></table></figure><p>在RR级别下，不加任何锁，是快照读。在Serializable级别下，是当前读，在pid=3的聚簇索引上加S锁，在num=300的非聚集索引上加S锁。在(200,300)(300,+∞)加上gap lock</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">num</span> = <span class="number">200</span> <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span></span><br></pre></td></tr></table></figure><p>是当前读，在pid=2、7的聚簇索引上加S锁，在num=200的非聚簇索引上加S锁，在(100,200)(200,300)加上gap lock</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">num</span> &gt; <span class="number">200</span> <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span></span><br></pre></td></tr></table></figure><p>是当前读，在pid=3的聚簇索引上加S锁，在num=300的非聚集索引上加S锁，在(200,300)(300,+∞)加上gap lock</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">num</span> = <span class="number">200</span> <span class="keyword">for</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure><p>是当前读，在pid=2的聚簇索引上加S锁，在num=200的非聚簇索引上加X锁，在(200,300)(300,+∞)加上gap lock</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">num</span> &gt; <span class="number">200</span> <span class="keyword">for</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure><p>是当前读，在pid=3的聚簇索引上加S锁，在num=300的非聚簇索引上加X锁，在在(200,300)(300,+∞)加上gap lock</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">num</span> = <span class="number">250</span> [<span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span>|<span class="keyword">for</span> <span class="keyword">update</span>]</span><br></pre></td></tr></table></figure><p><strong>注意了，num=250是不存在的列，这种情况会在(200,300)上加gap lock</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">num</span> &gt; <span class="number">400</span> [<span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span>|<span class="keyword">for</span> <span class="keyword">update</span>]</span><br></pre></td></tr></table></figure><p><strong>注意了，pid&gt;400，查询结果为空，在这种情况下，是在(400,+∞)上加gap lock</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#引言&quot;&gt;&lt;/a&gt; 引言&lt;/h2&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span clas
      
    
    </summary>
    
    
      <category term="Mysql" scheme="https://toyan.top/categories/Mysql/"/>
    
    
      <category term="SQL" scheme="https://toyan.top/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>Spring中常用的两种事务配置方式以及事务的传播性、隔离级别</title>
    <link href="https://toyan.top/spring-transactional/"/>
    <id>https://toyan.top/spring-transactional/</id>
    <published>2019-08-22T16:00:00.000Z</published>
    <updated>2020-02-08T15:09:18.250Z</updated>
    
    <content type="html"><![CDATA[<h2 id="注解式事务"><a class="markdownIt-Anchor" href="#注解式事务"></a> 注解式事务</h2><h3 id="事务配置实例"><a class="markdownIt-Anchor" href="#事务配置实例"></a> 事务配置实例</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 定义事务管理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--使用注释事务 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span>  <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h3 id="transactional"><a class="markdownIt-Anchor" href="#transactional"></a> @Transactional</h3><p>（1）有的把这个注解放在类名称上面了，这样你配置的这个@Transactional 对这个类中的所有public方法都起作用<br />（2）@Transactional 方法方法名上，只对这个方法有作用，同样必须是public的方法</p><h3 id="事务配置中有哪些属性可以配置"><a class="markdownIt-Anchor" href="#事务配置中有哪些属性可以配置"></a> 事务配置中有哪些属性可以配置</h3><p>（1）事务的传播性：<code>@Transactional(propagation=Propagation.REQUIRED)</code><br />​如果有事务，那么加入事务，没有的话新建一个（默认情况下）<br />（2）事务的超时性：<code>@Transactional(timeout=30) //默认是30秒</code><br />​注意这里说的是事务的超时性而不是Connection的超时性<br />（3）事务的隔离级别：<code>@Transactional(isolation = Isolation.READ_UNCOMMITTED)</code><br />​读取未提交数据(会出现脏读, 不可重复读) 基本不使用<br />（4）回滚<br />​指定单一异常类：<code>@Transactional(rollbackFor=RuntimeException.class)</code><br />​指定多个异常类：<code>@Transactional(rollbackFor={RuntimeException.class, Exception.class})</code><br />​该属性用于设置需要进行回滚的异常类数组，当方法中抛出指定异常数组中的异常时，则进行事务回滚<br />（5）只读：<code>@Transactional(readOnly=true)</code><br />​该属性用于设置当前事务是否为只读事务，设置为true表示只读，false则表示可读写，默认值为false</p><h3 id="注意"><a class="markdownIt-Anchor" href="#注意"></a> 注意</h3><p>（1）@Transactional 只能被应用到public方法上, 对于其它非public的方法,如果标记了@Transactional也不会报错,但方法没有事务功能<br />（2）用Spring事务管理器，由Spring来负责数据库的打开、提交、回滚，默认遇到运行期例外(<code>throw new RuntimeException;</code>)会回滚，即遇到不受检查unchecked的例外时回滚，而遇到需要捕获的例外(<code>throw new Exception;</code>)不会回滚，即遇到受检查的例外(就是非运行时抛出的异常，编译器会检查到的异常叫受检查例外或说受检查异常)时，需我们指定方式来让事务回滚，要想所有异常都回滚，要加上<code>@Transactional(rollbackFor={Exception.class,其它异常})</code>，如果让unchecked例外不回滚，要加上<code>@Transactional(notRollbackFor=RunTimeException.class)</code><br />（3）@Transactional 注解应该只被应用到 public 可见度的方法上。 如果你在 protected、private 或者 package-visible 的方法上使用 @Transactional 注解，它也不会报错， 但是这个被注解的方法将不会展示已配置的事务设置<br />（4）@Transactional 注解可以被应用于接口定义和接口方法、类定义和类的 public 方法上。然而，请注意仅仅 @Transactional 注解的出现不足于开启事务行为，它仅仅是一种元数据，能够被可以识别 @Transactional 注解和上述的配置适当的具有事务行为的beans所使用。上面的例子中，其实正是&lt;tx:annotation-driven/&gt;元素的出现 开启了事务行为<br />（5）Spring团队的建议是在具体的类（或类的方法）上使用@Transactional注解，而不是使用在类所要实现的任何接口上。可以在接口上使用 @Transactional 注解，但是这将只能当你设置基于接口的代理时它才生效。因为接口是<strong>不能继承</strong>的的，这就意味着如果正在使用基于类的代理时，那么事务的设置将不能被基于类的代理所识别，而且对象也将不会被事务代理所包装。因此，请接受Spring团队的建议并且在具体的类上使用 @Transactional 注解</p><h2 id="使用aop的方式实现事务的配置"><a class="markdownIt-Anchor" href="#使用aop的方式实现事务的配置"></a> 使用AOP的方式实现事务的配置</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 定义事务管理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 下面使用aop切面的方式来实现 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"TestAdvice"</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--配置事务传播性，隔离级别以及超时回滚等问题 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"save*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"del*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"update*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"add*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"*"</span> <span class="attr">rollback-for</span>=<span class="string">"Exception"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--配置事务切点 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"services"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">expression</span>=<span class="string">"execution(* com.website.service.*.*(..))"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">pointcut-ref</span>=<span class="string">"services"</span> <span class="attr">advice-ref</span>=<span class="string">"TestAdvice"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>AOP配置的属性如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"advice"</span> <span class="attr">transaction-manager</span>=<span class="string">"txManager"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- tx:method的属性:</span></span><br><span class="line"><span class="comment"> - name是必须的，表示与事务属性关联的方法名，对切入点进行细化。通配符*可以用来指定一批关联到相同的事务属性的方法。如get*、handle*、on*Event等等</span></span><br><span class="line"><span class="comment">- propagation不是必须的，默认值是REQUIRED，表示事务的传播行为，包括REQUIRED,SUPPORTS,MANDATORY,REQUIRES_NEW,NOT_SUPPORTED,NEVER,NESTED</span></span><br><span class="line"><span class="comment">- isolation 不是必须的，默认值DEFAULT，表示事务隔离级别（数据库的隔离级别）</span></span><br><span class="line"><span class="comment">- timeout 不是必须的，默认值-1（永不超时），表示事务超时的时间（以秒为单位）</span></span><br><span class="line"><span class="comment">- read-only 不是必须的，默认值false不是只读的，表示事务是否只读？</span></span><br><span class="line"><span class="comment">- rollback-for 不是必须的，表示将被触发进行回滚的Exception(s)以逗号分开</span></span><br><span class="line"><span class="comment">- no-rollback-for 不是必须的，表示不被触发进行回滚的Exception(s)以逗号分开</span></span><br><span class="line"><span class="comment">任何RuntimeException将触发事务回滚，但是任何checked Exception将不触发事务回滚</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"save*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span> <span class="attr">isolation</span>=<span class="string">"DEFAULT"</span> <span class="attr">read-only</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"update*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span> <span class="attr">isolation</span>=<span class="string">"DEFAULT"</span> <span class="attr">read-only</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"delete*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span> <span class="attr">isolation</span>=<span class="string">"DEFAULT"</span> <span class="attr">read-only</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 其他的方法之只读的 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"*"</span> <span class="attr">read-only</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="spring事务"><a class="markdownIt-Anchor" href="#spring事务"></a> Spring事务</h2><h3 id="spring事务的几种传播特性"><a class="markdownIt-Anchor" href="#spring事务的几种传播特性"></a> Spring事务的几种传播特性</h3><ul><li>PROPAGATION_REQUIRED：如果存在一个事务，则支持当前事务，如果没有事务则开启</li><li>PROPAGATION_SUPPORTS：如果存在一个事务，支持当前事务。如果没有事务，则非事务的执行</li><li>PROPAGATION_MANDATORY：如果存在一个事务，支持当前事务，如果没有一个活动事务，则抛出异常</li><li>PROPAGATION_REQUIRES_NEW：总是开启一个新的事务，如果一个事务已经存在，则将这个存在的事务挂起</li><li>PROPAGATION_NOT_SUPPORTED：总是非事务地执行，并挂起任何存在的事务</li><li>PROPAGATION_NEVER：总是非事务地执行，如果存在一个活动事务，则抛出异常</li><li>PROPAGATION_NESTED：如果一个活动的事务存在，则运行在一个嵌套的事务中。如果没有活动事务，则按TransactionDefinition.PROPAGATION_REQUIRED属性执行</li></ul><h3 id="spring事务的隔离级别"><a class="markdownIt-Anchor" href="#spring事务的隔离级别"></a> Spring事务的隔离级别</h3><ul><li>ISOLATION_DEFAULT：这是一个PlatfromTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别，另外四个与JDBC的隔离级别相对应</li><li>ISOLATION_READ_UNCOMMITTED：这是事务最低的隔离级别，它允许另外一个事务可以看到这个事务未提交的数据，这种隔离级别会产生脏读，不可重复读和幻读</li><li>ISOLATION_READ_COMMITTED：保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据</li><li>ISOLATION_SERIALIZABLE：这是花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行,除了防止脏读，不可重复读外，还避免了幻像读</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;注解式事务&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#注解式事务&quot;&gt;&lt;/a&gt; 注解式事务&lt;/h2&gt;
&lt;h3 id=&quot;事务配置实例&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#事务配置实例&quot;&gt;&lt;/a&gt; 事
      
    
    </summary>
    
    
      <category term="Web" scheme="https://toyan.top/categories/Web/"/>
    
      <category term="Spring" scheme="https://toyan.top/categories/Web/Spring/"/>
    
    
      <category term="Spring" scheme="https://toyan.top/tags/Spring/"/>
    
      <category term="Spring事务" scheme="https://toyan.top/tags/Spring%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>分布式锁</title>
    <link href="https://toyan.top/distributed-lock/"/>
    <id>https://toyan.top/distributed-lock/</id>
    <published>2019-08-08T16:00:00.000Z</published>
    <updated>2020-02-08T11:40:07.987Z</updated>
    
    <content type="html"><![CDATA[<p>分布式锁，是用来控制分布式系统中互斥访问共享资源的一种手段，从而避免并行导致的结果不可控。</p><p>基本的实现原理和单进程锁是一致的，通过一个共享标识来确定唯一性，对共享标识进行修改时能够保证原子性和和对锁服务调用方的可见性。</p><p>为了确保分布式锁可用，至少要确保锁的实现同时满足以下四个条件：</p><ul><li><strong>互斥性</strong>：在任意时刻，只有一个客户端能持有锁</li><li><strong>不会发生死锁</strong>：即使有一个客户端在持有锁的期间奔溃而没有主动解锁，也能保证后续其他客户端能加锁</li><li><strong>具有容错性</strong>：只要大部分的Redis节点正常运行，客户端就可以加锁和解锁</li><li><strong>解铃还须系铃人</strong>：加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了</li></ul><h2 id="基于redis实现的锁服务"><a class="markdownIt-Anchor" href="#基于redis实现的锁服务"></a> 基于Redis实现的锁服务</h2><h3 id="加锁代码"><a class="markdownIt-Anchor" href="#加锁代码"></a> 加锁代码</h3><h4 id="正确姿势"><a class="markdownIt-Anchor" href="#正确姿势"></a> 正确姿势</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTool</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOCK_SUCCESS = <span class="string">"OK"</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_IF_NOT_EXIST = <span class="string">"NX"</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_WITH_EXPIRE_TIME = <span class="string">"PX"</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试获取分布式锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jedis Redis客户端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockKey 锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestId 请求标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expireTime 超期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否获取成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">tryGetDistributedLock</span><span class="params">(Jedis jedis, String lockKey, String requestId, <span class="keyword">int</span> expireTime)</span> </span>&#123;</span><br><span class="line">    String result = jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (LOCK_SUCCESS.equals(result)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们加锁就一行代码：<code>jedis.set(String key, String value, String nxxx, String expx, int time)</code>，这个set()方法一共有五个形参：</p><ul><li>第一个为key，我们使用key当锁，因为key是唯一的</li><li>第二个为value，我们传的是requestId，很多童鞋可能不明白，有key作为锁不就够了吗，为什么还要用到value？原因就是我们在上面讲到可靠性时，分布式锁要满足第四个条件<strong>解铃还须系铃人</strong>，通过给value赋值为requestId，我们就知道这把锁是哪个请求加的了。在解锁的时候就可以有依据。requestId可以使用<code>UUID.randomUUID().toString()</code>方法生成</li><li>第三个是nxxx，这个参数我们填的是NX，意思是SET IF NOT EXIST，即当key不存在时，我们进行set操作；若key已经存在，则不做任何操作</li><li>第四个是expx，这个参数我们传的是PX，意思是我们要给这个key加一个过期的设置，具体时间由第五个参数决定</li><li>第五个是time，与第四个参数相呼应，代表key的过期时间</li></ul><p>总的来说，执行上面的set()方法就只会导致两种结果：</p><ol><li>当前没有锁（key不存在），那么就进行加锁操作，并对锁设置个有效期，同时value表示加锁的客户端</li><li>已有锁存在，不做任何操作</li></ol><p>通过上述我们发现，加锁代码满足我们可靠性里描述的三个条件。<br />首先，set()加入了NX参数，可以保证如果已有key存在，则函数不会调用成功，也就是只有一个客户端能持有锁，满足互斥性；<br />其次，由于我们对锁设置了过期时间，即使锁的持有者后续发生崩溃而没有解锁，锁也会因为到了过期时间而自动解锁（即key被删除），不会发生死锁；<br />最后，因为我们将value赋值为requestId，代表加锁的客户端请求标识，那么在客户端在解锁的时候就可以进行校验是否是同一个客户端。</p><p>由于我们只考虑Redis单机部署的场景，所以容错性我们暂不考虑。</p><h4 id="错误示例1"><a class="markdownIt-Anchor" href="#错误示例1"></a> 错误示例1</h4><p>比较常见的错误示例就是使用<code>jedis.setnx()</code>和<code>jedis.expire()</code>组合实现加锁，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">wrongGetLock1</span><span class="params">(Jedis jedis, String lockKey, String requestId, <span class="keyword">int</span> expireTime)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  Long result = jedis.setnx(lockKey, requestId);</span><br><span class="line">  <span class="keyword">if</span> (result == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 若在这里程序突然崩溃，则无法设置过期时间，将发生死锁</span></span><br><span class="line">    jedis.expire(lockKey, expireTime);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>setnx()方法作用就是SET IF NOT EXIST，expire()方法就是给锁加一个过期时间。<em>然而这是两条Redis命令，不具有原子性</em>，如果程序执行完setnx()之后突然奔溃，导致锁没有设置超时时间，那么将会发生死锁。网上之所以有人这样实现，是因为低版本的jedis并不支持多参数的set()方法。</p><h4 id="错误示例2"><a class="markdownIt-Anchor" href="#错误示例2"></a> 错误示例2</h4><p>该种错误的实现思路如下：使用<code>jedis.setnx()</code>命令实现加锁，其中key是锁，value是锁的过期时间。执行过程如下：1. 通过setnx()方法实现加锁，如果当前锁不存在，返回加锁成功；2. 如果锁已经存在则获取锁的过期时间，和当前时间相比，如果锁已经过期，则设置新的过期时间，返回加锁成功。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">wrongGetLock2</span><span class="params">(Jedis jedis, String lockKey, String requestId, <span class="keyword">int</span> expireTime)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> expires = System.currentTimeMillis() + expireTime;</span><br><span class="line">  String expireStr = String.valueOf(expires);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 如果当前锁不存在，返回加锁成功</span></span><br><span class="line">  <span class="keyword">if</span> (jedis.setnx(lockKey, expiresStr()) == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 如果锁存在，获取锁的过期时间</span></span><br><span class="line">  String currentValueStr = jedis.get(lockKey);</span><br><span class="line">  <span class="keyword">if</span> (currentValueStr != <span class="keyword">null</span> &amp;&amp; Long.parseLong(currentValueStr) &lt; System.currentTimeMillis()) &#123;</span><br><span class="line">    <span class="comment">// 锁已过期，获取上一个锁的过期时间，并设置现在锁的过期时间</span></span><br><span class="line">    String oldValueStr = jedis.getSet(lockKey, expiresStr);</span><br><span class="line">    <span class="keyword">if</span> (oldValueStr != <span class="keyword">null</span> &amp;&amp; oldValueStr.equals(currentValueStr)) &#123;</span><br><span class="line">      <span class="comment">// 考虑多线程并发的情况，只有一个线程的设置值和当前值相同，它才有权利加锁</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 其他情况，一律返回加锁失败</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码问题如下：</p><ol><li>由于是客户端自己生成过期时间，所以需要强制要求分布式下每个客户端的时间必须同步</li><li>当锁过期的时候，如果多个客户端同时执行<code>jedis.getSet()</code>方法，那么虽然最终只要一个客户端可以加锁，但是这个客户端的锁的过期时间可能被其他客户端覆盖</li><li>锁不具备拥有者标识，即任何客户端都可以加锁</li></ol><h3 id="解锁代码"><a class="markdownIt-Anchor" href="#解锁代码"></a> 解锁代码</h3><h4 id="正确姿势-2"><a class="markdownIt-Anchor" href="#正确姿势-2"></a> 正确姿势</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTool</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Long RELEASE_SUCCESS = <span class="number">1L</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放分布式锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jedis Redis客户端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockKey 锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestId 请求标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否释放成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">releaseDistributedLock</span><span class="params">(Jedis jedis, String lockKey, String requestId)</span> </span>&#123;</span><br><span class="line">    String script =<span class="string">"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end"</span>;</span><br><span class="line">    Object result = jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(requestId));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (RELEASE_SUCCESS.equals(result)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们解锁只需要两行代码就搞定了！第一行代码，我们写了一个简单的Lua脚本代码;第二行代码，我们将Lua代码传到<code>jedis.eval()</code>方法里，并使参数KEYS[1]赋值为lockKey，ARGV[1]赋值为requestId。eval()方法是将Lua代码交给Redis服务端执行。</p><p>那么这段Lua代码的功能是什么呢？其实很简单，首先获取锁对应的value值，检查是否与requestId相等，如果相等则删除锁（解锁）。那么为什么要使用Lua语言来实现呢？因为要确保上述操作是原子性的 。那么为什么执行eval()方法可以确保原子性，源于Redis的特性，下面是官网对eval命令的部分解释：</p><p><strong>简单来说，就是在eval命令执行Lua代码的时候，Lua代码将被当成一个命令去执行，并且直到eval命令执行完成，Redis才会执行其他命令。</strong></p><h4 id="错误示例1-2"><a class="markdownIt-Anchor" href="#错误示例1-2"></a> 错误示例1</h4><p>最常见的解锁代码就是直接使用<code>jedis.del()</code>方法删除锁，这种不先判断锁的拥有者而直接删除锁的方式，会导致任何客户端都可以随时进行解锁，即使这把锁不是它的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">wrongReleaseLock1</span><span class="params">(Jedis jedis, String lockKey)</span> </span>&#123;</span><br><span class="line">    jedis.del(lockKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="错误示例2-2"><a class="markdownIt-Anchor" href="#错误示例2-2"></a> 错误示例2</h4><p>这种解锁代码与之前的差不多，唯一区别的是分成两条命令去执行，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">wrongReleaseLock2</span><span class="params">(Jedis jedis, String lockKey, String requestId)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 判断解锁与加锁是不是同一个客户端</span></span><br><span class="line">  <span class="keyword">if</span> (requestId.equals(jedis.get(lockKey))) &#123;</span><br><span class="line">    <span class="comment">// 若在此时，这把锁突然不是这个客户端的，则会误解锁</span></span><br><span class="line">    jedis.del(lockKey);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如代码注释，问题在于如果调用<code>jedis.del()</code>方法的时候，这把锁已经不属于当前客户端的时候会解除他人加的锁。那么是否真的有这种场景？答案是肯定的，比如客户端A加锁，一段时间之后客户端A解锁，在执行<code>jedis.del()</code>之前，锁突然过期了，此时客户端B尝试加锁成功，然后客户端A再执行del()方法，则将客户端B的锁给解除了。</p><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>通过过期时间来避免死锁，过期时间设置多长对业务来说往往比较头疼，时间短了可能会造成：持有锁的线程A任务还未处理完成，锁过期了，线程B获得了锁，导致同一个资源被A、B两个线程并发访问；时间长了会造成：持有锁的进程宕机，造成其他等待获取锁的进程长时间的无效等待。</p><p>Redis的主从异步复制机制可能丢失数据，会出现如下场景：A线程获得了锁，但锁数据还未同步到slave上，master挂了，slave顶成主，线程B尝试加锁，仍然能够成功，造成A、B两个线程并发访问同一个资源。</p><h2 id="基于zookeeper实现的锁机制"><a class="markdownIt-Anchor" href="#基于zookeeper实现的锁机制"></a> 基于ZooKeeper实现的锁机制</h2><h3 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h3><p>在单进程应用中，我们经常使用锁来保障多个线程并发访问同一资源的互斥性。在多进程、分布式环境下，如果多个系统或者单个系统的多个节点并发访问同一资源，为了保障对资源读写的互斥性，就需要用到分布式锁。</p><h3 id="为什么用zookeeper来实现分布式锁"><a class="markdownIt-Anchor" href="#为什么用zookeeper来实现分布式锁"></a> 为什么用Zookeeper来实现分布式锁</h3><p>Zookeeper能够保障分布式场景下数据的一致性、有序性、原子性及可靠性，它的所有写入操作会在Leader节点持久化，并在集群过半节点写入成功才会返回；它也能够支持节点的奔溃恢复以及客户端的最终一致性视图。对于分布式锁场景来说，数据一致性的保障、以及锁服务的容灾保障至关重要。</p><p>另外，Zookeeper还提供了三种在分布式锁场景下非常有用的特征（以下的节点指的是Zookeeper内部存储的znode节点）：</p><ul><li><p>临时节点<br />客户端可以指定zk创建一个临时节点，此节点将在这个客户端与服务端建立的session到期时自动删除，这个特性可以保障客户端创建的分布式锁节点宕机或者网络通讯中断一段时间后自动释放该临时节点，从而避免分布式锁由于客户端或网络原因导致的死锁问题</p></li><li><p>有序节点<br />客户端可以指定zk创建一个有序节点，此节点将自动在客户端指定的节点名后面添加一个单调递增序号来确保多个客户端同时创建相同的节点名时能够创建成功，并且保障越早创建的节点的序号越小。利用该特性可以实现锁的互斥性和公平性，即同一时刻只有一个客户端能够成功获取到锁（序号最小的一个获取到锁），获取锁失败的节点可以按照</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;分布式锁，是用来控制分布式系统中互斥访问共享资源的一种手段，从而避免并行导致的结果不可控。&lt;/p&gt;
&lt;p&gt;基本的实现原理和单进程锁是一致的，通过一个共享标识来确定唯一性，对共享标识进行修改时能够保证原子性和和对锁服务调用方的可见性。&lt;/p&gt;
&lt;p&gt;为了确保分布式锁可用，至少
      
    
    </summary>
    
    
      <category term="Java" scheme="https://toyan.top/categories/Java/"/>
    
      <category term="锁" scheme="https://toyan.top/categories/Java/%E9%94%81/"/>
    
    
      <category term="lock" scheme="https://toyan.top/tags/lock/"/>
    
  </entry>
  
  <entry>
    <title>SQL</title>
    <link href="https://toyan.top/sql-summary/"/>
    <id>https://toyan.top/sql-summary/</id>
    <published>2018-10-13T16:00:00.000Z</published>
    <updated>2020-02-07T08:02:51.944Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础"><a class="markdownIt-Anchor" href="#基础"></a> 基础</h2><ol><li>DML语句：主要由insert、update和delete三个关键字组成</li><li>DDL语句：主要由create、alter、drop和truncate四个关键字组成</li></ol><h2 id="ddl语句"><a class="markdownIt-Anchor" href="#ddl语句"></a> DDL语句</h2><ol><li>增加列、修改列、删除列：add、modify、drop</li><li>删除表：drop table 表名;</li><li>truncate表：删除该表里的全部数据，但保留表结构；只能一次性删除整个表的全部记录；比delete删除速度要快</li><li>建立索引：create index 索引名 on 表名<br />索引的缺陷：<ul><li>当数据表中的记录被添加、删除、修改时，数据库系统需要维护索引，因此有一定的系统开销</li><li>存储索引需要一定的磁盘空间</li></ul></li><li>distinct去除重复记录</li></ol><h2 id="dml语句"><a class="markdownIt-Anchor" href="#dml语句"></a> DML语句</h2><ol><li>mysql使用concat进行字符串连接</li><li>SQL语句中的通配符：下划线代表一个任意的字符，百分号代表任意多个字符</li><li>数据库函数<ul><li>ifnull(expr1, expr2)，如果expr1为null，则返回expr2，否则返回expr1</li><li>nullif(expr1, expr2)，如果expr1和expr2相等，则返回null，否则返回expr2</li><li>if(expr1, expr2, expr3)，如果expr1为true，不等于0，且不等于null，则返回expr2，否则返回expr3</li><li>isnull(expr1)，判断expr1是否为null</li></ul></li><li>分组与组函数：avg、count、max、min和sum<ul><li>having子句：不能在where子句中过滤组，where子句仅用于过滤行。过滤组必须使用having子句；不能在where子句中使用组函数，having子句才可以使用组函数</li></ul></li><li>多表连接查询： 查询用的多个数据表显式使用xxx join连接，而不是直接依次排列在from之后，from之后只需要放一个数据表；连接条件不再放在where之后，而是提供了专门的连接条件子句<ul><li>on子句连接，每个on子句只指定一个连接条件</li><li>左、右、全外连接：left join、right join、full join<br />SQL99与SQL92的外连接恰好相反，SQL99左外连接将会把左边表中所有不满足连接条件的记录全部列出；SQL99右外连接将会把所有右边表不满足连接条件的记录全部列出；全外连接将会把两个表中所有不满足条件的记录全部列出（Mysql并不是全外连接）</li></ul></li><li>集合运算：将select返回的两个结果集做运算，intersect（交，不支持，使用多表连查来替代）、union（并）、minus（差，不支持，使用子查询来替代）<br />注意：<ul><li>两个结果集所包含的数据列的数量必须相同</li><li>两个结果集所包含的数据列的数据类型也必须一一对应</li></ul></li></ol><h2 id="sql-select语句的完整执行顺序"><a class="markdownIt-Anchor" href="#sql-select语句的完整执行顺序"></a> SQL select语句的完整执行顺序</h2><ul><li>from子句组装来自不同数据流的数据</li><li>where子句基于指定的条件对记录行进行筛选</li><li>group by子句将数据划分为多个分组</li><li>使用聚集函数进行计算</li><li>使用having子句筛选分组</li><li>计算所有的表达式</li><li>select的字段</li><li>使用order by对结果集进行排序</li></ul><p>SQL语言不同于其他编程语言最明显特征就是处理代码的顺序。在大多数据库语言中，代码按编码顺序被处理。但在SQL语言中，第一个被处理的子句是FROM，而不是SELECT，SQL查询处理的步骤编号如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(8)<span class="keyword">SELECT</span> (<span class="number">9</span>) <span class="keyword">DISTINCT</span> (<span class="number">11</span>) &lt;TOP_specification&gt; &lt;select_list&gt;</span><br><span class="line">(<span class="number">1</span>) <span class="keyword">FROM</span> &lt;left_table&gt;</span><br><span class="line">(<span class="number">3</span>) &lt;join_type&gt; <span class="keyword">JOIN</span> &lt;right_table&gt;</span><br><span class="line">(<span class="number">2</span>) <span class="keyword">ON</span> &lt;join_condition&gt;</span><br><span class="line">(<span class="number">4</span>) <span class="keyword">WHERE</span> &lt;where_condition&gt;</span><br><span class="line">(<span class="number">5</span>) <span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;group_by_list&gt;</span><br><span class="line">(<span class="number">6</span>) <span class="keyword">WITH</span> &#123;<span class="keyword">CUBE</span> | <span class="keyword">ROLLUP</span>&#125;</span><br><span class="line">(<span class="number">7</span>) <span class="keyword">HAVING</span> &lt;having_condition&gt;</span><br><span class="line">(<span class="number">8</span>) <span class="keyword">ORDER</span> <span class="keyword">BY</span> &lt;order_by_list&gt;</span><br></pre></td></tr></table></figure><p>以上每个步骤都会产生一个虚拟表，该虚拟表被用作下一个步骤的输入。这些虚拟表对调用者（客户端应用程序或者外部查询）不可用。只有最后一步生成的表才会给调用者。如果没有在查询中指定某一个子句，将跳过相应的步骤。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基础&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#基础&quot;&gt;&lt;/a&gt; 基础&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;DML语句：主要由insert、update和delete三个关键字组成&lt;/li&gt;
&lt;li&gt;DDL语句：主要由create、alte
      
    
    </summary>
    
    
      <category term="基础知识总结" scheme="https://toyan.top/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
      <category term="SQL" scheme="https://toyan.top/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/SQL/"/>
    
    
      <category term="SQL" scheme="https://toyan.top/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>JVM虚拟机总结</title>
    <link href="https://toyan.top/JVM-summary/"/>
    <id>https://toyan.top/JVM-summary/</id>
    <published>2018-10-06T16:00:00.000Z</published>
    <updated>2020-02-07T08:21:08.073Z</updated>
    
    <content type="html"><![CDATA[<h2 id="jvm垃圾处理方法"><a class="markdownIt-Anchor" href="#jvm垃圾处理方法"></a> JVM垃圾处理方法</h2><ul><li><p>标记-清除算法</p><ul><li>标记阶段：先通过根节点，标记所有从根节点开始的对象，未被标记的为垃圾对象</li><li>清除阶段：将所有未标记的对象清除</li></ul></li><li><p>标记-整理算法</p><ul><li>标记阶段：先通过根节点，标记所有从根节点开始的可达对象，未被标记的为垃圾对象</li><li>整理阶段：将所有的存活对象压缩到一段连续的内存空间，之后清理边界的所有空间</li></ul></li><li><p>复制算法</p><ul><li>将所有的内存空间分成两块，每次只使用一块，在垃圾回收时，将正在使用的内存中的存活对象复制到未使用的内存块中，然后清除正在使用的内存块中的所有对象</li></ul></li></ul><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%89%E7%A7%8D%E7%AE%97%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83.png" alt="JVM虚拟机三种算法的比较" /></p><h2 id="gc"><a class="markdownIt-Anchor" href="#gc"></a> GC</h2><ol><li><p>新生代、老年代、持久代</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/%E6%96%B0%E7%94%9F%E4%BB%A3%E3%80%81%E8%80%81%E5%B9%B4%E4%BB%A3%E3%80%81%E6%8C%81%E4%B9%85%E4%BB%A3.png" alt="" /></p></li><li><p>GC用的可达性分析算法中，可作为GC Roots对象</p><ul><li>Java虚拟机栈中的对象</li><li>方法区中的静态成员</li><li>方法区中的常量引用对象</li><li>本地方法区中的JNI(Native方法)引用对象</li></ul></li><li><p>新生代转移到老年代的触发条件</p><ul><li>长期存活的对象</li><li>大对象直接进入老年代</li><li>Minor GC后，survivor仍然放不下</li><li>动态年龄判断，大于等于某个年龄的对象超过了survivor空间的一半，大于等于这个年龄的对象直接进入老年代</li></ul></li><li><p>MinGC、FullGC</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/MinGC%E3%80%81FullGC.png" alt="" /></p></li><li><p>各个垃圾回收器的工作方式</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/Serial%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="Serial收集器" /></p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/ParNew%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="ParNew收集器" /></p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/Parallel%20Scavenge%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="Parallel+Scavenge收集器" /></p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/CMS%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="CMS收集器" /></p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/G1%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="G1收集器" /></p><p>还有两个老年代收集器：Serial old和Parallel old收集器</p></li></ol><h2 id="java虚拟机内存的划分以及每个区域的功能"><a class="markdownIt-Anchor" href="#java虚拟机内存的划分以及每个区域的功能"></a> Java虚拟机内存的划分以及每个区域的功能</h2><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/Java%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F.png" alt="Java运行时数据区域" /></p><ol><li><p>程序计数器（线程私有）</p><ul><li>线程创建时创建，执行本地方法时其值为undefined</li></ul></li><li><p>虚拟机栈（线程私有）</p><ul><li>（栈内存）为虚拟机执行Java方法服务，方法被调用时创建栈帧–&gt;局部变量表（基本数据类型，对象引用类型）–&gt;局部变量，对象引用</li><li>如果线程请求的栈深度超过了虚拟机所允许的深度，就会出现<code>StackOverfFow</code></li><li>虚拟机栈可以动态扩展，如果扩展到无法申请足够的内存时，会出现<code>OutOfMemeory</code></li></ul></li><li><p>本地方法栈（线程私有）</p><ul><li>Java虚拟机栈是为Java方法服务，而本地方法栈视为虚拟机使用到的Native方法服务</li><li>Java虚拟机没有对本地方法的使用和数据结构做强制规定。Sun HotSpot把Java虚拟机栈和本地方法栈合二为一</li><li>同样抛出<code>StackOverfFlowError</code>和<code>OutOfMemeoryError</code></li></ul></li><li><p>Java堆</p><ul><li>被所有线程所共享，在Java虚拟机启动时创建，几乎所有的对象实例都存放在这里</li><li>GC管理的主要区域</li><li>物理不连续，逻辑上连续，可以动态扩展，扩展失败抛出<code>OutOfMemeoryError</code></li></ul></li><li><p>方法区</p><ul><li>用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码的数据</li><li>Sun HotSpot虚拟机把方法区称为<code>永久代</code></li></ul></li><li><p>运行时常量池</p><ul><li>受到方法区的限制，可能抛出<code>OutOfMemeoryError</code></li></ul></li></ol><h2 id="双亲委派机制"><a class="markdownIt-Anchor" href="#双亲委派机制"></a> 双亲委派机制</h2><p><img src="https://user-gold-cdn.xitu.io/2017/5/8/74d4b5eadd9880c6ede99faefae88d24?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="类加载器双亲委派模型" /></p><p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而且把这个请求委派给父类加载器去完成，每一个层次的加载器都如此，因此所有的类加载器都会交给顶层的启动类加载器。只有当父类加载器无法完成该加载请求时（该加载器的搜索范围内没有找到对应的类）时，子加载器才会尝试直接去加载。</p><h2 id="student-s-new-student在内存中做的事情"><a class="markdownIt-Anchor" href="#student-s-new-student在内存中做的事情"></a> Student s = new Student()在内存中做的事情</h2><ol><li>加载Student class文件到内存</li><li>在栈内存为s开辟空间（对象引用类型）</li><li>在堆内存为学生对象开辟空间（对象实例）</li><li>对学生对象的成员变量进行默认初始化</li><li>对学生对象的成员变量进行显式初始化</li><li>通过构造方法给学生对象的成员变量进行赋值</li><li>学生对象初始化完成， 把对象地址赋值给s变量</li></ol><h2 id="java的gc为什么要分代"><a class="markdownIt-Anchor" href="#java的gc为什么要分代"></a> Java的GC为什么要分代</h2><p>分代的垃圾回收策略，是基于这样一个事实：**不同的对象的生命周期是不一样的。**因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。</p><blockquote><p>试想，在不进行对象存活时间区分的情况下，每次垃圾回收都是对整个堆空间进行回收，花费时间相对会长，同时，因为每次回收都需要遍历所有存活对象，但实际上，对于生命周期长的对象而言，这种遍历是没有效果的，因为可能进行了很多次遍历，但是他们依旧存在。因此，分代垃圾回收采用分治的思想，进行代的划分，把不同生命周期的对象放在不同代上，不同代上采用最适合它的垃圾回收方式进行回收。</p></blockquote><h3 id="如何分代"><a class="markdownIt-Anchor" href="#如何分代"></a> 如何分代</h3><p>虚拟机中共分为三代：年轻代、老年代和持久代。其中持久代主要存放的是Java类的类信息，与垃圾收集要收集的Java对象关系不大。年轻代和老年代是对垃圾收集影响比较大的。</p><ol><li><p>年轻代<br />所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。年轻代分为三个区。一个Eden区，两个Survivor区（一般而言）。大部分对象在Eden区中生成。当Eden区满时，还存活的对象将被复制到Survivor区（两个中的一个），当这个Survivor区也满了的时候，从第一个Survivor区复制过来的并且此时还存活的对象，将被复制到另一个Survivor区，当这个Survivor区也满了的时候，从第一个Survivor区复制过来的并且此时还存活的对象，将被复制到“老年区”。需要注意的是，Survivor的两个区是对称的，没先后顺序，所以同一个区中可能存在从Eden复制过来的对象，和从前一个Survivor复制过来的对象，而复制到老年区的只有从第一个Survivor区过去的对象。而且，Survivor区总有一个是空的。同时，根据程序需要，Survivor区是可以配置为多个的（多于两个），这样可以增加对象在年轻代中的存在时间，减少被放到老年代的可能。</p></li><li><p>老年代<br />在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到老年代。因此，可以认为老年代中存放的都是一些生命周期较长的对象。</p></li><li><p>持久代<br />用于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如hibernate等，在这种时候需要设置一个比较大的持久代空间来存放这些运动过程中新增的类。</p></li></ol><h2 id="minor-gc-full-gc触发条件是什么"><a class="markdownIt-Anchor" href="#minor-gc-full-gc触发条件是什么"></a> Minor GC、Full GC触发条件是什么？</h2><ul><li>从年轻代空间（包括Eden、Survivor区域）回收内存被称为Minor GC</li><li>对老年代GC称为Major GC</li><li>而Full GC是对整个堆来说</li></ul><p>在最近几个版本的JDK里默认包括了对永生代即方法区的回收（JDK8中无永生代了），出现Full GC的时候经常伴随至少一次的Minor GC,但非绝对的。</p><p>Major GC的速度一般会比Minor GC慢10倍以上。下边看看有那种情况触发JVM进行Full GC及应对策略。</p><ol><li><p>Minor GC触发条件：<br />当Eden区满时，触发Minor GC。</p></li><li><p>Full GC触发条件：</p><ul><li><p>System.gc()方法的调用</p><blockquote><p>此方法的调用是建议JVM进行Full GC，虽然只是建议而非一定，但很多情况下它会触发Full GC，从而增加Full GC的频率，也即增加了间歇性停顿的次数。虽然影响系统建议不能使用这个方法，让虚拟机自己去管理它的内存。</p></blockquote></li><li><p>老年代空间不足</p><blockquote><p>老年代空间只有在新生代对象转入及创建大对象、大数组时才会出现不足的现象，当执行Full GC后空间仍然不足，则抛出如下错误：<code>java.lang.OutOfMemoryError: Java heap space</code>，为避免以上两种情况引起的Full GC，调优时应尽量做到让对象在Minor GC阶段被回收、让对象在新生代多存活一段时间及不要创建过大的对象及数组。</p></blockquote></li><li><p>方法区空间不足</p><blockquote><p>JVM规范中运行时数据区域中的方法区，在HotSpot虚拟机中又被习惯称为永生代或者永生区，Permanet Generation中存放的为一些class的信息、常量、静态变量等数据，当系统中要加载的类、反射的类和调用的方法较多时，Permanet Generation可能会被占满，在未配置为采用CMS GC的情况下也会执行Full GC。如果经过Full GC仍然回收不了，那么JVM会抛出如下错误信息：<code>java.lang.OutOfMemoryError: PermGen space</code>。为避免Perm Gen占满造成Full GC现象，可采用的方法为增大Perm Gen空间或转为使用CMS GC。</p></blockquote></li><li><p>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</p><blockquote><p>如果发现统计数据说之前Minor GC的平均晋升大小比目前old gen剩余的空间大，则不会触发Minor GC而是转为触发full GC</p></blockquote></li><li><p>由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</p></li></ul></li></ol><h2 id="g1-gc"><a class="markdownIt-Anchor" href="#g1-gc"></a> G1 GC</h2><p>G1 GC是目前为止最为复杂、也是最先进的GC，在CMS算法中，GC管理的内存被划分为新生代、老年代和永久代/元空间。这些空间必须是地址连续的。在G1算法中，采用了另外一种完全不同的方式组织堆内存，堆内存被划分为多个大小相等的内存块（Region），每个Region是逻辑连续的一段内存，Region的大小可以通过<code>-XX:G1HeapRegionSize</code>参数指定，如果没有配置，默认堆内存按照2048份均分，最后得到一个合理的大小。在G1中，还有一个特殊的区域，叫Humongous 区域。</p><p>如果一个对象占用的空间超过了分区容量50%以上，G1收集器就认为这是一个巨型对象。这些巨型对象，默认直接会被分配在老年代，但是如果它是一个短期存在的巨型对象，就会对垃圾回收器造成负面影响。为了解决这个问题，G1划分了一个Humongous 区域，它用来专门存放巨型对象，下面的图片展示了G1的内存结构：<br /><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/7853175-8c5cbf9a129c4d54.png" alt="" /></p><h3 id="g1-gc内存结构"><a class="markdownIt-Anchor" href="#g1-gc内存结构"></a> G1 GC内存结构</h3><p>G1 GC的运行可以分为下面几个阶段：</p><ol><li><p>**初始标记：**扫描根集合，标记所有从根节点可直接到达的对象并将它们的字段压入扫描栈。在分代式G1模式中，初始标记阶段借用 Young GC 的暂停，因而没有额外的、单独的暂停阶段。</p></li><li><p>**并发标记：**这个阶段可以并发执行，GC线程不断从扫描栈取出引用，进行递归标记，直到扫描栈清空。</p></li><li><p>**最终标记：**重新标记写入屏障标记的对象，这个阶段也进行弱引用处理。</p></li><li><p>**筛选回收：**统计每个Region被标记位活的对象有多少，如果发现完全没有活对象的Region就会将其整体回收到可分配 Region 列表中。</p></li></ol><p>与其他GC相比，G1 GC有如下特点：</p><ol><li><p>**并行与并发：**G1 GC能充分利用CPU、多核心等硬件优势，使用多个CPU或者CPU核心来缩短STW的时间，部分其他GC需要停顿java线程执行的GC操作，在G1 GC中仍然可以通过并发的方式让java程序继续执行</p></li><li><p>**分代收集：**和其他GC一样，分代的概念在G1 GC中仍然保留</p></li><li><p>**空间整合：**与CMS的标记-清理算法不同，G1 GC从整体来看是通过”标记-整理“算法实现的GC，从局部（两个Region之间）来看是通过”复制“算法来实现的，无论如何，这两种算法在运行期间都不会产生内存碎片，GC 活动之后可以提供规整的内存空间。</p></li><li><p>**可预测的停顿：**这是G1 GC相对于CMS的另一大优势，降低停顿时间是G1 GC和CMS GC共同关注的，但是G1 GC除了追求低停顿时间外，还建立了可预测的停顿时间模型，能让使用这明确指定在一个长度为M的时间片内，消耗在垃圾收集上的事件不得超过N毫秒。</p></li></ol><p>下面的图片展示了多个GC以及他们工作的分代位置，以及如何组合使用：<br /><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/7853175-35e974e2a2f37f82.png" alt="" /></p><h3 id="jvm-gc的触发条件"><a class="markdownIt-Anchor" href="#jvm-gc的触发条件"></a> JVM GC的触发条件</h3><ol><li><p>**Young GC：**当Young generation中的Eden区分配满的时候触发。</p></li><li><p><strong>Full GC：</strong></p></li></ol><ul><li>当准备要触发一次young GC时，如果发现统计数据Young GC的平均大小比目前Old Gen剩余的空间大，则不会触发Young GC而是转为触发Full GC。</li><li>如果有Perm Gen的话，要在Perm Gen分配空间但已经没有足够空间时，也要触发一次Full GC</li><li>调用System.gc()默认也是触发Full GC</li></ul><h3 id="jvm性能监控与故障处理工具"><a class="markdownIt-Anchor" href="#jvm性能监控与故障处理工具"></a> JVM性能监控与故障处理工具</h3><ul><li><p>jps：JVM进程状况工具<br />选项：<br />-m 输出JVM进程启动时传递给主类main方法的参数<br />-l 输出主类的全名，如果进程执行的是jar包，输出jar包的路径<br />-v 输出进程启动时的JVM参数</p></li><li><p>jstat：JVM统计信息监控工具<br />该工具具有丰富的JVM统计功能，具体支持的统计可以使用man jstat来输出帮助文档</p></li><li><p>jinfo：java配置信息工具<br />jinfo用于获取当前JVM的配置信息</p></li><li><p>jmap：java内存映射工具<br />jmap用于生成堆的转储快照，下面为一个使用示例，用于将当前的JVM的堆的快照输出到文件中去</p></li><li><p>jhat：等jhat执行完毕后，就可以打开浏览器查看堆的情况的</p></li><li><p>jstack：JVM堆栈追踪工具<br />jstack用于生成当前堆栈的线程快照，这个命令会将所有在堆上的线程都输出，包括线程的运行状态，持有资源的状态等等，对于java应用调优，jstack是非常有用的。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;jvm垃圾处理方法&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#jvm垃圾处理方法&quot;&gt;&lt;/a&gt; JVM垃圾处理方法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;标记-清除算法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;标记阶段：先通过根节点，标记所有从根节点
      
    
    </summary>
    
    
      <category term="基础知识总结" scheme="https://toyan.top/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
      <category term="JVM" scheme="https://toyan.top/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/JVM/"/>
    
    
      <category term="Java" scheme="https://toyan.top/tags/Java/"/>
    
      <category term="JVM" scheme="https://toyan.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络总结</title>
    <link href="https://toyan.top/network-summary/"/>
    <id>https://toyan.top/network-summary/</id>
    <published>2018-10-06T16:00:00.000Z</published>
    <updated>2020-02-07T08:49:47.219Z</updated>
    
    <content type="html"><![CDATA[<h2 id="tcp报头格式"><a class="markdownIt-Anchor" href="#tcp报头格式"></a> TCP报头格式</h2><p>定义：TCP传输控制协议是一种面向连接的、可靠的、基于字节流的传输层协议。<br /><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/20140609125220296.png" alt="图一.TCP报文格式" /></p><p>图一是TCP报文格式，下面是对各参数的解释</p><ul><li>源端口号和目的端口号：TCP报头中的源端口号和目的端口号同IP数据报中的源IP与目的IP唯一确定一条TCP连接</li><li>序号：用来标识TCP发端向TCP收端发送的数据字节流</li><li>确认序号：ACK标志位为1时确认序号才有效（即不为0）；一旦连接建立，该值将始终发送</li><li>首部长度：报文头长度(单位：bit)/32<br />例子：1000（转化为十进制为8，8 * 32/8 = 32，该报文报头长度为32个字节）<br />存在该字段是因为TCP报头中任选字段长度可变<br />报头不包含任何任选字段则长度是20字节；4位所能表示的最大值为1111，转换为十进制是15，15*32/8 = 60，故报头最大长度是60字节</li><li>保留：占6位，保留为今后使用，目前应置为0</li><li>控制位：6位<ul><li>URG：紧急指针有效性标志</li><li>ACK：确认序号有效性标志，一旦一个连接建立起来，该标志位总被置为1，即除了请求建立连接报文（仅设置SYN标志位为1），其他所有报文的该标志位总为1</li><li>PSH（PuSH）：推送标志位，接收方应尽快将报文段提交至应用层，而不再等到整个缓存都填满了后再向上交付</li><li>RST（ReSeT）：重置连接标志位，当RST=1时，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立运输连接</li><li>SYN：同步序号标志</li><li>FIN：传输数据结束标志</li></ul></li><li>窗口大小（2字节）：TCP流量控制通过连接的每一个端声明窗口大小进行控制（接受缓冲区大小）<br />由于2字节能够表示的最大正整数为65535，故窗口最大值为65535</li><li>检验和（2字节）：检验和覆盖整个TCP报文段；强制字段，有发送端计算存储，有接收端进行验证</li><li>紧急指针（2字节）：当URG=1时，紧急指针才有效</li><li>选项（0-40字节）：当没有使用“选项”时，TCP的首部长度是20字节</li></ul><h2 id="tcp的三次握手与四次挥手"><a class="markdownIt-Anchor" href="#tcp的三次握手与四次挥手"></a> TCP的三次握手与四次挥手</h2><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/20170104214009596.png" alt="" /></p><ol><li><p>三次握手：<br />**第一次握手：**主机A发送位码为SYN=1，随机产生seq number=10001的数据包到服务器，主机B由SYN=1知道A要求建立联机，此时状态为SYN_SENT；</p><p>**第二次握手：**主机B收到请求后要确认联机信息，向A发送ack number=（主机A的seq+1），SYN=1，ACK=1，随机产生seq number=20001的包，此时状态有LISTEN变为SYN_RECV；</p><p>**第三次握手：**主机A收到后检查ack number是否正确，即第一次发送的seq number + 1，以及位码ack是否为1，若正确，主机A会再次发送ack number = （主机B的seq+1），ACK=1，主机B收到后确认seq值与ack=1则连接建立成功，双方状态established</p><p>完成三次握手，主机A与主机B开始传送数据。</p><p><strong>各个状态名称与含义</strong></p><ul><li>CLOSED：表示初始状态</li><li>LISTEN：表示服务器端的某个socket处于监听状态，可以接受连接了</li><li>SYN_RECV：这个状态表示接受到了SYN报文，在正常情况下，这个状态是服务端的socket在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂，基本上用netstat你是很难看到这个状态的。这种状态时，当收到客户端的ACK报文后，它会进入到established</li><li>SYN_SENT：这个状态与SYN_RECV遥相呼应，当客户端socket执行connect连接时，它首先发送SYN报文，因此也随机它会进入到了SYN_SENT状态，并等到服务端的发送三次握手中的第2个报文。SYN_SENT状态表示客户端已发送SYN报文</li><li>ESTABLISHED：表示连接已经建立了。</li></ul></li><li><p>四次挥手：<br /><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/1641067-5ed8bf6c24244b4c.png" alt="" /></p><p>假设Client端发起中断请求，也就是发送FIN报文。Server端接到FIN报文后，意思是说“我client端要发给你了”，但是如果你还没有数据要发送完成，则不必急着关闭Socket，可以继续发送数据。所以你先发送ACK，“告诉Client端，你的请求我收到了，但是我还没准备好，请继续你等我的消息”。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。当Server端确定数据已发送完成，则向Client端发送FIN报文，“告诉Client端，好了，我这边数据发完了，准备好关闭连接了”。Client端收到FIN报文后，“就知道可以关闭连接了，但是它还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。”，Server端收到ACK后，“就知道可以断开连接了”。Client端等待2MSL（报文最大生存时间）后仍然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。这样，TCP连接就这样关闭了。</p><p><strong>各个状态名称与含义：</strong></p><ul><li>FIN_WAIT_1：其实FIN_WAIT_1与FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。这两种状态的区别是：FIN_WAIT_1状态实际上是当Socket在established状态时，它想主动关闭连接，向对方发送FIN报文，此时该socket即进入FIN_WAIT_1状态。而当对方回应ACK报文后，则进入FIN_WAIT_2状态。当然在实际的正常情况下，无论对方何种情况下，都应该马上回应ACK报文，所以FIN_WAIT_1状态比较难见，而FIN_WAIT_2状态可以用netstat看到。</li><li>FIN_WAIT_2：实际上该状态下的socket，表示半连接，也即有一方要求close连接，但另外还告诉对方，我暂时还有些数据要传，稍后再关闭连接。</li><li>TIME_WAIT：表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL后即可回到CLOSED可用状态了。如果FIN_WAIT_1状态下，收到了对方同时带FIN标志和ACK标志的报文时，则可直接进入TIME_WAIT状态，而无需经过FIN_WAIT_2状态。</li></ul></li></ol><p><strong>下面两个问题记牢</strong></p><p><strong>为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？</strong><br />*第一种回答：*这是因为服务端的listen状态下的socket当收到SYN报文的连接请求时后，它可以把ACK和SYN（ACK起到应答作用，而SYN起同步作用）放在一个报文里来发送。但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了，但未必你所有的数据都全部发送给对方了，所以你可以未必会关闭socket连接，也即你可能还需要发送一些数据给对方之后，在发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。</p><p>*第二种回答：*因为当Server端收到Client端的SYN连接请求后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭Socket，所以只能先回复一个ACK报文，告诉client端，“你发送的FIN报文我收到了”。只有等到Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送，故需要四次挥手。</p><p><strong>为什么TIME_WAIT状态还需要等待2MSL后才能返回到CLOSED状态？</strong><br />答：因为虽然双方都同意关闭连接了，而且握手的4个报文也都发送完毕，按理可以直接回到CLOSED状态（就好比从SYN_SENT状态到ESTABLISH状态那样），但是我们必须假想网络是不可靠的，有可能最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。</p><h2 id="udp报头格式"><a class="markdownIt-Anchor" href="#udp报头格式"></a> UDP报头格式</h2><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/20150819162030063.png" alt="" /></p><p>源端口号：在需要对方回信时选用。不需要是可全为0<br />目的端口号：这在终点交付报文时必须要使用到<br />UDP长度：UDP报文的字节长度（包括首部和数据）<br />UDP校验和：检验UDP首部和数据部分的正确性</p><h2 id="tcpudp区别"><a class="markdownIt-Anchor" href="#tcpudp区别"></a> TCP/UDP区别</h2><p><em>课本：</em><br />UDP在传输数据之前<strong>不需要先建立连接</strong>。远程主机的运输层在收到UDP报文后，不需要给出任何确认。虽然UDP不提供可靠交付，但在某些情况下UDP却是一种最有效的工作方式。</p><p>TCP则<strong>提供面向连接的服务</strong>。在传送数据之前必须先建立连接，数据传送结束后要释放连接。TCP不提供广播或多播服务。由于TCP要提供可靠地、面向连接的运输服务，因此不可避免地增加了许多的开销，如确认、流量控制、计时器以及连接管理等。这不仅使协议数据单元的首部增大很大，还要占用许多的处理机资源。</p><p><em>博客答案：</em></p><table><thead><tr><th></th><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>是否连接</td><td>面向连接</td><td>面向非连接</td></tr><tr><td>传输可靠性</td><td>可靠的</td><td>不可靠的</td></tr><tr><td>应用场合</td><td>传输大量的数据</td><td>少量数据</td></tr><tr><td>速度</td><td>慢</td><td>块</td></tr></tbody></table><p>OSI和TCP/IP模型在传输层定义两种传输协议：TCP（传输控制协议）和UDP（用户数据报协议）。</p><p><strong>UDP</strong><br />UDP和TCP的主要区别在于UDP不一定提供可靠的数据传输。事实上，该协议不能保证数据准确无误地到达目的地。UDP在很多方面非常有效。当某个程序的目标是尽快地传输尽可能多的信息时（其中任意给定的重要性相对较低），可使用UDP。许多程序将使用单独的TCP连接和单独的UDP连接。重要的状态信息随可靠的TCP连接发送，而主数据留通过UDP发送。</p><p><strong>TCP</strong><br />TCP的目的是提供可靠的数据传输，并在相互进行通信的设备或服务之间保持一个虚拟连接。TCP在数据包接收无序、丢失或在交付期间被破坏时，负责数据恢复。它通过为其发送的每个数据包提供一个序号来完成此恢复。较低的网络层会将每个数据包视为一个独立的单元，因此，数据包可以沿完全不同的路径发送，即使它们都是同一消息的组成部分。这种路由与网络层处理分段和重新组装数据包的方式非常相似，只是级别更高而已。<br />为确保正确地接收数据，TCP要求在目标计算机成功收到数据时发回一个确认（即ACK）。如果在某个时限内未收到相应的ACK，将重新传送数据包。如果网络阻塞，这种重新传送将导致发送的数据包重复。但是，接收计算机可使用数据包的序号来确认它是否为重复数据包，并在必要时丢弃它。</p><p><strong>TCP与UDP的选择：</strong><br />如果比较UDP包和TCP包的结构，很明显UDP包不具备TCP包复杂的可靠性和控制机制。与TCP协议相同，UDP的源端口数和目的端口数也都支持一台主机上的多个应用。一个16位的UDP包包含了一个字节长的头部和数据的长度，校验码域使其可以进行整体校验。（许多应用只支持UDP，如：多媒体数据流，不产生任何额外的数据，即使知道有破坏的包也不进行重发。）很明显，当数据传输的性能必须让位于数据传输的完整性、可控制性和可靠性时，TCP协议是首选。当强调性能而不是传输的完整性时，如：音频和多媒体应用，UDP是最好的选择。在数据传输时间很短，以至于此前的连接过程成为整个流量主体的情况下，UDP较低的开销使其有更好的机会去传送管理数据。TCP丰富的功能有时会导致不可预料的性能低下，但是我们相信在不远的将来，TCP可靠的点对点将会用于绝大多数的网络应用。</p><p><strong>TCP协议和UDP协议特性区别总结：</strong></p><ul><li>TCP协议在传送数据段的时候要给段标号；UDP不需要</li><li>TCP协议可靠；UDP协议不可靠</li><li>TCP协议是面向连接的；UDP协议采用无连接</li><li>TCP协议负载较高，采用虚电路；UDP采用无连接</li><li>TCP协议的发送方要确认接收方是否收到数据段（3次握手协议）</li><li>TCP协议采用窗口技术和流控制</li></ul><h2 id="http状态码"><a class="markdownIt-Anchor" href="#http状态码"></a> HTTP状态码</h2><p>当浏览器访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含HTTP状态码的信息头（server header）用以响应浏览器的请求。</p><p>HTTP状态码的英文为HTTP Status Code。下面是常见的HTTP状态码：</p><ul><li>200 请求成功</li><li>301 资源（网页等）被永久转移到其他URL</li><li>404 请求的资源（网页等）不存在</li><li>500 内部服务器错误</li></ul><p><strong>状态码分类</strong></p><table><thead><tr><th>分类</th><th>分类描述</th></tr></thead><tbody><tr><td>1**</td><td>信息，服务器收到请求，需要请求者进行执行操作</td></tr><tr><td>2**</td><td>成功，操作被成功接收并处理</td></tr><tr><td>3**</td><td>重定向，需要进一步的操作以完成请求</td></tr><tr><td>4**</td><td>客户端错误，请求包含语法错误或无法完成请求</td></tr><tr><td>5**</td><td>服务器错误，服务器在处理请求的过程中发生了错误</td></tr></tbody></table><p><strong>状态码列表</strong></p><table><thead><tr><th>状态码</th><th>状态码英文名称</th><th>中文描述</th></tr></thead><tbody><tr><td>100</td><td>Continue</td><td>继续，客户端应继续其请求</td></tr><tr><td>101</td><td>Switching Protocols</td><td>切换协议。服务器根据客户端的请求切换协议。只能切换到HTTP的新版本协议</td></tr><tr><td></td><td></td><td></td></tr><tr><td>200</td><td>OK</td><td>请求成功。一般用于GET和POST请求</td></tr><tr><td>201</td><td>Created</td><td>已创建。成功请求并创建了新的资源</td></tr><tr><td>202</td><td>Accepted</td><td>已接受。已经接受请求，但未处理完成</td></tr><tr><td>203</td><td>Non-Authoritative Information</td><td>非授权信息。请求成功，但返回的meta信息不在原始的服务器，而是一个副本</td></tr><tr><td>204</td><td>No Content</td><td>无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td></tr><tr><td>205</td><td>Reset Content</td><td>重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清楚浏览器的表单域</td></tr><tr><td>206</td><td>Partial Content</td><td>部分内容。服务器成功处理了部分GET请求</td></tr><tr><td></td><td></td><td></td></tr><tr><td>300</td><td>Multiple Choices</td><td>多种选择。请求的资源可包含多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td></tr><tr><td>301</td><td>Moved Permanently</td><td>永久移动。请求的资源已被永久的移动到新URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td></tr><tr><td>302</td><td>Found</td><td>临时移动。与301类似，但资源只是临时被移动，客户端应继续使用原有URI</td></tr><tr><td>303</td><td>See Other</td><td>查看其它地址，与301、302类似，如果最初的请求是POST，那么新文档要用GET找到</td></tr><tr><td>304</td><td>Not Modified</td><td>未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td></tr><tr><td>305</td><td>Use Proxy</td><td>使用代理，所请求的资源必须通过代理访问</td></tr><tr><td>306</td><td>Unused</td><td>已经被废弃的HTTP状态码</td></tr><tr><td>307</td><td>Temporary Redirect</td><td>临时重定向。与302类似，使用GET请求重定向</td></tr><tr><td></td><td></td><td></td></tr><tr><td>400</td><td>Bad Request</td><td>客户端请求的语法错误，服务器无法理解</td></tr><tr><td>401</td><td>Unauthorized</td><td>请求要求用户的身份认证</td></tr><tr><td>402</td><td>Payment Required</td><td>保留</td></tr><tr><td>403</td><td>Forbidden</td><td>服务器理解请求客户端的请求，但是拒绝执行此请求</td></tr><tr><td>404</td><td>Not Found</td><td>服务器无法根据客户端的请求找到资源（网页），通过此代码，网站设计人员可设置“您所请求的资源无法找到”的个性页面</td></tr><tr><td>405</td><td>Method Not Allowed</td><td>客户端请求中的方法被禁止</td></tr><tr><td>406</td><td>Not Acceptable</td><td>服务器无法根据客户端请求的内容特性完成请求</td></tr><tr><td>407</td><td>Proxy Authentication Required</td><td>请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</td></tr><tr><td>408</td><td>Request Time-out</td><td>服务器等待客户端发送的请求时间太长，超时</td></tr><tr><td>409</td><td>Conflict</td><td>服务器完成客户端的PUT请求是可能返回此代码，服务器处理请求时发生了冲突</td></tr><tr><td>410</td><td>Gone</td><td>客户端请求的资源已经不存在，410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</td></tr><tr><td>411</td><td>Length Required</td><td>服务器无法处理客户端发送的不带Content-Length的请求信息</td></tr><tr><td>412</td><td>Precondition Failed</td><td>客户端请求信息的先决条件错误</td></tr><tr><td>413</td><td>Request Entity Too Large</td><td>由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连接请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</td></tr><tr><td>414</td><td>Request-URI Too Large</td><td>请求的URI过长（URI通常为网址），服务器无法处理</td></tr><tr><td>415</td><td>Unsupported Media Type</td><td>服务器无法处理请求附带的媒体格式</td></tr><tr><td>416</td><td>Requested range not satisfiable</td><td>客户端请求的范围无效</td></tr><tr><td>417</td><td>Expectation Failed</td><td>服务器无法满足Expect的请求头信息</td></tr><tr><td></td><td></td><td></td></tr><tr><td>500</td><td>Internal Server Error</td><td>服务器内部错误，无法完成请求</td></tr><tr><td>501</td><td>Not Implemented</td><td>服务器不支持请求的功能，无法完成请求</td></tr><tr><td>502</td><td>Bad Gateway</td><td>充当网关或代理的服务器，从远端服务器接收到了一个无效的请求</td></tr><tr><td>503</td><td>Service Unavailable</td><td>由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td></tr><tr><td>504</td><td>Gateway Time-out</td><td>充当网关或代理的服务器，未及时从远端服务器获取请求</td></tr><tr><td>505</td><td>HTTP Version not supported</td><td>服务器不支持请求的HTTP协议的版本，无法完成处理</td></tr></tbody></table><h2 id="http协议"><a class="markdownIt-Anchor" href="#http协议"></a> HTTP协议</h2><p>HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写，是用于从万维网（WWW：World Wide Web）服务器传输超文本到本地浏览器的传送协议。</p><p>HTTP是一个基于TCP/IP通信协议来传递数据（HTML文件、图片文件、查询结果等）。</p><p><strong>主要特点</strong></p><ul><li>简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、POST。</li><li>灵活：HTTP允许传输任意类型的数据对象，正在传输的类型由Content-Type加以标记</li><li>无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</li><li>无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传输的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</li><li>支持B/S及C/S</li></ul><h3 id="http之url"><a class="markdownIt-Anchor" href="#http之url"></a> HTTP之URL</h3><p>HTTP使用统一资源标识符（Uniform Resource Identifiers，URI）来传输数据和建立连接。URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息。<br />URL，全称是Uniform Resource Locator，中文叫统一资源定位符，是互联网上用来标识某一处资源的地址。</p><ol><li><p>URI，是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。<br />Web上可用的每种资源如HTML文档、图像、视频片段、程序等都是一个来URI来定位的URI一般有三个部分组成：</p><ul><li>访问资源的命名机制</li><li>存放资源的主机名</li><li>资源自身的名称，有路径标识，着重强调于资源</li></ul></li><li><p>URL是uniform resource locator，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。<br />URL是Internet上用来描述资源信息的字符串，主要用在各种WWW客户程序客户程序和服务器程序上。</p><p>采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL一般由三部分组成：</p><ul><li>协议（或称为服务方式）</li><li>存有该资源的主机IP地址（有时也包括端口号）</li><li>主机资源的具体地址。如目录和文件名等</li></ul></li><li><p>URN，uniform resource name，统一资源命名，是通过名字来标识资源</p></li></ol><p>URI是一种抽象的，高层次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。URL和URN都是一种URI。笼统地说，每个URL都是URI，但不一定每个URI都是URL。这是因为URI还包括一个子类，即统一资源名称（URN），它命名资源但不指定如何定位资源。</p><p>在Java的URI中，一个URI实例可以代表绝对的，也可以相对的，只要它符合URI的语法规则。而URL类则不仅符合语义，还包括了定位该资源的信息，因此它不能是相对的。</p><p>在Java类库中，URI类不包括任何访问资源的方法，它唯一的作用就是解析。相反的是，URL类可以打开一个到达资源的流。</p><h3 id="http之请求信息request"><a class="markdownIt-Anchor" href="#http之请求信息request"></a> HTTP之请求信息Request</h3><p>客户端发送一个HTTP请求到服务器的请求信息包括以下格式：<strong>请求行（request line）、请求头部（header）、空行和请求数据四个部分组成。</strong></p><h3 id="http之响应消息response"><a class="markdownIt-Anchor" href="#http之响应消息response"></a> HTTP之响应消息Response</h3><p>一般情况下，服务器接收并处理客户端发过来的请求后返回一个HTTP的响应消息。<strong>HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">200 OK                        &#x2F;&#x2F;客户端请求成功</span><br><span class="line">400 Bad Request               &#x2F;&#x2F;客户端请求有语法错误，不能被服务器所理解</span><br><span class="line">401 Unauthorized              &#x2F;&#x2F;请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 </span><br><span class="line">403 Forbidden                 &#x2F;&#x2F;服务器收到请求，但是拒绝提供服务</span><br><span class="line">404 Not Found                 &#x2F;&#x2F;请求资源不存在，eg：输入了错误的URL</span><br><span class="line">500 Internal Server Error     &#x2F;&#x2F;服务器发生不可预期的错误</span><br><span class="line">503 Server Unavailable        &#x2F;&#x2F;服务器当前不能处理客户端的请求，一段时间后可能恢复正常</span><br></pre></td></tr></table></figure><h3 id="http工作原理"><a class="markdownIt-Anchor" href="#http工作原理"></a> HTTP工作原理</h3><p>HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。</p><p>以下是HTTP请求/响应的步骤：</p><ol><li>客户端连接到Web服务器<br />一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认是80）建立一个TCP套接字连接。</li><li>发送HTTP请求<br />通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4个部分组成。</li><li>服务器接受请求并返回HTTP响应<br />Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4个部分组成。</li><li>释放连接TCP连接<br />若connection模型为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接；若connection模型为keep alive，则该连接会保持一段时间，则该时间内可以继续接受请求。</li><li>客户端浏览器解析HTML内容<br />客户端浏览器首先解析状态行，查看表明请求是否成功的状态码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。<br />例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程：<br />① 浏览器向DNS服务器请求解析该URL中的域名所对应的IP地址；<br />② 解析出IP地址后，根据该IP地址和默认端口80，和服务器建立TCP连接；<br />③ 浏览器发出读取文件（URL中域名后面部分对应的文件）的HTTP请求，该请求报文作为TCP三次握手的第三个报文的数据发送给服务器；<br />④ 服务器对浏览器请求作出响应，并将对应的HTML文本发送给浏览器；<br />⑤ 释放TCP连接<br />⑥ 浏览器将该HTML文本显示</li></ol><p><strong>GET和POST请求的区别</strong></p><ul><li>GET提交的数据会放在URL之后，以？分割URL和传输数据，参数之间以&amp;相连；POST方法是把提交的数据放在HTTP包的body里面；</li><li>GET提交的数据大小有限制（HTTP协议没有对传输的数据大小进行限制，HTTP协议规范也没有对URL长度进行限制，只是由于浏览器对URL的长度有限制），而POST方法提交的数据没有限制；</li><li>GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值；</li><li>GET方式提交数据，会带来安全问题</li><li>GET方式通过一次HTTP请求即可获得数据；POST方式通过两次HTTP请求获得数据，第一次返回状态码100表示浏览器继续请求。</li></ul><h2 id="osi协议-tcpip协议以及每层对应的协议"><a class="markdownIt-Anchor" href="#osi协议-tcpip协议以及每层对应的协议"></a> OSI协议、TCP/IP协议以及每层对应的协议</h2><p>OSI分层 （7层）：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层；<br />TCP/IP分层（4层）：网络接口层、 网际层、运输层、 应用层；<br />5层协议 （5层）：物理层、数据链路层、网络层、运输层、 应用层；</p><h2 id="session机制-cookie机制"><a class="markdownIt-Anchor" href="#session机制-cookie机制"></a> session机制、cookie机制</h2><p>由于http协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是session。这个session是保存在服务端的，有一个唯一标识。在服务端保存session的方法有很多，内存、数据库、文件都可以。</p><p>每次http请求的时候，客户端都会发送相应的cookie信息到服务端，实际上大多数的应用都是用cookie来实现session跟踪的，第一次创建session的时候，服务端会在http协议中告诉客户端，需要在cookie里面记录一个session id，以后每次请求把这个会话id发送到服务器。</p><p>如果客户端浏览器禁用了cookie，在这种情况下，会使用一种叫做URL重写的技术来进行会话跟踪，即每次http请求，URL后面都会附上一个诸如sid=xxx这样的参数，服务端据此来标识用户。</p><p><em>总结：Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。</em></p><h2 id="打开网页到页面显示之间的过程"><a class="markdownIt-Anchor" href="#打开网页到页面显示之间的过程"></a> 打开网页到页面显示之间的过程</h2><h3 id="dns解析"><a class="markdownIt-Anchor" href="#dns解析"></a> DNS解析</h3><h4 id="解析过程"><a class="markdownIt-Anchor" href="#解析过程"></a> 解析过程</h4><p>DNS解析是一个递归查询的过程<br /><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/20180909164251348.png" alt="" /></p><p>上图是查找www.google.com的IP地址流程。首先在本地域名服务器中查询IP地址，如果没有找到的情况下，本地域名服务器会向根域名服务器发送一个请求，如果根域名服务器也不存在该域名时，本地域名会向com顶级域名服务器发送一个请求，依次类推下去。直到最后本地域名服务器得到google的IP地址并把它缓存到本地，供下次查询使用。从上述过程中，可以看出网址的解析是一个从左向右的过程：com-&gt;google.com-&gt;<a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a>。事实上，<a href="http://xn--www-cs6et69dkeh2jun9at96b.google.com" target="_blank" rel="noopener">真正的网址是www.google.com</a>.，最后一个.对应的就是根域名服务器，默认情况下，通常会省略，浏览器在请求DNS的时候都会自动加上，所有网址真正的解析过程是：<code>.-&gt;.com-&gt;google.com.-&gt;www.google.com.</code>。</p><h4 id="dns优化"><a class="markdownIt-Anchor" href="#dns优化"></a> DNS优化</h4><p><strong>DNS缓存</strong><br />DNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种：浏览器缓存、系统缓存、根域名服务器缓存、顶级域名服务器缓存、主域名服务器缓存</p><p><strong>DNS负载均衡</strong><br />DNS可以返回一个合适的机器的IP给用户，例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等，这种过程就是DNS负载均衡，又叫做DNS重定向。CDN（Content Delivery Network）就是利用DNS的重定向技术，DNS服务器会返回一个跟用户最接近的点的IP返回给用户，CDN节点的服务器负责响应用户的请求，提供所需的内容。</p><h3 id="tcp连接"><a class="markdownIt-Anchor" href="#tcp连接"></a> TCP连接</h3><p>HTTP协议是使用TCP作为其传输层协议的，当TCP出现瓶颈时，HTTP也会受到影响。</p><h4 id="https协议"><a class="markdownIt-Anchor" href="#https协议"></a> HTTPS协议</h4><p>HTTP报文是包裹在TCP报文中发送的，服务器端收到TCP报文时会解包提取出HTTP报文。但是这个过程中存在一定的风险，HTTP报文是明文，如果中间被截取的话会存在一定信息泄露的风险。HTTPS协议的本质就是HTTP+SSL(or TLS)。在HTTP报文进入TCP报文之前，先使用SSL对HTTP报文进行加密。从网络的层次结构中看它位于HTTP协议与TCP协议之间。</p><p>https在传输数据之前需要客户端与服务端进行一个握手（TCL/SSL握手），在握手过程中将确立双方加密传输数据的密码信息。TCL/SSL使用了非对称加密，对称加密和hash等。具体过程见的阮一峰先生的博客<a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html" target="_blank" rel="noopener">图解SSL/TLS协议</a></p><h4 id="http请求"><a class="markdownIt-Anchor" href="#http请求"></a> HTTP请求</h4><p>发送HTTP请求的过程就是构建HTTP请求报文并通过TCP协议发送到服务器指定端口（80和443）。HTTP请求报文是由三部分组成：请求行、请求报头和请求正文。</p><h4 id="服务器处理请求并返回http报文"><a class="markdownIt-Anchor" href="#服务器处理请求并返回http报文"></a> 服务器处理请求并返回HTTP报文</h4><p>后端从在固定的端口接收到TCP报文开始，这一部分对应于编程语言中的socket。它会对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装成HTTP Request对象，供上层使用。这一部分工作一般由Web服务器去进行处理，有Tomcat、Jetty和Netty等。</p><p>HTTP响应报文也是由三部分组成：状态码、响应报头和响应报文。</p><h3 id="浏览器解析渲染页面"><a class="markdownIt-Anchor" href="#浏览器解析渲染页面"></a> 浏览器解析渲染页面</h3><p>浏览器是一个边解析边渲染的过程。首先浏览器解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。这个过程比较复杂，涉及到两个概念: reflow(回流)和repain(重绘)。DOM节点中的各个元素都是以盒模型的形式存在，这些都需要浏览器去计算其位置和大小等，这个过程称为relow；当盒模型的位置,大小以及其他属性，如颜色，字体，等确定下来之后，浏览器便开始绘制内容，这个过程称为repain。页面在首次加载时必然会经历reflow和repain。</p><p>JS的解析是由浏览器中的JS解析引擎完成的。JS是单线程运行，也就是说，在同一个时间内只能做一件事，所有的任务都需要排队，前一个任务结束，后一个任务才能开始。但是又存在某些任务比较耗时，如IO读写等，所以需要一种机制可以先执行排在后面的任务，这就是：同步任务(synchronous)和异步任务(asynchronous)。JS的执行机制就可以看做是一个主线程加上一个任务队列(task queue)。同步任务就是放在主线程上执行的任务，异步任务是放在任务队列中的任务。所有的同步任务在主线程上执行，形成一个执行栈;异步任务有了运行结果就会在任务队列中放置一个事件；脚本运行时先依次运行执行栈，然后会从任务队列里提取事件，运行任务队列中的任务，这个过程是不断重复的，所以又叫做事件循环(Event loop)。</p><p>浏览器在解析过程中，如果遇到请求外部资源时，如图像,iconfont,JS等。浏览器将重复1-6过程下载该资源。请求过程是异步的，并不会影响HTML文档进行加载，但是当文档加载过程中遇到JS文件，HTML文档会挂起渲染过程，不仅要等到文档中JS文件加载完毕还要等待解析执行完毕，才会继续HTML的渲染过程。原因是因为JS有可能修改DOM结构，这就意味着JS执行完成前，后续所有资源的下载是没有必要的，这就是JS阻塞后续资源下载的根本原因。CSS文件的加载不影响JS文件的加载，但是却影响JS文件的执行。JS代码执行前浏览器必须保证CSS文件已经下载并加载完毕。</p><h3 id="web优化"><a class="markdownIt-Anchor" href="#web优化"></a> Web优化</h3><p>如何尽快的加载资源？答案就是能不从网络中加载的资源就不从网络中加载，当我们合理使用缓存，将资源放在浏览器端，这是最快的方式。如果资源必须从网络中加载，则要考虑缩短连接时间，即DNS优化部分;减少响应内容大小，即对内容进行压缩。另一方面，如果加载的资源数比较少的话，也可以快速的响应用户。当资源到达浏览器之后，浏览器开始进行解析渲染，浏览器中最耗时的部分就是reflow，所以围绕这一部分就是考虑如何减少reflow的次数。</p><p><strong>补充：</strong></p><ol><li><p>一个完整的HTTP请求，通常有以下7个步骤</p><ul><li>建立TCP连接</li><li>web浏览器向web服务器发送请求命令</li><li>浏览器发送请求头信息</li><li>服务器应答</li><li>服务器发送应答头信息</li><li>服务器向浏览器发送数据</li><li>服务器关闭TCP连接</li></ul></li><li><p>一个HTTP请求由四部分组成</p><ul><li>HTTP请求方法或动作，如：GET与POST</li><li>正在请求的URL</li><li>请求头，包含一些客户端环境信息、身份验证信息</li><li>请求体，即请求正文，可包含提交的查询字符串信息、表单信息等。</li></ul></li><li><p>一个HTTP响应一般由三个部分组成</p><ul><li>一个数字和文字组成的状态码，用来显示请求成功还是失败</li><li>响应头，包含许多有用的信息，如：服务器类型、日期时间、内容类型和长度</li><li>响应体，即响应正文。</li></ul></li><li><p>readyState属性（返回请求的当前状态）</p><ul><li>0，请求未初始换，open还没有调用</li><li>1，服务器连接已建立，open已经调用</li><li>2，请求已接收，即接收到头部信息</li><li>3，请求处理中，即接收到响应体了</li><li>4，请求已完成，且响应已就绪，即响应完成了。</li></ul></li></ol><h2 id="http和https区别https在请求时额外的过程https是如何保证数据安全的"><a class="markdownIt-Anchor" href="#http和https区别https在请求时额外的过程https是如何保证数据安全的"></a> http和https区别，https在请求时额外的过程，https是如何保证数据安全的</h2><p><strong>区别：</strong><br />HTTP协议传输的数据都是未加密的，即明文，为了保证隐私数据能加密传输，使用SSL协议用于对HTTP协议传输的数据进行加密，这就是HTTPS。简单的说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</p><ul><li>https协议协议到CA申请证书，需要一定的费用</li><li>http是超文本传输协议，信息是明文传输，https则是具有安全性的SSL加密传输协议</li><li>http和https使用的是完全不用的连接方式，用到的端口不同，前者是80，后者是443</li><li>http的连接简单，是无状态的；https协议是ssl+http协议构成的可进行加密传输、身份认证的网络协议，比http协议安全</li></ul><p><strong>额外的过程：</strong><br />https在传输数据之前需要客户端与服务端进行一个握手（TCL/SSL握手），在握手过程中将确立双方加密传输数据的密码信息。TCL/SSL使用了非对称加密，对称加密和hash等。具体过程见的阮一峰先生的博客<a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html" target="_blank" rel="noopener">图解SSL/TLS协议</a></p><h2 id="ip地址子网划分"><a class="markdownIt-Anchor" href="#ip地址子网划分"></a> IP地址子网划分</h2><p><strong>IP地址的划分：</strong></p><ul><li>A类地址：以0开头，网络号是前一个字节</li><li>B类地址：以10开头，网络号是前两个字节</li><li>C类地址：以110开头，网络号是前三个字节</li></ul><p><strong>IP地址由网络号和主机号组成，ip与子网掩码相与得到网络号</strong></p><p><strong>子网划分</strong><br />传统的两级ip地址空间利用率很低，1个A类网络可连接的主机数可超过1000万台，但实际连接数并不多，所以需要对网络进行子网划分，通过子网掩码来区分网络。</p><p><strong>三级ip地址：&lt;网络号&gt;&lt;子网号&gt;&lt;主机号&gt;</strong></p><h2 id="tcp如何保证数据的可靠传输的这个问题可以引申出很多子问题拥塞控制慢开始-拥塞避免-快重传-滑动窗口协议-停止等待协议-超时重传机制"><a class="markdownIt-Anchor" href="#tcp如何保证数据的可靠传输的这个问题可以引申出很多子问题拥塞控制慢开始-拥塞避免-快重传-滑动窗口协议-停止等待协议-超时重传机制"></a> TCP如何保证数据的可靠传输的（这个问题可以引申出很多子问题，拥塞控制慢开始、拥塞避免、快重传、滑动窗口协议、停止等待协议、超时重传机制）</h2><p><em>总结一：</em></p><ol><li>确认和重传：接收方收到报文就会确认，发送方发送一段时间后没有收到确认就会重传</li><li>数据校验：TCP报文头有校验和，用于校验报文是否损坏</li><li>数据合理分片和排序：<br />TCP会按最大传输单元（MTU）合理分片，接收方会缓存为按排序到达的数据，重新排序后交给应用层<br />UDP：IP数据包大于1500字节，大于MTU。这个时候发送方的IP层就需要分片，吧数据包分成若干片，每一片都小于MTU。而接收方IP层则需要数据包的重组。由于UDP的特性，当某一片数据丢失时，接收方无法重组数据包，导致丢弃整个UDP数据包。</li><li>流量控制：当接收方来不及处理发送方的数据时，能通过滑动窗口，提示发送方降低发送的速率，防止包丢失。</li><li>拥塞控制：当网络拥塞时，通过拥塞窗口，减少数据的发送，防止包丢失。</li></ol><p><em>总结二：</em></p><ol><li>可靠传输：对于收到的请求，给出确认响应</li><li>超时重传</li><li>流量控制：让发送方的发送速率不要太快，要让接收方来得及接受。利用滑动窗口实现流量控制</li><li>拥塞控制：防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不至过载</li><li>慢开始：TCP开始发送报文段时先设置拥塞窗口为1</li><li>拥塞避免：使拥塞窗口按线性规律增长</li><li>快重传：发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待为其设置的重传计时器到期</li><li>快恢复(与快重传配合使用)：当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把慢开始门限减半。这是为了预防网络发生拥塞。请注意，接下来不执行慢开始算法。<br />由于发送方现在认为网络很可能没有发生拥塞(如果网络发生了严重的拥塞，就不会一连有好几个报文段连续达到接收方，就不会导致接收方连续发送重复确认)，因此与慢开始不同之处是现在不执行慢开始算法(即拥塞窗口现在不设置为1)，而是把它设置为慢开始门限减半后的数值，然后开始执行拥塞避免算法(“加法增大”)，使拥塞窗口缓慢地线性增长。</li></ol><h2 id="长连接与短连接"><a class="markdownIt-Anchor" href="#长连接与短连接"></a> 长连接与短连接</h2><h3 id="http协议和tcp协议"><a class="markdownIt-Anchor" href="#http协议和tcp协议"></a> HTTP协议和TCP协议</h3><p>HTTP的长连接和短连接本质上是TCP长连接和短连接。HTTP属于应用层协议，在传输层使用TCP协议，在网络层使用IP协议。IP协议主要解决网络路由和寻址问题，TCP协议主要解决如何在IP层之上可靠的传输数据包，使在网络上的另一端收到发端发出的所有包，并且顺序与发出顺序一致。TCP有可靠，面向连接的特点。</p><h3 id="http协议的长连接和短连接"><a class="markdownIt-Anchor" href="#http协议的长连接和短连接"></a> HTTP协议的长连接和短连接</h3><p>在HTTP/1.0中，默认使用的是短连接。也就是说，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。如果客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源，如JavaScript文件、图像文件、CSS文件等；当浏览器没遇到这样一个Web资源，就会建立一个HTTP会话。</p><p>但从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入如下代码：<code>Connection:keep-alive</code>。在使用长连接的情况下，当一个网页打开完成之后，客户端和服务端之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器的网页，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个事件。实现长连接要客户端和服务端都支持长连接。</p><p>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</p><h3 id="tcp长连接和短连接"><a class="markdownIt-Anchor" href="#tcp长连接和短连接"></a> TCP长连接和短连接</h3><p>我们模拟一下TCP短连接的情况，client向server发起连接请求，server接到请求，然后双方建立链接。client向server发送消息，server回应client，然后一次读写就完成了，这时候双方任何一个都可以发起close操作，不过一般都是client先发起close操作。为什么呢，一般的server不会回复完client后立即关闭连接的，当然不排除有特殊的情况。从上面的描述看，短连接一般只会在 client/server间传递一次读写操作。</p><p><strong>短连接的优点：管理起来比较方便，存在的连接都是有用的连接，不需要额外的控制手段。</strong></p><p>我们再模拟一下长连接的情况，client向server发起连接，server接受client连接，双方建立连接。client与server完成一次读写之后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个链接。</p><p><strong>首先说一下TCP/IP详解上讲到的TCP保活功能，保活功能主要为服务器应用提供，服务器应用希望知道客户主机是否崩溃，从而可以代表客户使用资源。如果客户已经消失，使得服务器上保留一个半开放的连接，而服务器又在等待来自客户端的数据，则服务器将应远等待客户端的数据，保活功能就是试图在服务器端检测到这种半开放的连接。</strong></p><h3 id="长连接和短连接的生命周期"><a class="markdownIt-Anchor" href="#长连接和短连接的生命周期"></a> 长连接和短连接的生命周期</h3><p>短连接在建立连接后，完成一次读写就会自动关闭了。</p><p>正常情况下，一条TCP长连接建立后，只要双方不提出关闭请求并且不出现异常情况，这条连接是一直存在的，操作系统不会自动去关闭它，甚至经过物理网络拓扑的改变之后仍然可以使用。所以一条连接保持几天、几个月、几年或者更长时间都有可能，只要不出现异常情况或由用户（应用层）主动关闭。</p><p>在编程中，往往需要建立一条TCP连接，并且长时间处于连接状态。所谓的TCP长连接并没有确切的时间限制，而是说这条连接需要的时间比较长。</p><h3 id="怎样维护长连接或者检查中断"><a class="markdownIt-Anchor" href="#怎样维护长连接或者检查中断"></a> 怎样维护长连接或者检查中断</h3><ul><li><p>在应用层使用heartbeat来主动监测<br />对于实时性要求较高的网络通信程序，往往需要更加及时的获取已经中断的连接，从而进行及时的处理。但如果对方的连接异常中断，往往是不能及时的得到对方连接已经中断的信息，操作系统检测连接是否中断的时间间隔默认是比较长的，即便它能够检测到，但却不符合我们的实时性需求，所以需要我们进行手工去不断探测。</p></li><li><p>改变socket的keepalive选项，以使socket检查连接是否中断的时间间隔更小，以满足我们的及时性需求。有关的几个选项使用和解析如下：</p><ol><li><p>我们在检测对端以一种非优雅的方式断开连接的时候，可以设置SO_KEEPALIVE属性使得我们在2小时以后发现对方的TCP连接是否依然存在。用法如下:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">keepAlive &#x3D; 1；</span><br><span class="line">setsockopt(listenfd, SOL_SOCKET, SO_KEEPALIVE, (void*)&amp;keepAlive, sizeof(keepAlive));</span><br></pre></td></tr></table></figure></li><li><p>如果我们不想使用这么长的等待时间，可以修改内核关于网络方面的配置参数，也可设置SOCKET的TCP层（SOL_TCP）选项TCP_KEEPIDLE、TCP_KEEPINTVL和TCP_KEEPCNT。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TCP_KEEPIDLE：开始首次KeepAlive探测前的TCP空闭时间</span><br><span class="line">TCP_KEEPINTVL：两次KeepAlive探测间的时间间隔</span><br><span class="line">TCP_KEEPCNT：断开前的KeepAlive探测次数</span><br></pre></td></tr></table></figure><p>如果心搏函数要维护客户端的存活，即服务器必须每隔一段时间必须向客户段发送一定的数据，那么使用SO_KEEPALIVE是有很大的不足的。因为SO_KEEPALIVE选项指&quot;此套接口的任一方向都没有数据交换&quot;。在Linux2.6系列上，上面话的理解是只要打开SO_KEEPALIVE选项的套接口端检测到数据发送或者数据接受就认为是数据交换。因此在这种情况下使用 SO_KEEPALIVE选项。</p><p>检测对方是否非正常连接是完全没有作用的，在每隔一段时间发包的情况， keep-alive的包是不可能被发送的。上层程序在非正常断开的情况下是可以正常发送包到缓冲区的。非正常端开的情况是指服务器没有收到&quot;FIN&quot; 或者 &quot;RST&quot;包。</p></li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;tcp报头格式&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#tcp报头格式&quot;&gt;&lt;/a&gt; TCP报头格式&lt;/h2&gt;
&lt;p&gt;定义：TCP传输控制协议是一种面向连接的、可靠的、基于字节流的传输层协议。&lt;br /&gt;
&lt;img src=&quot;htt
      
    
    </summary>
    
    
      <category term="基础知识总结" scheme="https://toyan.top/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
      <category term="计算机网络" scheme="https://toyan.top/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="https://toyan.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Java总结</title>
    <link href="https://toyan.top/java-summary/"/>
    <id>https://toyan.top/java-summary/</id>
    <published>2018-09-01T16:00:00.000Z</published>
    <updated>2020-02-07T14:40:28.724Z</updated>
    
    <content type="html"><![CDATA[<h2 id="java的四个特性抽象-封装-继承-多态对多态的理解多态的实现方式"><a class="markdownIt-Anchor" href="#java的四个特性抽象-封装-继承-多态对多态的理解多态的实现方式"></a> Java的四个特性（抽象、封装、继承、多态），对多态的理解（多态的实现方式）</h2><ul><li><p>抽象：抽象是将一类对象的共同特征总结出来构造类的过程。包括数据抽象和行为抽象两个方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。</p></li><li><p>继承：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类），继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段。</p></li><li><p>封装：通常认为封装是将数据与操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法是对实现细节的一种封装；我们编写的一个类就是对数据和数据操作的封装。封装就是隐藏一切可隐藏的东西，只向外提供简单的编程接口。</p></li><li><p>多态</p><ul><li>方法重载（overload）实现的是编译时的多态性（也成为前向绑定）</li><li>方法重写（overwrite）实现的是运行时的多态性（也成为后向绑定）</li><li>多态的实现方式：方法重写，子类继承父类并重写父类中已有的或抽象的方法；对象构造，用父类型引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为</li><li>举例：有两种客户：订购客户和卖方客户，两个客户都可以登录系统，他们有相同的方法login，但登录之后他们会进入不同的页面，也就是在登录后有不同的操作行为。两种客户都继承父类的Login方法，但对于不同的对象，拥有不同的操作。</li></ul></li></ul><h2 id="面向对象和面向过程的区别"><a class="markdownIt-Anchor" href="#面向对象和面向过程的区别"></a> 面向对象和面向过程的区别？</h2><ul><li><p>面向过程就像是一个细心的管家，事无具细的都要考虑到。而面向对象就像是一个家用电器，你只需要知道他的功能，不需要知道他的工作原理</p></li><li><p>面向过程是一种以时间为中心的编程思想，就是分析出解决问题所需的步骤，然后用函数把这些步骤实现，并按顺序调用。面向对象是以“对象”为中心的编程思想</p></li><li><p>举例：汽车发送、汽车到站</p><ul><li>对于面向过程来说，这是两个事件，面向过程编程我们关心的是事件，而不是汽车本身。针对上述过程，形成两个函数，依次调用</li><li>对于面向对象来说，我们关心的是汽车这类对象，两个事件只是这类对象所具有的行为。而且对于这两个行为没有顺序要求</li></ul></li></ul><h2 id="重载与重写"><a class="markdownIt-Anchor" href="#重载与重写"></a> 重载与重写</h2><ul><li><p>重载：重载发生在同一个类中，同名的方法如果有不同的参数列表（参数类型、参数个数或者两者都不同）则视为重载</p></li><li><p>重写：重写发生在子类与父类之间，重写要求子类重写方法与父类被重写方法具有相同的返回参数，比父类方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则），根据不同的子类对象确定调用哪个对象</p></li></ul><h2 id="面向对象开发的六个基本准则单一职责-开放封闭-里氏替换-依赖倒置-合成聚合复用-接口隔离迪米特法则"><a class="markdownIt-Anchor" href="#面向对象开发的六个基本准则单一职责-开放封闭-里氏替换-依赖倒置-合成聚合复用-接口隔离迪米特法则"></a> 面向对象开发的六个基本准则（单一职责、开放封闭、里氏替换、依赖倒置、合成聚合复用、接口隔离），迪米特法则</h2><ul><li><p>单一职责：一个类只能它该做的事情（高内聚），在面向对象中，如果只让一个类完成它该做的事，而不涉及与它无关的领域就是践行了高内聚的原则，这个类就是单一职责</p></li><li><p>开放封闭：软件实体应当对扩展开放，对修改关闭。要做到开闭有两点：抽象是关键，一个系统如果没有抽象类或者接口系统就没有扩展点；封装可变性，将系统中可变因素封装在一个继承结构中，如果多个可变因素混杂在一起，系统将复杂而混乱</p></li><li><p>里氏替换：任何时候都可以用子类替换父类，子类一定是增加了父类的能力而不是减少，因为子类比父类的能力更多，把能力多的对象当成能力少的对象来用没有问题</p></li><li><p>依赖倒置：面向接口编程（声明方法的参数类型、方法返回类型，变量的引用类型要尽量使用抽象类型而不是具体类型，因为抽象类型可以被其子类型所替代）</p></li><li><p>合成聚合复用：优先使用聚合或合成关系复用代码</p></li><li><p>接口隔离：接口不要大而全，要小而专，一个接口只应该描述一种能力，接口也应该是高内聚的</p></li></ul><p>迪米特法则：又称为最少知识原则，一个对象应当对其他对象有尽可能少的了解</p><h2 id="static与final的区别"><a class="markdownIt-Anchor" href="#static与final的区别"></a> static与final的区别</h2><p>static：</p><ul><li>修饰变量：静态变量随着类加载时完成初始化，内存中只有一个，且JVM只会为它分配一次内存，所有类共享静态变量</li><li>修饰方法：在类加载的时候就存在，不依赖任何实例；static方法必须实现，不能用abstract修饰</li><li>修饰代码块：在类加载完成后就会执行代码块中的内容</li><li>父类静态代码块-&gt;子类静态代码块-&gt;父类非静态代码块-&gt;父类构造方法-&gt;子类非静态代码块-&gt;子类构造方法</li></ul><p>final：</p><ul><li>修饰变量<ul><li>编译期常量：类加载的过程完成初始化，编译后带入到任何计算式中，只能是基本类型</li><li>运行时常量：基本数据类型或引用数据类型，引用不可变，但引用的对象内容可变</li></ul></li><li>修饰方法：不能被继承，不能被子类修改</li><li>修饰类：不能被继承</li><li>修饰新参：final形参不可变</li></ul><h2 id="hashmap和hashtable的区别hashmap中的key可以是任何对象或数据类型吗"><a class="markdownIt-Anchor" href="#hashmap和hashtable的区别hashmap中的key可以是任何对象或数据类型吗"></a> HashMap和Hashtable的区别，HashMap中的key可以是任何对象或数据类型吗？</h2><p>区别：</p><ul><li>Hashtable的方法是同步的，HashMap未经同步，所以在多线程环境下要手动同步HashMap，这个区别就相当于Vector和ArrayList</li><li>Hashtable不允许使用null（key和value都不可以），HashMap允许null值（key只能有一个null值，value没有限制）</li><li>两者的遍历方式大同小异，Hashtable仅仅比HashMap多一个elements方法<br />Hashtable和HashMap都能通过values()方法返回一个Collection，然后遍历<br />两者也都可以通过entrySet()返回一个Set，然后遍历</li><li>Hashtable使用Enumeration，HashMap使用Iterator</li><li>哈希值计算方法不同，hashtable直接使用对象的hashCode，hashMap重新计算hash值，而且用于代替求模</li><li>Hashtable的hash数组大小是11，增加方式是old*2+1，hashMap的默认大小是16，而且一定是2的指数</li><li>hashtable是基于Dictionary，hashMap是基于AbstractMap类</li></ul><p>HashMap的key可以为null，但不可以为可变对象。如果是可变对象时，对象的属性改变，则对象的hashCode也进行了相应的改变，导致下次无法查找到已存在Map的数据。</p><p>如果可变对象被用作HashMap的键时，在改变对象的状态时，不要再改变其哈希值，我们只需要保证成员变量的改变能保证该对象的哈希值不变即可。</p><p>hashtable是线程安全的，其实是在对应的方法添加了synchronized关键字进行修饰，由于在执行此方法的时候需要获得对象锁，则执行起来比较慢。所以可以使用concurrentHashMap</p><h2 id="hashmap与concurrenthashmap"><a class="markdownIt-Anchor" href="#hashmap与concurrenthashmap"></a> HashMap与concurrentHashMap</h2><ol><li><p>区别<br /><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/HashMap%E4%B8%8EconcurrentHashMap%E7%9A%84%E5%8C%BA%E5%88%AB.png" alt="HashMap与concurrentHashMap的区别" /></p></li><li><p>concurrentHashMap线程安全吗，如何保证线程安全？</p><ul><li><p>hashtable容器在竞争激烈的并发环境下表现出效率低下的原因是所有访问hashtable的线程都必须竞争同一把锁，当容器中有多把锁时，每一把锁用于锁住容器中的一部分数据，那么当多线程访问容器内不同数据段的数据时，线程间不会存在锁竞争，从而提高了并发访问的效率，这也是concurrentHashMap采用的锁分段技术，当一个线程访问其中一个段的数据时，其他段的数据也能被其他线程所访问</p></li><li><p>get的高效之处：get过程不需要加锁，除非读到的值是空的才需要加锁重读<br /><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/concurrentHashMap%E7%9A%84get%E6%96%B9%E6%B3%95%E9%AB%98%E6%95%88%E4%B9%8B%E5%A4%84.png" alt="concurrentHashMap的get方法高效之处" /></p></li><li><p>put方法首先定位到segment，然后在segment里进行插入操作<br /><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/concurrentHashMap%E7%9A%84put%E6%93%8D%E4%BD%9C%E6%AD%A5%E9%AA%A4.png" alt="concurrentHashMap的put操作步骤" /></p></li></ul></li></ol><h2 id="string-stringbuffer-stringbuilder"><a class="markdownIt-Anchor" href="#string-stringbuffer-stringbuilder"></a> String、StringBuffer、StringBuilder</h2><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/String%E3%80%81StringBuffer%E3%80%81StringBuilder.png" alt="String、StringBuffer、StringBuilder" /></p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/String%E7%9A%84%E4%B8%8D%E5%8F%98%E6%80%A7.png" alt="String的不变性" /></p><h2 id="string重写了object的hashcode和tostring重写equals不重写hashcode有什么问题"><a class="markdownIt-Anchor" href="#string重写了object的hashcode和tostring重写equals不重写hashcode有什么问题"></a> String重写了Object的hashCode和toString，重写equals()不重写hashCode()有什么问题？</h2><ul><li><p>当equals方法被重写，通常需要重写hashCode方法，以保证两个相等的对象必须有相同的hashCode</p><ul><li>object1.equals(object2)时为true，则object1.hashCode()==object2.hashCode()也为true</li><li>object1.hashCode()==object2.hashCode()为false，则 object1.equals(object2)一定为false</li><li>object1.hashCode()==object2.hashCode()为true，则object1.equals(object2)状态不确定</li></ul></li><li><p>在存储散列集合(如Set)时，如果原对象.equals(新对象)，但如果没有对hashCode重写，即两个对象拥有不同的hashCode，则在集合中会存储两个值相同的对象，从而导致混淆。<strong>因此，重写equals方法时，必须重写hashCode方法</strong></p></li></ul><h2 id="java序列化"><a class="markdownIt-Anchor" href="#java序列化"></a> Java序列化</h2><ol><li><p>定义：将那些实现了Serializable接口的对象转换成一个字节序列，并能够在以后将这个字节序列完全恢复到原来的对象，序列化可以弥补不同操作系统之间的差异</p></li><li><p>作用</p><ul><li>Java远程方法调用</li><li>对JavaBeans进行序列化</li></ul></li><li><p>序列化与反序列化<br /><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.png" alt="序列化与反序列化" /></p></li></ol><p><em>注意事项：</em></p><ul><li>被static修饰的属性不会被序列化</li><li>对象的类名、属性都会被序列化，但是方法不会被序列化</li><li>要保证对象所在的类的属性可以被序列化</li><li>当通过网络、文件进行序列化时，必须按照写入的顺序读取对象</li><li>反序列化时必须有序列化对象时的class文件</li><li>最好显示的声明serializableID，因为在不同的JVM时，默认生成的serializableID不同，可能导致反序列化失败</li></ul><h2 id="多线程"><a class="markdownIt-Anchor" href="#多线程"></a> 多线程</h2><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/%E5%A4%9A%E7%BA%BF%E7%A8%8B.png" alt="多线程" /></p><p><em>线程安全</em></p><ul><li>定义：某个类的行为与其规范一致；不管多个线程是怎样的执行顺序和优先级，或是wait、sleep、join等，如果一个类在多线程访问下都正常，并且不需要额外的同步处理和协调，那么这就是线程安全。</li><li>如何保证线程安全：对变量使用volitate；对程序段进行加锁（synchronized、lock）</li><li>注意：非线程安全的集合可以在多线程中使用，但是不能用作多个线程共享的属性，只能作为某个线程独享的属性</li></ul><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%85%B1%E7%94%A8%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F.png" alt="多线程共用一个变量" /></p><h2 id="线程池"><a class="markdownIt-Anchor" href="#线程池"></a> 线程池</h2><p>定义：实现先创建若干个可执行的线程放入一个容器（池）中，当需要的时候，不用自行创建只需要从容器中获取，使用完毕后不需要销毁而是放入到容器中，从而减少创建和销毁线程对象的开销。</p><p><strong>设计线程池</strong><br /><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0.png" alt="创建线程池" /></p><h2 id="volatile关键字与synchronized的区别"><a class="markdownIt-Anchor" href="#volatile关键字与synchronized的区别"></a> volatile关键字与synchronized的区别</h2><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/%E5%8C%BA%E5%88%AB.png" alt="区别" /></p><h2 id="sleep与wait"><a class="markdownIt-Anchor" href="#sleep与wait"></a> sleep()与wait()</h2><ul><li>sleep是Thread类的方法</li><li>wait是Object类的方法</li><li>区别：<ul><li>sleep()方法（休眠）是线程类（Thread）的静态方法，调用此方法会让当前线程暂停执行指定的时间，将执行机会（CPU）让给其他线程，但是对象的锁依然保持，因此休眠时间结束后会自动恢复（线程回到就绪状态）</li><li>wait()是object类的方法，调用对象的wait()方法导致当前线程放弃对象的锁（线程暂停执行），进入对象的等待池（wait pool），只有调用对象的notify()方法（或notifyAll()方法）时才能唤醒等待池中的线程进入等锁池（lock pool），如果线程重新获得对象的锁就可以进入就绪状态</li></ul></li></ul><h2 id="synchronized与lock"><a class="markdownIt-Anchor" href="#synchronized与lock"></a> synchronized与lock</h2><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/synchronized%E4%B8%8Elock%E7%9A%84%E5%8C%BA%E5%88%AB.png" alt="synchronized与lock的区别" /></p><p>synchronized与static synchronized的区别：</p><ul><li>synchronized是对类的当前实例进行加锁，防止其他线程同时访问该类的该实例的所有synchronized锁，同一个类的不同实例之间没有这种约束</li><li>static synchronized是控制类的所有实例的访问，限制线程同时访问JVM中该类的所有实例同时访问对应的代码块</li></ul><h2 id="异常"><a class="markdownIt-Anchor" href="#异常"></a> 异常</h2><ul><li>Throwable是Java语言中所有错误和异常的超类，它有两个子类：<code>Error</code>和<code>Exception</code></li><li>异常种类<ul><li>Error：错误，是程序无法处理的，如OutOfMemeryError、ThreadDeath等，这种情况下交由JVM处理，一般会选择终止线程</li><li>Exception：程序可以处理的异常，它又分为<code>CheckedException</code>（受检异常）和<code>UnCheckedException</code>（不受检异常）<ul><li><code>CheckedException</code>：发生在编译阶段，必须使用<code>try...catch...</code>或者<code>throws</code>，否则编译不通过。</li><li><code>UnCheckedException</code>：发生在运行期，一般由程序的逻辑问题引起。</li></ul></li></ul></li></ul><h2 id="java中的nio-bio-aio分别是什么"><a class="markdownIt-Anchor" href="#java中的nio-bio-aio分别是什么"></a> Java中的NIO、BIO、AIO分别是什么？</h2><ol><li><p>BIO</p><ul><li>同步并阻塞，服务器实现模式为<code>一个连接一个线程</code>，即客户端有请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情就会造成不必要的线程开销，可以通过线程池机制来改善</li><li>BIO方式适用于<code>连接数目比较小且固定的架构</code>，这种方式对服务器资源要求比较高，并发局限于应用中</li></ul></li><li><p>NIO</p><ul><li>同步非阻塞，服务器实现模式为<code>一个请求一个线程</code>，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时，才启动一个线程进行处理</li><li>NIO方式适用于<code>连接数多且连接比较短的架构</code>，比如聊天服务器，并发局限于应用中</li></ul></li><li><p>AIO</p><ul><li>异步非阻塞，服务器实现模式为<code>一个有效请求一个线程</code>，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理</li><li>AIO方式适用于<code>连接数目多且连接比较长的架构</code>，比如相册服务器，充分调用OS参与并发操作</li></ul></li></ol><h2 id="java内存模型java-memory-modeljmm"><a class="markdownIt-Anchor" href="#java内存模型java-memory-modeljmm"></a> Java内存模型（Java Memory model，JMM）</h2><p>对于并发编程，有两个关键问题：线程之间的<strong>通信和同步</strong></p><h3 id="线程之间的通信"><a class="markdownIt-Anchor" href="#线程之间的通信"></a> 线程之间的通信</h3><p>线程的通信是指线程之间以何种机制来交换信息。在命令式编程中，线程之间的通信机制有两种<strong>共享内存和消息传递。</strong><br />典型的共享内存通信方式就是通过<strong>共享对象</strong>来进行通信。典型的消息传递方式就是<strong>wait()和notify()。</strong></p><h3 id="线程之间的同步"><a class="markdownIt-Anchor" href="#线程之间的同步"></a> 线程之间的同步</h3><p>同步是指程序用于控制不同线程之间操作发生相对顺序的机制。<br />在共享内存并发模型里，同步是显式进行的。程序必须显式指定某个方法或某段代码需要在线程之间互斥执行。<br />在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。</p><h3 id="java的并发采用的是共享内存模型"><a class="markdownIt-Anchor" href="#java的并发采用的是共享内存模型"></a> Java的并发采用的是共享内存模型</h3><p>JMM决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来讲，JMM定义了线程和主内存之间的抽象关系：**线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，本地内存中存储了该线程以读/写共享变量的副本。**本地内存是JMM的一个抽象概念，并不真实存在。</p><p><em>线程之间的通信方式：首先，线程A把本地内存A中更新过的共享变量刷新到主内存中。然后，线程B到主内存中去读取线程A之前已更新过的共享变量。</em></p><p>从整体来看，这两个步骤实质上是线程A在向线程B发送消息，而且这个通信过程必须要经过主内存。JMM通过控制主内存与每个线程的本地内存之间的交互，来为Java程序员提供<strong>内存可见性保证</strong>。</p><h3 id="jvm对java内存模型的实现"><a class="markdownIt-Anchor" href="#jvm对java内存模型的实现"></a> JVM对Java内存模型的实现</h3><p>在JVM内部，Java内存模型把内存分成了两个部分：线程栈区和堆区。下图展示了Java内存模型在JVM中的逻辑视图：<br /><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/20160921182837697.jpg" alt="" /></p><p>JVM中运行的每个线程都拥有自己的线程栈，线程栈包括了当前线程执行的方法调用相关信息，我们也把它称作调用栈。随着代码的执行，调用栈会不断的变化。</p><p><strong>线程栈</strong>还包含了当前方法的所有本地变量信息。一个线程只能读取自己的线程栈，也就是说，**线程中的本地变量对其他线程是不可见的。**即使两个线程执行的是同一段代码，它们也会各自在自己的线程栈创建本地变量，因此，<strong>每个线程中的本地变量都有自己的版本。</strong><br />所有原始类型（boolean、byte、short、int、long、char、float、double）的本地变量都直接保存在线程栈中，对于它们的值各个线程都相互独立。对于原始类型的本地变量，一个线程可以传递一个副本给另一个线程，当它们之间是无法共享的。</p><p><strong>堆区</strong>包含了Java应用创建的所有对象信息，不管对象是哪个线程创建的，其中的对象包括原始类型的封装类（如Byte、Integer、Long等）。不管对象是属于一个成员变量还是方法中的本地变量，它都会被存储在堆区。</p><ul><li>一个本地变量如果是原始类型，那么它会被完全存储到栈区。</li><li>一个本地变量也有可能是一个对象的引用，这种情况下，这个本地引用会被存储到栈中，但是对象本身仍然存储在堆区。</li><li>对于一个对象的成员方法，这些方法中包含本地变量，仍需要存储在栈区，即使它们所属的对象在堆区。</li><li>对于一个对象的成员变量，不管它是原始类型还是包装类型，都会被存储到堆区。</li><li>Static类型的变量以及类本身相关信息都会随着类本身存储在堆区。</li></ul><p>堆中的对象可以被多线程共享。如果一个线程获得一个对象的应用，它便可访问这个对象的成员变量。如果两个线程同时调用了同一个对象的同一个方法，那么这两个线程便可同时访问这个对象的成员变量，但是对于本地变量，每个线程都会拷贝一份到自己的线程栈中。</p><p>下图是上面的全部过程：<br /><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/20160921182948601.jpg" alt="" /></p><h3 id="共享对象的可见性与竞争现象"><a class="markdownIt-Anchor" href="#共享对象的可见性与竞争现象"></a> 共享对象的可见性与竞争现象</h3><p>volatile关键字可以保证变量会直接从主存读取，而对变量的更新也会直接写到主存。volatile原理是基于CPU内存屏障指令实现的。<br />synchronized代码块可以保证同一个时刻只能有一个线程进入代码竞争区，synchronized代码块也能保证代码块中所有变量都将会从主存中读，当线程退出代码块时，对所有变量的更新将会flush到主存，不管这些变量是不是volatile类型的。</p><h3 id="volatile和synchronized的区别"><a class="markdownIt-Anchor" href="#volatile和synchronized的区别"></a> volatile和synchronized的区别</h3><p>首先理解线程安全的两个方面：<strong>执行控制和内存可见</strong>。<br />执行控制的目的是控制代码执行顺序及是否可以并发执行。<br />内存可见指的是线程执行结果在内存中对其他线程的可见性。根据Java内存模型的实现，线程在具体执行时，会先拷贝主存数据到线程本地（CPU缓存），操作完成后再把结果从线程本地刷到主存。</p><p><strong>synchronized关键字解决的是执行控制的问题</strong>，它会阻止其他线程获得当前对象的监控锁，这样使得当前被synchronized修饰的代码块无法被其他线程访问，也就无法并发执行。更为重要的是，synchronized还会创建<strong>内存屏障</strong>，内存屏障指令保证了所有CPU操作结果都会刷新到主存中，从而保证了内存可见性，<strong>同时也使得先获得这个锁的线程都happens-before与随后获得这个锁的线程。</strong></p><p>volatile关键字解决的是内存可见的问题，该关键字会使得被修饰的变量读写都会直接刷新到主存中，这样就保证了内存可见。<strong>该种方式可以保证内存可见性但是对读取没有要求的需求中。</strong></p><blockquote><p>使用volatile仅能实现对原始变量（如short、boolean、int等）操作的原子性，但是不能保证复合操作的原子性。例如，对于i++，实际上是由多个原子操作组成，如果使用多个线程去操作i++，则只能保证他们所操作的变量i在同一块内存区域，但是存在写入脏数据的情况。</p></blockquote><p><strong>使用volatile关键字要满足以下条件：</strong></p><ul><li>对变量的写入操作不依赖与变量的当前值，或者可以确保只有单个线程在操作变量</li><li>该变量没有包含在具有其他变量的不变式中</li></ul><p><strong>总结如下：</strong><br /><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/volatile%E4%B8%8Esynchronized%E7%9A%84%E5%8C%BA%E5%88%AB.png" alt="volatile与synchronized的区别" /></p><h3 id="java内存模型的基础原理"><a class="markdownIt-Anchor" href="#java内存模型的基础原理"></a> Java内存模型的基础原理</h3><ul><li>指令重排序：<br />为了提高程序的执行性能，编译器和处理器都会对指令进行重排序，但是JMM确保在不同的编译器和处理器平台下，通过插入指定类型的内存屏障来禁止编译器重排序和处理器重排序，为上层提供一致的内存可见性保证。</li></ul><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/%E6%8C%87%E4%BB%A4%E5%BA%8F%E5%88%97%E7%9A%84%E9%87%8D%E6%8E%92%E5%BA%8F.png" alt="指令序列的重排序" /></p><ul><li>数据依赖性：<br />如果两个操作在访问同一个变量，且这两个操作有一个是写操作，此时两个操作之间存在数据依赖性。</li></ul><p>编译器重排序和处理器重排序不会改变数据依赖性关系的两个操作之间的执行顺序，即不会重排序。</p><p><strong>注意：</strong><br />这里所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器和线程间之间的数据依赖性不被编译器和处理器所考虑。</p><ul><li>as-if-serial*<br />不过怎么重排序，单线程下的执行结果不能改变，编译器、runtime（运行时）和处理器都必须遵守as-if-serial语义</li></ul><h3 id="内存屏障memory-barrier"><a class="markdownIt-Anchor" href="#内存屏障memory-barrier"></a> 内存屏障（Memory Barrier）</h3><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C.png" alt="内存屏障" /></p><p><em>volatile内存语义的实现：</em><br /><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/volatile%E5%86%85%E5%AD%98%E8%AF%AD%E4%B9%89%E7%9A%84%E5%AE%9E%E7%8E%B0.png" alt="volatile内存语义的实现" /></p><p>对于volatile关键字，JMM采用保守策略</p><h3 id="happens-before策略"><a class="markdownIt-Anchor" href="#happens-before策略"></a> happens-before策略</h3><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/happens-before%E8%A7%84%E5%88%99.png" alt="happens-before规则" /></p><p><strong>注意：</strong><br />两个操作之间具有happens-before关系，并不意味前一个操作必须要在后一个操作之前执行！仅仅要求前一个操作的执行结果，对于后一个操作是可见的，且前一个操作按顺序排在后一个操作之前。</p><h2 id="解决hash冲突的几种方法"><a class="markdownIt-Anchor" href="#解决hash冲突的几种方法"></a> 解决hash冲突的几种方法</h2><h3 id="开放地址法"><a class="markdownIt-Anchor" href="#开放地址法"></a> 开放地址法</h3><ol><li><p>线性探测法：ThreadLocalMap<br />插入元素时，如果发生冲突，算法会简单的<strong>从该槽位置向后循环遍历hash表，直到找到表中的下一个空槽，并将该元素放入该槽中（会导致相同hash值的元素挨在一起和其他hash值对应的槽被占用）。</strong> 查找元素时，首先散列值所指向的槽，如果没有找到匹配，则继续从该槽遍历hash表，直到：（1）找到相应的元素；（2）找到一个空槽，指示查找的元素不存在，（所以不能随便删除元素）；（3）整个hash表遍历完毕（指示该元素不存在并且hash表是满的）<br />用线性探测法处理冲突，思路清晰，算法简单，但存在下列缺点：<br />① 处理溢出需另编程序。一般可另外设立一个溢出表，专门用来存放上述哈希表中放不下的记录。此溢出表最简单的结构是顺序表，查找方法可用顺序查找。<br />② 按上述算法建立起来的哈希表，删除工作非常困难。如果将此元素删除，查找的时会发现空槽，则会认为要找的元素不存在。只能标上已被删除的标记，否则，将会影响以后的查找。<br />③ 线性探测法很容易产生堆聚现象。所谓堆聚现象，就是存入哈希表的记录在表中连成一片。按照线性探测法处理冲突，如果生成哈希地址的连续序列愈长 ( 即不同关键字值的哈希地址相邻在一起愈长 ) ，则当新的记录加入该表时，与这个序列发生冲突的可能性愈大。因此，哈希地址的较长连续序列比较短连续序列生长得快，这就意味着，一旦出现堆聚 ( 伴随着冲突 ) ，就将引起进一步的堆聚。</p></li><li><p>线程补偿探测法<br />线性补偿探测法的基本思想是：将线性探测的步长从 1 改为 Q ，即将上述算法中的<br />hash ＝ (hash ＋ 1) % m 改为：hash ＝ (hash ＋ Q) % m = hash % m + Q % m，**而且要求 Q 与 m 是互质的，**以便能探测到哈希表中的所有单元。</p></li><li><p>伪随机探测<br />随机探测的基本思想是：将线性探测的步长从常数改为随机数，即令： hash ＝ (hash ＋ RN) % m ，其中 RN 是一个随机数。在实际程序中应预先用随机数发生器产生一个随机序列，将此序列作为依次探测的步长。这样就能使不同的关键字具有不同的探测次序，从而可以避 免或减少堆聚。基于与线性探测法相同的理由，在线性补偿探测法和随机探测法中，删除一个记录后也要打上删除标记。</p></li></ol><h3 id="拉链法"><a class="markdownIt-Anchor" href="#拉链法"></a> 拉链法</h3><p>HashMap<br />拉链法的优点<br />与开放定址法相比，拉链法有如下几个优点：<br />①拉链法处理冲突简单，且无堆积现象，即非同义词决不会发生冲突，因此平均查找长度较短；<br />②由于拉链法中各链表上的结点空间是动态申请的，故它更适合于造表前无法确定表长的情况；<br />③开放定址法为减少冲突，要求装填因子α较小，故当结点规模较大时会浪费很多空间。而拉链法中可取α≥1，且结点较大时，拉链法中增加的指针域可忽略不计，因此节省空间；<br />④在用拉链法构造的散列表中，删除结点的操作易于实现。只要简单地删去链表上相应的结点即可。</p><p>拉链法的缺点<br />　拉链法的缺点是：指针需要额外的空间，故当结点规模较小时，开放定址法较为节省空间，而若将节省的指针空间用来扩大散列表的规模，可使装填因子变小，这又减少了开放定址法中的冲突，从而提高平均查找速度。</p><h3 id="再散列双重散列-多重散列"><a class="markdownIt-Anchor" href="#再散列双重散列-多重散列"></a> 再散列（双重散列、多重散列）</h3><p>当发生冲突时，使用第二个、第三个、哈希函数计算地址，直到无冲突时。缺点：计算时间增加。</p><h3 id="建立一个公共溢出区"><a class="markdownIt-Anchor" href="#建立一个公共溢出区"></a> 建立一个公共溢出区</h3><p>假设哈希函数的值域为[0,m-1],则设向量HashTable[0…m-1]为基本表，另外设立存储空间向量OverTable[0…v]用以存储发生冲突的记录。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;java的四个特性抽象-封装-继承-多态对多态的理解多态的实现方式&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#java的四个特性抽象-封装-继承-多态对多态的理解多态的实现方式&quot;&gt;&lt;/a&gt; Java的四个特性（抽象、封装、继承、多态
      
    
    </summary>
    
    
      <category term="基础知识总结" scheme="https://toyan.top/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
      <category term="Java" scheme="https://toyan.top/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/Java/"/>
    
    
      <category term="Java" scheme="https://toyan.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>关于互联网行业的一些看法（摘抄）</title>
    <link href="https://toyan.top/view-for-internet/"/>
    <id>https://toyan.top/view-for-internet/</id>
    <published>2018-08-31T16:00:00.000Z</published>
    <updated>2020-02-06T12:04:30.551Z</updated>
    
    <content type="html"><![CDATA[<h2 id="这是最坏的时代也是最好的时代"><a class="markdownIt-Anchor" href="#这是最坏的时代也是最好的时代"></a> 这是最坏的时代，也是最好的时代</h2><h3 id="字节跳动"><a class="markdownIt-Anchor" href="#字节跳动"></a> 字节跳动</h3><p>今日头条打造“千人千面”的客户端，撕开了四大门户的壁垒；抖音利用年轻人的内心，结合其强大的内容分发机制，占据了原本属于微信的用户使用时间，使得腾讯不得不做出调整，也让新浪微博产生了一丝恐惧，而且自有的推荐算法也让其广告业务迅速盈利，使得百度在其原有的凤巢基础上成立新部门以应对头条的威胁。</p><h3 id="滴滴"><a class="markdownIt-Anchor" href="#滴滴"></a> 滴滴</h3><p>背靠腾讯以及阿里这两个大金主，将Uber赶出中国市场，打造了中国最大的出行平台。</p><h3 id="美团"><a class="markdownIt-Anchor" href="#美团"></a> 美团</h3><p>作为全球绝无仅有的独特理念，打造了全球最大的餐饮外卖服务提供商，并大手笔收购摩拜，解决了当下人们的“最后一公里”问题。</p><h3 id="拼多多"><a class="markdownIt-Anchor" href="#拼多多"></a> 拼多多</h3><p>原本以为京东和淘宝已经形成了无人撼动的地位，但是拼多多利用“社交+电商”的模式，利用腾讯提供的优势，作成了多年来腾讯一直想实现的“电商梦”，困扰京东淘宝多年的用户下沉问题也随之解决。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;这是最坏的时代也是最好的时代&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#这是最坏的时代也是最好的时代&quot;&gt;&lt;/a&gt; 这是最坏的时代，也是最好的时代&lt;/h2&gt;
&lt;h3 id=&quot;字节跳动&quot;&gt;&lt;a class=&quot;markdownIt-Anc
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://toyan.top/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="https://toyan.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>数据库总结</title>
    <link href="https://toyan.top/database-summary/"/>
    <id>https://toyan.top/database-summary/</id>
    <published>2018-08-27T16:00:00.000Z</published>
    <updated>2020-02-07T14:49:24.453Z</updated>
    
    <content type="html"><![CDATA[<h2 id="事务四大特性acid"><a class="markdownIt-Anchor" href="#事务四大特性acid"></a> 事务四大特性（ACID）</h2><p>数据库事务是指作为单个逻辑工作单元执行的一系列操作，这些操作要么全做要么全不做，是一个不可分割的工作单位。</p><ol><li>原子性(Atomicity)<br />事务的原子性是指，事务中包含的程序作为数据库的逻辑工作单位，它所做的对数据的修改操作要么全部执行，要么完全不执行。这种特性称为原子性。</li><li>一致性(Consistency)<br />事务一致性指的是在一个事务执行之前和执行之后数据库都必须处于一致性状态。这种特性称为事务的一致性。假如数据库的状态满足所有的完整性约束，就说该数据库是一致的。例如完整性约束：a + b = 10，一个事物改变了a，那么b也随之改变。</li><li>分离性(也称为独立性，lsolation)<br />分离性指并发的事务是相互隔离的。即一个事物内部的操作及正在操作的数据必须封锁起来，不被其他企图进行修改的事务看到。假如并发交叉执行的事务没有任何限制，操纵相关的共享对象的多个并发事务的执行可能引起异常。</li><li>持久性(Durability)<br />持久性意味着当系统或介质发生故障时，确保已提交事务的更新不能丢失。即一旦一个事务提交，DBMS保证它对数据库中数据的改变应该是永久性的，即对已提交事务的更新能恢复。持久性通过数据库备份和恢复来保证。</li></ol><h2 id="事务隔离性以及在mysql中的实践"><a class="markdownIt-Anchor" href="#事务隔离性以及在mysql中的实践"></a> 事务隔离性以及在MySQL中的实践</h2><p>数据库事务是指作为单个逻辑工作单元执行的一系列操作，要么全部执行，要么全部不执行。一方面，当多个应用程序并发访问数据库时，事务可以在应用程序间提供一个隔离方法，防止互相干扰；另一方面，事务为数据库操作序列提供了一个从失败恢复正常的方法。</p><p>当多个线程都开启事务操作数据库中的数据时，数据库系统要能进行隔离操作，以保证各个线程获取数据的准确性。</p><ol><li><p>如果没有隔离，会发生以下情况</p><ul><li>脏读：对于两个事务T1、T2，T1读取了已经被T2更新但还没有提交的字段，之后，若T2回滚，T1读取到的内容就是临时无效的内容。</li><li>不可重复读：对于事务T1、T2，T1需要读取一个字段两次，在第一次和第二次读取之间，T2更新了该字段，导致T1第二次读取到的内容值不同。</li><li>幻读：事务A读取与搜索条件相匹配的若干行。事务B以插入或删除行等方式来修改事务A的结果集，然后再提交。幻读与不可重复读之间的区别是幻读强调的是新增或删除，而不可重复读强调的是修改。比如Mary两次查工资，中间有人改过工资，则两次结果不一样，这就是不可重复读。Mary要查工资一千的人数，第一次查到了10个，中间有人增加了一条工资为一千的人，下次查的时候就变成了11个，好像第一次查询的是幻觉一样。</li></ul></li><li><p>事务的四个隔离级别<br />读未提交、读已提交、可重复读、串行化。四个级别增强逐渐增强，每个级别解决上个级别的一个问题。</p><ul><li>读未提交：另一个事务修改了数据，但尚未提交，而本事务中的select会读到这些未被提交的数据（脏读）。脏读是指另一个事务修改了数据，但尚未提交，而本事务中的select会读到这些未被提交的数据</li><li>读已提交：本事务读取到的是最新的数据（其他事务提交后）。问题是，在同一事务里，前后两次相同的select会读到不同的结果（不可重复读）。不可重复读是指同一个事务执行过程中，另外一个事务提交了新数据，因此本事务先后两次读到的数据结果会不一致。</li><li>可重复读：在同一个事务里，select的结果是事务开始时间点的状态，同样的select操作读到的结果会是一致的，但是有幻读现象。可重复读保证了同一个事务里，查询的结果都是事务开始时的状态（一致性）。但是，如果另一个事务同时提交了新数据，本事务再更新时，就会发现了这些新数据，貌似之前读到的数据都是幻觉，这就是幻读。</li><li>串行化：所有事务只能一个接一个串行执行，不能并行</li></ul></li></ol><p><strong>隔离级别的选择</strong><br />MySQL支持四种隔离级别，默认的是可重复读</p><h2 id="mysql的两种存储引擎区别"><a class="markdownIt-Anchor" href="#mysql的两种存储引擎区别"></a> MYSQL的两种存储引擎区别</h2><ul><li>MyISAM类型不支持事务处理等高级处理，而InnoDB类型支持</li><li>MyISAM表不支持外键，InnoDB支持</li><li>MyISAM锁的粒度是表级，而InnoDB支持行级锁定<br />MyISAM相对简单，所以在效率上要优于InnoDB，小型应用可以考虑使用MyISAM，当你的数据库有大量的写入、更新操作而查询比较少或者数据完整性要求比较高的时候就选择Innodb表。当你的数据库主要以查询为主，相比较而言更新和写入比较少，并且业务方面数据完整性要求不那么严格，就选择mysiam表。</li></ul><p><strong>应用场景：</strong></p><ul><li>MyIASM管理非事务表，提供高速存储和检索以及全文搜索能力，如果在应用中执行大量的select操作，应该选择MyIASM</li><li>InnoDB用于事务处理，具有ACID事务支持等特性，如果在应用中执行大量的insert和update操作，应该选择InnoDB</li></ul><h2 id="数据库的优化从sql语句优化和索引两个部分回答"><a class="markdownIt-Anchor" href="#数据库的优化从sql语句优化和索引两个部分回答"></a> 数据库的优化（从sql语句优化和索引两个部分回答）</h2><ol><li><p>只返回需要的数据</p><ul><li>不要写select * 的语句</li><li>合理写where子句，不要写没有where的SQL语句</li></ul></li><li><p>尽量少做重复的工作</p><ul><li>可以合并一些SQL语句</li></ul></li><li><p>适当建立索引（不是越多越好）但以下几点会进行全表扫描</p><ul><li>左模糊查询‘%…’</li><li>使用了不等操作符!=</li><li>or使用不当，or两边都必须有索引才行</li><li>in、not in</li><li>where子句对字段进行表达式操作</li><li>对于创建的复合索引（从最左边开始组合），查询条件用到的列必须从左边开始不能间隔。否则无效，复合索引的结构与电话簿类似</li><li>全文索引：当对于文件建立了一个以词库为目录的索引（文件大全文索引比模糊匹配效果好）</li></ul></li><li><p>使用join代替子查询</p></li><li><p>使用union代替手动创建临时表</p></li></ol><h2 id="乐观锁与悲观锁"><a class="markdownIt-Anchor" href="#乐观锁与悲观锁"></a> 乐观锁与悲观锁</h2><p>当并发事务同时访问一个资源时，有可能导致数据不一致，因此需要一种机制来将数据访问顺序化，以保证数据库数据的一致性。锁就是其中一种机制。在计算机科学中，锁时在执行多线程时用于强行限制资源访问的同步机制，即用于在并发控制保证对互斥要求的满足。在数据库的锁机制中，数据库管理系统中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。</p><p>乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。</p><p>悲观锁是一种并发控制的方法。它可以阻止一个事务以影响其他用户的方式来修改数据。如果一个事务执行的操作对某行数据应用了锁，那只有当这个事务把锁释放，其他事务才能够执行与该锁冲突的操作。主要用于数据争用激烈的环境，以及发生冲突时使用锁保护数据的成本要低于该锁冲突的操作。</p><p>悲观锁的流程：在对任意记录进行修改前，先尝试为该记录加上排他锁；如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁。期间有任何对该记录做修改或加排他锁的操作，都会等待我们解锁或者直接抛出异常。</p><p>悲观锁的缺点：悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；另外，在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载；还有会降低了并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数据。</p><p>乐观锁，它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各种影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，在没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。</p><p>相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是记录数据版本。实现数据版本有两种方式，<strong>第一种是使用版本号，第二种是使用时间戳</strong>。</p><p>乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。但如果直接简单这么做，还是有可能会遇到不可预期的结果，例如两个事务都读取了数据库的某一行，经过修改以后写回数据库，这时就遇到了问题。</p><h2 id="关系型数据库和非关系型数据库区别"><a class="markdownIt-Anchor" href="#关系型数据库和非关系型数据库区别"></a> 关系型数据库和非关系型数据库区别</h2><p>一般非关系数据库是基于CAP模型，而传统的关系型数据库是基于ACID模型的</p><ol><li>数据存储结构<br />首先关系型数据库一般都有固定的表结构，并且需要通过DDL语句来修改表结构，不是很容易进行扩展，而非关系数据库的存储机制就有很多了，比如基于文档的、K-V键值对的，还有基于图的等，对于数据的格式十分灵活没有固定的表结构，方便扩展，因此如果业务的数据结构并不是固定的或者经常变动比较大的，那么非关系数据库是个好的选择。</li><li>可扩展性<br />传统的关系型数据库给人一种横向扩展难，不好对数据进行分片等，而一些非关系型数据库则原生就支持数据的水平扩展，并且这可能也是很多NoSQL的一大卖点，其实像MySQL这种关系型数据库的水平扩展也不是很难，即使NoSQL水平扩展容易但对于向跨分片进行joins没有好的解决办法。不管是关系型还是非关系型数据库，解决水平扩展或者跨分片Joins这种场景，在应用层和数据库层中间加一层中间件来做数据处理也许是个好的办法。</li><li>数据一致性<br />非关系型数据库一般强调的是数据最终一致性，而没有像ACID一样强调数据的强一致性，从非关系型数据库中读到的有可能还是处于一个中间态的数据，因此如果你的业务对于数据的一致性要求很高，那么应该选择关系型数据库。非关系型数据库可能更多的偏向于OLAP场景，而关系型数据库更多偏向于OLTP场景。</li></ol><p>博客<a href="http://www.cnblogs.com/wanghongyun/p/6193912.html" target="_blank" rel="noopener">SQL与NoSQL（关系型与非关系型）数据库的区别</a></p><h2 id="聚集索引与非聚集索引以及sql的查询优化技术"><a class="markdownIt-Anchor" href="#聚集索引与非聚集索引以及sql的查询优化技术"></a> 聚集索引与非聚集索引以及SQL的查询优化技术</h2><p>聚集索引：聚集索引的顺序就是数据的物理存储顺序；<br />非聚集索引：索引顺序与数据物理排列顺序无关。<br />正因为如此，所以一个表最多只能有一个聚簇索引。简单来说，聚簇索引的叶子节点就是数据节点，非聚簇索引的叶节点仍然为索引节点，只不过有一个指针指向对应的数据块。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;事务四大特性acid&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#事务四大特性acid&quot;&gt;&lt;/a&gt; 事务四大特性（ACID）&lt;/h2&gt;
&lt;p&gt;数据库事务是指作为单个逻辑工作单元执行的一系列操作，这些操作要么全做要么全不做，是一个不可分
      
    
    </summary>
    
    
      <category term="基础知识总结" scheme="https://toyan.top/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
      <category term="数据库" scheme="https://toyan.top/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="https://toyan.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>排序算法</title>
    <link href="https://toyan.top/algorithm-sort/"/>
    <id>https://toyan.top/algorithm-sort/</id>
    <published>2018-08-15T16:00:00.000Z</published>
    <updated>2020-02-04T13:43:23.740Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Sort;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: hta</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2018/03/26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 22:03</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 冒泡排序</span></span><br><span class="line"><span class="comment"> * o(n^2)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">bubbleSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &gt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> tmp = nums[j];</span><br><span class="line">                    nums[j] = nums[j + <span class="number">1</span>];</span><br><span class="line">                    nums[j + <span class="number">1</span>] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        bubbleSort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">            System.out.print(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Sort;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: hta</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2018/03/26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 21:31</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 堆排序</span></span><br><span class="line"><span class="comment"> * o(nlogn)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 先建立最大堆，然后排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">heapSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> index = nums.length;</span><br><span class="line">        heapify(nums);</span><br><span class="line">        <span class="keyword">while</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = nums[index - <span class="number">1</span>];</span><br><span class="line">            nums[index - <span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line">            nums[<span class="number">0</span>] = tmp;</span><br><span class="line"></span><br><span class="line">            index--;</span><br><span class="line">            helper(nums, index, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">            System.out.print(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (nums.length - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            helper(nums, nums.length, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> len, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (k &lt; len) &#123;</span><br><span class="line">            <span class="keyword">int</span> largest = k;</span><br><span class="line">            <span class="keyword">if</span> (k * <span class="number">2</span> + <span class="number">1</span> &lt; len &amp;&amp; nums[largest] &lt; nums[k * <span class="number">2</span> + <span class="number">1</span>]) &#123;</span><br><span class="line">                largest = k * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (k * <span class="number">2</span> + <span class="number">2</span> &lt; len &amp;&amp; nums[largest] &lt; nums[k * <span class="number">2</span> + <span class="number">2</span>]) &#123;</span><br><span class="line">                largest = k * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (k == largest) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> tmp = nums[largest];</span><br><span class="line">            nums[largest] = nums[k];</span><br><span class="line">            nums[k] = tmp;</span><br><span class="line"></span><br><span class="line">            k = largest;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Sort;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: hta</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2018/03/26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 20:03</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 希尔排序</span></span><br><span class="line"><span class="comment"> * o(n^1.5)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">insertShell</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> len = n / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (len &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - len; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nums[j] &gt; nums[j + len]) &#123;</span><br><span class="line">                        <span class="keyword">int</span> tmp = nums[j];</span><br><span class="line">                        nums[j] = nums[j + len];</span><br><span class="line">                        nums[j + len] = tmp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            len /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        insertSort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">            System.out.print(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Sort;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: hta</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2018/03/26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 19:52</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 直接插入排序，当前位置与它前面的数字比较，看插入哪一个位置</span></span><br><span class="line"><span class="comment"> * o(n^2)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">insertSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &gt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> tmp = nums[j];</span><br><span class="line">                    nums[j] = nums[j + <span class="number">1</span>];</span><br><span class="line">                    nums[j + <span class="number">1</span>] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        insertSort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">            System.out.print(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Sort;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by hta on 17-5-5.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        quickSort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            System.out.println(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= end) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = start;</span><br><span class="line">        <span class="keyword">int</span> right = end;</span><br><span class="line">        <span class="keyword">int</span> pivot = nums[(start + end) / <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">while</span> (left &lt;= right &amp;&amp; nums[left] &lt; pivot) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (left &lt;= right &amp;&amp; nums[right] &gt; pivot) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left &lt;= right) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[left];</span><br><span class="line">                nums[left] = nums[right];</span><br><span class="line">                nums[right] = temp;</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        quickSort(nums, start, right);</span><br><span class="line">        quickSort(nums, left, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Sort;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * author: hta</span></span><br><span class="line"><span class="comment"> * since: 上午10:45 17-5-6</span></span><br><span class="line"><span class="comment"> * time: O(nlogn)</span></span><br><span class="line"><span class="comment"> * param: int[] nums, int[] temp, int start, int end</span></span><br><span class="line"><span class="comment"> * return: void</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">mergeSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">55</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        mergeSort(nums, temp, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            System.out.println(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span>[] temp, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= end) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = start;</span><br><span class="line">        <span class="keyword">int</span> right = end;</span><br><span class="line">        <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">        mergeSort(nums, temp, left, mid);</span><br><span class="line">        mergeSort(nums, temp, mid + <span class="number">1</span>, right);</span><br><span class="line">        merge(nums, temp, start, mid, end);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span>[] temp, <span class="keyword">int</span> start, <span class="keyword">int</span> mid, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> leftIndex = start;</span><br><span class="line">        <span class="keyword">int</span> rightIndex = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> index = start;</span><br><span class="line">        <span class="keyword">while</span> (leftIndex &lt;= mid &amp;&amp; rightIndex &lt;= end) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[leftIndex] &lt;= nums[rightIndex]) &#123;</span><br><span class="line">                temp[index++] = nums[leftIndex++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp[index++] = nums[rightIndex++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (leftIndex &lt;= mid) &#123;</span><br><span class="line">            temp[index++] = nums[leftIndex++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (rightIndex &lt;= end) &#123;</span><br><span class="line">            temp[index++] = nums[rightIndex++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">            nums[i] = temp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Sort;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: hta</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2018/03/26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 20:59</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 简单选择排序</span></span><br><span class="line"><span class="comment"> * o(n^2)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">selectSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> min = nums[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; min) &#123;</span><br><span class="line">                    <span class="keyword">int</span> tmp = nums[j];</span><br><span class="line">                    nums[j] = min;</span><br><span class="line">                    min = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[i] = min;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        selectSort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">            System.out.print(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://toyan.top/categories/algorithm/"/>
    
      <category term="sort" scheme="https://toyan.top/categories/algorithm/sort/"/>
    
    
      <category term="算法" scheme="https://toyan.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>操作系统总结</title>
    <link href="https://toyan.top/system-summary/"/>
    <id>https://toyan.top/system-summary/</id>
    <published>2018-08-14T16:00:00.000Z</published>
    <updated>2020-02-07T14:52:21.165Z</updated>
    
    <content type="html"><![CDATA[<h2 id="linux内核空间和用户空间详解"><a class="markdownIt-Anchor" href="#linux内核空间和用户空间详解"></a> Linux内核空间和用户空间详解</h2><h3 id="基础知识"><a class="markdownIt-Anchor" href="#基础知识"></a> 基础知识</h3><p>Linux简化了分段机制，使得虚拟地址与线性地址总是一致，因此，Linux的虚拟地址空间也为0~4G。Linux内核将这4G字节的空间分为两部分。**将较高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为“内核空间”。而将较低的3G字节（从虚拟地址 0x00000000到0xBFFFFFFF），供各个进程使用，称为“用户空间”。**因为各个进程可以通过系统调用进入内核，因此，Linux内核是系统内的所有进程共享。于是，从具体进程的角度来看，每个进程可以拥有4G字节的虚拟空间。</p><p>**Linux使用两级保护机制：0级供内核使用，3级供用户程序使用。**每个进程有各自的私有用户空间（0~3G），这个空间对系统中的其他进程是不可见的。最高的1GB字节虚拟内核空间则为所有进程以及内核所共享。</p><blockquote><p>内核空间中存放的是内核代码和数据，而进程的用户空间中存放的是用户程序的代码和数据。不管是内核空间还是用户空间，它们都处于虚拟空间中。</p></blockquote><p>虽然内核空间占据了每个虚拟空间中的最高1GB字节，但映射到物理内存却总是从最低地址（0x00000000）开始。对内核空间来说，其地址映射是很简单的线性映射，0xC0000000就是物理地址与线性地址之间的位移量，在Linux代码中就叫做PAGE_OFFSET。</p><p><strong>常见问题：</strong></p><ol><li>内核空间和用户空间之间如何进行通讯？<br />一般通过系统调用进行通信</li><li>如何判断一个驱动是用户模式还是内核模式驱动？判断的标志是什么？<br />用户空间模式的驱动一般通过系统调用来完成对硬件的访问，如通过系统调用将驱动的io空间映射到用户空间等。<strong>因此，主要的判断依据就是系统调用。</strong></li></ol><h3 id="内核态和用户态"><a class="markdownIt-Anchor" href="#内核态和用户态"></a> 内核态和用户态</h3><p>当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）。此时处理器处于特权级最高的（0级）内核代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。当进程在执行用户自己的代码时，则称其处于用户运行态（用户态）。即此时处理器在特权级最低的（3级）用户代码中运行。当正在执行用户程序而突然被中断程序中断时，此时用户程序也可以象征性地称为处于进程的内核态。因为中断处理程序将使用当前进程的内核栈。这与处于内核态的进程的状态有些类似。</p><h3 id="进程上下文和中断上下文"><a class="markdownIt-Anchor" href="#进程上下文和中断上下文"></a> 进程上下文和中断上下文</h3><p>处理器总处于以下状态中的一种：</p><ul><li>内核态，运行于进程上下文，内核代表进程运行于内核空间；</li><li>内核态，运行于中断上下文，内核代表硬件运行于内核空间；</li><li>用户态，运行于用户空间。</li></ul><p>用户空间的应用程序，通过系统调用，进入内核空间。这个时候用户空间的进程要传递很多变量、参数的值给内核，内核态运行的时候也要保存用户进程的一些寄存器值、变量等。所谓的“进程上下文”，可以看作是用户进程传递给内核的这些参数以及内核要保存的那一整套的变量和寄存器值和当时的环境等。</p><p>硬件通过触发信号，导致内核调用中断处理程序，进入内核空间。这个过程中，硬件的一些变量和参数也要传递给内核，内核通过这些参数进行中断处理。所谓的“中断上下文”，其实也可以看作就是硬件传递过来的这些参数和内核需要保存的一些其他环境（主要是当前被打断执行的进程环境）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;linux内核空间和用户空间详解&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#linux内核空间和用户空间详解&quot;&gt;&lt;/a&gt; Linux内核空间和用户空间详解&lt;/h2&gt;
&lt;h3 id=&quot;基础知识&quot;&gt;&lt;a class=&quot;markdownI
      
    
    </summary>
    
    
      <category term="基础知识总结" scheme="https://toyan.top/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
      <category term="操作系统" scheme="https://toyan.top/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="https://toyan.top/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
</feed>
