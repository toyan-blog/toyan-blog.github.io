<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Mybatis缓存机制"><meta name="keywords" content="Mybatis"><meta name="author" content="Toyan"><meta name="copyright" content="Toyan"><title>Mybatis缓存机制 | ToyanのBlog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
  google_ad_client: 'ca-pub-5300746137487021',
  enable_page_level_ads: 'true'
});
</script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?c61658fe357dc669ee95b5bd4e25caad";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="ToyanのBlog" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一级缓存"><span class="toc-number">1.</span> <span class="toc-text"> 一级缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#一级缓存介绍"><span class="toc-number">1.1.</span> <span class="toc-text"> 一级缓存介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#一级缓存配置"><span class="toc-number">1.2.</span> <span class="toc-text"> 一级缓存配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#一级缓存实验"><span class="toc-number">1.3.</span> <span class="toc-text"> 一级缓存实验</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#实验1"><span class="toc-number">1.3.1.</span> <span class="toc-text"> 实验1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实验2"><span class="toc-number">1.3.2.</span> <span class="toc-text"> 实验2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实验3"><span class="toc-number">1.3.3.</span> <span class="toc-text"> 实验3</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#一级缓存工作流程源码分析"><span class="toc-number">1.4.</span> <span class="toc-text"> 一级缓存工作流程&amp;源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#工作流程"><span class="toc-number">1.4.1.</span> <span class="toc-text"> 工作流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#源码分析"><span class="toc-number">1.4.2.</span> <span class="toc-text"> 源码分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-number">1.5.</span> <span class="toc-text"> 总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二级缓存"><span class="toc-number">2.</span> <span class="toc-text"> 二级缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#二级缓存介绍"><span class="toc-number">2.1.</span> <span class="toc-text"> 二级缓存介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二级缓存配置"><span class="toc-number">2.2.</span> <span class="toc-text"> 二级缓存配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二级缓存实验"><span class="toc-number">2.3.</span> <span class="toc-text"> 二级缓存实验</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#实验1-2"><span class="toc-number">2.3.1.</span> <span class="toc-text"> 实验1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实验2-2"><span class="toc-number">2.3.2.</span> <span class="toc-text"> 实验2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实验3-2"><span class="toc-number">2.3.3.</span> <span class="toc-text"> 实验3</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实验4"><span class="toc-number">2.3.4.</span> <span class="toc-text"> 实验4</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实验5"><span class="toc-number">2.3.5.</span> <span class="toc-text"> 实验5</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#四-二级缓存源码分析"><span class="toc-number">2.4.</span> <span class="toc-text"> 四、二级缓存源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#源码分析-2"><span class="toc-number">2.4.1.</span> <span class="toc-text"> 源码分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结-2"><span class="toc-number">2.5.</span> <span class="toc-text"> 总结</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/public/avatar.jpeg"></div><div class="author-info__name text-center">Toyan</div><div class="author-info__description text-center">Email: tonganhao1103@gmail.com</div><div class="follow-button"><a href="https://github.com/toyan-blog" target="_blank" rel="noopener">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">26</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">19</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">26</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="https://molunerfinn.com/hexo-theme-melody-doc/" target="_blank" rel="noopener">hexo-theme-melody</a><a class="author-info-links__name text-center" href="https://molunerfinn.com/" target="_blank" rel="noopener">Molunerfinn</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/public/blog.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">ToyanのBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">Mybatis缓存机制</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-09-26</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Web/">Web</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Web/Mybatis/">Mybatis</a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">5.7k</span><span class="post-meta__separator">|</span><span>Reading time: 22 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="一级缓存"><a class="markdownIt-Anchor" href="#一级缓存"></a> 一级缓存</h2>
<h3 id="一级缓存介绍"><a class="markdownIt-Anchor" href="#一级缓存介绍"></a> 一级缓存介绍</h3>
<p>在应用运行过程中，我们有可能在一次数据库会话中，执行多次查询条件完全相同的SQL，Mybatis提供了一级缓存的方案优化这部分场景，如果是相同的SQL语句，会优先命中一级缓存，避免直接对数据库进行查询，提高性能，具体执行过程如下图所示</p>
<p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/6e38df6a.jpg" alt="" /></p>
<p>每个SqlSession中持有了Executor，每个Executor中有一个LocalCache。当用户发起查询时，Mybatis根据当前执行的语句生成MappedStatement，在LocalCache进行查询，如果命中缓存的话，直接返回结果给用户，如果缓存没有命中的话，查询数据库，结果写入LocalCache，最后返回结果给用户。具体实现类的类关系图如下图所示。</p>
<p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/d76ec5fe.jpg" alt="" /></p>
<h3 id="一级缓存配置"><a class="markdownIt-Anchor" href="#一级缓存配置"></a> 一级缓存配置</h3>
<p>我们来看看如何使用Mybatis一级缓存。开发者只需在Mybatis的配置文件中，添加如下语句，就可以使用一级缓存。共有两个选项，<code>session</code>和<code>statement</code>，默认是<code>session</code>级别，即在一个Mybatis会话中执行的所有语句，都会共享这一个缓存，一种是<code>statement</code>级别，可以理解为缓存只对当前执行的这一个statement有效。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"localCacheScope"</span> <span class="attr">value</span>=<span class="string">"SESSION"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="一级缓存实验"><a class="markdownIt-Anchor" href="#一级缓存实验"></a> 一级缓存实验</h3>
<p>首先创建实例表，创建对应的POJO类和增改的方法</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`student`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">200</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`age`</span> <span class="built_in">tinyint</span>(<span class="number">3</span>) <span class="keyword">unsigned</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">4</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COLLATE</span>=utf8_bin;</span><br></pre></td></tr></table></figure>
<p>在以下实验中，id为1的学生名称是凯伦</p>
<h4 id="实验1"><a class="markdownIt-Anchor" href="#实验1"></a> 实验1</h4>
<p>开启一级缓存，范围为会话级别，调用三次<code>getStudentById</code>，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getStudentById</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  SqlSession sqlSession = factory.openSession(<span class="keyword">true</span>); <span class="comment">// 自动提交事务</span></span><br><span class="line">  StudentMapper studentMapper = sqlSession.getMapper(StudentMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  System.out.println(studentMapper.getStudentById(<span class="number">1</span>));</span><br><span class="line">  System.out.println(studentMapper.getStudentById(<span class="number">1</span>));</span><br><span class="line">  System.out.println(studentMapper.getStudentById(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/9e996384.jpg" alt="" /></p>
<p>我们能够看到，只要第一次真正查询了数据库，后续地查询使用了一级缓存</p>
<h4 id="实验2"><a class="markdownIt-Anchor" href="#实验2"></a> 实验2</h4>
<p>增加了对数据库的修改操作，验证在一次数据库会话中，如果对数据库发生了修改操作，一级缓存是否会失效</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addStudent</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  SqlSession sqlSession = factory.openSession(<span class="keyword">true</span>);</span><br><span class="line">  StudentMapper studentMapper = sqlSession.getMapper(StudentMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  System.out.println(studentMapper.getStudentById(<span class="number">1</span>));</span><br><span class="line">  System.out.println(<span class="string">"增加了"</span> + studentMapper.addStudent(buildStudent()) + <span class="string">"个学生"</span>);</span><br><span class="line">  System.out.println(studentMapper.getStudentById(<span class="number">1</span>));</span><br><span class="line">  sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/fb6a78e0.jpg" alt="" /></p>
<p>我们能够看到，在修改操作后执行的相同查询，查询了数据库，一级缓存失效</p>
<h4 id="实验3"><a class="markdownIt-Anchor" href="#实验3"></a> 实验3</h4>
<p>开启了两个SqlSession，在sqlSession中查询数据，使一级缓存生效，在sqlSession2中更新数据库，验证一级缓存只在数据库会话内部共享</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLocalCacheScope</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SqlSession sqlSession1 = factory.openSession(<span class="keyword">true</span>); </span><br><span class="line">        SqlSession sqlSession2 = factory.openSession(<span class="keyword">true</span>); </span><br><span class="line">        StudentMapper studentMapper = sqlSession1.getMapper(StudentMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        StudentMapper studentMapper2 = sqlSession2.getMapper(StudentMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(<span class="string">"studentMapper读取数据: "</span> + studentMapper.getStudentById(<span class="number">1</span>));</span><br><span class="line">        System.out.println(<span class="string">"studentMapper读取数据: "</span> + studentMapper.getStudentById(<span class="number">1</span>));</span><br><span class="line">        System.out.println(<span class="string">"studentMapper2更新了"</span> + studentMapper2.updateStudentName(<span class="string">"小岑"</span>,<span class="number">1</span>) + <span class="string">"个学生的数据"</span>);</span><br><span class="line">        System.out.println(<span class="string">"studentMapper读取数据: "</span> + studentMapper.getStudentById(<span class="number">1</span>));</span><br><span class="line">        System.out.println(<span class="string">"studentMapper2读取数据: "</span> + studentMapper2.getStudentById(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/f480ac76.jpg" alt="" /></p>
<p>sqlSession2更新了id为1的学生的姓名，从凯伦改为了小岑，但session1之后的查询中，id为1的学生的姓名还是凯伦，出现了脏数据，也证明了之前的设想，一级缓存只在数据库会话内部有效</p>
<h3 id="一级缓存工作流程源码分析"><a class="markdownIt-Anchor" href="#一级缓存工作流程源码分析"></a> 一级缓存工作流程&amp;源码分析</h3>
<p>那么，一级缓存的工作流程是怎样的呢？我们从源码层面来学习一下</p>
<h4 id="工作流程"><a class="markdownIt-Anchor" href="#工作流程"></a> 工作流程</h4>
<p>一级缓存执行额时序图，如下图所示</p>
<p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/bb851700.png" alt="" /></p>
<h4 id="源码分析"><a class="markdownIt-Anchor" href="#源码分析"></a> 源码分析</h4>
<p>接下来将对Mybatis查询相关的核心类和一级缓存的源码进行走读。这对后面学习二级缓存也有帮助</p>
<p>**SqlSession：**对外提供了用户和数据库之间交互需要的所有方法，隐藏了底层的细节，默认实现类是<code>DefaultSqlSession</code></p>
<p>![](/Users/haotongan/MyDocument/summary/personal/图片/屏幕快照 2019-09-22 上午10.44.50.png)</p>
<p><strong>Executor：</strong><code>SqlSession</code>向用户提供操作数据库的方法，但和数据库操作有关的职责都会委托给Executor</p>
<p>![](<a href="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2020/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7" target="_blank" rel="noopener">https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2020/屏幕快照</a> 2019-09-22 上午10.51.12.png)</p>
<p>如下图所示，Executor有若干个实现类，为Executor赋予了不同的能力，大家可以根据类名，自行学习每个类的基本作用</p>
<p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/83326eb3.jpg" alt="" /></p>
<p>在一级缓存的源码分析中，主要学习<code>BaseExecutor</code>的内部实现</p>
<p><strong>BaseExecutor：</strong><code>BaseExecutor</code>是一个实现了Executor接口的抽象类，定义若干抽象方法，在执行的时候，把具体的操作委托给子类进行执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">doUpdate</span><span class="params">(MappedStatement ms, Object parameter)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> List&lt;BatchResult&gt; <span class="title">doFlushStatements</span><span class="params">(<span class="keyword">boolean</span> isRollback)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> &lt;E&gt; <span class="function">Cursor&lt;E&gt; <span class="title">doQueryCursor</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException</span>;</span><br></pre></td></tr></table></figure>
<p>在一级缓存的介绍中提到对<code>LocalCache</code>的查询和写入是在<code>Executor</code>内部完成的，在阅读<code>BaseExecutor</code>的代码中发现<code>LocalCache</code>是<code>BaseExecutor</code>内部的一个成员变量，如下代码所示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"> 		<span class="keyword">protected</span> ConcurrentLinkedQueue&lt;BaseExecutor.DeferredLoad&gt; deferredLoads;</span><br><span class="line">    <span class="keyword">protected</span> PerpetualCache localCache;</span><br></pre></td></tr></table></figure>
<p>**Cache：**Mybatis中的Cache接口，提供了和缓存相关的最基本的操作，如下图所示</p>
<p>![](<a href="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2020/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7" target="_blank" rel="noopener">https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2020/屏幕快照</a> 2019-09-22 下午5.17.34.png)</p>
<p>有若干个实现类，使用装饰器模式互相组装，提供丰富的操控缓存的能力，部分实现类如下图所示：</p>
<p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/cdb21712.jpg" alt="" /><br />
<code>BaseExecutor</code>成员变量之一的<code>PerpetualCache</code>，是对Cache接口最基本的实现，其实现非常简单，内部持有HashMap，对一级缓存的操作实则是对HashMap的操作。如下代码所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PerpetualCache</span> <span class="keyword">implements</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Object, Object&gt; cache = <span class="keyword">new</span> HashMap();</span><br></pre></td></tr></table></figure>
<p>为执行和数据库的交互，首先需要初始化<code>SqlSession</code>，通过<code>DefaultSqlSessionFactory</code>开启<code>SqlSession</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SqlSession <span class="title">openSessionFromDataSource</span><span class="params">(ExecutorType execType, TransactionIsolationLevel level, <span class="keyword">boolean</span> autoCommit)</span> </span>&#123;</span><br><span class="line">  Transaction tx = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  DefaultSqlSession var8;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Environment environment = <span class="keyword">this</span>.configuration.getEnvironment();</span><br><span class="line">    TransactionFactory transactionFactory = <span class="keyword">this</span>.getTransactionFactoryFromEnvironment(environment);</span><br><span class="line">    tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);</span><br><span class="line">    <span class="comment">// 重要的两行代码</span></span><br><span class="line">    Executor executor = <span class="keyword">this</span>.configuration.newExecutor(tx, execType);</span><br><span class="line">    var8 = <span class="keyword">new</span> DefaultSqlSession(<span class="keyword">this</span>.configuration, executor, autoCommit);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception var12) &#123;</span><br><span class="line">    <span class="keyword">this</span>.closeTransaction(tx);</span><br><span class="line">    <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error opening session.  Cause: "</span> + var12, var12);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ErrorContext.instance().reset();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> var8;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在初始化<code>SqlSession</code>时，会使用<code>Configuration</code>类创建一个全新的<code>Executor</code>，作为<code>DefaultSqlSession</code>构造函数的参数，创建Executor代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Executor <span class="title">newExecutor</span><span class="params">(Transaction transaction, ExecutorType executorType)</span> </span>&#123;</span><br><span class="line">  executorType = executorType == <span class="keyword">null</span> ? <span class="keyword">this</span>.defaultExecutorType : executorType;</span><br><span class="line">  executorType = executorType == <span class="keyword">null</span> ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">  Object executor;</span><br><span class="line">  <span class="keyword">if</span> (ExecutorType.BATCH == executorType) &#123;</span><br><span class="line">    executor = <span class="keyword">new</span> BatchExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorType.REUSE == executorType) &#123;</span><br><span class="line">    executor = <span class="keyword">new</span> ReuseExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    executor = <span class="keyword">new</span> SimpleExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="comment">// 这里需要注意的是，如果两级缓存开关开启的话，是使用CachingExecutor装饰BaseExecutor的子类</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.cacheEnabled) &#123;</span><br><span class="line">    executor = <span class="keyword">new</span> CachingExecutor((Executor)executor);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Executor executor = (Executor)<span class="keyword">this</span>.interceptorChain.pluginAll(executor);</span><br><span class="line">  <span class="keyword">return</span> executor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>SqlSession</code>创建完毕后，根据Statment的不同类型，会进入<code>SqlSession</code>的不同方法中，如果是<code>Select</code>语句的话，最后会执行到<code>SqlSession</code>的<code>selectList</code>，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">selectList</span><span class="params">(String statement, Object parameter, RowBounds rowBounds)</span> </span>&#123;</span><br><span class="line">  List var5;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    MappedStatement ms = <span class="keyword">this</span>.configuration.getMappedStatement(statement);</span><br><span class="line">    var5 = <span class="keyword">this</span>.executor.query(ms, <span class="keyword">this</span>.wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception var9) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error querying database.  Cause: "</span> + var9, var9);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ErrorContext.instance().reset();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>SqlSession</code>把具体的查询职责委托给了Executor。如果只开启一级缓存的话，首先会进入<code>BaseExecutor</code>的<code>query</code>方法。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  BoundSql boundSql = ms.getBoundSql(parameter);</span><br><span class="line">  CacheKey key = <span class="keyword">this</span>.createCacheKey(ms, parameter, rowBounds, boundSql);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.query(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中，会先根据传入的参数生成CacheKey，进入该方法查看CacheKey是如何生成的，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CacheKey <span class="title">createCacheKey</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.closed) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">"Executor was closed."</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    CacheKey cacheKey = <span class="keyword">new</span> CacheKey();</span><br><span class="line">    cacheKey.update(ms.getId());</span><br><span class="line">    cacheKey.update(rowBounds.getOffset());</span><br><span class="line">    cacheKey.update(rowBounds.getLimit());</span><br><span class="line">    cacheKey.update(boundSql.getSql());</span><br><span class="line">    <span class="comment">// 后面是update了sql中带的参数</span></span><br><span class="line">    List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();</span><br><span class="line">    TypeHandlerRegistry typeHandlerRegistry = ms.getConfiguration().getTypeHandlerRegistry();</span><br><span class="line">    Iterator var8 = parameterMappings.iterator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(var8.hasNext()) &#123;</span><br><span class="line">      ParameterMapping parameterMapping = (ParameterMapping)var8.next();</span><br><span class="line">      <span class="keyword">if</span> (parameterMapping.getMode() != ParameterMode.OUT) &#123;</span><br><span class="line">        String propertyName = parameterMapping.getProperty();</span><br><span class="line">        Object value;</span><br><span class="line">        <span class="keyword">if</span> (boundSql.hasAdditionalParameter(propertyName)) &#123;</span><br><span class="line">          value = boundSql.getAdditionalParameter(propertyName);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parameterObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">          value = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) &#123;</span><br><span class="line">          value = parameterObject;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          MetaObject metaObject = <span class="keyword">this</span>.configuration.newMetaObject(parameterObject);</span><br><span class="line">          value = metaObject.getValue(propertyName);</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">// 最终需要的生成结果</span></span><br><span class="line">        cacheKey.update(value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.configuration.getEnvironment() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      cacheKey.update(<span class="keyword">this</span>.configuration.getEnvironment().getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cacheKey;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，将<code>MappedStatement</code>的Id、SQL的offset、SQL的limit、SQL本身以及SQL中的参数传入了CacheKey这个类，最终构成CacheKey。以下是这个类的内部结构：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MULTIPLYER = <span class="number">37</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_HASHCODE = <span class="number">17</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> multiplier;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> hashcode;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> checksum;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">private</span> List&lt;Object&gt; updateList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CacheKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.hashcode = DEFAULT_HASHCODE;</span><br><span class="line">  <span class="keyword">this</span>.multiplier = DEFAULT_MULTIPLYER;</span><br><span class="line">  <span class="keyword">this</span>.count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">this</span>.updateList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先是成员变量和构造函数，有一个初始的<code>hashCode</code>和乘数，同时维护了一个内部的<code>updateList</code>。在<code>CacheKey</code>的<code>update</code>方法中，会进行一个<code>hashCode</code>和<code>checkSum</code>的计算，同时把传入的参数添加进<code>updateList</code>中，如下代码所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> baseHashCode = object == <span class="keyword">null</span> ? <span class="number">1</span> : ArrayUtil.hashCode(object);</span><br><span class="line">  ++<span class="keyword">this</span>.count;</span><br><span class="line">  <span class="keyword">this</span>.checksum += (<span class="keyword">long</span>)baseHashCode;</span><br><span class="line">  baseHashCode *= <span class="keyword">this</span>.count;</span><br><span class="line">  <span class="keyword">this</span>.hashcode = <span class="keyword">this</span>.multiplier * <span class="keyword">this</span>.hashcode + baseHashCode;</span><br><span class="line">  <span class="keyword">this</span>.updateList.add(object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时重写了<code>CacheKey</code>的<code>equals</code>方法，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> == object) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(object <span class="keyword">instanceof</span> CacheKey)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    CacheKey cacheKey = (CacheKey)object;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.hashcode != cacheKey.hashcode) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.checksum != cacheKey.checksum) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.count != cacheKey.count) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.updateList.size(); ++i) &#123;</span><br><span class="line">        Object thisObject = <span class="keyword">this</span>.updateList.get(i);</span><br><span class="line">        Object thatObject = cacheKey.updateList.get(i);</span><br><span class="line">        <span class="keyword">if</span> (!ArrayUtil.equals(thisObject, thatObject)) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除去hashCode、checksum和count的比较外，只要updatelist中的元素一一对应相等，那么就可以认为是CacheKey相等。只要两条SQL的下列五个值相同，即可以认为是相同的SQL</p>
<blockquote>
<p>Statement Id + Offset + Limit + Sql + Params</p>
</blockquote>
<p>BaseExecutor的query方法继续往下走，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">list = resultHandler == <span class="keyword">null</span> ? (List)<span class="keyword">this</span>.localCache.getObject(key) : <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (list != <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="keyword">this</span>.handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  list = <span class="keyword">this</span>.queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果查不到的话，就从数据库查，在<code>queryFromDataBase</code>中，会对<code>localCache</code>进行写入</p>
<p>在<code>query</code>方法执行的最后，会判断一级缓存级别是否是<code>STATEMENT</code>级别，如果是的话，就清空缓存，这也就是<code>STATEMENT</code>级别的一级缓存无法共享<code>localCache</code>的原因。代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) &#123;</span><br><span class="line">  <span class="keyword">this</span>.clearLocalCache();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在源码分析的最后，我们确认一下，如果是<code>insert/delete/update</code>方法，缓存就会刷新的原因</p>
<p><code>SqlSession</code>的<code>insert</code>方法和<code>delete</code>方法，就会统一走<code>update</code>的流程，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insert</span><span class="params">(String statement, Object parameter)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.update(statement, parameter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(String statement, Object parameter)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.update(statement, parameter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(String statement, Object parameter)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> var4;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.dirty = <span class="keyword">true</span>;</span><br><span class="line">    MappedStatement ms = <span class="keyword">this</span>.configuration.getMappedStatement(statement);</span><br><span class="line">    var4 = <span class="keyword">this</span>.executor.update(ms, <span class="keyword">this</span>.wrapCollection(parameter));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception var8) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error updating database.  Cause: "</span> + var8, var8);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ErrorContext.instance().reset();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> var4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>update</code>方法也是委托给了<code>Executor</code>执行。<code>BaseExecutor</code>的执行方法如下所示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(MappedStatement ms, Object parameter)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">"executing an update"</span>).object(ms.getId());</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.closed) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">"Executor was closed."</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.clearLocalCache();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.doUpdate(ms, parameter);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每次执行<code>update</code>前都会清空<code>localCache</code></p>
<p>至此，一级缓存的工作流程讲解以及源码分析完毕</p>
<h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3>
<p>1、Mybatis一级缓存的生命周期和SqlSession一致</p>
<p>2、Mybatis一级缓存内部设计简单，只是一个没有容量限定的HashMap，在缓存的功能性上有所欠缺</p>
<p>3、Mybatis的一级缓存最大范围是SqlSession内部，有多个SqlSession或者分布式的环境下，数据库写操作会引起脏数据，建议设定缓存级别为Statement</p>
<h2 id="二级缓存"><a class="markdownIt-Anchor" href="#二级缓存"></a> 二级缓存</h2>
<h3 id="二级缓存介绍"><a class="markdownIt-Anchor" href="#二级缓存介绍"></a> 二级缓存介绍</h3>
<p>在上文中提到的一级缓存中，其最大的共享范围就是一个SqlSession内部，如果多个SqlSession之间需要共享缓存，则需要使用到二级缓存。开启二级缓存后，会使用CachingExecutor装饰Executor，进入一级缓存的查询流程前，先在CachingExecutor进行二级缓存的查询，具体的工作流程如下所示：</p>
<p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/28399eba.png" alt="" /></p>
<p>二级缓存开启后，同一个namespace下的所有操作语句，都影响着同一个Cache，即二级缓存被多个SqlSession共享，是一个全局的变量</p>
<p>当开启缓存后，数据的查询执行的流程就是 <strong>二级缓存 --&gt; 一级缓存 --&gt; 数据库</strong></p>
<h3 id="二级缓存配置"><a class="markdownIt-Anchor" href="#二级缓存配置"></a> 二级缓存配置</h3>
<p>要正确的使用二级缓存，需完成如下配置的</p>
<p>1、在Mybatis的配置文件中开启二级缓存</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"cacheEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>2、在Mybatis的映射XML中配置cache或者cache-ref</p>
<p>cache标签用于声明这个namespace使用二级缓存，并且可以自定义配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>type</code>：cache使用的类型，默认是<code>PerpetualCache</code>，这在一级缓存中提到过</li>
<li><code>eviction</code>：定义回收的策略，常见的有FIFO、LRU</li>
<li><code>flushInterval</code>：配置一定时间自动刷新缓存，单位是毫秒</li>
<li><code>size</code>：最多缓存对象的个数</li>
<li><code>readOnly</code>：是否只读，若配置可读写，则需要对应的实体类能够序列化</li>
<li><code>blocking</code>：若缓存中找不到对应的key，是否会一直blocking，直到有对应的数据进入缓存</li>
</ul>
<p><code>cache-ref</code>代表引用别的命名空间的Cache配置，两个命名空间的操作使用的是同一个Cache</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache-ref</span> <span class="attr">namespace</span>=<span class="string">"mapper.StudentMapper"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="二级缓存实验"><a class="markdownIt-Anchor" href="#二级缓存实验"></a> 二级缓存实验</h3>
<p>接下来我们通过实验，了解Mybatis二级缓存在使用上的一些特点</p>
<p>在本实验中，id为1的学生名称初始化为点点</p>
<h4 id="实验1-2"><a class="markdownIt-Anchor" href="#实验1-2"></a> 实验1</h4>
<p>测试二级缓存效果，不提交事务，<code>sqlSession1</code>查询完数据后，<code>sqlSession2</code>相同的查询是否会从缓存中获取数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCacheWithoutCommitOrClose</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  SqlSession sqlSession1 = factory.openSession(<span class="keyword">true</span>);</span><br><span class="line">  SqlSession sqlSession2 = factory.openSession(<span class="keyword">true</span>);</span><br><span class="line">  </span><br><span class="line">  StudentMapper studentMapper = sqlSession1.getMapper(StudentMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  StudentMapper studentMapper2 = sqlSession2.getMapper(StudentMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  </span><br><span class="line">  System.out.println(<span class="string">"studentMapper读取数据: "</span> + studentMapper.getStudentById(<span class="number">1</span>));</span><br><span class="line">  System.out.println(<span class="string">"studentMapper2读取数据："</span> + studentMapper2.getStudentById(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/71e2bfdc.jpg" alt="" /></p>
<p>我们可以看到，当<code>sqlSession</code>没有调用<code>commit()</code>方法，二级缓存并没有起到作用</p>
<h4 id="实验2-2"><a class="markdownIt-Anchor" href="#实验2-2"></a> 实验2</h4>
<p>测试二级缓存效果，当提交事务时，<code>sqlSession1</code>查询完数据后，<code>sqlSession2</code>相同的查询是否会从缓存中获取数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCacheWithCommitOrClose</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  SqlSession sqlSession1 = factory.openSession(<span class="keyword">true</span>); </span><br><span class="line">  SqlSession sqlSession2 = factory.openSession(<span class="keyword">true</span>); </span><br><span class="line"></span><br><span class="line">  StudentMapper studentMapper = sqlSession1.getMapper(StudentMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  StudentMapper studentMapper2 = sqlSession2.getMapper(StudentMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">"studentMapper读取数据: "</span> + studentMapper.getStudentById(<span class="number">1</span>));</span><br><span class="line">  sqlSession1.commit();</span><br><span class="line">  System.out.println(<span class="string">"studentMapper2读取数据: "</span> + studentMapper2.getStudentById(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/f366f34e.jpg" alt="" /></p>
<p>从图上可知，<code>sqlSession2</code>的查询，使用了缓存，缓存的命中率是0.5</p>
<h4 id="实验3-2"><a class="markdownIt-Anchor" href="#实验3-2"></a> 实验3</h4>
<p>测试<code>update</code>操作是否会刷新该<code>namespace</code>下的二级缓存</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCacheWithUpdate</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  SqlSession sqlSession1 = factory.openSession(<span class="keyword">true</span>); </span><br><span class="line">  SqlSession sqlSession2 = factory.openSession(<span class="keyword">true</span>); </span><br><span class="line">  SqlSession sqlSession3 = factory.openSession(<span class="keyword">true</span>); </span><br><span class="line"></span><br><span class="line">  StudentMapper studentMapper = sqlSession1.getMapper(StudentMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  StudentMapper studentMapper2 = sqlSession2.getMapper(StudentMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  StudentMapper studentMapper3 = sqlSession3.getMapper(StudentMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">"studentMapper读取数据: "</span> + studentMapper.getStudentById(<span class="number">1</span>));</span><br><span class="line">  sqlSession1.commit();</span><br><span class="line">  System.out.println(<span class="string">"studentMapper2读取数据: "</span> + studentMapper2.getStudentById(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">  studentMapper3.updateStudentName(<span class="string">"方方"</span>,<span class="number">1</span>);</span><br><span class="line">  sqlSession3.commit();</span><br><span class="line">  System.out.println(<span class="string">"studentMapper2读取数据: "</span> + studentMapper2.getStudentById(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/3ad93c3a.jpg" alt="" /></p>
<p>我们能够看到，在<code>sqlSession3</code>更新数据库，并提交事务后，<code>sqlSession2</code>的<code>studentMapper namespace</code>下的查询下走了数据库，没有走Cache</p>
<h4 id="实验4"><a class="markdownIt-Anchor" href="#实验4"></a> 实验4</h4>
<p>验证Mybatis的二级缓存不适应用于映射文件中存在多表查询的情况</p>
<p>通常我们会为每个单表创建单独的映射文件，由于Mybatis的二级缓存是基于<code>namespace</code>的，多表查询语句所在的<code>namespace</code>无法感应到其他<code>namespace</code>中的语句对多表查询中涉及的表进行的修改，引发脏数据问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCacheWithDiffererntNamespace</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  SqlSession sqlSession1 = factory.openSession(<span class="keyword">true</span>); </span><br><span class="line">  SqlSession sqlSession2 = factory.openSession(<span class="keyword">true</span>); </span><br><span class="line">  SqlSession sqlSession3 = factory.openSession(<span class="keyword">true</span>); </span><br><span class="line"></span><br><span class="line">  StudentMapper studentMapper = sqlSession1.getMapper(StudentMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  StudentMapper studentMapper2 = sqlSession2.getMapper(StudentMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  ClassMapper classMapper = sqlSession3.getMapper(ClassMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">"studentMapper读取数据: "</span> + studentMapper.getStudentByIdWithClassInfo(<span class="number">1</span>));</span><br><span class="line">  sqlSession1.close();</span><br><span class="line">  System.out.println(<span class="string">"studentMapper2读取数据: "</span> + studentMapper2.getStudentByIdWithClassInfo(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">  classMapper.updateClassName(<span class="string">"特色一班"</span>,<span class="number">1</span>);</span><br><span class="line">  sqlSession3.commit();</span><br><span class="line">  System.out.println(<span class="string">"studentMapper2读取数据: "</span> + studentMapper2.getStudentByIdWithClassInfo(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果</p>
<p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/5265ed97.jpg" alt="" /></p>
<p>在这个实验中，我们引入了两张新的表，一张class，一张classroom。class中保存了班级的id和班级名，classroom中保存了班级id和学生id。我们在StudentMapper中增加了一个查询方法<code>getStudentByIdWithClassInfo</code>，用于查询学生所在的班级，涉及到多表查询。在ClassMapper中添加了<code>updateClassName</code>，根据班级id更新班级名的操作</p>
<p>当<code>sqlSession1</code>的<code>studentMapper</code>查询数据后，二级缓存生效。保存在StudentMapper的namespace下的cache中。当<code>sqlSession3</code>的<code>classMapper</code>的<code>updateClassName</code>方法对class表进行更新时，<code>updateClassName</code>下的cache没有感应到变化，没有刷新缓存。当<code>StudentMapper</code>中同样的查询再次发起时，从缓存中读取了脏数据</p>
<h4 id="实验5"><a class="markdownIt-Anchor" href="#实验5"></a> 实验5</h4>
<p>为了解决实验4的问题，可以使用Cache ref，让<code>ClassMapper</code>引用<code>StudentMapper</code>命名空间，这样两个映射文件对应的SQL操作都使用的是同一个缓存了</p>
<p>执行结果：</p>
<p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/a2e4c2d8.jpg" alt="" /></p>
<p>不过这样做的后果是，缓存的粒度变粗了，多个<code>Mapper namespace</code>下的所有操作都会对缓存使用造成影响</p>
<h3 id="四-二级缓存源码分析"><a class="markdownIt-Anchor" href="#四-二级缓存源码分析"></a> 四、二级缓存源码分析</h3>
<p>Mybatis二级缓存的工作流程和前文提到的一级缓存类似，只是在一级缓存处理前，用<code>CachingExecutor</code>装饰了<code>BaseExecutor</code>的子类，在委托具体职责给<code>delegate</code>之前，实现了二级缓存的查询和写入功能，具体类关系图如下图所示</p>
<p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/090216b1.jpg" alt="" /></p>
<h4 id="源码分析-2"><a class="markdownIt-Anchor" href="#源码分析-2"></a> 源码分析</h4>
<p>源码分析从<code>CachingExecutor</code>的<code>query</code>方法展开</p>
<p><code>CachingExecutor</code>的<code>query</code>方法，首先会从<code>MappedStatement</code>中获得在配置初始化时赋予的Cache</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache cache = ms.getCache();</span><br></pre></td></tr></table></figure>
<p>本质上是装饰器模式的使用，具体的装饰链是：</p>
<blockquote>
<p>SynchronizedCache --&gt; LoggingCache --&gt; SerializedCache --&gt; LruCache --&gt; PerpetualCache</p>
</blockquote>
<p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/1f5233b2.jpg" alt="" /></p>
<p>以下是具体这些Cache实现类的介绍，它们的组合为Cache赋予了不同的能力</p>
<ul>
<li><code>SynchronizedCache</code>：同步Cache，实现比较简单，直接使用synchronized修饰方法</li>
<li><code>LoggingCache</code>：日志功能，装饰类，用于记录缓存的命中率，如果开启了DEBUG模式，则会输出命中率日志</li>
<li><code>SerializedCache</code>：序列化功能，将值序列化后存到缓存中。该功能用于缓存返回一份实例的Copy，用于保存线程安全</li>
<li><code>LruCache</code>：采用了Lru算法的Cache实现，移除最近最少使用的Key/Value</li>
<li><code>PerpetualCache</code>：作为最基础的缓存类，底层实现比较简单，直接使用了HashMap</li>
</ul>
<p>然后是判断是否需要刷新缓存，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.flushCacheIfRequired(ms);</span><br></pre></td></tr></table></figure>
<p>在默认的设置中<code>SELECT</code>语句不会刷新缓存，<code>insert/update/delete</code>会刷新缓存。进入该方法，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flushCacheIfRequired</span><span class="params">(MappedStatement ms)</span> </span>&#123;</span><br><span class="line">  Cache cache = ms.getCache();</span><br><span class="line">  <span class="keyword">if</span> (cache != <span class="keyword">null</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;</span><br><span class="line">    <span class="keyword">this</span>.tcm.clear(cache);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Mybatis的<code>CachingExecutor</code>持有了<code>TransactionalCacheManager</code>，即上述代码中tcm</p>
<p><code>TransactionalCacheManager</code>中持有了一个Map，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;Cache, TransactionalCache&gt; transactionalCaches = <span class="keyword">new</span> HashMap();</span><br></pre></td></tr></table></figure>
<p>这个Map保存了Cache和用<code>TransactionalCache</code>包装后的Cache的映射关系</p>
<p><code>TransactionalCache</code>实现了Cache接口，<code>CachingExecutor</code>会默认使用它包装初始生成的Cache，作用是如果事务提交，对缓存的操作才会生效，对缓存的操作才会生效，如果事务回滚或者不提交事务，则不对缓存产生影响</p>
<p>在<code>TransactionalCache</code>的clear，有以下两句。清空了需要在提交时加入缓存的列表，同时设定提交时清空缓存，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.clearOnCommit = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">this</span>.entriesToAddOnCommit.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>CachingExecutor</code>继续往下走，<code>ensureNoOutParams</code>主要是用来处理存储过程的，暂时不用考虑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ms.isUseCache() &amp;&amp; resultHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="keyword">this</span>.ensureNoOutParams(ms, parameterObject, boundSql);</span><br></pre></td></tr></table></figure>
<p>之后会尝试从tcm中获取缓存的列表</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;E&gt; list = (List)<span class="keyword">this</span>.tcm.getObject(cache, key);</span><br></pre></td></tr></table></figure>
<p>在<code>getObject</code>方法中，会把获取值的职责一路传递，最终到<code>TransactionalCache</code>。如果没有查到，会把key加入到Miss集合，这个主要是为了统计命中率。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  Object object = <span class="keyword">this</span>.delegate.getObject(key);</span><br><span class="line">  <span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.entriesMissedInCache.add(key);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.clearOnCommit ? <span class="keyword">null</span> : object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>CachingExecutor</code>继续往下走，如果查询到数据，则调用<code>tcm.putObject</code>方法，往缓存中放入值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (list == <span class="keyword">null</span>) &#123;</span><br><span class="line">  list = <span class="keyword">this</span>.delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">  <span class="keyword">this</span>.tcm.putObject(cache, key, list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>tcm的<code>put</code>方法也不是直接操作缓存，只是在把这次的数据和key放入待提交的Map中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object object)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.entriesToAddOnCommit.put(key, object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从以上的代码分析中，我们可以明白，如果不调用<code>commit</code>方法的话，由于<code>TransactionalCache</code>的作用，并不会对二级缓存造成直接的影响。因此我们看看<code>SqlSession</code>的<code>commit</code>的方法中做了什么。代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">(<span class="keyword">boolean</span> force)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.executor.commit(<span class="keyword">this</span>.isCommitOrRollbackRequired(force));</span><br><span class="line">    <span class="keyword">this</span>.dirty = <span class="keyword">false</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception var6) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error committing transaction.  Cause: "</span> + var6, var6);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ErrorContext.instance().reset();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为我们使用了<code>CachingExecutor</code>，首先会进入<code>CachingExecutor</code>实现的commit方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">(<span class="keyword">boolean</span> required)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.delegate.commit(required);</span><br><span class="line">  <span class="keyword">this</span>.tcm.commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会把具体commit的职责委托给包装的<code>Executor</code>，主要是看下<code>tcm.commit()</code>，tcm最终又会调用到<code>TransactionalCache</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.clearOnCommit) &#123;</span><br><span class="line">    <span class="keyword">this</span>.delegate.clear();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.flushPendingEntries();</span><br><span class="line">  <span class="keyword">this</span>.reset();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到这里的<code>clearOnCommit</code>就想起刚才<code>TransactionalCache</code>的<code>clear</code>方法设置的标志位，真正的清理Cache是放到这里来进行的。具体清理的职责委托给了包装的Cache类。之后进入<code>flushPendingEntries</code>方法。代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flushPendingEntries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Iterator var1 = <span class="keyword">this</span>.entriesToAddOnCommit.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(var1.hasNext()) &#123;</span><br><span class="line">    Entry&lt;Object, Object&gt; entry = (Entry)var1.next();</span><br><span class="line">    <span class="keyword">this</span>.delegate.putObject(entry.getKey(), entry.getValue());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var1 = <span class="keyword">this</span>.entriesMissedInCache.iterator();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(var1.hasNext()) &#123;</span><br><span class="line">    Object entry = var1.next();</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.entriesToAddOnCommit.containsKey(entry)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.delegate.putObject(entry, (Object)<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>flushPendingEntries</code>中，将待提交的Map进行循环处理，委托给包装的Cache类，进行<code>putObject</code>的操作</p>
<p>后续的查询操作会重复执行这套流程。如果是<code>insert|update|delete</code>的话，会统一进入<code>CachingExecutor</code>的<code>update</code>方法，其中调用了这个函数。代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flushCacheIfRequired</span><span class="params">(MappedStatement ms)</span> </span>&#123;</span><br><span class="line">  Cache cache = ms.getCache();</span><br><span class="line">  <span class="keyword">if</span> (cache != <span class="keyword">null</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;</span><br><span class="line">    <span class="keyword">this</span>.tcm.clear(cache);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在二级缓存执行流程后就会进入一级缓存的执行流程，因此不再累赘</p>
<h3 id="总结-2"><a class="markdownIt-Anchor" href="#总结-2"></a> 总结</h3>
<ol>
<li>Mybatis的二级缓存相对于一级缓存来说，实现了<code>SqlSession</code>之间缓存数据的共享，同时粒度更加的细，能够到<code>namespace</code>级别，通过Cache接口实现不同的组合，对Cache的可控性也更强</li>
<li>Mybatis在多表查询中，极大可能出现脏数据，有设计上的缺陷，安全使用二级缓存的条件比较苛刻</li>
<li>在分布式环境下，由于默认的Mybatis Cache实现都是基于本地的，分布式环境下必然出现读取到脏数据，需要使用集中式缓存将Mybatis的Cache接口实现，有一定的开发成本，直接使用Redis、Memcached等分布式存储可能成本更低，安全性也更高</li>
</ol>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Toyan</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://toyan.top/mybatis-cache/">https://toyan.top/mybatis-cache/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Mybatis/">Mybatis</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/public/alipay.jpeg"><div class="post-qr-code__desc">支付宝打赏</div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/public/wechat.jpeg"><div class="post-qr-code__desc">微信打赏</div></div></div><div class="social-share pull-right"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/jvm-metaspaceSize/"><i class="fa fa-chevron-left">  </i><span>JVM中Metaspace理解</span></a></div><div class="next-post pull-right"><a href="/mysql-lock/"><span>select加锁分析MySQL</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '64bf96f3f30de518911b',
  clientSecret: '2b721d1728859b321e4f4533bd870be019c30c37',
  repo: 'toyan-blog.github.io',
  owner: 'toyan-blog',
  admin: 'toyan-blog',
  id: md5(decodeURI(location.pathname)),
  language: 'en'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/public/blog.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2020 By Toyan</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"superSample":2,"width":210,"height":420,"position":"left","hOffset":0,"vOffset":-20},"log":false,"tagMode":false});</script></body></html>