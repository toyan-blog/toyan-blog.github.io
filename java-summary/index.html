<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Java总结"><meta name="keywords" content="Java"><meta name="author" content="Toyan"><meta name="copyright" content="Toyan"><title>Java总结 | ToyanのBlog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?c61658fe357dc669ee95b5bd4e25caad";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><link rel="dns-prefetch" href="http://ta.qq.com"><script>(function() {
   var hm = document.createElement("script");
   hm.src = "https://tajs.qq.com/stats?sId=66513922";
   var s = document.getElementsByTagName("script")[0];
   s.parentNode.insertBefore(hm, s);
 })();</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="ToyanのBlog" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#java的四个特性抽象-封装-继承-多态对多态的理解多态的实现方式"><span class="toc-number">1.</span> <span class="toc-text"> Java的四个特性（抽象、封装、继承、多态），对多态的理解（多态的实现方式）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面向对象和面向过程的区别"><span class="toc-number">2.</span> <span class="toc-text"> 面向对象和面向过程的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#重载与重写"><span class="toc-number">3.</span> <span class="toc-text"> 重载与重写</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面向对象开发的六个基本准则单一职责-开放封闭-里氏替换-依赖倒置-合成聚合复用-接口隔离迪米特法则"><span class="toc-number">4.</span> <span class="toc-text"> 面向对象开发的六个基本准则（单一职责、开放封闭、里氏替换、依赖倒置、合成聚合复用、接口隔离），迪米特法则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#static与final的区别"><span class="toc-number">5.</span> <span class="toc-text"> static与final的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hashmap和hashtable的区别hashmap中的key可以是任何对象或数据类型吗"><span class="toc-number">6.</span> <span class="toc-text"> HashMap和Hashtable的区别，HashMap中的key可以是任何对象或数据类型吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hashmap与concurrenthashmap"><span class="toc-number">7.</span> <span class="toc-text"> HashMap与concurrentHashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#区别"><span class="toc-number">7.1.</span> <span class="toc-text"> 区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#concurrenthashmap线程安全吗如何保证线程安全"><span class="toc-number">7.2.</span> <span class="toc-text"> concurrentHashMap线程安全吗，如何保证线程安全？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#string-stringbuffer-stringbuilder"><span class="toc-number">8.</span> <span class="toc-text"> String、StringBuffer、StringBuilder</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#string重写了object的hashcode和tostring重写equals不重写hashcode有什么问题"><span class="toc-number">9.</span> <span class="toc-text"> String重写了Object的hashCode和toString，重写equals()不重写hashCode()有什么问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java序列化"><span class="toc-number">10.</span> <span class="toc-text"> Java序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#定义"><span class="toc-number">10.1.</span> <span class="toc-text"> 定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#作用"><span class="toc-number">10.2.</span> <span class="toc-text"> 作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#序列化与反序列化"><span class="toc-number">10.3.</span> <span class="toc-text"> 序列化与反序列化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多线程"><span class="toc-number">11.</span> <span class="toc-text"> 多线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程池"><span class="toc-number">12.</span> <span class="toc-text"> 线程池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#volatile关键字与synchronized的区别"><span class="toc-number">13.</span> <span class="toc-text"> volatile关键字与synchronized的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sleep与wait"><span class="toc-number">14.</span> <span class="toc-text"> sleep()与wait()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized与lock"><span class="toc-number">15.</span> <span class="toc-text"> synchronized与lock</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized与static-synchronized的区别"><span class="toc-number">15.1.</span> <span class="toc-text"> synchronized与static synchronized的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#异常"><span class="toc-number">16.</span> <span class="toc-text"> 异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java中的nio-bio-aio分别是什么"><span class="toc-number">17.</span> <span class="toc-text"> Java中的NIO、BIO、AIO分别是什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#bio"><span class="toc-number">17.1.</span> <span class="toc-text"> BIO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nio"><span class="toc-number">17.2.</span> <span class="toc-text"> NIO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#aio"><span class="toc-number">17.3.</span> <span class="toc-text"> AIO</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java内存模型java-memory-modeljmm"><span class="toc-number">18.</span> <span class="toc-text"> Java内存模型（Java Memory model，JMM）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#线程之间的通信"><span class="toc-number">18.1.</span> <span class="toc-text"> 线程之间的通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程之间的同步"><span class="toc-number">18.2.</span> <span class="toc-text"> 线程之间的同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java的并发采用的是共享内存模型"><span class="toc-number">18.3.</span> <span class="toc-text"> Java的并发采用的是共享内存模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jvm对java内存模型的实现"><span class="toc-number">18.4.</span> <span class="toc-text"> JVM对Java内存模型的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#共享对象的可见性与竞争现象"><span class="toc-number">18.5.</span> <span class="toc-text"> 共享对象的可见性与竞争现象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile和synchronized的区别"><span class="toc-number">18.6.</span> <span class="toc-text"> volatile和synchronized的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java内存模型的基础原理"><span class="toc-number">18.7.</span> <span class="toc-text"> Java内存模型的基础原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内存屏障memory-barrier"><span class="toc-number">18.8.</span> <span class="toc-text"> 内存屏障（Memory Barrier）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#happens-before策略"><span class="toc-number">18.9.</span> <span class="toc-text"> happens-before策略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#解决hash冲突的几种方法"><span class="toc-number">19.</span> <span class="toc-text"> 解决hash冲突的几种方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#开放地址法"><span class="toc-number">19.1.</span> <span class="toc-text"> 开放地址法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#拉链法"><span class="toc-number">19.2.</span> <span class="toc-text"> 拉链法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#再散列双重散列-多重散列"><span class="toc-number">19.3.</span> <span class="toc-text"> 再散列（双重散列、多重散列）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#建立一个公共溢出区"><span class="toc-number">19.4.</span> <span class="toc-text"> 建立一个公共溢出区</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/public/avatar.jpeg"></div><div class="author-info__name text-center">Toyan</div><div class="author-info__description text-center">Email: tonganhao1103@gmail.com</div><div class="follow-button"><a href="https://github.com/toyan-blog" target="_blank" rel="noopener">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">15</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">13</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">18</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="https://molunerfinn.com/hexo-theme-melody-doc/" target="_blank" rel="noopener">hexo-theme-melody</a><a class="author-info-links__name text-center" href="https://molunerfinn.com/" target="_blank" rel="noopener">Molunerfinn</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/public/blog.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">ToyanのBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">Java总结</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-09-02</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/">基础知识总结</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/Java/">Java</a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">7k</span><span class="post-meta__separator">|</span><span>Reading time: 21 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="java的四个特性抽象-封装-继承-多态对多态的理解多态的实现方式"><a class="markdownIt-Anchor" href="#java的四个特性抽象-封装-继承-多态对多态的理解多态的实现方式"></a> Java的四个特性（抽象、封装、继承、多态），对多态的理解（多态的实现方式）</h2>
<ul>
<li>抽象：抽象是将一类对象的共同特征总结出来构造类的过程。包括数据抽象和行为抽象两个方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。</li>
<li>继承：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类），继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段。</li>
<li>封装：通常认为封装是将数据与操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法是对实现细节的一种封装；我们编写的一个类就是对数据和数据操作的封装。封装就是隐藏一切可隐藏的东西，只向外提供简单的编程接口。</li>
<li>多态
<ul>
<li>方法重载（overload）实现的是编译时的多态性（也成为前向绑定）</li>
<li>方法重写（overwrite）实现的是运行时的多态性（也成为后向绑定）</li>
<li>多态的实现方式：方法重写，子类继承父类并重写父类中已有的或抽象的方法；对象构造，用父类型引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为</li>
<li>举例：有两种客户：订购客户和卖方客户，两个客户都可以登录系统，他们有相同的方法login，但登录之后他们会进入不同的页面，也就是在登录后有不同的操作行为。两种客户都继承父类的Login方法，但对于不同的对象，拥有不同的操作。</li>
</ul>
</li>
</ul>
<h2 id="面向对象和面向过程的区别"><a class="markdownIt-Anchor" href="#面向对象和面向过程的区别"></a> 面向对象和面向过程的区别？</h2>
<ul>
<li>面向过程就像是一个细心的管家，事无具细的都要考虑到。而面向对象就像是一个家用电器，你只需要知道他的功能，不需要知道他的工作原理</li>
<li>面向过程是一种以时间为中心的编程思想，就是分析出解决问题所需的步骤，然后用函数把这些步骤实现，并按顺序调用。面向对象是以“对象”为中心的编程思想</li>
<li>举例：汽车发送、汽车到站
<ul>
<li>对于面向过程来说，这是两个事件，面向过程编程我们关心的是事件，而不是汽车本身。针对上述过程，形成两个函数，依次调用</li>
<li>对于面向对象来说，我们关心的是汽车这类对象，两个事件只是这类对象所具有的行为。而且对于这两个行为没有顺序要求</li>
</ul>
</li>
</ul>
<h2 id="重载与重写"><a class="markdownIt-Anchor" href="#重载与重写"></a> 重载与重写</h2>
<ul>
<li>重载：重载发生在同一个类中，同名的方法如果有不同的参数列表（参数类型、参数个数或者两者都不同）则视为重载</li>
<li>重写：重写发生在子类与父类之间，重写要求子类重写方法与父类被重写方法具有相同的返回参数，比父类方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则），根据不同的子类对象确定调用哪个对象</li>
</ul>
<h2 id="面向对象开发的六个基本准则单一职责-开放封闭-里氏替换-依赖倒置-合成聚合复用-接口隔离迪米特法则"><a class="markdownIt-Anchor" href="#面向对象开发的六个基本准则单一职责-开放封闭-里氏替换-依赖倒置-合成聚合复用-接口隔离迪米特法则"></a> 面向对象开发的六个基本准则（单一职责、开放封闭、里氏替换、依赖倒置、合成聚合复用、接口隔离），迪米特法则</h2>
<ul>
<li>单一职责：一个类只能它该做的事情（高内聚），在面向对象中，如果只让一个类完成它该做的事，而不涉及与它无关的领域就是践行了高内聚的原则，这个类就是单一职责</li>
<li>开放封闭：软件实体应当对扩展开放，对修改关闭。要做到开闭有两点：抽象是关键，一个系统如果没有抽象类或者接口系统就没有扩展点；封装可变性，将系统中可变因素封装在一个继承结构中，如果多个可变因素混杂在一起，系统将复杂而混乱</li>
<li>里氏替换：任何时候都可以用子类替换父类，子类一定是增加了父类的能力而不是减少，因为子类比父类的能力更多，把能力多的对象当成能力少的对象来用没有问题</li>
<li>依赖倒置：面向接口编程（声明方法的参数类型、方法返回类型，变量的引用类型要尽量使用抽象类型而不是具体类型，因为抽象类型可以被其子类型所替代）</li>
<li>合成聚合复用：优先使用聚合或合成关系复用代码</li>
<li>接口隔离：接口不要大而全，要小而专，一个接口只应该描述一种能力，接口也应该是高内聚的</li>
</ul>
<p>迪米特法则：又称为最少知识原则，一个对象应当对其他对象有尽可能少的了解</p>
<h2 id="static与final的区别"><a class="markdownIt-Anchor" href="#static与final的区别"></a> static与final的区别</h2>
<p>static：</p>
<ul>
<li>修饰变量：静态变量随着类加载时完成初始化，内存中只有一个，且JVM只会为它分配一次内存，所有类共享静态变量</li>
<li>修饰方法：在类加载的时候就存在，不依赖任何实例；static方法必须实现，不能用abstract修饰</li>
<li>修饰代码块：在类加载完成后就会执行代码块中的内容</li>
<li>父类静态代码块-&gt;子类静态代码块-&gt;父类非静态代码块-&gt;父类构造方法-&gt;子类非静态代码块-&gt;子类构造方法</li>
</ul>
<p>final：</p>
<ul>
<li>修饰变量
<ul>
<li>编译期常量：类加载的过程完成初始化，编译后带入到任何计算式中，只能是基本类型</li>
<li>运行时常量：基本数据类型或引用数据类型，引用不可变，但引用的对象内容可变</li>
</ul>
</li>
<li>修饰方法：不能被继承，不能被子类修改</li>
<li>修饰类：不能被继承</li>
<li>修饰新参：final形参不可变</li>
</ul>
<h2 id="hashmap和hashtable的区别hashmap中的key可以是任何对象或数据类型吗"><a class="markdownIt-Anchor" href="#hashmap和hashtable的区别hashmap中的key可以是任何对象或数据类型吗"></a> HashMap和Hashtable的区别，HashMap中的key可以是任何对象或数据类型吗？</h2>
<p>区别：</p>
<ul>
<li>Hashtable的方法是同步的，HashMap未经同步，所以在多线程环境下要手动同步HashMap，这个区别就相当于Vector和ArrayList</li>
<li>Hashtable不允许使用null（key和value都不可以），HashMap允许null值（key只能有一个null值，value没有限制）</li>
<li>两者的遍历方式大同小异，Hashtable仅仅比HashMap多一个elements方法<br />
Hashtable和HashMap都能通过values()方法返回一个Collection，然后遍历<br />
两者也都可以通过entrySet()返回一个Set，然后遍历</li>
<li>Hashtable使用Enumeration，HashMap使用Iterator</li>
<li>哈希值计算方法不同，hashtable直接使用对象的hashCode，hashMap重新计算hash值，而且用于代替求模</li>
<li>Hashtable的hash数组大小是11，增加方式是old*2+1，hashMap的默认大小是16，而且一定是2的指数</li>
<li>hashtable是基于Dictionary，hashMap是基于AbstractMap类</li>
</ul>
<p>HashMap的key可以为null，但不可以为可变对象。如果是可变对象时，对象的属性改变，则对象的hashCode也进行了相应的改变，导致下次无法查找到已存在Map的数据。<br />
如果可变对象被用作HashMap的键时，在改变对象的状态时，不要再改变其哈希值，我们只需要保证成员变量的改变能保证该对象的哈希值不变即可。<br />
hashtable是线程安全的，其实是在对应的方法添加了synchronized关键字进行修饰，由于在执行此方法的时候需要获得对象锁，则执行起来比较慢。所以可以使用concurrentHashMap</p>
<h2 id="hashmap与concurrenthashmap"><a class="markdownIt-Anchor" href="#hashmap与concurrenthashmap"></a> HashMap与concurrentHashMap</h2>
<h3 id="区别"><a class="markdownIt-Anchor" href="#区别"></a> 区别</h3>
<p><img src="https://upload-images.jianshu.io/upload_images/4470227-3cd6f552df38c5da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="HashMap与concurrentHashMap的区别.png" /></p>
<h3 id="concurrenthashmap线程安全吗如何保证线程安全"><a class="markdownIt-Anchor" href="#concurrenthashmap线程安全吗如何保证线程安全"></a> concurrentHashMap线程安全吗，如何保证线程安全？</h3>
<ul>
<li>
<p>hashtable容器在竞争激烈的并发环境下表现出效率低下的原因是所有访问hashtable的线程都必须竞争同一把锁，当容器中有多把锁时，每一把锁用于锁住容器中的一部分数据，那么当多线程访问容器内不同数据段的数据时，线程间不会存在锁竞争，从而提高了并发访问的效率，这也是concurrentHashMap采用的锁分段技术，当一个线程访问其中一个段的数据时，其他段的数据也能被其他线程所访问</p>
</li>
<li>
<p>get的高效之处：get过程不需要加锁，除非读到的值是空的才需要加锁重读</p>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/4470227-07abfdfff5f9bdd7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="concurrentHashMap的get方法高效之处.png" /></p>
<ul>
<li>put方法首先定位到segment，然后在segment里进行插入操作</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/4470227-1e18e15487173b7d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="concurrentHashMap的put操作步骤.png" /></p>
<h2 id="string-stringbuffer-stringbuilder"><a class="markdownIt-Anchor" href="#string-stringbuffer-stringbuilder"></a> String、StringBuffer、StringBuilder</h2>
<p><img src="https://upload-images.jianshu.io/upload_images/4470227-199d8cc0f1e566db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="String、StringBuffer、StringBuilder.png" /></p>
<p><img src="https://upload-images.jianshu.io/upload_images/4470227-165d0d85963e2435.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="String的不变性.png" /></p>
<h2 id="string重写了object的hashcode和tostring重写equals不重写hashcode有什么问题"><a class="markdownIt-Anchor" href="#string重写了object的hashcode和tostring重写equals不重写hashcode有什么问题"></a> String重写了Object的hashCode和toString，重写equals()不重写hashCode()有什么问题？</h2>
<ul>
<li>当equals方法被重写，通常需要重写hashCode方法，以保证两个相等的对象必须有相同的hashCode
<ul>
<li>object1.equals(object2)时为true，则object1.hashCode()==object2.hashCode()也为true</li>
<li>object1.hashCode()==object2.hashCode()为false，则 object1.equals(object2)一定为false</li>
<li>object1.hashCode()==object2.hashCode()为true，则object1.equals(object2)状态不确定</li>
</ul>
</li>
<li>在存储散列集合(如Set)时，如果原对象.equals(新对象)，但如果没有对hashCode重写，即两个对象拥有不同的hashCode，则在集合中会存储两个值相同的对象，从而导致混淆。<strong>因此，重写equals方法时，必须重写hashCode方法</strong></li>
</ul>
<h2 id="java序列化"><a class="markdownIt-Anchor" href="#java序列化"></a> Java序列化</h2>
<h3 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h3>
<p>将那些实现了Serializable接口的对象转换成一个字节序列，并能够在以后将这个字节序列完全恢复到原来的对象，序列化可以弥补不同操作系统之间的差异</p>
<h3 id="作用"><a class="markdownIt-Anchor" href="#作用"></a> 作用</h3>
<ul>
<li>Java远程方法调用</li>
<li>对JavaBeans进行序列化</li>
</ul>
<h3 id="序列化与反序列化"><a class="markdownIt-Anchor" href="#序列化与反序列化"></a> 序列化与反序列化</h3>
<p><img src="https://upload-images.jianshu.io/upload_images/4470227-9e20b70fbf8a2ffb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="序列化与反序列化.png" /></p>
<p><em>注意事项：</em></p>
<ul>
<li>被static修饰的属性不会被序列化</li>
<li>对象的类名、属性都会被序列化，但是方法不会被序列化</li>
<li>要保证对象所在的类的属性可以被序列化</li>
<li>当通过网络、文件进行序列化时，必须按照写入的顺序读取对象</li>
<li>反序列化时必须有序列化对象时的class文件</li>
<li>最好显示的声明serializableID，因为在不同的JVM时，默认生成的serializableID不同，可能导致反序列化失败</li>
</ul>
<h2 id="多线程"><a class="markdownIt-Anchor" href="#多线程"></a> 多线程</h2>
<p><img src="https://upload-images.jianshu.io/upload_images/4470227-a3706a708bb787b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="多线程.png" /></p>
<p><em>线程安全</em></p>
<ul>
<li>定义：某个类的行为与其规范一致；不管多个线程是怎样的执行顺序和优先级，或是wait、sleep、join等，如果一个类在多线程访问下都正常，并且不需要额外的同步处理和协调，那么这就是线程安全。</li>
<li>如何保证线程安全：对变量使用volitate；对程序段进行加锁（synchronized、lock）</li>
<li>注意：非线程安全的集合可以在多线程中使用，但是不能用作多个线程共享的属性，只能作为某个线程独享的属性</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/4470227-0808045764dfe335.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="多线程共用一个变量.png" /></p>
<h2 id="线程池"><a class="markdownIt-Anchor" href="#线程池"></a> 线程池</h2>
<p>定义：实现先创建若干个可执行的线程放入一个容器（池）中，当需要的时候，不用自行创建只需要从容器中获取，使用完毕后不需要销毁而是放入到容器中，从而减少创建和销毁线程对象的开销。</p>
<p><strong>设计线程池</strong><br />
<img src="https://upload-images.jianshu.io/upload_images/4470227-4b7af091d802db0e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="创建线程池.png" /></p>
<h2 id="volatile关键字与synchronized的区别"><a class="markdownIt-Anchor" href="#volatile关键字与synchronized的区别"></a> volatile关键字与synchronized的区别</h2>
<p><img src="https://upload-images.jianshu.io/upload_images/4470227-b8f44396064cf9dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="区别.png" /></p>
<h2 id="sleep与wait"><a class="markdownIt-Anchor" href="#sleep与wait"></a> sleep()与wait()</h2>
<ul>
<li>sleep是Thread类的方法</li>
<li>wait是Object类的方法</li>
<li>区别：
<ul>
<li>sleep()方法（休眠）是线程类（Thread）的静态方法，调用此方法会让当前线程暂停执行指定的时间，将执行机会（CPU）让给其他线程，但是对象的锁依然保持，因此休眠时间结束后会自动恢复（线程回到就绪状态）</li>
<li>wait()是object类的方法，调用对象的wait()方法导致当前线程放弃对象的锁（线程暂停执行），进入对象的等待池（wait pool），只有调用对象的notify()方法（或notifyAll()方法）时才能唤醒等待池中的线程进入等锁池（lock pool），如果线程重新获得对象的锁就可以进入就绪状态</li>
</ul>
</li>
</ul>
<h2 id="synchronized与lock"><a class="markdownIt-Anchor" href="#synchronized与lock"></a> synchronized与lock</h2>
<p><img src="https://upload-images.jianshu.io/upload_images/4470227-dc6c2c91b5a20469.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="synchronized与lock的区别.png" /></p>
<h3 id="synchronized与static-synchronized的区别"><a class="markdownIt-Anchor" href="#synchronized与static-synchronized的区别"></a> synchronized与static synchronized的区别</h3>
<ul>
<li>synchronized是对类的当前实例进行加锁，防止其他线程同时访问该类的该实例的所有synchronized锁，同一个类的不同实例之间没有这种约束</li>
<li>static synchronized是控制类的所有实例的访问，限制线程同时访问JVM中该类的所有实例同时访问对应的代码块</li>
</ul>
<h2 id="异常"><a class="markdownIt-Anchor" href="#异常"></a> 异常</h2>
<ul>
<li>Throwable是Java语言中所有错误和异常的超类，它有两个子类：<code>Error</code>和<code>Exception</code></li>
<li>异常种类
<ul>
<li>Error：错误，是程序无法处理的，如OutOfMemeryError、ThreadDeath等，这种情况下交由JVM处理，一般会选择终止线程</li>
<li>Exception：程序可以处理的异常，它又分为<code>CheckedException</code>（受检异常）和<code>UnCheckedException</code>（不受检异常）
<ul>
<li><code>CheckedException</code>：发生在编译阶段，必须使用<code>try...catch...</code>或者<code>throws</code>，否则编译不通过。</li>
<li><code>UnCheckedException</code>：发生在运行期，一般由程序的逻辑问题引起。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="java中的nio-bio-aio分别是什么"><a class="markdownIt-Anchor" href="#java中的nio-bio-aio分别是什么"></a> Java中的NIO、BIO、AIO分别是什么？</h2>
<h3 id="bio"><a class="markdownIt-Anchor" href="#bio"></a> BIO</h3>
<ul>
<li>同步并阻塞，服务器实现模式为<code>一个连接一个线程</code>，即客户端有请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情就会造成不必要的线程开销，可以通过线程池机制来改善</li>
<li>BIO方式适用于<code>连接数目比较小且固定的架构</code>，这种方式对服务器资源要求比较高，并发局限于应用中</li>
</ul>
<h3 id="nio"><a class="markdownIt-Anchor" href="#nio"></a> NIO</h3>
<ul>
<li>同步非阻塞，服务器实现模式为<code>一个请求一个线程</code>，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时，才启动一个线程进行处理</li>
<li>NIO方式适用于<code>连接数多且连接比较短的架构</code>，比如聊天服务器，并发局限于应用中</li>
</ul>
<h3 id="aio"><a class="markdownIt-Anchor" href="#aio"></a> AIO</h3>
<ul>
<li>异步非阻塞，服务器实现模式为<code>一个有效请求一个线程</code>，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理</li>
<li>AIO方式适用于<code>连接数目多且连接比较长的架构</code>，比如相册服务器，充分调用OS参与并发操作</li>
</ul>
<h2 id="java内存模型java-memory-modeljmm"><a class="markdownIt-Anchor" href="#java内存模型java-memory-modeljmm"></a> Java内存模型（Java Memory model，JMM）</h2>
<p>对于并发编程，有两个关键问题：线程之间的<strong>通信和同步</strong></p>
<h3 id="线程之间的通信"><a class="markdownIt-Anchor" href="#线程之间的通信"></a> 线程之间的通信</h3>
<p>线程的通信是指线程之间以何种机制来交换信息。在命令式编程中，线程之间的通信机制有两种<strong>共享内存和消息传递。</strong><br />
典型的共享内存通信方式就是通过<strong>共享对象</strong>来进行通信。典型的消息传递方式就是<strong>wait()和notify()。</strong></p>
<h3 id="线程之间的同步"><a class="markdownIt-Anchor" href="#线程之间的同步"></a> 线程之间的同步</h3>
<p>同步是指程序用于控制不同线程之间操作发生相对顺序的机制。<br />
在共享内存并发模型里，同步是显式进行的。程序必须显式指定某个方法或某段代码需要在线程之间互斥执行。<br />
在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。</p>
<h3 id="java的并发采用的是共享内存模型"><a class="markdownIt-Anchor" href="#java的并发采用的是共享内存模型"></a> Java的并发采用的是共享内存模型</h3>
<p>JMM决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来讲，JMM定义了线程和主内存之间的抽象关系：<strong>线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，本地内存中存储了该线程以读/写共享变量的副本。<strong>本地内存是JMM的一个抽象概念，并不真实存在。<br />
<em>线程之间的通信方式：首先，线程A把本地内存A中更新过的共享变量刷新到主内存中。然后，线程B到主内存中去读取线程A之前已更新过的共享变量。</em><br />
从整体来看，这两个步骤实质上是线程A在向线程B发送消息，而且这个通信过程必须要经过主内存。JMM通过控制主内存与每个线程的本地内存之间的交互，来为java程序员提供</strong>内存可见性保证</strong>。</p>
<h3 id="jvm对java内存模型的实现"><a class="markdownIt-Anchor" href="#jvm对java内存模型的实现"></a> JVM对Java内存模型的实现</h3>
<p>在JVM内部，Java内存模型把内存分成了两个部分：线程栈区和堆区。下图展示了Java内存模型在JVM中的逻辑视图：</p>
<p><img src="http://img.blog.csdn.net/20160921182837697" alt="" /></p>
<p>JVM中运行的每个线程都拥有自己的线程栈，线程栈包括了当前线程执行的方法调用相关信息，我们也把它称作调用栈。随着代码的执行，调用栈会不断的变化。</p>
<p><strong>线程栈</strong>还包含了当前方法的所有本地变量信息。一个线程只能读取自己的线程栈，也就是说，**线程中的本地变量对其他线程是不可见的。**即使两个线程执行的是同一段代码，它们也会各自在自己的线程栈创建本地变量，因此，<strong>每个线程中的本地变量都有自己的版本。</strong><br />
所有原始类型（boolean、byte、short、int、long、char、float、double）的本地变量都直接保存在线程栈中，对于它们的值各个线程都相互独立。对于原始类型的本地变量，一个线程可以传递一个副本给另一个线程，当它们之间是无法共享的。</p>
<p><strong>堆区</strong>包含了Java应用创建的所有对象信息，不管对象是哪个线程创建的，其中的对象包括原始类型的封装类（如Byte、Integer、Long等）。不管对象是属于一个成员变量还是方法中的本地变量，它都会被存储在堆区。</p>
<p><strong>一个本地变量如果是原始类型，那么它会被完全存储到栈区。</strong></p>
<p><strong>一个本地变量也有可能是一个对象的引用，这种情况下，这个本地引用会被存储到栈中，但是对象本身仍然存储在堆区。</strong></p>
<p><strong>对于一个对象的成员方法，这些方法中包含本地变量，仍需要存储在栈区，即使它们所属的对象在堆区。</strong></p>
<p><strong>对于一个对象的成员变量，不管它是原始类型还是包装类型，都会被存储到堆区。</strong></p>
<p><strong>Static类型的变量以及类本身相关信息都会随着类本身存储在堆区。</strong></p>
<p>堆中的对象可以被多线程共享。如果一个线程获得一个对象的应用，它便可访问这个对象的成员变量。如果两个线程同时调用了同一个对象的同一个方法，那么这两个线程便可同时访问这个对象的成员变量，但是对于本地变量，每个线程都会拷贝一份到自己的线程栈中。</p>
<p>下图是上面的全部过程：<br />
<img src="http://img.blog.csdn.net/20160921182948601" alt="" /></p>
<h3 id="共享对象的可见性与竞争现象"><a class="markdownIt-Anchor" href="#共享对象的可见性与竞争现象"></a> 共享对象的可见性与竞争现象</h3>
<p>volatile关键字可以保证变量会直接从主存读取，而对变量的更新也会直接写到主存。volatile原理是基于CPU内存屏障指令实现的。<br />
synchronized代码块可以保证同一个时刻只能有一个线程进入代码竞争区，synchronized代码块也能保证代码块中所有变量都将会从主存中读，当线程退出代码块时，对所有变量的更新将会flush到主存，不管这些变量是不是volatile类型的。</p>
<h3 id="volatile和synchronized的区别"><a class="markdownIt-Anchor" href="#volatile和synchronized的区别"></a> volatile和synchronized的区别</h3>
<p>首先理解线程安全的两个方面：<strong>执行控制和内存可见</strong>。</p>
<p>执行控制的目的是控制代码执行顺序及是否可以并发执行。</p>
<p>内存可见指的是线程执行结果在内存中对其他线程的可见性。根据Java内存模型的实现，线程在具体执行时，会先拷贝主存数据到线程本地（CPU缓存），操作完成后再把结果从线程本地刷到主存。</p>
<p><strong>synchronized关键字解决的是执行控制的问题</strong>，它会阻止其他线程获得当前对象的监控锁，这样使得当前被synchronized修饰的代码块无法被其他线程访问，也就无法并发执行。更为重要的是，synchronized还会创建<strong>内存屏障</strong>，内存屏障指令保证了所有CPU操作结果都会刷新到主存中，从而保证了内存可见性，<strong>同时也使得先获得这个锁的线程都happens-before与随后获得这个锁的线程。</strong></p>
<p>volatile关键字解决的是内存可见的问题，该关键字会使得被修饰的变量读写都会直接刷新到主存中，这样就保证了内存可见。<strong>该种方式可以保证内存可见性但是对读取没有要求的需求中。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**使用volatile关键字要满足以下条件：**</span><br><span class="line">&#96;&#96;&#96;1. 对变量的写入操作不依赖与变量的当前值，或者可以确保只有单个线程在操作变量</span><br></pre></td></tr></table></figure>
<p><code>2. 该变量没有包含在具有其他变量的不变式中</code></p>
<p><strong>总结如下：</strong><br />
<img src="https://upload-images.jianshu.io/upload_images/4470227-cd84a254ff0a465a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="volatile与synchronized的区别" /></p>
<h3 id="java内存模型的基础原理"><a class="markdownIt-Anchor" href="#java内存模型的基础原理"></a> Java内存模型的基础原理</h3>
<ul>
<li>指令重排序：<br />
为了提高程序的执行性能，编译器和处理器都会对指令进行重排序，但是JMM确保在不同的编译器和处理器平台下，通过插入指定类型的内存屏障来禁止编译器重排序和处理器重排序，为上层提供一致的内存可见性保证。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/4470227-f9b9e6bf36c57f64.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="指令序列的重排序" /></p>
<ul>
<li>数据依赖性：<br />
如果两个操作在访问同一个变量，且这两个操作有一个是写操作，此时两个操作之间存在数据依赖性。</li>
</ul>
<p>编译器重排序和处理器重排序不会改变数据依赖性关系的两个操作之间的执行顺序，即不会重排序。</p>
<p><strong>注意：</strong><br />
这里所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器和线程间之间的数据依赖性不被编译器和处理器所考虑。</p>
<ul>
<li>as-if-serial*<br />
不过怎么重排序，单线程下的执行结果不能改变，编译器、runtime（运行时）和处理器都必须遵守as-if-serial语义</li>
</ul>
<h3 id="内存屏障memory-barrier"><a class="markdownIt-Anchor" href="#内存屏障memory-barrier"></a> 内存屏障（Memory Barrier）</h3>
<p><img src="https://upload-images.jianshu.io/upload_images/4470227-3ec44c6a754b1d28.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="内存屏障" /></p>
<p><em>volatile内存语义的实现：</em><br />
<img src="https://upload-images.jianshu.io/upload_images/4470227-1b17395a4d02b463.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="volatile内存语义的实现" /></p>
<p>对于volatile关键字，JMM采用保守策略</p>
<h3 id="happens-before策略"><a class="markdownIt-Anchor" href="#happens-before策略"></a> happens-before策略</h3>
<p><img src="https://upload-images.jianshu.io/upload_images/4470227-a113f57af59bcfc2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="happens-before规则" /></p>
<p><strong>注意：</strong><br />
两个操作之间具有happens-before关系，并不意味前一个操作必须要在后一个操作之前执行！仅仅要求前一个操作的执行结果，对于后一个操作是可见的，且前一个操作按顺序排在后一个操作之前。</p>
<h2 id="解决hash冲突的几种方法"><a class="markdownIt-Anchor" href="#解决hash冲突的几种方法"></a> 解决hash冲突的几种方法</h2>
<h3 id="开放地址法"><a class="markdownIt-Anchor" href="#开放地址法"></a> 开放地址法</h3>
<ol>
<li>
<p>线性探测法：ThreadLocalMap<br />
插入元素时，如果发生冲突，算法会简单的<strong>从该槽位置向后循环遍历hash表，直到找到表中的下一个空槽，并将该元素放入该槽中（会导致相同hash值的元素挨在一起和其他hash值对应的槽被占用）。</strong> 查找元素时，首先散列值所指向的槽，如果没有找到匹配，则继续从该槽遍历hash表，直到：（1）找到相应的元素；（2）找到一个空槽，指示查找的元素不存在，（所以不能随便删除元素）；（3）整个hash表遍历完毕（指示该元素不存在并且hash表是满的）<br />
用线性探测法处理冲突，思路清晰，算法简单，但存在下列缺点：<br />
① 处理溢出需另编程序。一般可另外设立一个溢出表，专门用来存放上述哈希表中放不下的记录。此溢出表最简单的结构是顺序表，查找方法可用顺序查找。<br />
② 按上述算法建立起来的哈希表，删除工作非常困难。如果将此元素删除，查找的时会发现空槽，则会认为要找的元素不存在。只能标上已被删除的标记，否则，将会影响以后的查找。<br />
③ 线性探测法很容易产生堆聚现象。所谓堆聚现象，就是存入哈希表的记录在表中连成一片。按照线性探测法处理冲突，如果生成哈希地址的连续序列愈长 ( 即不同关键字值的哈希地址相邻在一起愈长 ) ，则当新的记录加入该表时，与这个序列发生冲突的可能性愈大。因此，哈希地址的较长连续序列比较短连续序列生长得快，这就意味着，一旦出现堆聚 ( 伴随着冲突 ) ，就将引起进一步的堆聚。</p>
</li>
<li>
<p>线程补偿探测法<br />
线性补偿探测法的基本思想是：将线性探测的步长从 1 改为 Q ，即将上述算法中的<br />
hash ＝ (hash ＋ 1) % m 改为：hash ＝ (hash ＋ Q) % m = hash % m + Q % m，**而且要求 Q 与 m 是互质的，**以便能探测到哈希表中的所有单元。</p>
</li>
<li>
<p>伪随机探测<br />
随机探测的基本思想是：将线性探测的步长从常数改为随机数，即令： hash ＝ (hash ＋ RN) % m ，其中 RN 是一个随机数。在实际程序中应预先用随机数发生器产生一个随机序列，将此序列作为依次探测的步长。这样就能使不同的关键字具有不同的探测次序，从而可以避 免或减少堆聚。基于与线性探测法相同的理由，在线性补偿探测法和随机探测法中，删除一个记录后也要打上删除标记。</p>
</li>
</ol>
<h3 id="拉链法"><a class="markdownIt-Anchor" href="#拉链法"></a> 拉链法</h3>
<p>HashMap<br />
拉链法的优点<br />
与开放定址法相比，拉链法有如下几个优点：<br />
①拉链法处理冲突简单，且无堆积现象，即非同义词决不会发生冲突，因此平均查找长度较短；<br />
②由于拉链法中各链表上的结点空间是动态申请的，故它更适合于造表前无法确定表长的情况；<br />
③开放定址法为减少冲突，要求装填因子α较小，故当结点规模较大时会浪费很多空间。而拉链法中可取α≥1，且结点较大时，拉链法中增加的指针域可忽略不计，因此节省空间；<br />
④在用拉链法构造的散列表中，删除结点的操作易于实现。只要简单地删去链表上相应的结点即可。</p>
<p>拉链法的缺点<br />
　拉链法的缺点是：指针需要额外的空间，故当结点规模较小时，开放定址法较为节省空间，而若将节省的指针空间用来扩大散列表的规模，可使装填因子变小，这又减少了开放定址法中的冲突，从而提高平均查找速度。</p>
<h3 id="再散列双重散列-多重散列"><a class="markdownIt-Anchor" href="#再散列双重散列-多重散列"></a> 再散列（双重散列、多重散列）</h3>
<p>当发生冲突时，使用第二个、第三个、哈希函数计算地址，直到无冲突时。缺点：计算时间增加。</p>
<h3 id="建立一个公共溢出区"><a class="markdownIt-Anchor" href="#建立一个公共溢出区"></a> 建立一个公共溢出区</h3>
<p>假设哈希函数的值域为[0,m-1],则设向量HashTable[0…m-1]为基本表，另外设立存储空间向量OverTable[0…v]用以存储发生冲突的记录。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Toyan</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://toyan.top/java-summary/">https://toyan.top/java-summary/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/public/alipay.jpeg"><div class="post-qr-code__desc">支付宝打赏</div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/public/wechat.jpeg"><div class="post-qr-code__desc">微信打赏</div></div></div><div class="social-share pull-right"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/network-summary/"><i class="fa fa-chevron-left">  </i><span>计算机网络总结</span></a></div><div class="next-post pull-right"><a href="/database-summary/"><span>数据库总结</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '64bf96f3f30de518911b',
  clientSecret: '2b721d1728859b321e4f4533bd870be019c30c37',
  repo: 'toyan-blog.github.io',
  owner: 'toyan-blog',
  admin: 'toyan-blog',
  id: md5(decodeURI(location.pathname)),
  language: 'en'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/public/blog.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2020 By Toyan</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script src="/js/search/local-search.js"></script><script id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zIndex="-1" data-click="false"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"superSample":2,"width":210,"height":420,"position":"left","hOffset":0,"vOffset":-20},"log":false,"tagMode":false});</script></body></html>